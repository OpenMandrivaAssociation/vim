To: vim_dev@googlegroups.com
Subject: Patch 7.4.1147
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1147
Problem:    Conflict for "chartab". (Kazunobu Kuriyama)
Solution:   Rename the global one to something less obvious.  Move it into
            src/chartab.c.
Files:      src/macros.h, src/globals.h, src/charset.c, src/main.c,
            src/option.c, src/screen.c, src/vim.h


*** ../vim-7.4.1146/src/macros.h	2015-12-31 19:06:56.032082082 +0100
--- src/macros.h	2016-01-20 22:39:21.726454428 +0100
***************
*** 121,131 ****
  /* Returns empty string if it is NULL. */
  #define EMPTY_IF_NULL(x) ((x) ? (x) : (u_char *)"")
  
- /* macro version of chartab().
-  * Only works with values 0-255!
-  * Doesn't work for UTF-8 mode with chars >= 0x80. */
- #define CHARSIZE(c)	(chartab[c] & CT_CELL_MASK)
- 
  #ifdef FEAT_LANGMAP
  /*
   * Adjust chars in a language according to 'langmap' option.
--- 121,126 ----
*** ../vim-7.4.1146/src/globals.h	2016-01-16 15:40:04.702704650 +0100
--- src/globals.h	2016-01-20 22:41:22.173292424 +0100
***************
*** 1012,1020 ****
  #endif
  EXTERN int	maptick INIT(= 0);	/* tick for each non-mapped char */
  
- EXTERN char_u	chartab[256];		/* table used in charset.c; See
- 					   init_chartab() for explanation */
- 
  EXTERN int	must_redraw INIT(= 0);	    /* type of redraw necessary */
  EXTERN int	skip_redraw INIT(= FALSE);  /* skip redraw once */
  EXTERN int	do_redraw INIT(= FALSE);    /* extra redraw once */
--- 1012,1017 ----
*** ../vim-7.4.1146/src/charset.c	2016-01-02 17:54:04.411793395 +0100
--- src/charset.c	2016-01-20 22:41:57.484947725 +0100
***************
*** 30,50 ****
  #define RESET_CHARTAB(buf, c) (buf)->b_chartab[(unsigned)(c) >> 3] &= ~(1 << ((c) & 0x7))
  #define GET_CHARTAB(buf, c) ((buf)->b_chartab[(unsigned)(c) >> 3] & (1 << ((c) & 0x7)))
  
  /*
!  * Fill chartab[].  Also fills curbuf->b_chartab[] with flags for keyword
   * characters for current buffer.
   *
   * Depends on the option settings 'iskeyword', 'isident', 'isfname',
   * 'isprint' and 'encoding'.
   *
!  * The index in chartab[] depends on 'encoding':
   * - For non-multi-byte index with the byte (same as the character).
   * - For DBCS index with the first byte.
   * - For UTF-8 index with the character (when first byte is up to 0x80 it is
   *   the same as the character, if the first byte is 0x80 and above it depends
   *   on further bytes).
   *
!  * The contents of chartab[]:
   * - The lower two bits, masked by CT_CELL_MASK, give the number of display
   *   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.
   * - CT_PRINT_CHAR bit is set when the character is printable (no need to
--- 30,61 ----
  #define RESET_CHARTAB(buf, c) (buf)->b_chartab[(unsigned)(c) >> 3] &= ~(1 << ((c) & 0x7))
  #define GET_CHARTAB(buf, c) ((buf)->b_chartab[(unsigned)(c) >> 3] & (1 << ((c) & 0x7)))
  
+ /* table used below, see init_chartab() for an explanation */
+ static char_u	g_chartab[256];
+ 
+ /*
+  * Flags for g_chartab[].
+  */
+ #define CT_CELL_MASK	0x07	/* mask: nr of display cells (1, 2 or 4) */
+ #define CT_PRINT_CHAR	0x10	/* flag: set for printable chars */
+ #define CT_ID_CHAR	0x20	/* flag: set for ID chars */
+ #define CT_FNAME_CHAR	0x40	/* flag: set for file name chars */
+ 
  /*
!  * Fill g_chartab[].  Also fills curbuf->b_chartab[] with flags for keyword
   * characters for current buffer.
   *
   * Depends on the option settings 'iskeyword', 'isident', 'isfname',
   * 'isprint' and 'encoding'.
   *
!  * The index in g_chartab[] depends on 'encoding':
   * - For non-multi-byte index with the byte (same as the character).
   * - For DBCS index with the first byte.
   * - For UTF-8 index with the character (when first byte is up to 0x80 it is
   *   the same as the character, if the first byte is 0x80 and above it depends
   *   on further bytes).
   *
!  * The contents of g_chartab[]:
   * - The lower two bits, masked by CT_CELL_MASK, give the number of display
   *   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.
   * - CT_PRINT_CHAR bit is set when the character is printable (no need to
***************
*** 86,103 ****
  	 */
  	c = 0;
  	while (c < ' ')
! 	    chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;
  #ifdef EBCDIC
  	while (c < 255)
  #else
  	while (c <= '~')
  #endif
! 	    chartab[c++] = 1 + CT_PRINT_CHAR;
  #ifdef FEAT_FKMAP
  	if (p_altkeymap)
  	{
  	    while (c < YE)
! 		chartab[c++] = 1 + CT_PRINT_CHAR;
  	}
  #endif
  	while (c < 256)
--- 97,114 ----
  	 */
  	c = 0;
  	while (c < ' ')
! 	    g_chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;
  #ifdef EBCDIC
  	while (c < 255)
  #else
  	while (c <= '~')
  #endif
! 	    g_chartab[c++] = 1 + CT_PRINT_CHAR;
  #ifdef FEAT_FKMAP
  	if (p_altkeymap)
  	{
  	    while (c < YE)
! 		g_chartab[c++] = 1 + CT_PRINT_CHAR;
  	}
  #endif
  	while (c < 256)
***************
*** 105,121 ****
  #ifdef FEAT_MBYTE
  	    /* UTF-8: bytes 0xa0 - 0xff are printable (latin1) */
  	    if (enc_utf8 && c >= 0xa0)
! 		chartab[c++] = CT_PRINT_CHAR + 1;
  	    /* euc-jp characters starting with 0x8e are single width */
  	    else if (enc_dbcs == DBCS_JPNU && c == 0x8e)
! 		chartab[c++] = CT_PRINT_CHAR + 1;
  	    /* other double-byte chars can be printable AND double-width */
  	    else if (enc_dbcs != 0 && MB_BYTE2LEN(c) == 2)
! 		chartab[c++] = CT_PRINT_CHAR + 2;
  	    else
  #endif
  		/* the rest is unprintable by default */
! 		chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;
  	}
  
  #ifdef FEAT_MBYTE
--- 116,132 ----
  #ifdef FEAT_MBYTE
  	    /* UTF-8: bytes 0xa0 - 0xff are printable (latin1) */
  	    if (enc_utf8 && c >= 0xa0)
! 		g_chartab[c++] = CT_PRINT_CHAR + 1;
  	    /* euc-jp characters starting with 0x8e are single width */
  	    else if (enc_dbcs == DBCS_JPNU && c == 0x8e)
! 		g_chartab[c++] = CT_PRINT_CHAR + 1;
  	    /* other double-byte chars can be printable AND double-width */
  	    else if (enc_dbcs != 0 && MB_BYTE2LEN(c) == 2)
! 		g_chartab[c++] = CT_PRINT_CHAR + 2;
  	    else
  #endif
  		/* the rest is unprintable by default */
! 		g_chartab[c++] = (dy_flags & DY_UHEX) ? 4 : 2;
  	}
  
  #ifdef FEAT_MBYTE
***************
*** 124,130 ****
  	    if ((enc_dbcs != 0 && MB_BYTE2LEN(c) > 1)
  		    || (enc_dbcs == DBCS_JPNU && c == 0x8e)
  		    || (enc_utf8 && c >= 0xa0))
! 		chartab[c] |= CT_FNAME_CHAR;
  #endif
      }
  
--- 135,141 ----
  	    if ((enc_dbcs != 0 && MB_BYTE2LEN(c) > 1)
  		    || (enc_dbcs == DBCS_JPNU && c == 0x8e)
  		    || (enc_utf8 && c >= 0xa0))
! 		g_chartab[c] |= CT_FNAME_CHAR;
  #endif
      }
  
***************
*** 232,240 ****
  		    if (i == 0)			/* (re)set ID flag */
  		    {
  			if (tilde)
! 			    chartab[c] &= ~CT_ID_CHAR;
  			else
! 			    chartab[c] |= CT_ID_CHAR;
  		    }
  		    else if (i == 1)		/* (re)set printable */
  		    {
--- 243,251 ----
  		    if (i == 0)			/* (re)set ID flag */
  		    {
  			if (tilde)
! 			    g_chartab[c] &= ~CT_ID_CHAR;
  			else
! 			    g_chartab[c] |= CT_ID_CHAR;
  		    }
  		    else if (i == 1)		/* (re)set printable */
  		    {
***************
*** 256,278 ****
  			{
  			    if (tilde)
  			    {
! 				chartab[c] = (chartab[c] & ~CT_CELL_MASK)
  					     + ((dy_flags & DY_UHEX) ? 4 : 2);
! 				chartab[c] &= ~CT_PRINT_CHAR;
  			    }
  			    else
  			    {
! 				chartab[c] = (chartab[c] & ~CT_CELL_MASK) + 1;
! 				chartab[c] |= CT_PRINT_CHAR;
  			    }
  			}
  		    }
  		    else if (i == 2)		/* (re)set fname flag */
  		    {
  			if (tilde)
! 			    chartab[c] &= ~CT_FNAME_CHAR;
  			else
! 			    chartab[c] |= CT_FNAME_CHAR;
  		    }
  		    else /* i == 3 */		/* (re)set keyword flag */
  		    {
--- 267,289 ----
  			{
  			    if (tilde)
  			    {
! 				g_chartab[c] = (g_chartab[c] & ~CT_CELL_MASK)
  					     + ((dy_flags & DY_UHEX) ? 4 : 2);
! 				g_chartab[c] &= ~CT_PRINT_CHAR;
  			    }
  			    else
  			    {
! 				g_chartab[c] = (g_chartab[c] & ~CT_CELL_MASK) + 1;
! 				g_chartab[c] |= CT_PRINT_CHAR;
  			    }
  			}
  		    }
  		    else if (i == 2)		/* (re)set fname flag */
  		    {
  			if (tilde)
! 			    g_chartab[c] &= ~CT_FNAME_CHAR;
  			else
! 			    g_chartab[c] |= CT_FNAME_CHAR;
  		    }
  		    else /* i == 3 */		/* (re)set keyword flag */
  		    {
***************
*** 531,539 ****
  #endif
  
  /*
!  * Catch 22: chartab[] can't be initialized before the options are
   * initialized, and initializing options may cause transchar() to be called!
!  * When chartab_initialized == FALSE don't use chartab[].
   * Does NOT work for multi-byte characters, c must be <= 255.
   * Also doesn't work for the first byte of a multi-byte, "c" must be a
   * character!
--- 542,550 ----
  #endif
  
  /*
!  * Catch 22: g_chartab[] can't be initialized before the options are
   * initialized, and initializing options may cause transchar() to be called!
!  * When chartab_initialized == FALSE don't use g_chartab[].
   * Does NOT work for multi-byte characters, c must be <= 255.
   * Also doesn't work for the first byte of a multi-byte, "c" must be a
   * character!
***************
*** 718,724 ****
      if (enc_utf8 && b >= 0x80)
  	return 0;
  #endif
!     return (chartab[b] & CT_CELL_MASK);
  }
  
  /*
--- 729,735 ----
      if (enc_utf8 && b >= 0x80)
  	return 0;
  #endif
!     return (g_chartab[b] & CT_CELL_MASK);
  }
  
  /*
***************
*** 748,754 ****
  	}
      }
  #endif
!     return (chartab[c & 0xff] & CT_CELL_MASK);
  }
  
  /*
--- 759,765 ----
  	}
      }
  #endif
!     return (g_chartab[c & 0xff] & CT_CELL_MASK);
  }
  
  /*
***************
*** 765,771 ****
  	return utf_ptr2cells(p);
      /* For DBCS we can tell the cell count from the first byte. */
  #endif
!     return (chartab[*p] & CT_CELL_MASK);
  }
  
  /*
--- 776,782 ----
  	return utf_ptr2cells(p);
      /* For DBCS we can tell the cell count from the first byte. */
  #endif
!     return (g_chartab[*p] & CT_CELL_MASK);
  }
  
  /*
***************
*** 900,906 ****
  vim_isIDc(c)
      int c;
  {
!     return (c > 0 && c < 0x100 && (chartab[c] & CT_ID_CHAR));
  }
  
  /*
--- 911,917 ----
  vim_isIDc(c)
      int c;
  {
!     return (c > 0 && c < 0x100 && (g_chartab[c] & CT_ID_CHAR));
  }
  
  /*
***************
*** 966,972 ****
  vim_isfilec(c)
      int	c;
  {
!     return (c >= 0x100 || (c > 0 && (chartab[c] & CT_FNAME_CHAR)));
  }
  
  /*
--- 977,983 ----
  vim_isfilec(c)
      int	c;
  {
!     return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_FNAME_CHAR)));
  }
  
  /*
***************
*** 999,1005 ****
      if (enc_utf8 && c >= 0x100)
  	return utf_printable(c);
  #endif
!     return (c >= 0x100 || (c > 0 && (chartab[c] & CT_PRINT_CHAR)));
  }
  
  /*
--- 1010,1016 ----
      if (enc_utf8 && c >= 0x100)
  	return utf_printable(c);
  #endif
!     return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_PRINT_CHAR)));
  }
  
  /*
***************
*** 1016,1022 ****
      if (enc_utf8 && c >= 0x100)
  	return utf_printable(c);
  #endif
!     return (c >= 0x100 || (c > 0 && (chartab[c] & CT_PRINT_CHAR)));
  }
  
  /*
--- 1027,1033 ----
      if (enc_utf8 && c >= 0x100)
  	return utf_printable(c);
  #endif
!     return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_PRINT_CHAR)));
  }
  
  /*
***************
*** 1368,1374 ****
  		    if (enc_utf8 && c >= 0x80)
  			incr = utf_ptr2cells(ptr);
  		    else
! 			incr = CHARSIZE(c);
  
  		    /* If a double-cell char doesn't fit at the end of a line
  		     * it wraps to the next line, it's like this char is three
--- 1379,1385 ----
  		    if (enc_utf8 && c >= 0x80)
  			incr = utf_ptr2cells(ptr);
  		    else
! 			incr = g_chartab[c] & CT_CELL_MASK;
  
  		    /* If a double-cell char doesn't fit at the end of a line
  		     * it wraps to the next line, it's like this char is three
***************
*** 1382,1388 ****
  		}
  		else
  #endif
! 		    incr = CHARSIZE(c);
  	    }
  
  	    if (posptr != NULL && ptr >= posptr) /* character at pos->col */
--- 1393,1399 ----
  		}
  		else
  #endif
! 		    incr = g_chartab[c] & CT_CELL_MASK;
  	    }
  
  	    if (posptr != NULL && ptr >= posptr) /* character at pos->col */
*** ../vim-7.4.1146/src/main.c	2016-01-16 18:05:40.441065385 +0100
--- src/main.c	2016-01-20 22:33:39.602314314 +0100
***************
*** 1582,1589 ****
  	/* Initialize the gettext library */
  	dyn_libintl_init();
  #  endif
! 	/* expand_env() doesn't work yet, because chartab[] is not initialized
! 	 * yet, call vim_getenv() directly */
  	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
  	if (p != NULL && *p != NUL)
  	{
--- 1582,1589 ----
  	/* Initialize the gettext library */
  	dyn_libintl_init();
  #  endif
! 	/* expand_env() doesn't work yet, because g_chartab[] is not
! 	 * initialized yet, call vim_getenv() directly */
  	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
  	if (p != NULL && *p != NUL)
  	{
*** ../vim-7.4.1146/src/option.c	2016-01-19 22:28:54.611593027 +0100
--- src/option.c	2016-01-20 22:34:13.037889608 +0100
***************
*** 5934,5942 ****
  #endif
  
      /*
!      * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill chartab[]
       * If the new option is invalid, use old value.  'lisp' option: refill
!      * chartab[] for '-' char
       */
      else if (  varp == &p_isi
  	    || varp == &(curbuf->b_p_isk)
--- 5934,5942 ----
  #endif
  
      /*
!      * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]
       * If the new option is invalid, use old value.  'lisp' option: refill
!      * g_chartab[] for '-' char
       */
      else if (  varp == &p_isi
  	    || varp == &(curbuf->b_p_isk)
*** ../vim-7.4.1146/src/screen.c	2016-01-15 22:52:17.863736622 +0100
--- src/screen.c	2016-01-20 22:37:12.495676383 +0100
***************
*** 4598,4604 ****
  	    /*
  	     * Handling of non-printable characters.
  	     */
! 	    if (!(chartab[c & 0xff] & CT_PRINT_CHAR))
  	    {
  		/*
  		 * when getting a character from the file, we may have to
--- 4598,4604 ----
  	    /*
  	     * Handling of non-printable characters.
  	     */
! 	    if (!vim_isprintc(c))
  	    {
  		/*
  		 * when getting a character from the file, we may have to
*** ../vim-7.4.1146/src/vim.h	2016-01-17 18:23:51.539928692 +0100
--- src/vim.h	2016-01-20 22:40:40.133700443 +0100
***************
*** 1111,1124 ****
  #define HIST_COUNT	5	/* number of history tables */
  
  /*
-  * Flags for chartab[].
-  */
- #define CT_CELL_MASK	0x07	/* mask: nr of display cells (1, 2 or 4) */
- #define CT_PRINT_CHAR	0x10	/* flag: set for printable chars */
- #define CT_ID_CHAR	0x20	/* flag: set for ID chars */
- #define CT_FNAME_CHAR	0x40	/* flag: set for file name chars */
- 
- /*
   * Values for do_tag().
   */
  #define DT_TAG		1	/* jump to newer position or same tag again */
--- 1111,1116 ----
*** ../vim-7.4.1146/src/version.c	2016-01-20 22:23:10.378059819 +0100
--- src/version.c	2016-01-20 22:42:43.448496399 +0100
***************
*** 743,744 ****
--- 743,746 ----
  {   /* Add new patch number below this line */
+ /**/
+     1147,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
21. Your dog has its own home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
