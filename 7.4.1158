To: vim_dev@googlegroups.com
Subject: Patch 7.4.1158
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1158
Problem:    Still using __ARGS().
Solution:   Remove __ARGS() from eval.c
Files:      src/eval.c


*** ../vim-7.4.1157/src/eval.c	2016-01-23 21:59:47.569792161 +0100
--- src/eval.c	2016-01-23 22:11:28.462145284 +0100
***************
*** 388,880 ****
  static dictitem_T	vimvars_var;		/* variable used for v: */
  #define vimvarht  vimvardict.dv_hashtab
  
! static void prepare_vimvar __ARGS((int idx, typval_T *save_tv));
! static void restore_vimvar __ARGS((int idx, typval_T *save_tv));
! static int ex_let_vars __ARGS((char_u *arg, typval_T *tv, int copy, int semicolon, int var_count, char_u *nextchars));
! static char_u *skip_var_list __ARGS((char_u *arg, int *var_count, int *semicolon));
! static char_u *skip_var_one __ARGS((char_u *arg));
! static void list_hashtable_vars __ARGS((hashtab_T *ht, char_u *prefix, int empty, int *first));
! static void list_glob_vars __ARGS((int *first));
! static void list_buf_vars __ARGS((int *first));
! static void list_win_vars __ARGS((int *first));
  #ifdef FEAT_WINDOWS
! static void list_tab_vars __ARGS((int *first));
  #endif
! static void list_vim_vars __ARGS((int *first));
! static void list_script_vars __ARGS((int *first));
! static void list_func_vars __ARGS((int *first));
! static char_u *list_arg_vars __ARGS((exarg_T *eap, char_u *arg, int *first));
! static char_u *ex_let_one __ARGS((char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op));
! static int check_changedtick __ARGS((char_u *arg));
! static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags));
! static void clear_lval __ARGS((lval_T *lp));
! static void set_var_lval __ARGS((lval_T *lp, char_u *endp, typval_T *rettv, int copy, char_u *op));
! static int tv_op __ARGS((typval_T *tv1, typval_T *tv2, char_u  *op));
! static void list_fix_watch __ARGS((list_T *l, listitem_T *item));
! static void ex_unletlock __ARGS((exarg_T *eap, char_u *argstart, int deep));
! static int do_unlet_var __ARGS((lval_T *lp, char_u *name_end, int forceit));
! static int do_lock_var __ARGS((lval_T *lp, char_u *name_end, int deep, int lock));
! static void item_lock __ARGS((typval_T *tv, int deep, int lock));
! static int tv_islocked __ARGS((typval_T *tv));
! 
! static int eval0 __ARGS((char_u *arg,  typval_T *rettv, char_u **nextcmd, int evaluate));
! static int eval1 __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int eval2 __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int eval3 __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int eval4 __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int eval5 __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int eval6 __ARGS((char_u **arg, typval_T *rettv, int evaluate, int want_string));
! static int eval7 __ARGS((char_u **arg, typval_T *rettv, int evaluate, int want_string));
! 
! static int eval_index __ARGS((char_u **arg, typval_T *rettv, int evaluate, int verbose));
! static int get_option_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int get_string_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int get_lit_string_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int get_list_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static long list_len __ARGS((list_T *l));
! static int list_equal __ARGS((list_T *l1, list_T *l2, int ic, int recursive));
! static int dict_equal __ARGS((dict_T *d1, dict_T *d2, int ic, int recursive));
! static int tv_equal __ARGS((typval_T *tv1, typval_T *tv2, int ic, int recursive));
! static long list_find_nr __ARGS((list_T *l, long idx, int *errorp));
! static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
! static int list_append_number __ARGS((list_T *l, varnumber_T n));
! static int list_extend __ARGS((list_T	*l1, list_T *l2, listitem_T *bef));
! static int list_concat __ARGS((list_T *l1, list_T *l2, typval_T *tv));
! static list_T *list_copy __ARGS((list_T *orig, int deep, int copyID));
! static char_u *list2string __ARGS((typval_T *tv, int copyID));
! static int list_join_inner __ARGS((garray_T *gap, list_T *l, char_u *sep, int echo_style, int copyID, garray_T *join_gap));
! static int list_join __ARGS((garray_T *gap, list_T *l, char_u *sep, int echo, int copyID));
! static int free_unref_items __ARGS((int copyID));
! static dictitem_T *dictitem_copy __ARGS((dictitem_T *org));
! static void dictitem_remove __ARGS((dict_T *dict, dictitem_T *item));
! static dict_T *dict_copy __ARGS((dict_T *orig, int deep, int copyID));
! static long dict_len __ARGS((dict_T *d));
! static char_u *dict2string __ARGS((typval_T *tv, int copyID));
! static int get_dict_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static char_u *echo_string __ARGS((typval_T *tv, char_u **tofree, char_u *numbuf, int copyID));
! static char_u *tv2string __ARGS((typval_T *tv, char_u **tofree, char_u *numbuf, int copyID));
! static char_u *string_quote __ARGS((char_u *str, int function));
! static int get_env_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
! static int find_internal_func __ARGS((char_u *name));
! static char_u *deref_func_name __ARGS((char_u *name, int *lenp, int no_autoload));
! static int get_func_tv __ARGS((char_u *name, int len, typval_T *rettv, char_u **arg, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
! static int call_func __ARGS((char_u *funcname, int len, typval_T *rettv, int argcount, typval_T *argvars, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
! static void emsg_funcname __ARGS((char *ermsg, char_u *name));
! static int non_zero_arg __ARGS((typval_T *argvars));
! 
! #ifdef FEAT_FLOAT
! static void f_abs __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_acos __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_add __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_alloc_fail __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_and __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_append __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_argc __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_argidx __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_arglistid __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_argv __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_assert_equal __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_assert_exception __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_assert_fails __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_assert_false __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_assert_true __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_asin __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_atan __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_atan2 __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_browse __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_browsedir __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_bufexists __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_buflisted __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_bufloaded __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_bufname __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_bufnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_bufwinnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_byte2line __ARGS((typval_T *argvars, typval_T *rettv));
! static void byteidx __ARGS((typval_T *argvars, typval_T *rettv, int comp));
! static void f_byteidx __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_byteidxcomp __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_call __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_ceil __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_changenr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_char2nr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_cindent __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_clearmatches __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_col __ARGS((typval_T *argvars, typval_T *rettv));
  #if defined(FEAT_INS_EXPAND)
! static void f_complete __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_complete_add __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_complete_check __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_confirm __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_copy __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_cos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_cosh __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_count __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_cscope_connection __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_cursor __ARGS((typval_T *argsvars, typval_T *rettv));
! static void f_deepcopy __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_delete __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_did_filetype __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_diff_filler __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_diff_hlID __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_empty __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_escape __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_eval __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_eventhandler __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_executable __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_exepath __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_exists __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_exp __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_expand __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_extend __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_feedkeys __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_filereadable __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_filewritable __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_filter __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_finddir __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_findfile __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_float2nr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_floor __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_fmod __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_fnameescape __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_fnamemodify __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_foldclosed __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_foldclosedend __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_foldlevel __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_foldtext __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_foldtextresult __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_foreground __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_function __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_garbagecollect __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_get __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getbufline __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getbufvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getchar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcharmod __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcharsearch __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcmdline __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcmdpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcmdtype __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcmdwintype __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcwd __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getfontname __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getfperm __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getfsize __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getftime __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getftype __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getline __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getmatches __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getpid __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getcurpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getqflist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getreg __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getregtype __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_gettabvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_gettabwinvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getwinposx __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getwinposy __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_getwinvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_glob __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_globpath __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_glob2regpat  __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_has __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_has_key __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_haslocaldir __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_hasmapto __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_histadd __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_histdel __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_histget __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_histnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_hlID __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_hlexists __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_hostname __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_iconv __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_indent __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_index __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_input __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_inputdialog __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_inputlist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_inputrestore __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_inputsave __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_inputsecret __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_insert __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_invert __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_isdirectory __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_islocked __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_items __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_join __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_jsondecode __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_jsonencode __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_keys __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_last_buffer_nr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_len __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_libcall __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_libcallnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_line __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_line2byte __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_lispindent __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_localtime __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef FEAT_FLOAT
! static void f_log __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_log10 __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
  #ifdef FEAT_LUA
! static void f_luaeval __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_map __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_maparg __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_mapcheck __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_match __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matchadd __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matchaddpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matcharg __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matchdelete __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matchend __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matchlist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_matchstr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_max __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_min __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef vim_mkdir
! static void f_mkdir __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_mode __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef FEAT_MZSCHEME
! static void f_mzeval __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_nextnonblank __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_nr2char __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_or __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_pathshorten __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef FEAT_PERL
! static void f_perleval __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
  #ifdef FEAT_FLOAT
! static void f_pow __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_prevnonblank __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_printf __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_pumvisible __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef FEAT_PYTHON3
! static void f_py3eval __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
  #ifdef FEAT_PYTHON
! static void f_pyeval __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_range __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_readfile __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_reltime __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_reltimestr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_remote_expr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_remote_foreground __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_remote_peek __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_remote_read __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_remote_send __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_remove __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_rename __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_repeat __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_resolve __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_reverse __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_round __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_screenattr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_screenchar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_screencol __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_screenrow __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_search __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_searchdecl __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_searchpair __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_searchpairpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_searchpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_server2client __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_serverlist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setbufvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setcharsearch __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setcmdpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setline __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setloclist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setmatches __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setpos __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setqflist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setreg __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_settabvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_settabwinvar __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_setwinvar __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef FEAT_CRYPT
! static void f_sha256 __ARGS((typval_T *argvars, typval_T *rettv));
  #endif /* FEAT_CRYPT */
! static void f_shellescape __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_shiftwidth __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_simplify __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_sin __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_sinh __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_sort __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_soundfold __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_spellbadword __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_spellsuggest __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_split __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef FEAT_FLOAT
! static void f_sqrt __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_str2float __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_str2nr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strchars __ARGS((typval_T *argvars, typval_T *rettv));
  #ifdef HAVE_STRFTIME
! static void f_strftime __ARGS((typval_T *argvars, typval_T *rettv));
  #endif
! static void f_stridx __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_string __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strlen __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strpart __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strridx __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strtrans __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strdisplaywidth __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_strwidth __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_submatch __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_substitute __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_synID __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_synIDattr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_synIDtrans __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_synstack __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_synconcealed __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_system __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_systemlist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tabpagebuflist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tabpagenr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tabpagewinnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_taglist __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tagfiles __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tempname __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_test __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_tan __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tanh __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_tolower __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_toupper __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_tr __ARGS((typval_T *argvars, typval_T *rettv));
! #ifdef FEAT_FLOAT
! static void f_trunc __ARGS((typval_T *argvars, typval_T *rettv));
! #endif
! static void f_type __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_undofile __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_undotree __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_uniq __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_values __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_virtcol __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_visualmode __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_wildmenumode __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winbufnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_wincol __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winheight __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winline __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winnr __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winrestcmd __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winrestview __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winsaveview __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_winwidth __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_writefile __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_wordcount __ARGS((typval_T *argvars, typval_T *rettv));
! static void f_xor __ARGS((typval_T *argvars, typval_T *rettv));
! 
! static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp));
! static pos_T *var2fpos __ARGS((typval_T *varp, int dollar_lnum, int *fnum));
! static int get_env_len __ARGS((char_u **arg));
! static int get_id_len __ARGS((char_u **arg));
! static int get_name_len __ARGS((char_u **arg, char_u **alias, int evaluate, int verbose));
! static char_u *find_name_end __ARGS((char_u *arg, char_u **expr_start, char_u **expr_end, int flags));
  #define FNE_INCL_BR	1	/* find_name_end(): include [] in name */
  #define FNE_CHECK_START	2	/* find_name_end(): check name starts with
  				   valid character */
! static char_u * make_expanded_name __ARGS((char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end));
! static int eval_isnamec __ARGS((int c));
! static int eval_isnamec1 __ARGS((int c));
! static int get_var_tv __ARGS((char_u *name, int len, typval_T *rettv, dictitem_T **dip, int verbose, int no_autoload));
! static int handle_subscript __ARGS((char_u **arg, typval_T *rettv, int evaluate, int verbose));
! static typval_T *alloc_tv __ARGS((void));
! static typval_T *alloc_string_tv __ARGS((char_u *string));
! static void init_tv __ARGS((typval_T *varp));
! static long get_tv_number __ARGS((typval_T *varp));
  #ifdef FEAT_FLOAT
  static float_T get_tv_float(typval_T *varp);
  #endif
! static linenr_T get_tv_lnum __ARGS((typval_T *argvars));
! static linenr_T get_tv_lnum_buf __ARGS((typval_T *argvars, buf_T *buf));
! static char_u *get_tv_string __ARGS((typval_T *varp));
! static char_u *get_tv_string_buf __ARGS((typval_T *varp, char_u *buf));
! static dictitem_T *find_var __ARGS((char_u *name, hashtab_T **htp, int no_autoload));
! static dictitem_T *find_var_in_ht __ARGS((hashtab_T *ht, int htname, char_u *varname, int no_autoload));
! static hashtab_T *find_var_ht __ARGS((char_u *name, char_u **varname));
! static funccall_T *get_funccal __ARGS((void));
! static void vars_clear_ext __ARGS((hashtab_T *ht, int free_val));
! static void delete_var __ARGS((hashtab_T *ht, hashitem_T *hi));
! static void list_one_var __ARGS((dictitem_T *v, char_u *prefix, int *first));
! static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string, int *first));
! static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
! static int var_check_ro __ARGS((int flags, char_u *name, int use_gettext));
! static int var_check_fixed __ARGS((int flags, char_u *name, int use_gettext));
! static int var_check_func_name __ARGS((char_u *name, int new_var));
! static int valid_varname __ARGS((char_u *varname));
! static int tv_check_lock __ARGS((int lock, char_u *name, int use_gettext));
! static int item_copy __ARGS((typval_T *from, typval_T *to, int deep, int copyID));
! static char_u *find_option_end __ARGS((char_u **arg, int *opt_flags));
! static char_u *trans_function_name __ARGS((char_u **pp, int skip, int flags, funcdict_T *fd));
! static int eval_fname_script __ARGS((char_u *p));
! static int eval_fname_sid __ARGS((char_u *p));
! static void list_func_head __ARGS((ufunc_T *fp, int indent));
! static ufunc_T *find_func __ARGS((char_u *name));
! static int function_exists __ARGS((char_u *name));
! static int builtin_function __ARGS((char_u *name, int len));
  #ifdef FEAT_PROFILE
! static void func_do_profile __ARGS((ufunc_T *fp));
! static void prof_sort_list __ARGS((FILE *fd, ufunc_T **sorttab, int st_len, char *title, int prefer_self));
! static void prof_func_line __ARGS((FILE *fd, int count, proftime_T *total, proftime_T *self, int prefer_self));
  static int
  # ifdef __BORLANDC__
      _RTLENTRYF
  # endif
! 	prof_total_cmp __ARGS((const void *s1, const void *s2));
  static int
  # ifdef __BORLANDC__
      _RTLENTRYF
  # endif
! 	prof_self_cmp __ARGS((const void *s1, const void *s2));
  #endif
! static int script_autoload __ARGS((char_u *name, int reload));
! static char_u *autoload_name __ARGS((char_u *name));
! static void cat_func_name __ARGS((char_u *buf, ufunc_T *fp));
! static void func_free __ARGS((ufunc_T *fp));
! static void call_user_func __ARGS((ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, linenr_T firstline, linenr_T lastline, dict_T *selfdict));
! static int can_free_funccal __ARGS((funccall_T *fc, int copyID)) ;
! static void free_funccal __ARGS((funccall_T *fc, int free_val));
! static void add_nr_var __ARGS((dict_T *dp, dictitem_T *v, char *name, varnumber_T nr));
! static win_T *find_win_by_nr __ARGS((typval_T *vp, tabpage_T *tp));
! static win_T *find_tabwin __ARGS((typval_T *wvp, typval_T *tvp));
! static void getwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
! static int searchpair_cmn __ARGS((typval_T *argvars, pos_T *match_pos));
! static int search_cmn __ARGS((typval_T *argvars, pos_T *match_pos, int *flagsp));
! static void setwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
! static int write_list __ARGS((FILE *fd, list_T *list, int binary));
! static void get_cmd_output_as_rettv __ARGS((typval_T *argvars, typval_T *rettv, int retlist));
  
  
  #ifdef EBCDIC
! static int compare_func_name __ARGS((const void *s1, const void *s2));
! static void sortFunctions __ARGS(());
  #endif
  
  /*
--- 388,880 ----
  static dictitem_T	vimvars_var;		/* variable used for v: */
  #define vimvarht  vimvardict.dv_hashtab
  
! static void prepare_vimvar(int idx, typval_T *save_tv);
! static void restore_vimvar(int idx, typval_T *save_tv);
! static int ex_let_vars(char_u *arg, typval_T *tv, int copy, int semicolon, int var_count, char_u *nextchars);
! static char_u *skip_var_list(char_u *arg, int *var_count, int *semicolon);
! static char_u *skip_var_one(char_u *arg);
! static void list_hashtable_vars(hashtab_T *ht, char_u *prefix, int empty, int *first);
! static void list_glob_vars(int *first);
! static void list_buf_vars(int *first);
! static void list_win_vars(int *first);
  #ifdef FEAT_WINDOWS
! static void list_tab_vars(int *first);
  #endif
! static void list_vim_vars(int *first);
! static void list_script_vars(int *first);
! static void list_func_vars(int *first);
! static char_u *list_arg_vars(exarg_T *eap, char_u *arg, int *first);
! static char_u *ex_let_one(char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op);
! static int check_changedtick(char_u *arg);
! static char_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);
! static void clear_lval(lval_T *lp);
! static void set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv, int copy, char_u *op);
! static int tv_op(typval_T *tv1, typval_T *tv2, char_u  *op);
! static void list_fix_watch(list_T *l, listitem_T *item);
! static void ex_unletlock(exarg_T *eap, char_u *argstart, int deep);
! static int do_unlet_var(lval_T *lp, char_u *name_end, int forceit);
! static int do_lock_var(lval_T *lp, char_u *name_end, int deep, int lock);
! static void item_lock(typval_T *tv, int deep, int lock);
! static int tv_islocked(typval_T *tv);
! 
! static int eval0(char_u *arg,  typval_T *rettv, char_u **nextcmd, int evaluate);
! static int eval1(char_u **arg, typval_T *rettv, int evaluate);
! static int eval2(char_u **arg, typval_T *rettv, int evaluate);
! static int eval3(char_u **arg, typval_T *rettv, int evaluate);
! static int eval4(char_u **arg, typval_T *rettv, int evaluate);
! static int eval5(char_u **arg, typval_T *rettv, int evaluate);
! static int eval6(char_u **arg, typval_T *rettv, int evaluate, int want_string);
! static int eval7(char_u **arg, typval_T *rettv, int evaluate, int want_string);
! 
! static int eval_index(char_u **arg, typval_T *rettv, int evaluate, int verbose);
! static int get_option_tv(char_u **arg, typval_T *rettv, int evaluate);
! static int get_string_tv(char_u **arg, typval_T *rettv, int evaluate);
! static int get_lit_string_tv(char_u **arg, typval_T *rettv, int evaluate);
! static int get_list_tv(char_u **arg, typval_T *rettv, int evaluate);
! static long list_len(list_T *l);
! static int list_equal(list_T *l1, list_T *l2, int ic, int recursive);
! static int dict_equal(dict_T *d1, dict_T *d2, int ic, int recursive);
! static int tv_equal(typval_T *tv1, typval_T *tv2, int ic, int recursive);
! static long list_find_nr(list_T *l, long idx, int *errorp);
! static long list_idx_of_item(list_T *l, listitem_T *item);
! static int list_append_number(list_T *l, varnumber_T n);
! static int list_extend(list_T	*l1, list_T *l2, listitem_T *bef);
! static int list_concat(list_T *l1, list_T *l2, typval_T *tv);
! static list_T *list_copy(list_T *orig, int deep, int copyID);
! static char_u *list2string(typval_T *tv, int copyID);
! static int list_join_inner(garray_T *gap, list_T *l, char_u *sep, int echo_style, int copyID, garray_T *join_gap);
! static int list_join(garray_T *gap, list_T *l, char_u *sep, int echo, int copyID);
! static int free_unref_items(int copyID);
! static dictitem_T *dictitem_copy(dictitem_T *org);
! static void dictitem_remove(dict_T *dict, dictitem_T *item);
! static dict_T *dict_copy(dict_T *orig, int deep, int copyID);
! static long dict_len(dict_T *d);
! static char_u *dict2string(typval_T *tv, int copyID);
! static int get_dict_tv(char_u **arg, typval_T *rettv, int evaluate);
! static char_u *echo_string(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID);
! static char_u *tv2string(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID);
! static char_u *string_quote(char_u *str, int function);
! static int get_env_tv(char_u **arg, typval_T *rettv, int evaluate);
! static int find_internal_func(char_u *name);
! static char_u *deref_func_name(char_u *name, int *lenp, int no_autoload);
! static int get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict);
! static int call_func(char_u *funcname, int len, typval_T *rettv, int argcount, typval_T *argvars, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict);
! static void emsg_funcname(char *ermsg, char_u *name);
! static int non_zero_arg(typval_T *argvars);
! 
! #ifdef FEAT_FLOAT
! static void f_abs(typval_T *argvars, typval_T *rettv);
! static void f_acos(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_add(typval_T *argvars, typval_T *rettv);
! static void f_alloc_fail(typval_T *argvars, typval_T *rettv);
! static void f_and(typval_T *argvars, typval_T *rettv);
! static void f_append(typval_T *argvars, typval_T *rettv);
! static void f_argc(typval_T *argvars, typval_T *rettv);
! static void f_argidx(typval_T *argvars, typval_T *rettv);
! static void f_arglistid(typval_T *argvars, typval_T *rettv);
! static void f_argv(typval_T *argvars, typval_T *rettv);
! static void f_assert_equal(typval_T *argvars, typval_T *rettv);
! static void f_assert_exception(typval_T *argvars, typval_T *rettv);
! static void f_assert_fails(typval_T *argvars, typval_T *rettv);
! static void f_assert_false(typval_T *argvars, typval_T *rettv);
! static void f_assert_true(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_asin(typval_T *argvars, typval_T *rettv);
! static void f_atan(typval_T *argvars, typval_T *rettv);
! static void f_atan2(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_browse(typval_T *argvars, typval_T *rettv);
! static void f_browsedir(typval_T *argvars, typval_T *rettv);
! static void f_bufexists(typval_T *argvars, typval_T *rettv);
! static void f_buflisted(typval_T *argvars, typval_T *rettv);
! static void f_bufloaded(typval_T *argvars, typval_T *rettv);
! static void f_bufname(typval_T *argvars, typval_T *rettv);
! static void f_bufnr(typval_T *argvars, typval_T *rettv);
! static void f_bufwinnr(typval_T *argvars, typval_T *rettv);
! static void f_byte2line(typval_T *argvars, typval_T *rettv);
! static void byteidx(typval_T *argvars, typval_T *rettv, int comp);
! static void f_byteidx(typval_T *argvars, typval_T *rettv);
! static void f_byteidxcomp(typval_T *argvars, typval_T *rettv);
! static void f_call(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_ceil(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_changenr(typval_T *argvars, typval_T *rettv);
! static void f_char2nr(typval_T *argvars, typval_T *rettv);
! static void f_cindent(typval_T *argvars, typval_T *rettv);
! static void f_clearmatches(typval_T *argvars, typval_T *rettv);
! static void f_col(typval_T *argvars, typval_T *rettv);
  #if defined(FEAT_INS_EXPAND)
! static void f_complete(typval_T *argvars, typval_T *rettv);
! static void f_complete_add(typval_T *argvars, typval_T *rettv);
! static void f_complete_check(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_confirm(typval_T *argvars, typval_T *rettv);
! static void f_copy(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_cos(typval_T *argvars, typval_T *rettv);
! static void f_cosh(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_count(typval_T *argvars, typval_T *rettv);
! static void f_cscope_connection(typval_T *argvars, typval_T *rettv);
! static void f_cursor(typval_T *argsvars, typval_T *rettv);
! static void f_deepcopy(typval_T *argvars, typval_T *rettv);
! static void f_delete(typval_T *argvars, typval_T *rettv);
! static void f_did_filetype(typval_T *argvars, typval_T *rettv);
! static void f_diff_filler(typval_T *argvars, typval_T *rettv);
! static void f_diff_hlID(typval_T *argvars, typval_T *rettv);
! static void f_empty(typval_T *argvars, typval_T *rettv);
! static void f_escape(typval_T *argvars, typval_T *rettv);
! static void f_eval(typval_T *argvars, typval_T *rettv);
! static void f_eventhandler(typval_T *argvars, typval_T *rettv);
! static void f_executable(typval_T *argvars, typval_T *rettv);
! static void f_exepath(typval_T *argvars, typval_T *rettv);
! static void f_exists(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_exp(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_expand(typval_T *argvars, typval_T *rettv);
! static void f_extend(typval_T *argvars, typval_T *rettv);
! static void f_feedkeys(typval_T *argvars, typval_T *rettv);
! static void f_filereadable(typval_T *argvars, typval_T *rettv);
! static void f_filewritable(typval_T *argvars, typval_T *rettv);
! static void f_filter(typval_T *argvars, typval_T *rettv);
! static void f_finddir(typval_T *argvars, typval_T *rettv);
! static void f_findfile(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_float2nr(typval_T *argvars, typval_T *rettv);
! static void f_floor(typval_T *argvars, typval_T *rettv);
! static void f_fmod(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_fnameescape(typval_T *argvars, typval_T *rettv);
! static void f_fnamemodify(typval_T *argvars, typval_T *rettv);
! static void f_foldclosed(typval_T *argvars, typval_T *rettv);
! static void f_foldclosedend(typval_T *argvars, typval_T *rettv);
! static void f_foldlevel(typval_T *argvars, typval_T *rettv);
! static void f_foldtext(typval_T *argvars, typval_T *rettv);
! static void f_foldtextresult(typval_T *argvars, typval_T *rettv);
! static void f_foreground(typval_T *argvars, typval_T *rettv);
! static void f_function(typval_T *argvars, typval_T *rettv);
! static void f_garbagecollect(typval_T *argvars, typval_T *rettv);
! static void f_get(typval_T *argvars, typval_T *rettv);
! static void f_getbufline(typval_T *argvars, typval_T *rettv);
! static void f_getbufvar(typval_T *argvars, typval_T *rettv);
! static void f_getchar(typval_T *argvars, typval_T *rettv);
! static void f_getcharmod(typval_T *argvars, typval_T *rettv);
! static void f_getcharsearch(typval_T *argvars, typval_T *rettv);
! static void f_getcmdline(typval_T *argvars, typval_T *rettv);
! static void f_getcmdpos(typval_T *argvars, typval_T *rettv);
! static void f_getcmdtype(typval_T *argvars, typval_T *rettv);
! static void f_getcmdwintype(typval_T *argvars, typval_T *rettv);
! static void f_getcwd(typval_T *argvars, typval_T *rettv);
! static void f_getfontname(typval_T *argvars, typval_T *rettv);
! static void f_getfperm(typval_T *argvars, typval_T *rettv);
! static void f_getfsize(typval_T *argvars, typval_T *rettv);
! static void f_getftime(typval_T *argvars, typval_T *rettv);
! static void f_getftype(typval_T *argvars, typval_T *rettv);
! static void f_getline(typval_T *argvars, typval_T *rettv);
! static void f_getmatches(typval_T *argvars, typval_T *rettv);
! static void f_getpid(typval_T *argvars, typval_T *rettv);
! static void f_getcurpos(typval_T *argvars, typval_T *rettv);
! static void f_getpos(typval_T *argvars, typval_T *rettv);
! static void f_getqflist(typval_T *argvars, typval_T *rettv);
! static void f_getreg(typval_T *argvars, typval_T *rettv);
! static void f_getregtype(typval_T *argvars, typval_T *rettv);
! static void f_gettabvar(typval_T *argvars, typval_T *rettv);
! static void f_gettabwinvar(typval_T *argvars, typval_T *rettv);
! static void f_getwinposx(typval_T *argvars, typval_T *rettv);
! static void f_getwinposy(typval_T *argvars, typval_T *rettv);
! static void f_getwinvar(typval_T *argvars, typval_T *rettv);
! static void f_glob(typval_T *argvars, typval_T *rettv);
! static void f_globpath(typval_T *argvars, typval_T *rettv);
! static void f_glob2regpat(typval_T *argvars, typval_T *rettv);
! static void f_has(typval_T *argvars, typval_T *rettv);
! static void f_has_key(typval_T *argvars, typval_T *rettv);
! static void f_haslocaldir(typval_T *argvars, typval_T *rettv);
! static void f_hasmapto(typval_T *argvars, typval_T *rettv);
! static void f_histadd(typval_T *argvars, typval_T *rettv);
! static void f_histdel(typval_T *argvars, typval_T *rettv);
! static void f_histget(typval_T *argvars, typval_T *rettv);
! static void f_histnr(typval_T *argvars, typval_T *rettv);
! static void f_hlID(typval_T *argvars, typval_T *rettv);
! static void f_hlexists(typval_T *argvars, typval_T *rettv);
! static void f_hostname(typval_T *argvars, typval_T *rettv);
! static void f_iconv(typval_T *argvars, typval_T *rettv);
! static void f_indent(typval_T *argvars, typval_T *rettv);
! static void f_index(typval_T *argvars, typval_T *rettv);
! static void f_input(typval_T *argvars, typval_T *rettv);
! static void f_inputdialog(typval_T *argvars, typval_T *rettv);
! static void f_inputlist(typval_T *argvars, typval_T *rettv);
! static void f_inputrestore(typval_T *argvars, typval_T *rettv);
! static void f_inputsave(typval_T *argvars, typval_T *rettv);
! static void f_inputsecret(typval_T *argvars, typval_T *rettv);
! static void f_insert(typval_T *argvars, typval_T *rettv);
! static void f_invert(typval_T *argvars, typval_T *rettv);
! static void f_isdirectory(typval_T *argvars, typval_T *rettv);
! static void f_islocked(typval_T *argvars, typval_T *rettv);
! static void f_items(typval_T *argvars, typval_T *rettv);
! static void f_join(typval_T *argvars, typval_T *rettv);
! static void f_jsondecode(typval_T *argvars, typval_T *rettv);
! static void f_jsonencode(typval_T *argvars, typval_T *rettv);
! static void f_keys(typval_T *argvars, typval_T *rettv);
! static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv);
! static void f_len(typval_T *argvars, typval_T *rettv);
! static void f_libcall(typval_T *argvars, typval_T *rettv);
! static void f_libcallnr(typval_T *argvars, typval_T *rettv);
! static void f_line(typval_T *argvars, typval_T *rettv);
! static void f_line2byte(typval_T *argvars, typval_T *rettv);
! static void f_lispindent(typval_T *argvars, typval_T *rettv);
! static void f_localtime(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_FLOAT
! static void f_log(typval_T *argvars, typval_T *rettv);
! static void f_log10(typval_T *argvars, typval_T *rettv);
  #endif
  #ifdef FEAT_LUA
! static void f_luaeval(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_map(typval_T *argvars, typval_T *rettv);
! static void f_maparg(typval_T *argvars, typval_T *rettv);
! static void f_mapcheck(typval_T *argvars, typval_T *rettv);
! static void f_match(typval_T *argvars, typval_T *rettv);
! static void f_matchadd(typval_T *argvars, typval_T *rettv);
! static void f_matchaddpos(typval_T *argvars, typval_T *rettv);
! static void f_matcharg(typval_T *argvars, typval_T *rettv);
! static void f_matchdelete(typval_T *argvars, typval_T *rettv);
! static void f_matchend(typval_T *argvars, typval_T *rettv);
! static void f_matchlist(typval_T *argvars, typval_T *rettv);
! static void f_matchstr(typval_T *argvars, typval_T *rettv);
! static void f_max(typval_T *argvars, typval_T *rettv);
! static void f_min(typval_T *argvars, typval_T *rettv);
  #ifdef vim_mkdir
! static void f_mkdir(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_mode(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_MZSCHEME
! static void f_mzeval(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_nextnonblank(typval_T *argvars, typval_T *rettv);
! static void f_nr2char(typval_T *argvars, typval_T *rettv);
! static void f_or(typval_T *argvars, typval_T *rettv);
! static void f_pathshorten(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_PERL
! static void f_perleval(typval_T *argvars, typval_T *rettv);
  #endif
  #ifdef FEAT_FLOAT
! static void f_pow(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_prevnonblank(typval_T *argvars, typval_T *rettv);
! static void f_printf(typval_T *argvars, typval_T *rettv);
! static void f_pumvisible(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_PYTHON3
! static void f_py3eval(typval_T *argvars, typval_T *rettv);
  #endif
  #ifdef FEAT_PYTHON
! static void f_pyeval(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_range(typval_T *argvars, typval_T *rettv);
! static void f_readfile(typval_T *argvars, typval_T *rettv);
! static void f_reltime(typval_T *argvars, typval_T *rettv);
! static void f_reltimestr(typval_T *argvars, typval_T *rettv);
! static void f_remote_expr(typval_T *argvars, typval_T *rettv);
! static void f_remote_foreground(typval_T *argvars, typval_T *rettv);
! static void f_remote_peek(typval_T *argvars, typval_T *rettv);
! static void f_remote_read(typval_T *argvars, typval_T *rettv);
! static void f_remote_send(typval_T *argvars, typval_T *rettv);
! static void f_remove(typval_T *argvars, typval_T *rettv);
! static void f_rename(typval_T *argvars, typval_T *rettv);
! static void f_repeat(typval_T *argvars, typval_T *rettv);
! static void f_resolve(typval_T *argvars, typval_T *rettv);
! static void f_reverse(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_round(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_screenattr(typval_T *argvars, typval_T *rettv);
! static void f_screenchar(typval_T *argvars, typval_T *rettv);
! static void f_screencol(typval_T *argvars, typval_T *rettv);
! static void f_screenrow(typval_T *argvars, typval_T *rettv);
! static void f_search(typval_T *argvars, typval_T *rettv);
! static void f_searchdecl(typval_T *argvars, typval_T *rettv);
! static void f_searchpair(typval_T *argvars, typval_T *rettv);
! static void f_searchpairpos(typval_T *argvars, typval_T *rettv);
! static void f_searchpos(typval_T *argvars, typval_T *rettv);
! static void f_server2client(typval_T *argvars, typval_T *rettv);
! static void f_serverlist(typval_T *argvars, typval_T *rettv);
! static void f_setbufvar(typval_T *argvars, typval_T *rettv);
! static void f_setcharsearch(typval_T *argvars, typval_T *rettv);
! static void f_setcmdpos(typval_T *argvars, typval_T *rettv);
! static void f_setline(typval_T *argvars, typval_T *rettv);
! static void f_setloclist(typval_T *argvars, typval_T *rettv);
! static void f_setmatches(typval_T *argvars, typval_T *rettv);
! static void f_setpos(typval_T *argvars, typval_T *rettv);
! static void f_setqflist(typval_T *argvars, typval_T *rettv);
! static void f_setreg(typval_T *argvars, typval_T *rettv);
! static void f_settabvar(typval_T *argvars, typval_T *rettv);
! static void f_settabwinvar(typval_T *argvars, typval_T *rettv);
! static void f_setwinvar(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_CRYPT
! static void f_sha256(typval_T *argvars, typval_T *rettv);
  #endif /* FEAT_CRYPT */
! static void f_shellescape(typval_T *argvars, typval_T *rettv);
! static void f_shiftwidth(typval_T *argvars, typval_T *rettv);
! static void f_simplify(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_sin(typval_T *argvars, typval_T *rettv);
! static void f_sinh(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_sort(typval_T *argvars, typval_T *rettv);
! static void f_soundfold(typval_T *argvars, typval_T *rettv);
! static void f_spellbadword(typval_T *argvars, typval_T *rettv);
! static void f_spellsuggest(typval_T *argvars, typval_T *rettv);
! static void f_split(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_FLOAT
! static void f_sqrt(typval_T *argvars, typval_T *rettv);
! static void f_str2float(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_str2nr(typval_T *argvars, typval_T *rettv);
! static void f_strchars(typval_T *argvars, typval_T *rettv);
  #ifdef HAVE_STRFTIME
! static void f_strftime(typval_T *argvars, typval_T *rettv);
  #endif
! static void f_stridx(typval_T *argvars, typval_T *rettv);
! static void f_string(typval_T *argvars, typval_T *rettv);
! static void f_strlen(typval_T *argvars, typval_T *rettv);
! static void f_strpart(typval_T *argvars, typval_T *rettv);
! static void f_strridx(typval_T *argvars, typval_T *rettv);
! static void f_strtrans(typval_T *argvars, typval_T *rettv);
! static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv);
! static void f_strwidth(typval_T *argvars, typval_T *rettv);
! static void f_submatch(typval_T *argvars, typval_T *rettv);
! static void f_substitute(typval_T *argvars, typval_T *rettv);
! static void f_synID(typval_T *argvars, typval_T *rettv);
! static void f_synIDattr(typval_T *argvars, typval_T *rettv);
! static void f_synIDtrans(typval_T *argvars, typval_T *rettv);
! static void f_synstack(typval_T *argvars, typval_T *rettv);
! static void f_synconcealed(typval_T *argvars, typval_T *rettv);
! static void f_system(typval_T *argvars, typval_T *rettv);
! static void f_systemlist(typval_T *argvars, typval_T *rettv);
! static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv);
! static void f_tabpagenr(typval_T *argvars, typval_T *rettv);
! static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv);
! static void f_taglist(typval_T *argvars, typval_T *rettv);
! static void f_tagfiles(typval_T *argvars, typval_T *rettv);
! static void f_tempname(typval_T *argvars, typval_T *rettv);
! static void f_test(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_tan(typval_T *argvars, typval_T *rettv);
! static void f_tanh(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_tolower(typval_T *argvars, typval_T *rettv);
! static void f_toupper(typval_T *argvars, typval_T *rettv);
! static void f_tr(typval_T *argvars, typval_T *rettv);
! #ifdef FEAT_FLOAT
! static void f_trunc(typval_T *argvars, typval_T *rettv);
! #endif
! static void f_type(typval_T *argvars, typval_T *rettv);
! static void f_undofile(typval_T *argvars, typval_T *rettv);
! static void f_undotree(typval_T *argvars, typval_T *rettv);
! static void f_uniq(typval_T *argvars, typval_T *rettv);
! static void f_values(typval_T *argvars, typval_T *rettv);
! static void f_virtcol(typval_T *argvars, typval_T *rettv);
! static void f_visualmode(typval_T *argvars, typval_T *rettv);
! static void f_wildmenumode(typval_T *argvars, typval_T *rettv);
! static void f_winbufnr(typval_T *argvars, typval_T *rettv);
! static void f_wincol(typval_T *argvars, typval_T *rettv);
! static void f_winheight(typval_T *argvars, typval_T *rettv);
! static void f_winline(typval_T *argvars, typval_T *rettv);
! static void f_winnr(typval_T *argvars, typval_T *rettv);
! static void f_winrestcmd(typval_T *argvars, typval_T *rettv);
! static void f_winrestview(typval_T *argvars, typval_T *rettv);
! static void f_winsaveview(typval_T *argvars, typval_T *rettv);
! static void f_winwidth(typval_T *argvars, typval_T *rettv);
! static void f_writefile(typval_T *argvars, typval_T *rettv);
! static void f_wordcount(typval_T *argvars, typval_T *rettv);
! static void f_xor(typval_T *argvars, typval_T *rettv);
! 
! static int list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp);
! static pos_T *var2fpos(typval_T *varp, int dollar_lnum, int *fnum);
! static int get_env_len(char_u **arg);
! static int get_id_len(char_u **arg);
! static int get_name_len(char_u **arg, char_u **alias, int evaluate, int verbose);
! static char_u *find_name_end(char_u *arg, char_u **expr_start, char_u **expr_end, int flags);
  #define FNE_INCL_BR	1	/* find_name_end(): include [] in name */
  #define FNE_CHECK_START	2	/* find_name_end(): check name starts with
  				   valid character */
! static char_u * make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);
! static int eval_isnamec(int c);
! static int eval_isnamec1(int c);
! static int get_var_tv(char_u *name, int len, typval_T *rettv, dictitem_T **dip, int verbose, int no_autoload);
! static int handle_subscript(char_u **arg, typval_T *rettv, int evaluate, int verbose);
! static typval_T *alloc_tv(void);
! static typval_T *alloc_string_tv(char_u *string);
! static void init_tv(typval_T *varp);
! static long get_tv_number(typval_T *varp);
  #ifdef FEAT_FLOAT
  static float_T get_tv_float(typval_T *varp);
  #endif
! static linenr_T get_tv_lnum(typval_T *argvars);
! static linenr_T get_tv_lnum_buf(typval_T *argvars, buf_T *buf);
! static char_u *get_tv_string(typval_T *varp);
! static char_u *get_tv_string_buf(typval_T *varp, char_u *buf);
! static dictitem_T *find_var(char_u *name, hashtab_T **htp, int no_autoload);
! static dictitem_T *find_var_in_ht(hashtab_T *ht, int htname, char_u *varname, int no_autoload);
! static hashtab_T *find_var_ht(char_u *name, char_u **varname);
! static funccall_T *get_funccal(void);
! static void vars_clear_ext(hashtab_T *ht, int free_val);
! static void delete_var(hashtab_T *ht, hashitem_T *hi);
! static void list_one_var(dictitem_T *v, char_u *prefix, int *first);
! static void list_one_var_a(char_u *prefix, char_u *name, int type, char_u *string, int *first);
! static void set_var(char_u *name, typval_T *varp, int copy);
! static int var_check_ro(int flags, char_u *name, int use_gettext);
! static int var_check_fixed(int flags, char_u *name, int use_gettext);
! static int var_check_func_name(char_u *name, int new_var);
! static int valid_varname(char_u *varname);
! static int tv_check_lock(int lock, char_u *name, int use_gettext);
! static int item_copy(typval_T *from, typval_T *to, int deep, int copyID);
! static char_u *find_option_end(char_u **arg, int *opt_flags);
! static char_u *trans_function_name(char_u **pp, int skip, int flags, funcdict_T *fd);
! static int eval_fname_script(char_u *p);
! static int eval_fname_sid(char_u *p);
! static void list_func_head(ufunc_T *fp, int indent);
! static ufunc_T *find_func(char_u *name);
! static int function_exists(char_u *name);
! static int builtin_function(char_u *name, int len);
  #ifdef FEAT_PROFILE
! static void func_do_profile(ufunc_T *fp);
! static void prof_sort_list(FILE *fd, ufunc_T **sorttab, int st_len, char *title, int prefer_self);
! static void prof_func_line(FILE *fd, int count, proftime_T *total, proftime_T *self, int prefer_self);
  static int
  # ifdef __BORLANDC__
      _RTLENTRYF
  # endif
! 	prof_total_cmp(const void *s1, const void *s2);
  static int
  # ifdef __BORLANDC__
      _RTLENTRYF
  # endif
! 	prof_self_cmp(const void *s1, const void *s2);
  #endif
! static int script_autoload(char_u *name, int reload);
! static char_u *autoload_name(char_u *name);
! static void cat_func_name(char_u *buf, ufunc_T *fp);
! static void func_free(ufunc_T *fp);
! static void call_user_func(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, linenr_T firstline, linenr_T lastline, dict_T *selfdict);
! static int can_free_funccal(funccall_T *fc, int copyID) ;
! static void free_funccal(funccall_T *fc, int free_val);
! static void add_nr_var(dict_T *dp, dictitem_T *v, char *name, varnumber_T nr);
! static win_T *find_win_by_nr(typval_T *vp, tabpage_T *tp);
! static win_T *find_tabwin(typval_T *wvp, typval_T *tvp);
! static void getwinvar(typval_T *argvars, typval_T *rettv, int off);
! static int searchpair_cmn(typval_T *argvars, pos_T *match_pos);
! static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp);
! static void setwinvar(typval_T *argvars, typval_T *rettv, int off);
! static int write_list(FILE *fd, list_T *list, int binary);
! static void get_cmd_output_as_rettv(typval_T *argvars, typval_T *rettv, int retlist);
  
  
  #ifdef EBCDIC
! static int compare_func_name(const void *s1, const void *s2);
! static void sortFunctions();
  #endif
  
  /*
***************
*** 3971,3977 ****
   * get_user_var_name().
   */
  
! static char_u *cat_prefix_varname __ARGS((int prefix, char_u *name));
  
  static char_u	*varnamebuf = NULL;
  static int	varnamebuflen = 0;
--- 3971,3977 ----
   * get_user_var_name().
   */
  
! static char_u *cat_prefix_varname(int prefix, char_u *name);
  
  static char_u	*varnamebuf = NULL;
  static int	varnamebuflen = 0;
***************
*** 8106,8112 ****
      char	*f_name;	/* function name */
      char	f_min_argc;	/* minimal number of arguments */
      char	f_max_argc;	/* maximal number of arguments */
!     void	(*f_func) __ARGS((typval_T *args, typval_T *rvar));
  				/* implementation of function */
  } functions[] =
  {
--- 8106,8112 ----
      char	*f_name;	/* function name */
      char	f_min_argc;	/* minimal number of arguments */
      char	f_max_argc;	/* maximal number of arguments */
!     void	(*f_func)(typval_T *args, typval_T *rvar);
  				/* implementation of function */
  } functions[] =
  {
***************
*** 8941,8947 ****
   */
  
  #ifdef FEAT_FLOAT
! static int get_float_arg __ARGS((typval_T *argvars, float_T *f));
  
  /*
   * Get the float value of "argvars[0]" into "f".
--- 8941,8947 ----
   */
  
  #ifdef FEAT_FLOAT
! static int get_float_arg(typval_T *argvars, float_T *f);
  
  /*
   * Get the float value of "argvars[0]" into "f".
***************
*** 9199,9208 ****
  					       alist_name(&ARGLIST[idx]), -1);
  }
  
! static void prepare_assert_error __ARGS((garray_T*gap));
! static void fill_assert_error __ARGS((garray_T *gap, typval_T *opt_msg_tv, char_u *exp_str, typval_T *exp_tv, typval_T *got_tv));
! static void assert_error __ARGS((garray_T *gap));
! static void assert_bool __ARGS((typval_T *argvars, int isTrue));
  
  /*
   * Prepare "gap" for an assert error and add the sourcing position.
--- 9199,9208 ----
  					       alist_name(&ARGLIST[idx]), -1);
  }
  
! static void prepare_assert_error(garray_T*gap);
! static void fill_assert_error(garray_T *gap, typval_T *opt_msg_tv, char_u *exp_str, typval_T *exp_tv, typval_T *got_tv);
! static void assert_error(garray_T *gap);
! static void assert_bool(typval_T *argvars, int isTrue);
  
  /*
   * Prepare "gap" for an assert error and add the sourcing position.
***************
*** 9534,9540 ****
      rettv->v_type = VAR_STRING;
  }
  
! static buf_T *find_buffer __ARGS((typval_T *avar));
  
  /*
   * Find a buffer by number or exact name.
--- 9534,9540 ----
      rettv->v_type = VAR_STRING;
  }
  
! static buf_T *find_buffer(typval_T *avar);
  
  /*
   * Find a buffer by number or exact name.
***************
*** 9607,9613 ****
      rettv->vval.v_number = (buf != NULL && buf->b_ml.ml_mfp != NULL);
  }
  
! static buf_T *get_buf_tv __ARGS((typval_T *tv, int curtab_only));
  
  /*
   * Get buffer by number or pattern.
--- 9607,9613 ----
      rettv->vval.v_number = (buf != NULL && buf->b_ml.ml_mfp != NULL);
  }
  
! static buf_T *get_buf_tv(typval_T *tv, int curtab_only);
  
  /*
   * Get buffer by number or pattern.
***************
*** 11080,11086 ****
      rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
  }
  
! static void findfilendir __ARGS((typval_T *argvars, typval_T *rettv, int find_what));
  
      static void
  findfilendir(argvars, rettv, find_what)
--- 11080,11086 ----
      rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
  }
  
! static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what);
  
      static void
  findfilendir(argvars, rettv, find_what)
***************
*** 11149,11156 ****
  #endif
  }
  
! static void filter_map __ARGS((typval_T *argvars, typval_T *rettv, int map));
! static int filter_map_one __ARGS((typval_T *tv, char_u *expr, int map, int *remp));
  
  /*
   * Implementation of map() and filter().
--- 11149,11156 ----
  #endif
  }
  
! static void filter_map(typval_T *argvars, typval_T *rettv, int map);
! static int filter_map_one(typval_T *tv, char_u *expr, int map, int *remp);
  
  /*
   * Implementation of map() and filter().
***************
*** 11458,11464 ****
      vim_free(fbuf);
  }
  
! static void foldclosed_both __ARGS((typval_T *argvars, typval_T *rettv, int end));
  
  /*
   * "foldclosed()" function
--- 11458,11464 ----
      vim_free(fbuf);
  }
  
! static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end);
  
  /*
   * "foldclosed()" function
***************
*** 11752,11758 ****
  	copy_tv(tv, rettv);
  }
  
! static void get_buffer_lines __ARGS((buf_T *buf, linenr_T start, linenr_T end, int retlist, typval_T *rettv));
  
  /*
   * Get line or list of lines from buffer "buf" into "rettv".
--- 11752,11758 ----
  	copy_tv(tv, rettv);
  }
  
! static void get_buffer_lines(buf_T *buf, linenr_T start, linenr_T end, int retlist, typval_T *rettv);
  
  /*
   * Get line or list of lines from buffer "buf" into "rettv".
***************
*** 12428,12434 ****
      rettv->vval.v_number = mch_get_pid();
  }
  
! static void getpos_both __ARGS((typval_T *argvars, typval_T *rettv, int getcurpos));
  
  /*
   * "getcurpos()" function
--- 12428,12434 ----
      rettv->vval.v_number = mch_get_pid();
  }
  
! static void getpos_both(typval_T *argvars, typval_T *rettv, int getcurpos);
  
  /*
   * "getcurpos()" function
***************
*** 13908,13914 ****
  
  static int inputsecret_flag = 0;
  
! static void get_user_input __ARGS((typval_T *argvars, typval_T *rettv, int inputdialog));
  
  /*
   * This function is used by f_input() and f_inputdialog() functions. The third
--- 13908,13914 ----
  
  static int inputsecret_flag = 0;
  
! static void get_user_input(typval_T *argvars, typval_T *rettv, int inputdialog);
  
  /*
   * This function is used by f_input() and f_inputdialog() functions. The third
***************
*** 14295,14301 ****
      clear_lval(&lv);
  }
  
! static void dict_list __ARGS((typval_T *argvars, typval_T *rettv, int what));
  
  /*
   * Turn a dict into a list:
--- 14295,14301 ----
      clear_lval(&lv);
  }
  
! static void dict_list(typval_T *argvars, typval_T *rettv, int what);
  
  /*
   * Turn a dict into a list:
***************
*** 14513,14519 ****
      }
  }
  
! static void libcall_common __ARGS((typval_T *argvars, typval_T *rettv, int type));
  
      static void
  libcall_common(argvars, rettv, type)
--- 14513,14519 ----
      }
  }
  
! static void libcall_common(typval_T *argvars, typval_T *rettv, int type);
  
      static void
  libcall_common(argvars, rettv, type)
***************
*** 14656,14662 ****
      rettv->vval.v_number = (varnumber_T)time(NULL);
  }
  
! static void get_maparg __ARGS((typval_T *argvars, typval_T *rettv, int exact));
  
      static void
  get_maparg(argvars, rettv, exact)
--- 14656,14662 ----
      rettv->vval.v_number = (varnumber_T)time(NULL);
  }
  
! static void get_maparg(typval_T *argvars, typval_T *rettv, int exact);
  
      static void
  get_maparg(argvars, rettv, exact)
***************
*** 14819,14825 ****
      get_maparg(argvars, rettv, FALSE);
  }
  
! static void find_some_match __ARGS((typval_T *argvars, typval_T *rettv, int start));
  
      static void
  find_some_match(argvars, rettv, type)
--- 14819,14825 ----
      get_maparg(argvars, rettv, FALSE);
  }
  
! static void find_some_match(typval_T *argvars, typval_T *rettv, int start);
  
      static void
  find_some_match(argvars, rettv, type)
***************
*** 15228,15234 ****
      find_some_match(argvars, rettv, 2);
  }
  
! static void max_min __ARGS((typval_T *argvars, typval_T *rettv, int domax));
  
      static void
  max_min(argvars, rettv, domax)
--- 15228,15234 ----
      find_some_match(argvars, rettv, 2);
  }
  
! static void max_min(typval_T *argvars, typval_T *rettv, int domax);
  
      static void
  max_min(argvars, rettv, domax)
***************
*** 15319,15325 ****
      max_min(argvars, rettv, FALSE);
  }
  
! static int mkdir_recurse __ARGS((char_u *dir, int prot));
  
  /*
   * Create the directory in which "dir" is located, and higher levels when
--- 15319,15325 ----
      max_min(argvars, rettv, FALSE);
  }
  
! static int mkdir_recurse(char_u *dir, int prot);
  
  /*
   * Create the directory in which "dir" is located, and higher levels when
***************
*** 15992,15998 ****
  }
  
  #if defined(FEAT_RELTIME)
! static int list2proftime __ARGS((typval_T *arg, proftime_T *tm));
  
  /*
   * Convert a List to proftime_T.
--- 15992,15998 ----
  }
  
  #if defined(FEAT_RELTIME)
! static int list2proftime(typval_T *arg, proftime_T *tm);
  
  /*
   * Convert a List to proftime_T.
***************
*** 16092,16099 ****
  }
  
  #if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
! static void make_connection __ARGS((void));
! static int check_connection __ARGS((void));
  
      static void
  make_connection()
--- 16092,16099 ----
  }
  
  #if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)
! static void make_connection(void);
! static int check_connection(void);
  
      static void
  make_connection()
***************
*** 16124,16130 ****
  #endif
  
  #ifdef FEAT_CLIENTSERVER
! static void remote_common __ARGS((typval_T *argvars, typval_T *rettv, int expr));
  
      static void
  remote_common(argvars, rettv, expr)
--- 16124,16130 ----
  #endif
  
  #ifdef FEAT_CLIENTSERVER
! static void remote_common(typval_T *argvars, typval_T *rettv, int expr);
  
      static void
  remote_common(argvars, rettv, expr)
***************
*** 16749,16755 ****
  #define SP_END		0x40	    /* leave cursor at end of match */
  #define SP_COLUMN	0x80	    /* start at cursor column */
  
! static int get_search_arg __ARGS((typval_T *varp, int *flagsp));
  
  /*
   * Get flags for a search function.
--- 16749,16755 ----
  #define SP_END		0x40	    /* leave cursor at end of match */
  #define SP_COLUMN	0x80	    /* start at cursor column */
  
! static int get_search_arg(typval_T *varp, int *flagsp);
  
  /*
   * Get flags for a search function.
***************
*** 17605,17611 ****
  	appended_lines_mark(lcount, added);
  }
  
! static void set_qf_ll_list __ARGS((win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *rettv));
  
  /*
   * Used by "setqflist()" and "setloclist()" functions
--- 17605,17611 ----
  	appended_lines_mark(lcount, added);
  }
  
! static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *rettv);
  
  /*
   * Used by "setqflist()" and "setloclist()" functions
***************
*** 18197,18208 ****
  #ifdef __BORLANDC__
      _RTLENTRYF
  #endif
! 	item_compare __ARGS((const void *s1, const void *s2));
  static int
  #ifdef __BORLANDC__
      _RTLENTRYF
  #endif
! 	item_compare2 __ARGS((const void *s1, const void *s2));
  
  /* struct used in the array that's given to qsort() */
  typedef struct
--- 18197,18208 ----
  #ifdef __BORLANDC__
      _RTLENTRYF
  #endif
! 	item_compare(const void *s1, const void *s2);
  static int
  #ifdef __BORLANDC__
      _RTLENTRYF
  #endif
! 	item_compare2(const void *s1, const void *s2);
  
  /* struct used in the array that's given to qsort() */
  typedef struct
***************
*** 18221,18227 ****
  static dict_T	*item_compare_selfdict;
  static int	item_compare_func_err;
  static int	item_compare_keep_zero;
! static void	do_sort_uniq __ARGS((typval_T *argvars, typval_T *rettv, int sort));
  #define ITEM_COMPARE_FAIL 999
  
  /*
--- 18221,18227 ----
  static dict_T	*item_compare_selfdict;
  static int	item_compare_func_err;
  static int	item_compare_keep_zero;
! static void	do_sort_uniq(typval_T *argvars, typval_T *rettv, int sort);
  #define ITEM_COMPARE_FAIL 999
  
  /*
***************
*** 18501,18507 ****
  	}
  	else
  	{
! 	    int	(*item_compare_func_ptr)__ARGS((const void *, const void *));
  
  	    /* f_uniq(): ptrs will be a stack of items to remove */
  	    item_compare_func_err = FALSE;
--- 18501,18507 ----
  	}
  	else
  	{
! 	    int	(*item_compare_func_ptr)(const void *, const void *);
  
  	    /* f_uniq(): ptrs will be a stack of items to remove */
  	    item_compare_func_err = FALSE;
***************
*** 19717,19723 ****
  
  
  #ifdef FEAT_WINDOWS
! static int get_winnr __ARGS((tabpage_T *tp, typval_T *argvar));
  
  /*
   * Common code for tabpagewinnr() and winnr().
--- 19717,19723 ----
  
  
  #ifdef FEAT_WINDOWS
! static int get_winnr(tabpage_T *tp, typval_T *argvar);
  
  /*
   * Common code for tabpagewinnr() and winnr().
***************
*** 25160,25166 ****
      VAR_FLAVOUR_VIMINFO		/* all uppercase */
  } var_flavour_T;
  
! static var_flavour_T var_flavour __ARGS((char_u *varname));
  
      static var_flavour_T
  var_flavour(varname)
--- 25160,25166 ----
      VAR_FLAVOUR_VIMINFO		/* all uppercase */
  } var_flavour_T;
  
! static var_flavour_T var_flavour(char_u *varname);
  
      static var_flavour_T
  var_flavour(varname)
***************
*** 25475,25483 ****
  /*
   * Functions for ":8" filename modifier: get 8.3 version of a filename.
   */
! static int get_short_pathname __ARGS((char_u **fnamep, char_u **bufp, int *fnamelen));
! static int shortpath_for_invalid_fname __ARGS((char_u **fname, char_u **bufp, int *fnamelen));
! static int shortpath_for_partial __ARGS((char_u **fnamep, char_u **bufp, int *fnamelen));
  
  /*
   * Get the short path (8.3) for the filename in "fnamep".
--- 25475,25483 ----
  /*
   * Functions for ":8" filename modifier: get 8.3 version of a filename.
   */
! static int get_short_pathname(char_u **fnamep, char_u **bufp, int *fnamelen);
! static int shortpath_for_invalid_fname(char_u **fname, char_u **bufp, int *fnamelen);
! static int shortpath_for_partial(char_u **fnamep, char_u **bufp, int *fnamelen);
  
  /*
   * Get the short path (8.3) for the filename in "fnamep".
*** ../vim-7.4.1157/src/version.c	2016-01-23 21:59:47.569792161 +0100
--- src/version.c	2016-01-23 22:13:56.152537861 +0100
***************
*** 743,744 ****
--- 743,746 ----
  {   /* Add new patch number below this line */
+ /**/
+     1158,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
16. Have your coworkers address you by your wrestling name, Rock Hard Kim.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
