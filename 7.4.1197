To: vim_dev@googlegroups.com
Subject: Patch 7.4.1197
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1197
Problem:    Still using __ARGS.
Solution:   Remove __ARGS in several files. (script by Hirohito Higashi)
Files:      src/ex_eval.c, src/ex_getln.c, src/farsi.c, src/fileio.c,
            src/fold.c, src/getchar.c, src/gui.c, src/gui_at_fs.c,
            gui_at_sb.c, src/gui_athena.c, src/gui_beval.c, src/gui_motif.c,
            src/gui_w32.c, src/gui_w48.c


*** ../vim-7.4.1196/src/ex_eval.c	2013-11-28 17:04:38.000000000 +0100
--- src/ex_eval.c	2016-01-29 22:06:03.316465517 +0100
***************
*** 15,23 ****
  
  #if defined(FEAT_EVAL) || defined(PROTO)
  
! static void	free_msglist __ARGS((struct msglist *l));
! static int	throw_exception __ARGS((void *, int, char_u *));
! static char_u	*get_end_emsg __ARGS((struct condstack *cstack));
  
  /*
   * Exception handling terms:
--- 15,23 ----
  
  #if defined(FEAT_EVAL) || defined(PROTO)
  
! static void	free_msglist(struct msglist *l);
! static int	throw_exception(void *, int, char_u *);
! static char_u	*get_end_emsg(struct condstack *cstack);
  
  /*
   * Exception handling terms:
***************
*** 65,74 ****
  # define THROW_ON_INTERRUPT_TRUE
  #endif
  
! static void	catch_exception __ARGS((except_T *excp));
! static void	finish_exception __ARGS((except_T *excp));
! static void	discard_exception __ARGS((except_T *excp, int was_finished));
! static void	report_pending __ARGS((int action, int pending, void *value));
  
  /*
   * When several errors appear in a row, setting "force_abort" is delayed until
--- 65,74 ----
  # define THROW_ON_INTERRUPT_TRUE
  #endif
  
! static void	catch_exception(except_T *excp);
! static void	finish_exception(except_T *excp);
! static void	discard_exception(except_T *excp, int was_finished);
! static void	report_pending(int action, int pending, void *value);
  
  /*
   * When several errors appear in a row, setting "force_abort" is delayed until
*** ../vim-7.4.1196/src/ex_getln.c	2016-01-02 17:54:04.419793309 +0100
--- src/ex_getln.c	2016-01-29 22:07:21.347639666 +0100
***************
*** 66,76 ****
  		    /* identifying (unique) number of newest history entry */
  static int	hislen = 0;		/* actual length of history tables */
  
! static int	hist_char2type __ARGS((int c));
  
! static int	in_history __ARGS((int, char_u *, int, int, int));
  # ifdef FEAT_EVAL
! static int	calc_hist_idx __ARGS((int histype, int num));
  # endif
  #endif
  
--- 66,76 ----
  		    /* identifying (unique) number of newest history entry */
  static int	hislen = 0;		/* actual length of history tables */
  
! static int	hist_char2type(int c);
  
! static int	in_history(int, char_u *, int, int, int);
  # ifdef FEAT_EVAL
! static int	calc_hist_idx(int histype, int num);
  # endif
  #endif
  
***************
*** 82,131 ****
  static int	cmd_fkmap = 0;	/* Farsi mapping during command line */
  #endif
  
! static int	cmdline_charsize __ARGS((int idx));
! static void	set_cmdspos __ARGS((void));
! static void	set_cmdspos_cursor __ARGS((void));
  #ifdef FEAT_MBYTE
! static void	correct_cmdspos __ARGS((int idx, int cells));
  #endif
! static void	alloc_cmdbuff __ARGS((int len));
! static int	realloc_cmdbuff __ARGS((int len));
! static void	draw_cmdline __ARGS((int start, int len));
! static void	save_cmdline __ARGS((struct cmdline_info *ccp));
! static void	restore_cmdline __ARGS((struct cmdline_info *ccp));
! static int	cmdline_paste __ARGS((int regname, int literally, int remcr));
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
! static void	redrawcmd_preedit __ARGS((void));
  #endif
  #ifdef FEAT_WILDMENU
! static void	cmdline_del __ARGS((int from));
  #endif
! static void	redrawcmdprompt __ARGS((void));
! static void	cursorcmd __ARGS((void));
! static int	ccheck_abbr __ARGS((int));
! static int	nextwild __ARGS((expand_T *xp, int type, int options, int escape));
! static void	escape_fname __ARGS((char_u **pp));
! static int	showmatches __ARGS((expand_T *xp, int wildmenu));
! static void	set_expand_context __ARGS((expand_T *xp));
! static int	ExpandFromContext __ARGS((expand_T *xp, char_u *, int *, char_u ***, int));
! static int	expand_showtail __ARGS((expand_T *xp));
  #ifdef FEAT_CMDL_COMPL
! static int	expand_shellcmd __ARGS((char_u *filepat, int *num_file, char_u ***file, int flagsarg));
! static int	ExpandRTDir __ARGS((char_u *pat, int *num_file, char_u ***file, char *dirname[]));
  # ifdef FEAT_CMDHIST
! static char_u	*get_history_arg __ARGS((expand_T *xp, int idx));
  # endif
  # if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL)
! static int	ExpandUserDefined __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file));
! static int	ExpandUserList __ARGS((expand_T *xp, int *num_file, char_u ***file));
  # endif
  #endif
  #ifdef FEAT_CMDHIST
! static void	clear_hist_entry __ARGS((histentry_T *hisptr));
  #endif
  
  #ifdef FEAT_CMDWIN
! static int	ex_window __ARGS((void));
  #endif
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
--- 82,131 ----
  static int	cmd_fkmap = 0;	/* Farsi mapping during command line */
  #endif
  
! static int	cmdline_charsize(int idx);
! static void	set_cmdspos(void);
! static void	set_cmdspos_cursor(void);
  #ifdef FEAT_MBYTE
! static void	correct_cmdspos(int idx, int cells);
  #endif
! static void	alloc_cmdbuff(int len);
! static int	realloc_cmdbuff(int len);
! static void	draw_cmdline(int start, int len);
! static void	save_cmdline(struct cmdline_info *ccp);
! static void	restore_cmdline(struct cmdline_info *ccp);
! static int	cmdline_paste(int regname, int literally, int remcr);
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
! static void	redrawcmd_preedit(void);
  #endif
  #ifdef FEAT_WILDMENU
! static void	cmdline_del(int from);
  #endif
! static void	redrawcmdprompt(void);
! static void	cursorcmd(void);
! static int	ccheck_abbr(int);
! static int	nextwild(expand_T *xp, int type, int options, int escape);
! static void	escape_fname(char_u **pp);
! static int	showmatches(expand_T *xp, int wildmenu);
! static void	set_expand_context(expand_T *xp);
! static int	ExpandFromContext(expand_T *xp, char_u *, int *, char_u ***, int);
! static int	expand_showtail(expand_T *xp);
  #ifdef FEAT_CMDL_COMPL
! static int	expand_shellcmd(char_u *filepat, int *num_file, char_u ***file, int flagsarg);
! static int	ExpandRTDir(char_u *pat, int *num_file, char_u ***file, char *dirname[]);
  # ifdef FEAT_CMDHIST
! static char_u	*get_history_arg(expand_T *xp, int idx);
  # endif
  # if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL)
! static int	ExpandUserDefined(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file);
! static int	ExpandUserList(expand_T *xp, int *num_file, char_u ***file);
  # endif
  #endif
  #ifdef FEAT_CMDHIST
! static void	clear_hist_entry(histentry_T *hisptr);
  #endif
  
  #ifdef FEAT_CMDWIN
! static int	ex_window(void);
  #endif
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
***************
*** 133,139 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_func_compare __ARGS((const void *s1, const void *s2));
  #endif
  
  /*
--- 133,139 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_func_compare(const void *s1, const void *s2);
  #endif
  
  /*
***************
*** 4530,4536 ****
  /*
   * Cleanup matches for help tags: remove "@en" if "en" is the only language.
   */
! static void	cleanup_help_tags __ARGS((int num_file, char_u **file));
  
      static void
  cleanup_help_tags(num_file, file)
--- 4530,4536 ----
  /*
   * Cleanup matches for help tags: remove "@en" if "en" is the only language.
   */
! static void	cleanup_help_tags(int num_file, char_u **file);
  
      static void
  cleanup_help_tags(num_file, file)
***************
*** 5009,5015 ****
  
  
  # if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL)
! static void * call_user_expand_func __ARGS((void *(*user_expand_func) __ARGS((char_u *, int, char_u **, int)), expand_T	*xp, int *num_file, char_u ***file));
  
  /*
   * Call "user_expand_func()" to invoke a user defined VimL function and return
--- 5009,5015 ----
  
  
  # if defined(FEAT_USR_CMDS) && defined(FEAT_EVAL)
! static void * call_user_expand_func(void *(*user_expand_func)(char_u *, int, char_u **, int), expand_T	*xp, int *num_file, char_u ***file);
  
  /*
   * Call "user_expand_func()" to invoke a user defined VimL function and return
***************
*** 5017,5023 ****
   */
      static void *
  call_user_expand_func(user_expand_func, xp, num_file, file)
!     void	*(*user_expand_func) __ARGS((char_u *, int, char_u **, int));
      expand_T	*xp;
      int		*num_file;
      char_u	***file;
--- 5017,5023 ----
   */
      static void *
  call_user_expand_func(user_expand_func, xp, num_file, file)
!     void	*(*user_expand_func)(char_u *, int, char_u **, int);
      expand_T	*xp;
      int		*num_file;
      char_u	***file;
***************
*** 5610,5616 ****
      return history[histype][hisidx[histype]].hisnum;
  }
  
! static struct cmdline_info *get_ccline_ptr __ARGS((void));
  
  /*
   * Get pointer to the command line info to use. cmdline_paste() may clear
--- 5610,5616 ----
      return history[histype][hisidx[histype]].hisnum;
  }
  
! static struct cmdline_info *get_ccline_ptr(void);
  
  /*
   * Get pointer to the command line info to use. cmdline_paste() may clear
***************
*** 6066,6072 ****
  static int	viminfo_hislen[HIST_COUNT] = {0, 0, 0, 0};
  static int	viminfo_add_at_front = FALSE;
  
! static int	hist_type2char __ARGS((int type, int use_question));
  
  /*
   * Translate a history type number to the associated character.
--- 6066,6072 ----
  static int	viminfo_hislen[HIST_COUNT] = {0, 0, 0, 0};
  static int	viminfo_add_at_front = FALSE;
  
! static int	hist_type2char(int type, int use_question);
  
  /*
   * Translate a history type number to the associated character.
*** ../vim-7.4.1196/src/farsi.c	2013-05-06 04:06:04.000000000 +0200
--- src/farsi.c	2016-01-29 22:08:02.603203083 +0100
***************
*** 13,38 ****
   * Included by main.c, when FEAT_FKMAP is defined.
   */
  
! static int toF_Xor_X_ __ARGS((int c));
! static int F_is_TyE __ARGS((int c));
! static int F_is_TyC_TyD __ARGS((int c));
! static int F_is_TyB_TyC_TyD __ARGS((int src, int offset));
! static int toF_TyB __ARGS((int c));
! static void put_curr_and_l_to_X __ARGS((int c));
! static void put_and_redo __ARGS((int c));
! static void chg_c_toX_orX __ARGS((void));
! static void chg_c_to_X_orX_ __ARGS((void));
! static void chg_c_to_X_or_X __ARGS((void));
! static void chg_l_to_X_orX_ __ARGS((void));
! static void chg_l_toXor_X __ARGS((void));
! static void chg_r_to_Xor_X_ __ARGS((void));
! static int toF_leading __ARGS((int c));
! static int toF_Rjoin __ARGS((int c));
! static int canF_Ljoin __ARGS((int c));
! static int canF_Rjoin __ARGS((int c));
! static int F_isterm __ARGS((int c));
! static int toF_ending __ARGS((int c));
! static void lrswapbuf __ARGS((char_u *buf, int len));
  
  /*
  ** Convert the given Farsi character into a _X or _X_ type
--- 13,38 ----
   * Included by main.c, when FEAT_FKMAP is defined.
   */
  
! static int toF_Xor_X_(int c);
! static int F_is_TyE(int c);
! static int F_is_TyC_TyD(int c);
! static int F_is_TyB_TyC_TyD(int src, int offset);
! static int toF_TyB(int c);
! static void put_curr_and_l_to_X(int c);
! static void put_and_redo(int c);
! static void chg_c_toX_orX(void);
! static void chg_c_to_X_orX_(void);
! static void chg_c_to_X_or_X(void);
! static void chg_l_to_X_orX_(void);
! static void chg_l_toXor_X(void);
! static void chg_r_to_Xor_X_(void);
! static int toF_leading(int c);
! static int toF_Rjoin(int c);
! static int canF_Ljoin(int c);
! static int canF_Rjoin(int c);
! static int F_isterm(int c);
! static int toF_ending(int c);
! static void lrswapbuf(char_u *buf, int len);
  
  /*
  ** Convert the given Farsi character into a _X or _X_ type
*** ../vim-7.4.1196/src/fileio.c	2016-01-17 22:15:10.603764137 +0100
--- src/fileio.c	2016-01-29 22:08:23.102986159 +0100
***************
*** 32,59 ****
  static int is_dev_fd_file(char_u *fname);
  #endif
  #ifdef FEAT_MBYTE
! static char_u *next_fenc __ARGS((char_u **pp));
  # ifdef FEAT_EVAL
! static char_u *readfile_charconvert __ARGS((char_u *fname, char_u *fenc, int *fdp));
  # endif
  #endif
  #ifdef FEAT_VIMINFO
! static void check_marks_read __ARGS((void));
  #endif
  #ifdef FEAT_CRYPT
! static char_u *check_for_cryptkey __ARGS((char_u *cryptkey, char_u *ptr, long *sizep, off_t *filesizep, int newfile, char_u *fname, int *did_ask));
  #endif
  #ifdef UNIX
! static void set_file_time __ARGS((char_u *fname, time_t atime, time_t mtime));
  #endif
! static int set_rw_fname __ARGS((char_u *fname, char_u *sfname));
! static int msg_add_fileformat __ARGS((int eol_type));
! static void msg_add_eol __ARGS((void));
! static int check_mtime __ARGS((buf_T *buf, struct stat *s));
! static int time_differs __ARGS((long t1, long t2));
  #ifdef FEAT_AUTOCMD
! static int apply_autocmds_exarg __ARGS((event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap));
! static int au_find_group __ARGS((char_u *name));
  
  # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
  # define AUGROUP_ERROR	    -2	    /* erroneous autocmd group */
--- 32,59 ----
  static int is_dev_fd_file(char_u *fname);
  #endif
  #ifdef FEAT_MBYTE
! static char_u *next_fenc(char_u **pp);
  # ifdef FEAT_EVAL
! static char_u *readfile_charconvert(char_u *fname, char_u *fenc, int *fdp);
  # endif
  #endif
  #ifdef FEAT_VIMINFO
! static void check_marks_read(void);
  #endif
  #ifdef FEAT_CRYPT
! static char_u *check_for_cryptkey(char_u *cryptkey, char_u *ptr, long *sizep, off_t *filesizep, int newfile, char_u *fname, int *did_ask);
  #endif
  #ifdef UNIX
! static void set_file_time(char_u *fname, time_t atime, time_t mtime);
  #endif
! static int set_rw_fname(char_u *fname, char_u *sfname);
! static int msg_add_fileformat(int eol_type);
! static void msg_add_eol(void);
! static int check_mtime(buf_T *buf, struct stat *s);
! static int time_differs(long t1, long t2);
  #ifdef FEAT_AUTOCMD
! static int apply_autocmds_exarg(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap);
! static int au_find_group(char_u *name);
  
  # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
  # define AUGROUP_ERROR	    -2	    /* erroneous autocmd group */
***************
*** 119,143 ****
  #endif
  };
  
! static int  buf_write_bytes __ARGS((struct bw_info *ip));
  
  #ifdef FEAT_MBYTE
! static linenr_T readfile_linenr __ARGS((linenr_T linecnt, char_u *p, char_u *endp));
! static int ucs2bytes __ARGS((unsigned c, char_u **pp, int flags));
! static int need_conversion __ARGS((char_u *fenc));
! static int get_fio_flags __ARGS((char_u *ptr));
! static char_u *check_for_bom __ARGS((char_u *p, long size, int *lenp, int flags));
! static int make_bom __ARGS((char_u *buf, char_u *name));
  # ifdef WIN3264
! static int get_win_fio_flags __ARGS((char_u *ptr));
  # endif
  # ifdef MACOS_X
! static int get_mac_fio_flags __ARGS((char_u *ptr));
  # endif
  #endif
! static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
  #ifdef TEMPDIRNAMES
! static void vim_settempdir __ARGS((char_u *tempdir));
  #endif
  #ifdef FEAT_AUTOCMD
  static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
--- 119,143 ----
  #endif
  };
  
! static int  buf_write_bytes(struct bw_info *ip);
  
  #ifdef FEAT_MBYTE
! static linenr_T readfile_linenr(linenr_T linecnt, char_u *p, char_u *endp);
! static int ucs2bytes(unsigned c, char_u **pp, int flags);
! static int need_conversion(char_u *fenc);
! static int get_fio_flags(char_u *ptr);
! static char_u *check_for_bom(char_u *p, long size, int *lenp, int flags);
! static int make_bom(char_u *buf, char_u *name);
  # ifdef WIN3264
! static int get_win_fio_flags(char_u *ptr);
  # endif
  # ifdef MACOS_X
! static int get_mac_fio_flags(char_u *ptr);
  # endif
  #endif
! static int move_lines(buf_T *frombuf, buf_T *tobuf);
  #ifdef TEMPDIRNAMES
! static void vim_settempdir(char_u *tempdir);
  #endif
  #ifdef FEAT_AUTOCMD
  static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
***************
*** 7811,7832 ****
  
  static int au_need_clean = FALSE;   /* need to delete marked patterns */
  
! static void show_autocmd __ARGS((AutoPat *ap, event_T event));
! static void au_remove_pat __ARGS((AutoPat *ap));
! static void au_remove_cmds __ARGS((AutoPat *ap));
! static void au_cleanup __ARGS((void));
! static int au_new_group __ARGS((char_u *name));
! static void au_del_group __ARGS((char_u *name));
! static event_T event_name2nr __ARGS((char_u *start, char_u **end));
! static char_u *event_nr2name __ARGS((event_T event));
! static char_u *find_end_event __ARGS((char_u *arg, int have_group));
! static int event_ignored __ARGS((event_T event));
! static int au_get_grouparg __ARGS((char_u **argp));
! static int do_autocmd_event __ARGS((event_T event, char_u *pat, int nested, char_u *cmd, int forceit, int group));
! static int apply_autocmds_group __ARGS((event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap));
! static void auto_next_pat __ARGS((AutoPatCmd *apc, int stop_at_last));
  #if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN)
! static int match_file_pat __ARGS((char_u *pattern, regprog_T **prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs));
  #endif
  
  
--- 7811,7832 ----
  
  static int au_need_clean = FALSE;   /* need to delete marked patterns */
  
! static void show_autocmd(AutoPat *ap, event_T event);
! static void au_remove_pat(AutoPat *ap);
! static void au_remove_cmds(AutoPat *ap);
! static void au_cleanup(void);
! static int au_new_group(char_u *name);
! static void au_del_group(char_u *name);
! static event_T event_name2nr(char_u *start, char_u **end);
! static char_u *event_nr2name(event_T event);
! static char_u *find_end_event(char_u *arg, int have_group);
! static int event_ignored(event_T event);
! static int au_get_grouparg(char_u **argp);
! static int do_autocmd_event(event_T event, char_u *pat, int nested, char_u *cmd, int forceit, int group);
! static int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);
! static void auto_next_pat(AutoPatCmd *apc, int stop_at_last);
  #if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN)
! static int match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs);
  #endif
  
  
*** ../vim-7.4.1196/src/fold.c	2015-08-11 19:13:55.138175689 +0200
--- src/fold.c	2016-01-29 22:08:44.438760403 +0100
***************
*** 43,69 ****
  #define MAX_LEVEL	20	/* maximum fold depth */
  
  /* static functions {{{2 */
! static void newFoldLevelWin __ARGS((win_T *wp));
! static int checkCloseRec __ARGS((garray_T *gap, linenr_T lnum, int level));
! static int foldFind __ARGS((garray_T *gap, linenr_T lnum, fold_T **fpp));
! static int foldLevelWin __ARGS((win_T *wp, linenr_T lnum));
! static void checkupdate __ARGS((win_T *wp));
! static void setFoldRepeat __ARGS((linenr_T lnum, long count, int do_open));
! static linenr_T setManualFold __ARGS((linenr_T lnum, int opening, int recurse, int *donep));
! static linenr_T setManualFoldWin __ARGS((win_T *wp, linenr_T lnum, int opening, int recurse, int *donep));
! static void foldOpenNested __ARGS((fold_T *fpr));
! static void deleteFoldEntry __ARGS((garray_T *gap, int idx, int recursive));
! static void foldMarkAdjustRecurse __ARGS((garray_T *gap, linenr_T line1, linenr_T line2, long amount, long amount_after));
! static int getDeepestNestingRecurse __ARGS((garray_T *gap));
! static int check_closed __ARGS((win_T *win, fold_T *fp, int *use_levelp, int level, int *maybe_smallp, linenr_T lnum_off));
! static void checkSmall __ARGS((win_T *wp, fold_T *fp, linenr_T lnum_off));
! static void setSmallMaybe __ARGS((garray_T *gap));
! static void foldCreateMarkers __ARGS((linenr_T start, linenr_T end));
! static void foldAddMarker __ARGS((linenr_T lnum, char_u *marker, int markerlen));
! static void deleteFoldMarkers __ARGS((fold_T *fp, int recursive, linenr_T lnum_off));
! static void foldDelMarker __ARGS((linenr_T lnum, char_u *marker, int markerlen));
! static void foldUpdateIEMS __ARGS((win_T *wp, linenr_T top, linenr_T bot));
! static void parseMarker __ARGS((win_T *wp));
  
  static char *e_nofold = N_("E490: No fold found");
  
--- 43,69 ----
  #define MAX_LEVEL	20	/* maximum fold depth */
  
  /* static functions {{{2 */
! static void newFoldLevelWin(win_T *wp);
! static int checkCloseRec(garray_T *gap, linenr_T lnum, int level);
! static int foldFind(garray_T *gap, linenr_T lnum, fold_T **fpp);
! static int foldLevelWin(win_T *wp, linenr_T lnum);
! static void checkupdate(win_T *wp);
! static void setFoldRepeat(linenr_T lnum, long count, int do_open);
! static linenr_T setManualFold(linenr_T lnum, int opening, int recurse, int *donep);
! static linenr_T setManualFoldWin(win_T *wp, linenr_T lnum, int opening, int recurse, int *donep);
! static void foldOpenNested(fold_T *fpr);
! static void deleteFoldEntry(garray_T *gap, int idx, int recursive);
! static void foldMarkAdjustRecurse(garray_T *gap, linenr_T line1, linenr_T line2, long amount, long amount_after);
! static int getDeepestNestingRecurse(garray_T *gap);
! static int check_closed(win_T *win, fold_T *fp, int *use_levelp, int level, int *maybe_smallp, linenr_T lnum_off);
! static void checkSmall(win_T *wp, fold_T *fp, linenr_T lnum_off);
! static void setSmallMaybe(garray_T *gap);
! static void foldCreateMarkers(linenr_T start, linenr_T end);
! static void foldAddMarker(linenr_T lnum, char_u *marker, int markerlen);
! static void deleteFoldMarkers(fold_T *fp, int recursive, linenr_T lnum_off);
! static void foldDelMarker(linenr_T lnum, char_u *marker, int markerlen);
! static void foldUpdateIEMS(win_T *wp, linenr_T top, linenr_T bot);
! static void parseMarker(win_T *wp);
  
  static char *e_nofold = N_("E490: No fold found");
  
***************
*** 2142,2159 ****
  static int fold_changed;
  
  /* Function declarations. {{{2 */
! static linenr_T foldUpdateIEMSRecurse __ARGS((garray_T *gap, int level, linenr_T startlnum, fline_T *flp, void (*getlevel)__ARGS((fline_T *)), linenr_T bot, int topflags));
! static int foldInsert __ARGS((garray_T *gap, int i));
! static void foldSplit __ARGS((garray_T *gap, int i, linenr_T top, linenr_T bot));
! static void foldRemove __ARGS((garray_T *gap, linenr_T top, linenr_T bot));
! static void foldMerge __ARGS((fold_T *fp1, garray_T *gap, fold_T *fp2));
! static void foldlevelIndent __ARGS((fline_T *flp));
  #ifdef FEAT_DIFF
! static void foldlevelDiff __ARGS((fline_T *flp));
  #endif
! static void foldlevelExpr __ARGS((fline_T *flp));
! static void foldlevelMarker __ARGS((fline_T *flp));
! static void foldlevelSyntax __ARGS((fline_T *flp));
  
  /* foldUpdateIEMS() {{{2 */
  /*
--- 2142,2159 ----
  static int fold_changed;
  
  /* Function declarations. {{{2 */
! static linenr_T foldUpdateIEMSRecurse(garray_T *gap, int level, linenr_T startlnum, fline_T *flp, void (*getlevel)__ARGS((fline_T *)), linenr_T bot, int topflags);
! static int foldInsert(garray_T *gap, int i);
! static void foldSplit(garray_T *gap, int i, linenr_T top, linenr_T bot);
! static void foldRemove(garray_T *gap, linenr_T top, linenr_T bot);
! static void foldMerge(fold_T *fp1, garray_T *gap, fold_T *fp2);
! static void foldlevelIndent(fline_T *flp);
  #ifdef FEAT_DIFF
! static void foldlevelDiff(fline_T *flp);
  #endif
! static void foldlevelExpr(fline_T *flp);
! static void foldlevelMarker(fline_T *flp);
! static void foldlevelSyntax(fline_T *flp);
  
  /* foldUpdateIEMS() {{{2 */
  /*
***************
*** 3314,3322 ****
  /* functions for storing the fold state in a View {{{1 */
  /* put_folds() {{{2 */
  #if defined(FEAT_SESSION) || defined(PROTO)
! static int put_folds_recurse __ARGS((FILE *fd, garray_T *gap, linenr_T off));
! static int put_foldopen_recurse __ARGS((FILE *fd, win_T *wp, garray_T *gap, linenr_T off));
! static int put_fold_open_close __ARGS((FILE *fd, fold_T *fp, linenr_T off));
  
  /*
   * Write commands to "fd" to restore the manual folds in window "wp".
--- 3314,3322 ----
  /* functions for storing the fold state in a View {{{1 */
  /* put_folds() {{{2 */
  #if defined(FEAT_SESSION) || defined(PROTO)
! static int put_folds_recurse(FILE *fd, garray_T *gap, linenr_T off);
! static int put_foldopen_recurse(FILE *fd, win_T *wp, garray_T *gap, linenr_T off);
! static int put_fold_open_close(FILE *fd, fold_T *fp, linenr_T off);
  
  /*
   * Write commands to "fd" to restore the manual folds in window "wp".
*** ../vim-7.4.1196/src/getchar.c	2016-01-21 23:32:14.146035999 +0100
--- src/getchar.c	2016-01-29 22:09:00.118594497 +0100
***************
*** 112,136 ****
  
  static int	last_recorded_len = 0;	/* number of last recorded chars */
  
! static char_u	*get_buffcont __ARGS((buffheader_T *, int));
! static void	add_buff __ARGS((buffheader_T *, char_u *, long n));
! static void	add_num_buff __ARGS((buffheader_T *, long));
! static void	add_char_buff __ARGS((buffheader_T *, int));
! static int	read_readbuffers __ARGS((int advance));
! static int	read_readbuf __ARGS((buffheader_T *buf, int advance));
! static void	start_stuff __ARGS((void));
! static int	read_redo __ARGS((int, int));
! static void	copy_redo __ARGS((int));
! static void	init_typebuf __ARGS((void));
! static void	gotchars __ARGS((char_u *, int));
! static void	may_sync_undo __ARGS((void));
! static void	closescript __ARGS((void));
! static int	vgetorpeek __ARGS((int));
! static void	map_free __ARGS((mapblock_T **));
! static void	validate_maphash __ARGS((void));
! static void	showmap __ARGS((mapblock_T *mp, int local));
  #ifdef FEAT_EVAL
! static char_u	*eval_map_expr __ARGS((char_u *str, int c));
  #endif
  
  /*
--- 112,136 ----
  
  static int	last_recorded_len = 0;	/* number of last recorded chars */
  
! static char_u	*get_buffcont(buffheader_T *, int);
! static void	add_buff(buffheader_T *, char_u *, long n);
! static void	add_num_buff(buffheader_T *, long);
! static void	add_char_buff(buffheader_T *, int);
! static int	read_readbuffers(int advance);
! static int	read_readbuf(buffheader_T *buf, int advance);
! static void	start_stuff(void);
! static int	read_redo(int, int);
! static void	copy_redo(int);
! static void	init_typebuf(void);
! static void	gotchars(char_u *, int);
! static void	may_sync_undo(void);
! static void	closescript(void);
! static int	vgetorpeek(int);
! static void	map_free(mapblock_T **);
! static void	validate_maphash(void);
! static void	showmap(mapblock_T *mp, int local);
  #ifdef FEAT_EVAL
! static char_u	*eval_map_expr(char_u *str, int c);
  #endif
  
  /*
*** ../vim-7.4.1196/src/gui.c	2016-01-02 22:25:40.670710107 +0100
--- src/gui.c	2016-01-29 22:09:14.250444975 +0100
***************
*** 14,47 ****
  gui_T gui;
  
  #if defined(FEAT_MBYTE) && !defined(FEAT_GUI_GTK)
! static void set_guifontwide __ARGS((char_u *font_name));
  #endif
! static void gui_check_pos __ARGS((void));
! static void gui_position_components __ARGS((int));
! static void gui_outstr __ARGS((char_u *, int));
! static int gui_screenchar __ARGS((int off, int flags, guicolor_T fg, guicolor_T bg, int back));
  #ifdef FEAT_GUI_GTK
! static int gui_screenstr __ARGS((int off, int len, int flags, guicolor_T fg, guicolor_T bg, int back));
  #endif
! static void gui_delete_lines __ARGS((int row, int count));
! static void gui_insert_lines __ARGS((int row, int count));
! static void fill_mouse_coord __ARGS((char_u *p, int col, int row));
  #if defined(FEAT_GUI_TABLINE) || defined(PROTO)
! static int gui_has_tabline __ARGS((void));
  #endif
! static void gui_do_scrollbar __ARGS((win_T *wp, int which, int enable));
! static colnr_T scroll_line_len __ARGS((linenr_T lnum));
! static linenr_T gui_find_longest_lnum __ARGS((void));
! static void gui_update_horiz_scrollbar __ARGS((int));
! static void gui_set_fg_color __ARGS((char_u *name));
! static void gui_set_bg_color __ARGS((char_u *name));
! static win_T *xy2win __ARGS((int x, int y));
  
  #if defined(UNIX) && !defined(MACOS_X) && !defined(__APPLE__)
  # define MAY_FORK
! static void gui_do_fork __ARGS((void));
  
! static int gui_read_child_pipe __ARGS((int fd));
  
  /* Return values for gui_read_child_pipe */
  enum {
--- 14,47 ----
  gui_T gui;
  
  #if defined(FEAT_MBYTE) && !defined(FEAT_GUI_GTK)
! static void set_guifontwide(char_u *font_name);
  #endif
! static void gui_check_pos(void);
! static void gui_position_components(int);
! static void gui_outstr(char_u *, int);
! static int gui_screenchar(int off, int flags, guicolor_T fg, guicolor_T bg, int back);
  #ifdef FEAT_GUI_GTK
! static int gui_screenstr(int off, int len, int flags, guicolor_T fg, guicolor_T bg, int back);
  #endif
! static void gui_delete_lines(int row, int count);
! static void gui_insert_lines(int row, int count);
! static void fill_mouse_coord(char_u *p, int col, int row);
  #if defined(FEAT_GUI_TABLINE) || defined(PROTO)
! static int gui_has_tabline(void);
  #endif
! static void gui_do_scrollbar(win_T *wp, int which, int enable);
! static colnr_T scroll_line_len(linenr_T lnum);
! static linenr_T gui_find_longest_lnum(void);
! static void gui_update_horiz_scrollbar(int);
! static void gui_set_fg_color(char_u *name);
! static void gui_set_bg_color(char_u *name);
! static win_T *xy2win(int x, int y);
  
  #if defined(UNIX) && !defined(MACOS_X) && !defined(__APPLE__)
  # define MAY_FORK
! static void gui_do_fork(void);
  
! static int gui_read_child_pipe(int fd);
  
  /* Return values for gui_read_child_pipe */
  enum {
***************
*** 52,58 ****
  
  #endif /* MAY_FORK */
  
! static void gui_attempt_start __ARGS((void));
  
  static int can_update_cursor = TRUE; /* can display the cursor */
  
--- 52,58 ----
  
  #endif /* MAY_FORK */
  
! static void gui_attempt_start(void);
  
  static int can_update_cursor = TRUE; /* can display the cursor */
  
***************
*** 5017,5023 ****
  /*
   * This is shared between Athena, Motif and GTK.
   */
! static void gfp_setname __ARGS((char_u *fname, void *cookie));
  
  /*
   * Callback function for do_in_runtimepath().
--- 5017,5023 ----
  /*
   * This is shared between Athena, Motif and GTK.
   */
! static void gfp_setname(char_u *fname, void *cookie);
  
  /*
   * Callback function for do_in_runtimepath().
***************
*** 5191,5197 ****
  #endif
  
  #if defined(FIND_REPLACE_DIALOG) || defined(PROTO)
! static void concat_esc __ARGS((garray_T *gap, char_u *text, int what));
  
  /*
   * Get the text to use in a find/replace dialog.  Uses the last search pattern
--- 5191,5197 ----
  #endif
  
  #if defined(FIND_REPLACE_DIALOG) || defined(PROTO)
! static void concat_esc(garray_T *gap, char_u *text, int what);
  
  /*
   * Get the text to use in a find/replace dialog.  Uses the last search pattern
***************
*** 5416,5422 ****
  	|| defined(PROTO)
  
  #ifdef FEAT_WINDOWS
! static void gui_wingoto_xy __ARGS((int x, int y));
  
  /*
   * Jump to the window at specified point (x, y).
--- 5416,5422 ----
  	|| defined(PROTO)
  
  #ifdef FEAT_WINDOWS
! static void gui_wingoto_xy(int x, int y);
  
  /*
   * Jump to the window at specified point (x, y).
*** ../vim-7.4.1196/src/gui_at_fs.c	2013-06-27 22:31:35.000000000 +0200
--- src/gui_at_fs.c	2016-01-29 22:09:45.002119619 +0100
***************
*** 172,207 ****
  
  /***************** static functions */
  
! static void SFsetText __ARGS((char *path));
! static void SFtextChanged __ARGS((void));
! static char *SFgetText __ARGS((void));
! static void SFupdatePath __ARGS((void));
! static int SFgetDir __ARGS((SFDir *dir));
! static void SFdrawLists __ARGS((int doScroll));
! static void SFdrawList __ARGS((int n, int doScroll));
! static void SFclearList __ARGS((int n, int doScroll));
! static void SFbuttonPressList __ARGS((Widget w, int n, XButtonPressedEvent *event));
! static void SFbuttonReleaseList __ARGS((Widget w, int n, XButtonReleasedEvent *event));
! static void SFdirModTimer __ARGS((XtPointer cl, XtIntervalId *id));
! static char SFstatChar __ARGS((struct stat *statBuf));
! static void SFdrawStrings __ARGS((Window w, SFDir *dir, int from, int to));
! static int SFnewInvertEntry __ARGS((int n, XMotionEvent *event));
! static void SFinvertEntry __ARGS((int n));
! static void SFenterList __ARGS((Widget w, int n, XEnterWindowEvent *event));
! static void SFleaveList __ARGS((Widget w, int n, XEvent *event));
! static void SFmotionList __ARGS((Widget w, int n, XMotionEvent *event));
! static void SFvFloatSliderMovedCallback __ARGS((Widget w, XtPointer n, XtPointer fnew));
! static void SFvSliderMovedCallback __ARGS((Widget w, int n, int nw));
! static void SFvAreaSelectedCallback __ARGS((Widget w, XtPointer n, XtPointer pnew));
! static void SFhSliderMovedCallback __ARGS((Widget w, XtPointer n, XtPointer nw));
! static void SFhAreaSelectedCallback __ARGS((Widget w, XtPointer n, XtPointer pnew));
! static void SFpathSliderMovedCallback __ARGS((Widget w, XtPointer client_data, XtPointer nw));
! static void SFpathAreaSelectedCallback __ARGS((Widget w, XtPointer client_data, XtPointer pnew));
! static Boolean SFworkProc __ARGS((void));
! static int SFcompareEntries __ARGS((const void *p, const void *q));
! static void SFprepareToReturn __ARGS((void));
! static void SFcreateWidgets __ARGS((Widget toplevel, char *prompt, char *ok, char *cancel));
! static void SFsetColors __ARGS((guicolor_T bg, guicolor_T fg, guicolor_T scroll_bg, guicolor_T scrollfg));
  
  /***************** xstat.h */
  
--- 172,207 ----
  
  /***************** static functions */
  
! static void SFsetText(char *path);
! static void SFtextChanged(void);
! static char *SFgetText(void);
! static void SFupdatePath(void);
! static int SFgetDir(SFDir *dir);
! static void SFdrawLists(int doScroll);
! static void SFdrawList(int n, int doScroll);
! static void SFclearList(int n, int doScroll);
! static void SFbuttonPressList(Widget w, int n, XButtonPressedEvent *event);
! static void SFbuttonReleaseList(Widget w, int n, XButtonReleasedEvent *event);
! static void SFdirModTimer(XtPointer cl, XtIntervalId *id);
! static char SFstatChar(struct stat *statBuf);
! static void SFdrawStrings(Window w, SFDir *dir, int from, int to);
! static int SFnewInvertEntry(int n, XMotionEvent *event);
! static void SFinvertEntry(int n);
! static void SFenterList(Widget w, int n, XEnterWindowEvent *event);
! static void SFleaveList(Widget w, int n, XEvent *event);
! static void SFmotionList(Widget w, int n, XMotionEvent *event);
! static void SFvFloatSliderMovedCallback(Widget w, XtPointer n, XtPointer fnew);
! static void SFvSliderMovedCallback(Widget w, int n, int nw);
! static void SFvAreaSelectedCallback(Widget w, XtPointer n, XtPointer pnew);
! static void SFhSliderMovedCallback(Widget w, XtPointer n, XtPointer nw);
! static void SFhAreaSelectedCallback(Widget w, XtPointer n, XtPointer pnew);
! static void SFpathSliderMovedCallback(Widget w, XtPointer client_data, XtPointer nw);
! static void SFpathAreaSelectedCallback(Widget w, XtPointer client_data, XtPointer pnew);
! static Boolean SFworkProc(void);
! static int SFcompareEntries(const void *p, const void *q);
! static void SFprepareToReturn(void);
! static void SFcreateWidgets(Widget toplevel, char *prompt, char *ok, char *cancel);
! static void SFsetColors(guicolor_T bg, guicolor_T fg, guicolor_T scroll_bg, guicolor_T scrollfg);
  
  /***************** xstat.h */
  
***************
*** 237,243 ****
  
  static int	SFtwiddle = 0;
  
! static int SFchdir __ARGS((char *path));
  
      static int
  SFchdir(path)
--- 237,243 ----
  
  static int	SFtwiddle = 0;
  
! static int SFchdir(char *path);
  
      static int
  SFchdir(path)
***************
*** 257,263 ****
      return result;
  }
  
! static void SFfree __ARGS((int i));
  
      static void
  SFfree(i)
--- 257,263 ----
      return result;
  }
  
! static void SFfree(int i);
  
      static void
  SFfree(i)
***************
*** 281,287 ****
      dir->dir = NULL;
  }
  
! static void SFstrdup __ARGS((char **s1, char *s2));
  
      static void
  SFstrdup(s1, s2)
--- 281,287 ----
      dir->dir = NULL;
  }
  
! static void SFstrdup(char **s1, char *s2);
  
      static void
  SFstrdup(s1, s2)
***************
*** 291,297 ****
      *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
  }
  
! static void SFunreadableDir __ARGS((SFDir *dir));
  
      static void
  SFunreadableDir(dir)
--- 291,297 ----
      *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
  }
  
! static void SFunreadableDir(SFDir *dir);
  
      static void
  SFunreadableDir(dir)
***************
*** 307,313 ****
      dir->nChars = strlen(cannotOpen);
  }
  
! static void SFreplaceText __ARGS((SFDir *dir, char *str));
  
      static void
  SFreplaceText(dir, str)
--- 307,313 ----
      dir->nChars = strlen(cannotOpen);
  }
  
! static void SFreplaceText(SFDir *dir, char *str);
  
      static void
  SFreplaceText(dir, str)
***************
*** 330,336 ****
      SFtextChanged();
  }
  
! static void SFexpand __ARGS((char *str));
  
      static void
  SFexpand(str)
--- 330,336 ----
      SFtextChanged();
  }
  
! static void SFexpand(char *str);
  
      static void
  SFexpand(str)
***************
*** 387,393 ****
      XtFree(growing);
  }
  
! static int SFfindFile __ARGS((SFDir *dir, char *str));
  
      static int
  SFfindFile(dir, str)
--- 387,393 ----
      XtFree(growing);
  }
  
! static int SFfindFile(SFDir *dir, char *str);
  
      static int
  SFfindFile(dir, str)
***************
*** 488,494 ****
      return 0;
  }
  
! static void SFunselect __ARGS((void));
  
      static void
  SFunselect()
--- 488,494 ----
      return 0;
  }
  
! static void SFunselect(void);
  
      static void
  SFunselect()
***************
*** 502,508 ****
      dir->endSelection = -1;
  }
  
! static int SFcompareLogins __ARGS((const void *p, const void *q));
  
      static int
  SFcompareLogins(p, q)
--- 502,508 ----
      dir->endSelection = -1;
  }
  
! static int SFcompareLogins(const void *p, const void *q);
  
      static int
  SFcompareLogins(p, q)
***************
*** 511,517 ****
      return strcmp(((SFLogin *)p)->name, ((SFLogin *)q)->name);
  }
  
! static void SFgetHomeDirs __ARGS((void));
  
      static void
  SFgetHomeDirs()
--- 511,517 ----
      return strcmp(((SFLogin *)p)->name, ((SFLogin *)q)->name);
  }
  
! static void SFgetHomeDirs(void);
  
      static void
  SFgetHomeDirs()
***************
*** 579,585 ****
  	(void)strcat(entries[i].real, "/");
  }
  
! static int SFfindHomeDir __ARGS((char *begin, char *end));
  
      static int
  SFfindHomeDir(begin, end)
--- 579,585 ----
  	(void)strcat(entries[i].real, "/");
  }
  
! static int SFfindHomeDir(char *begin, char *end);
  
      static int
  SFfindHomeDir(begin, end)
***************
*** 882,888 ****
      }
  }
  
! static int SFcheckDir __ARGS((int n, SFDir *dir));
  
      static int
  SFcheckDir(n, dir)
--- 882,888 ----
      }
  }
  
! static int SFcheckDir(int n, SFDir *dir);
  
      static int
  SFcheckDir(n, dir)
***************
*** 948,954 ****
      return 0;
  }
  
! static int SFcheckFiles __ARGS((SFDir *dir));
  
      static int
  SFcheckFiles(dir)
--- 948,954 ----
      return 0;
  }
  
! static int SFcheckFiles(SFDir *dir);
  
      static int
  SFcheckFiles(dir)
***************
*** 1097,1103 ****
  
  static XtIntervalId SFscrollTimerId;
  
! static void SFinitFont __ARGS((void));
  
      static void
  SFinitFont()
--- 1097,1103 ----
  
  static XtIntervalId SFscrollTimerId;
  
! static void SFinitFont(void);
  
      static void
  SFinitFont()
***************
*** 1148,1154 ****
  #endif
  }
  
! static void SFcreateGC __ARGS((void));
  
      static void
  SFcreateGC()
--- 1148,1154 ----
  #endif
  }
  
! static void SFcreateGC(void);
  
      static void
  SFcreateGC()
***************
*** 1283,1289 ****
      }
  }
  
! static void SFdeleteEntry __ARGS((SFDir *dir, SFEntry *entry));
  
      static void
  SFdeleteEntry(dir, entry)
--- 1283,1289 ----
      }
  }
  
! static void SFdeleteEntry(SFDir *dir, SFEntry *entry);
  
      static void
  SFdeleteEntry(dir, entry)
***************
*** 1337,1343 ****
  #endif
  }
  
! static void SFwriteStatChar __ARGS((char *name, int last, struct stat *statBuf));
  
      static void
  SFwriteStatChar(name, last, statBuf)
--- 1337,1343 ----
  #endif
  }
  
! static void SFwriteStatChar(char *name, int last, struct stat *statBuf);
  
      static void
  SFwriteStatChar(name, last, statBuf)
***************
*** 1348,1354 ****
      name[last] = SFstatChar(statBuf);
  }
  
! static int SFstatAndCheck __ARGS((SFDir *dir, SFEntry *entry));
  
      static int
  SFstatAndCheck(dir, entry)
--- 1348,1354 ----
      name[last] = SFstatChar(statBuf);
  }
  
! static int SFstatAndCheck(SFDir *dir, SFEntry *entry);
  
      static int
  SFstatAndCheck(dir, entry)
***************
*** 1562,1568 ****
  	    SFentryHeight);
  }
  
! static unsigned long SFscrollTimerInterval __ARGS((void));
  
      static unsigned long
  SFscrollTimerInterval()
--- 1562,1568 ----
  	    SFentryHeight);
  }
  
! static unsigned long SFscrollTimerInterval(void);
  
      static unsigned long
  SFscrollTimerInterval()
***************
*** 1591,1597 ****
      return (unsigned long)t;
  }
  
! static void SFscrollTimer __ARGS((XtPointer p, XtIntervalId *id));
  
      static void
  SFscrollTimer(p, id)
--- 1591,1597 ----
      return (unsigned long)t;
  }
  
! static void SFscrollTimer(XtPointer p, XtIntervalId *id);
  
      static void
  SFscrollTimer(p, id)
***************
*** 2191,2197 ****
  	Ctrl<Key>M:	redraw-display()\n\
  ";
  
! static void SFexposeList __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
  
      static void
  SFexposeList(w, n, event, cont)
--- 2191,2197 ----
  	Ctrl<Key>M:	redraw-display()\n\
  ";
  
! static void SFexposeList(Widget w, XtPointer n, XEvent *event, Boolean *cont);
  
      static void
  SFexposeList(w, n, event, cont)
***************
*** 2206,2212 ****
      SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
  }
  
! static void SFmodVerifyCallback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
  
      static void
  SFmodVerifyCallback(w, client_data, event, cont)
--- 2206,2212 ----
      SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
  }
  
! static void SFmodVerifyCallback(Widget w, XtPointer client_data, XEvent *event, Boolean *cont);
  
      static void
  SFmodVerifyCallback(w, client_data, event, cont)
***************
*** 2224,2230 ****
  	SFstatus = SEL_FILE_TEXT;
  }
  
! static void SFokCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
  
      static void
  SFokCallback(w, cl, cd)
--- 2224,2230 ----
  	SFstatus = SEL_FILE_TEXT;
  }
  
! static void SFokCallback(Widget w, XtPointer cl, XtPointer cd);
  
      static void
  SFokCallback(w, cl, cd)
***************
*** 2241,2247 ****
      { NULL, (XtPointer) NULL },
  };
  
! static void SFcancelCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
  
      static void
  SFcancelCallback(w, cl, cd)
--- 2241,2247 ----
      { NULL, (XtPointer) NULL },
  };
  
! static void SFcancelCallback(Widget w, XtPointer cl, XtPointer cd);
  
      static void
  SFcancelCallback(w, cl, cd)
***************
*** 2258,2264 ****
      { NULL, (XtPointer) NULL },
  };
  
! static void SFdismissAction __ARGS((Widget w, XEvent *event, String *params, Cardinal *num_params));
  
      static void
  SFdismissAction(w, event, params, num_params)
--- 2258,2264 ----
      { NULL, (XtPointer) NULL },
  };
  
! static void SFdismissAction(Widget w, XEvent *event, String *params, Cardinal *num_params);
  
      static void
  SFdismissAction(w, event, params, num_params)
*** ../vim-7.4.1196/src/gui_athena.c	2013-05-06 04:06:04.000000000 +0200
--- src/gui_athena.c	2016-01-29 22:10:31.141631499 +0100
***************
*** 49,63 ****
  
  /* Used to figure out menu ordering */
  static vimmenu_T *a_cur_menu = NULL;
! static Cardinal	athena_calculate_ins_pos __ARGS((Widget));
  
! static Pixmap gui_athena_create_pullright_pixmap __ARGS((Widget));
! static void gui_athena_menu_timeout __ARGS((XtPointer, XtIntervalId *));
! static void gui_athena_popup_callback __ARGS((Widget, XtPointer, XtPointer));
! static void gui_athena_delayed_arm_action __ARGS((Widget, XEvent *, String *,
! 						 Cardinal *));
! static void gui_athena_popdown_submenus_action __ARGS((Widget, XEvent *,
! 						      String *, Cardinal *));
  static XtActionsRec	pullAction[2] = {
      { "menu-delayedpopup", (XtActionProc)gui_athena_delayed_arm_action},
      { "menu-popdownsubmenus", (XtActionProc)gui_athena_popdown_submenus_action}
--- 49,63 ----
  
  /* Used to figure out menu ordering */
  static vimmenu_T *a_cur_menu = NULL;
! static Cardinal	athena_calculate_ins_pos(Widget);
  
! static Pixmap gui_athena_create_pullright_pixmap(Widget);
! static void gui_athena_menu_timeout(XtPointer, XtIntervalId *);
! static void gui_athena_popup_callback(Widget, XtPointer, XtPointer);
! static void gui_athena_delayed_arm_action(Widget, XEvent *, String *,
! 						 Cardinal *);
! static void gui_athena_popdown_submenus_action(Widget, XEvent *,
! 						      String *, Cardinal *);
  static XtActionsRec	pullAction[2] = {
      { "menu-delayedpopup", (XtActionProc)gui_athena_delayed_arm_action},
      { "menu-popdownsubmenus", (XtActionProc)gui_athena_popdown_submenus_action}
***************
*** 65,80 ****
  #endif
  
  #ifdef FEAT_TOOLBAR
! static void gui_mch_reset_focus __ARGS((void));
  static Widget toolBar = (Widget)0;
  #endif
  
! static void gui_athena_scroll_cb_jump	__ARGS((Widget, XtPointer, XtPointer));
! static void gui_athena_scroll_cb_scroll __ARGS((Widget, XtPointer, XtPointer));
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_MENU)
! static void gui_athena_menu_colors __ARGS((Widget id));
  #endif
! static void gui_athena_scroll_colors __ARGS((Widget id));
  
  #ifdef FEAT_MENU
  static XtTranslations	popupTrans, parentTrans, menuTrans, supermenuTrans;
--- 65,80 ----
  #endif
  
  #ifdef FEAT_TOOLBAR
! static void gui_mch_reset_focus(void);
  static Widget toolBar = (Widget)0;
  #endif
  
! static void gui_athena_scroll_cb_jump(Widget, XtPointer, XtPointer);
! static void gui_athena_scroll_cb_scroll(Widget, XtPointer, XtPointer);
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_MENU)
! static void gui_athena_menu_colors(Widget id);
  #endif
! static void gui_athena_scroll_colors(Widget id);
  
  #ifdef FEAT_MENU
  static XtTranslations	popupTrans, parentTrans, menuTrans, supermenuTrans;
***************
*** 442,449 ****
  #  include <X11/xpm.h>
  # endif
  
! static void createXpmImages __ARGS((char_u *path, char **xpm, Pixmap *sen));
! static void get_toolbar_pixmap __ARGS((vimmenu_T *menu, Pixmap *sen));
  
  /*
   * Allocated a pixmap for toolbar menu "menu".
--- 442,449 ----
  #  include <X11/xpm.h>
  # endif
  
! static void createXpmImages(char_u *path, char **xpm, Pixmap *sen);
! static void get_toolbar_pixmap(vimmenu_T *menu, Pixmap *sen);
  
  /*
   * Allocated a pixmap for toolbar menu "menu".
***************
*** 643,655 ****
   * Menu stuff.
   */
  
! static char_u	*make_pull_name __ARGS((char_u * name));
! static Widget	get_popup_entry __ARGS((Widget w));
! static Widget	submenu_widget __ARGS((Widget));
! static Boolean	has_submenu __ARGS((Widget));
! static void gui_mch_submenu_change __ARGS((vimmenu_T *mp, int colors));
! static void gui_athena_menu_font __ARGS((Widget id));
! static Boolean	gui_athena_menu_has_submenus __ARGS((Widget, Widget));
  
      void
  gui_mch_enable_menu(flag)
--- 643,655 ----
   * Menu stuff.
   */
  
! static char_u	*make_pull_name(char_u * name);
! static Widget	get_popup_entry(Widget w);
! static Widget	submenu_widget(Widget);
! static Boolean	has_submenu(Widget);
! static void gui_mch_submenu_change(vimmenu_T *mp, int colors);
! static void gui_athena_menu_font(Widget id);
! static Boolean	gui_athena_menu_has_submenus(Widget, Widget);
  
      void
  gui_mch_enable_menu(flag)
***************
*** 2066,2074 ****
  static int	dialogStatus;
  static Atom	dialogatom;
  
! static void keyhit_callback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
! static void butproc __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void dialog_wm_handler __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *dum));
  
  /*
   * Callback function for the textfield.  When CR is hit this works like
--- 2066,2074 ----
  static int	dialogStatus;
  static Atom	dialogatom;
  
! static void keyhit_callback(Widget w, XtPointer client_data, XEvent *event, Boolean *cont);
! static void butproc(Widget w, XtPointer client_data, XtPointer call_data);
! static void dialog_wm_handler(Widget w, XtPointer client_data, XEvent *event, Boolean *dum);
  
  /*
   * Callback function for the textfield.  When CR is hit this works like
*** ../vim-7.4.1196/src/gui_beval.c	2014-10-21 14:15:13.419158607 +0200
--- src/gui_beval.c	2016-01-29 22:10:43.721498422 +0100
***************
*** 160,185 ****
  #endif
  
  #ifdef FEAT_GUI_GTK
! static void addEventHandler __ARGS((GtkWidget *, BalloonEval *));
! static void removeEventHandler __ARGS((BalloonEval *));
! static gint target_event_cb __ARGS((GtkWidget *, GdkEvent *, gpointer));
! static gint mainwin_event_cb __ARGS((GtkWidget *, GdkEvent *, gpointer));
! static void pointer_event __ARGS((BalloonEval *, int, int, unsigned));
! static void key_event __ARGS((BalloonEval *, unsigned, int));
! static gint timeout_cb __ARGS((gpointer));
! static gint balloon_expose_event_cb __ARGS((GtkWidget *, GdkEventExpose *, gpointer));
  #else
! static void addEventHandler __ARGS((Widget, BalloonEval *));
! static void removeEventHandler __ARGS((BalloonEval *));
! static void pointerEventEH __ARGS((Widget, XtPointer, XEvent *, Boolean *));
! static void pointerEvent __ARGS((BalloonEval *, XEvent *));
! static void timerRoutine __ARGS((XtPointer, XtIntervalId *));
  #endif
! static void cancelBalloon __ARGS((BalloonEval *));
! static void requestBalloon __ARGS((BalloonEval *));
! static void drawBalloon __ARGS((BalloonEval *));
! static void undrawBalloon __ARGS((BalloonEval *beval));
! static void createBalloonEvalWindow __ARGS((BalloonEval *));
  
  
  
--- 160,185 ----
  #endif
  
  #ifdef FEAT_GUI_GTK
! static void addEventHandler(GtkWidget *, BalloonEval *);
! static void removeEventHandler(BalloonEval *);
! static gint target_event_cb(GtkWidget *, GdkEvent *, gpointer);
! static gint mainwin_event_cb(GtkWidget *, GdkEvent *, gpointer);
! static void pointer_event(BalloonEval *, int, int, unsigned);
! static void key_event(BalloonEval *, unsigned, int);
! static gint timeout_cb(gpointer);
! static gint balloon_expose_event_cb(GtkWidget *, GdkEventExpose *, gpointer);
  #else
! static void addEventHandler(Widget, BalloonEval *);
! static void removeEventHandler(BalloonEval *);
! static void pointerEventEH(Widget, XtPointer, XEvent *, Boolean *);
! static void pointerEvent(BalloonEval *, XEvent *);
! static void timerRoutine(XtPointer, XtIntervalId *);
  #endif
! static void cancelBalloon(BalloonEval *);
! static void requestBalloon(BalloonEval *);
! static void drawBalloon(BalloonEval *);
! static void undrawBalloon(BalloonEval *beval);
! static void createBalloonEvalWindow(BalloonEval *);
  
  
  
*** ../vim-7.4.1196/src/gui_motif.c	2015-06-09 19:14:18.777373918 +0200
--- src/gui_motif.c	2016-01-29 22:11:16.749149049 +0100
***************
*** 83,111 ****
  static Widget menuBar;
  #endif
  
! static void scroll_cb __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
  #ifdef FEAT_GUI_TABLINE
! static void tabline_cb __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void tabline_button_cb __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void tabline_menu_cb __ARGS((Widget w, XtPointer	closure, XEvent	*e, Boolean *continue_dispatch));
! static void tabline_balloon_cb __ARGS((BalloonEval *beval, int state));
  #endif
  #ifdef FEAT_TOOLBAR
  # ifdef FEAT_FOOTER
! static void toolbarbutton_enter_cb __ARGS((Widget, XtPointer, XEvent *, Boolean *));
! static void toolbarbutton_leave_cb __ARGS((Widget, XtPointer, XEvent *, Boolean *));
  # endif
! static void reset_focus __ARGS((void));
  #endif
  #ifdef FEAT_FOOTER
! static int gui_mch_compute_footer_height __ARGS((void));
  #endif
  #ifdef WSDEBUG
  static void attachDump(Widget, char *);
  #endif
  
! static void gui_motif_menu_colors __ARGS((Widget id));
! static void gui_motif_scroll_colors __ARGS((Widget id));
  
  #if (XmVersion >= 1002)
  # define STRING_TAG  XmFONTLIST_DEFAULT_TAG
--- 83,111 ----
  static Widget menuBar;
  #endif
  
! static void scroll_cb(Widget w, XtPointer client_data, XtPointer call_data);
  #ifdef FEAT_GUI_TABLINE
! static void tabline_cb(Widget w, XtPointer client_data, XtPointer call_data);
! static void tabline_button_cb(Widget w, XtPointer client_data, XtPointer call_data);
! static void tabline_menu_cb(Widget w, XtPointer	closure, XEvent	*e, Boolean *continue_dispatch);
! static void tabline_balloon_cb(BalloonEval *beval, int state);
  #endif
  #ifdef FEAT_TOOLBAR
  # ifdef FEAT_FOOTER
! static void toolbarbutton_enter_cb(Widget, XtPointer, XEvent *, Boolean *);
! static void toolbarbutton_leave_cb(Widget, XtPointer, XEvent *, Boolean *);
  # endif
! static void reset_focus(void);
  #endif
  #ifdef FEAT_FOOTER
! static int gui_mch_compute_footer_height(void);
  #endif
  #ifdef WSDEBUG
  static void attachDump(Widget, char *);
  #endif
  
! static void gui_motif_menu_colors(Widget id);
! static void gui_motif_scroll_colors(Widget id);
  
  #if (XmVersion >= 1002)
  # define STRING_TAG  XmFONTLIST_DEFAULT_TAG
***************
*** 310,316 ****
  
  static XtExposeProc old_label_expose = NULL;
  
! static void label_expose __ARGS((Widget _w, XEvent *_event, Region _region));
  
      static void
  label_expose(_w, _event, _region)
--- 310,316 ----
  
  static XtExposeProc old_label_expose = NULL;
  
! static void label_expose(Widget _w, XEvent *_event, Region _region);
  
      static void
  label_expose(_w, _event, _region)
***************
*** 777,790 ****
   * Menu stuff.
   */
  
! static void gui_motif_add_actext __ARGS((vimmenu_T *menu));
  #if (XmVersion >= 1002)
! static void toggle_tearoff __ARGS((Widget wid));
! static void gui_mch_recurse_tearoffs __ARGS((vimmenu_T *menu));
  #endif
! static void submenu_change __ARGS((vimmenu_T *mp, int colors));
  
! static void do_set_mnemonics __ARGS((int enable));
  static int menu_enabled = TRUE;
  
      void
--- 777,790 ----
   * Menu stuff.
   */
  
! static void gui_motif_add_actext(vimmenu_T *menu);
  #if (XmVersion >= 1002)
! static void toggle_tearoff(Widget wid);
! static void gui_mch_recurse_tearoffs(vimmenu_T *menu);
  #endif
! static void submenu_change(vimmenu_T *mp, int colors);
  
! static void do_set_mnemonics(int enable);
  static int menu_enabled = TRUE;
  
      void
***************
*** 1192,1200 ****
   */
  #include "gui_x11_pm.h"
  
! static int check_xpm __ARGS((char_u *path));
! static char **get_toolbar_pixmap __ARGS((vimmenu_T *menu, char **fname));
! static int add_pixmap_args __ARGS((vimmenu_T *menu, Arg *args, int n));
  
  /*
   * Read an Xpm file.  Return OK or FAIL.
--- 1192,1200 ----
   */
  #include "gui_x11_pm.h"
  
! static int check_xpm(char_u *path);
! static char **get_toolbar_pixmap(vimmenu_T *menu, char **fname);
! static int add_pixmap_args(vimmenu_T *menu, Arg *args, int n);
  
  /*
   * Read an Xpm file.  Return OK or FAIL.
***************
*** 2124,2130 ****
  }
  
  #if defined(FEAT_BROWSE) || defined(FEAT_GUI_DIALOG)
! static void set_fontlist __ARGS((Widget wg));
  
  /*
   * Use the 'guifont' or 'guifontset' as a fontlist for a dialog widget.
--- 2124,2130 ----
  }
  
  #if defined(FEAT_BROWSE) || defined(FEAT_GUI_DIALOG)
! static void set_fontlist(Widget wg);
  
  /*
   * Use the 'guifont' or 'guifontset' as a fontlist for a dialog widget.
***************
*** 2197,2204 ****
  static XmStringCharSet charset = (XmStringCharSet) XmSTRING_DEFAULT_CHARSET;
  				/* used to set up XmStrings */
  
! static void DialogCancelCB __ARGS((Widget, XtPointer, XtPointer));
! static void DialogAcceptCB __ARGS((Widget, XtPointer, XtPointer));
  
  /*
   * This function is used to translate the predefined label text of the
--- 2197,2204 ----
  static XmStringCharSet charset = (XmStringCharSet) XmSTRING_DEFAULT_CHARSET;
  				/* used to set up XmStrings */
  
! static void DialogCancelCB(Widget, XtPointer, XtPointer);
! static void DialogAcceptCB(Widget, XtPointer, XtPointer);
  
  /*
   * This function is used to translate the predefined label text of the
***************
*** 2209,2215 ****
   * - equalize the messages between different GUI implementations as far as
   * possible.
   */
! static void set_predefined_label __ARGS((Widget parent, String name, char *new_label));
  
  static void
  set_predefined_label(parent, name, new_label)
--- 2209,2215 ----
   * - equalize the messages between different GUI implementations as far as
   * possible.
   */
! static void set_predefined_label(Widget parent, String name, char *new_label);
  
  static void
  set_predefined_label(parent, name, new_label)
***************
*** 2446,2453 ****
  
  static int	dialogStatus;
  
! static void keyhit_callback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
! static void butproc __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
  
  /*
   * Callback function for the textfield.  When CR is hit this works like
--- 2446,2453 ----
  
  static int	dialogStatus;
  
! static void keyhit_callback(Widget w, XtPointer client_data, XEvent *event, Boolean *cont);
! static void butproc(Widget w, XtPointer client_data, XtPointer call_data);
  
  /*
   * Callback function for the textfield.  When CR is hit this works like
***************
*** 3540,3551 ****
  static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  
! static void find_replace_destroy_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void find_replace_dismiss_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void entry_activate_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void find_replace_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
! static void find_replace_keypress __ARGS((Widget w, SharedFindReplace * frdp, XKeyEvent * event));
! static void find_replace_dialog_create __ARGS((char_u *entry_text, int do_replace));
  
      static void
  find_replace_destroy_callback(w, client_data, call_data)
--- 3540,3551 ----
  static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  
! static void find_replace_destroy_callback(Widget w, XtPointer client_data, XtPointer call_data);
! static void find_replace_dismiss_callback(Widget w, XtPointer client_data, XtPointer call_data);
! static void entry_activate_callback(Widget w, XtPointer client_data, XtPointer call_data);
! static void find_replace_callback(Widget w, XtPointer client_data, XtPointer call_data);
! static void find_replace_keypress(Widget w, SharedFindReplace * frdp, XKeyEvent * event);
! static void find_replace_dialog_create(char_u *entry_text, int do_replace);
  
      static void
  find_replace_destroy_callback(w, client_data, call_data)
*** ../vim-7.4.1196/src/gui_w32.c	2016-01-29 21:11:20.967061365 +0100
--- src/gui_w32.c	2016-01-29 22:11:35.320952605 +0100
***************
*** 331,339 ****
  # define UINT_PTR UINT
  #endif
  
! static void make_tooltip __ARGS((BalloonEval *beval, char *text, POINT pt));
! static void delete_tooltip __ARGS((BalloonEval *beval));
! static VOID CALLBACK BevalTimerProc __ARGS((HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime));
  
  static BalloonEval  *cur_beval = NULL;
  static UINT_PTR	    BevalTimerId = 0;
--- 331,339 ----
  # define UINT_PTR UINT
  #endif
  
! static void make_tooltip(BalloonEval *beval, char *text, POINT pt);
! static void delete_tooltip(BalloonEval *beval);
! static VOID CALLBACK BevalTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
  
  static BalloonEval  *cur_beval = NULL;
  static UINT_PTR	    BevalTimerId = 0;
*** ../vim-7.4.1196/src/gui_w48.c	2016-01-27 21:08:12.527796721 +0100
--- src/gui_w48.c	2016-01-29 22:11:47.972818780 +0100
***************
*** 320,327 ****
  
  #ifdef FEAT_BEVAL
  /* balloon-eval WM_NOTIFY_HANDLER */
! static void Handle_WM_Notify __ARGS((HWND hwnd, LPNMHDR pnmh));
! static void TrackUserActivity __ARGS((UINT uMsg));
  #endif
  
  /*
--- 320,327 ----
  
  #ifdef FEAT_BEVAL
  /* balloon-eval WM_NOTIFY_HANDLER */
! static void Handle_WM_Notify(HWND hwnd, LPNMHDR pnmh);
! static void TrackUserActivity(UINT uMsg);
  #endif
  
  /*
*** ../vim-7.4.1196/src/version.c	2016-01-29 22:03:43.485945782 +0100
--- src/version.c	2016-01-29 22:06:19.028299222 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1197,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
77. The phone company asks you to test drive their new PBX system

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
