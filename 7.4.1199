To: vim_dev@googlegroups.com
Subject: Patch 7.4.1199
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1199
Problem:    Still using __ARGS.
Solution:   Remove __ARGS in several files. (script by Hirohito Higashi)
Files:      src/ops.c, src/option.c, src/os_amiga.c, src/os_mac_conv.c,
            src/os_unix.c, src/os_vms.c, src/os_w32exe.c, src/popupmnu.c,
            src/pty.c, src/quickfix.c, src/regexp.c, src/regexp_nfa.c,
            src/screen.c, src/search.c, src/sha256.c, src/spell.c,
            src/syntax.c, src/tag.c, src/term.c, src/termlib.c, src/ui.c,
            src/undo.c, src/version.c, src/window.c


*** ../vim-7.4.1198/src/ops.c	2016-01-12 20:53:20.195539011 +0100
--- src/ops.c	2016-01-29 22:38:38.619809456 +0100
***************
*** 89,127 ****
  };
  
  #ifdef FEAT_VISUALEXTRA
! static void shift_block __ARGS((oparg_T *oap, int amount));
! static void block_insert __ARGS((oparg_T *oap, char_u *s, int b_insert, struct block_def*bdp));
  #endif
! static int	stuff_yank __ARGS((int, char_u *));
! static void	put_reedit_in_typebuf __ARGS((int silent));
! static int	put_in_typebuf __ARGS((char_u *s, int esc, int colon,
! 								 int silent));
! static void	stuffescaped __ARGS((char_u *arg, int literally));
  #ifdef FEAT_MBYTE
! static void	mb_adjust_opend __ARGS((oparg_T *oap));
  #endif
! static void	free_yank __ARGS((long));
! static void	free_yank_all __ARGS((void));
! static int	yank_copy_line __ARGS((struct block_def *bd, long y_idx));
  #ifdef FEAT_CLIPBOARD
! static void	copy_yank_reg __ARGS((struct yankreg *reg));
! static void	may_set_selection __ARGS((void));
  #endif
! static void	dis_msg __ARGS((char_u *p, int skip_esc));
  #if defined(FEAT_COMMENTS) || defined(PROTO)
! static char_u	*skip_comment __ARGS((char_u *line, int process, int include_space, int *is_comment));
  #endif
! static void	block_prep __ARGS((oparg_T *oap, struct block_def *, linenr_T, int));
! static int	do_addsub __ARGS((int op_type, pos_T *pos, int length, linenr_T Prenum1));
  #if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)
! static void	str_to_reg __ARGS((struct yankreg *y_ptr, int yank_type, char_u *str, long len, long blocklen, int str_list));
  #endif
! static int	ends_in_white __ARGS((linenr_T lnum));
  #ifdef FEAT_COMMENTS
! static int	same_leader __ARGS((linenr_T lnum, int, char_u *, int, char_u *));
! static int	fmt_check_par __ARGS((linenr_T, int *, char_u **, int do_comments));
  #else
! static int	fmt_check_par __ARGS((linenr_T));
  #endif
  
  /*
--- 89,127 ----
  };
  
  #ifdef FEAT_VISUALEXTRA
! static void shift_block(oparg_T *oap, int amount);
! static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def*bdp);
  #endif
! static int	stuff_yank(int, char_u *);
! static void	put_reedit_in_typebuf(int silent);
! static int	put_in_typebuf(char_u *s, int esc, int colon,
! 								 int silent);
! static void	stuffescaped(char_u *arg, int literally);
  #ifdef FEAT_MBYTE
! static void	mb_adjust_opend(oparg_T *oap);
  #endif
! static void	free_yank(long);
! static void	free_yank_all(void);
! static int	yank_copy_line(struct block_def *bd, long y_idx);
  #ifdef FEAT_CLIPBOARD
! static void	copy_yank_reg(struct yankreg *reg);
! static void	may_set_selection(void);
  #endif
! static void	dis_msg(char_u *p, int skip_esc);
  #if defined(FEAT_COMMENTS) || defined(PROTO)
! static char_u	*skip_comment(char_u *line, int process, int include_space, int *is_comment);
  #endif
! static void	block_prep(oparg_T *oap, struct block_def *, linenr_T, int);
! static int	do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1);
  #if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)
! static void	str_to_reg(struct yankreg *y_ptr, int yank_type, char_u *str, long len, long blocklen, int str_list);
  #endif
! static int	ends_in_white(linenr_T lnum);
  #ifdef FEAT_COMMENTS
! static int	same_leader(linenr_T lnum, int, char_u *, int, char_u *);
! static int	fmt_check_par(linenr_T, int *, char_u **, int do_comments);
  #else
! static int	fmt_check_par(linenr_T);
  #endif
  
  /*
***************
*** 689,695 ****
      void
  op_reindent(oap, how)
      oparg_T	*oap;
!     int		(*how) __ARGS((void));
  {
      long	i;
      char_u	*l;
--- 689,695 ----
      void
  op_reindent(oap, how)
      oparg_T	*oap;
!     int		(*how)(void);
  {
      long	i;
      char_u	*l;
***************
*** 2276,2282 ****
  }
  #endif
  
! static int swapchars __ARGS((int op_type, pos_T *pos, int length));
  
  /*
   * Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".
--- 2276,2282 ----
  }
  #endif
  
! static int swapchars(int op_type, pos_T *pos, int length);
  
  /*
   * Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".
***************
*** 6429,6435 ****
      return MAUTO;
  }
  
! static char_u *getreg_wrap_one_line __ARGS((char_u *s, int flags));
  
  /*
   * When "flags" has GREG_LIST return a list with text "s".
--- 6429,6435 ----
      return MAUTO;
  }
  
! static char_u *getreg_wrap_one_line(char_u *s, int flags);
  
  /*
   * When "flags" has GREG_LIST return a list with text "s".
***************
*** 6905,6911 ****
      vim_memset(oap, 0, sizeof(oparg_T));
  }
  
! static long	line_count_info __ARGS((char_u *line, long *wc, long *cc, long limit, int eol_size));
  
  /*
   *  Count the number of bytes, characters and "words" in a line.
--- 6905,6911 ----
      vim_memset(oap, 0, sizeof(oparg_T));
  }
  
! static long	line_count_info(char_u *line, long *wc, long *cc, long limit, int eol_size);
  
  /*
   *  Count the number of bytes, characters and "words" in a line.
*** ../vim-7.4.1198/src/option.c	2016-01-20 22:47:57.661335759 +0100
--- src/option.c	2016-01-29 22:38:48.695703186 +0100
***************
*** 3088,3162 ****
  static char *(p_cot_values[]) = {"menu", "menuone", "longest", "preview", "noinsert", "noselect", NULL};
  #endif
  
! static void set_option_default __ARGS((int, int opt_flags, int compatible));
! static void set_options_default __ARGS((int opt_flags));
! static char_u *term_bg_default __ARGS((void));
! static void did_set_option __ARGS((int opt_idx, int opt_flags, int new_value));
! static char_u *illegal_char __ARGS((char_u *, int));
! static int string_to_key __ARGS((char_u *arg));
  #ifdef FEAT_CMDWIN
! static char_u *check_cedit __ARGS((void));
  #endif
  #ifdef FEAT_TITLE
! static void did_set_title __ARGS((int icon));
  #endif
! static char_u *option_expand __ARGS((int opt_idx, char_u *val));
! static void didset_options __ARGS((void));
! static void didset_options2 __ARGS((void));
! static void check_string_option __ARGS((char_u **pp));
  #if defined(FEAT_EVAL) || defined(PROTO)
! static long_u *insecure_flag __ARGS((int opt_idx, int opt_flags));
  #else
  # define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)
  #endif
! static void set_string_option_global __ARGS((int opt_idx, char_u **varp));
! static char_u *set_string_option __ARGS((int opt_idx, char_u *value, int opt_flags));
! static char_u *did_set_string_option __ARGS((int opt_idx, char_u **varp, int new_value_alloced, char_u *oldval, char_u *errbuf, int opt_flags));
! static char_u *set_chars_option __ARGS((char_u **varp));
  #ifdef FEAT_SYN_HL
! static int int_cmp __ARGS((const void *a, const void *b));
  #endif
  #ifdef FEAT_CLIPBOARD
! static char_u *check_clipboard_option __ARGS((void));
  #endif
  #ifdef FEAT_SPELL
! static char_u *did_set_spell_option __ARGS((int is_spellfile));
! static char_u *compile_cap_prog __ARGS((synblock_T *synblock));
  #endif
  #ifdef FEAT_EVAL
! static void set_option_scriptID_idx __ARGS((int opt_idx, int opt_flags, int id));
  #endif
! static char_u *set_bool_option __ARGS((int opt_idx, char_u *varp, int value, int opt_flags));
! static char_u *set_num_option __ARGS((int opt_idx, char_u *varp, long value, char_u *errbuf, size_t errbuflen, int opt_flags));
! static void check_redraw __ARGS((long_u flags));
! static int findoption __ARGS((char_u *));
! static int find_key_option __ARGS((char_u *));
! static void showoptions __ARGS((int all, int opt_flags));
! static int optval_default __ARGS((struct vimoption *, char_u *varp));
! static void showoneopt __ARGS((struct vimoption *, int opt_flags));
! static int put_setstring __ARGS((FILE *fd, char *cmd, char *name, char_u **valuep, int expand));
! static int put_setnum __ARGS((FILE *fd, char *cmd, char *name, long *valuep));
! static int put_setbool __ARGS((FILE *fd, char *cmd, char *name, int value));
! static int  istermoption __ARGS((struct vimoption *));
! static char_u *get_varp_scope __ARGS((struct vimoption *p, int opt_flags));
! static char_u *get_varp __ARGS((struct vimoption *));
! static void option_value2string __ARGS((struct vimoption *, int opt_flags));
! static void check_winopt __ARGS((winopt_T *wop));
! static int wc_use_keyname __ARGS((char_u *varp, long *wcp));
  #ifdef FEAT_LANGMAP
! static void langmap_init __ARGS((void));
! static void langmap_set __ARGS((void));
  #endif
! static void paste_option_changed __ARGS((void));
! static void compatible_set __ARGS((void));
  #ifdef FEAT_LINEBREAK
! static void fill_breakat_flags __ARGS((void));
  #endif
! static int opt_strings_flags __ARGS((char_u *val, char **values, unsigned *flagp, int list));
! static int check_opt_strings __ARGS((char_u *val, char **values, int));
! static int check_opt_wim __ARGS((void));
  #ifdef FEAT_LINEBREAK
! static int briopt_check __ARGS((win_T *wp));
  #endif
  
  /*
--- 3088,3162 ----
  static char *(p_cot_values[]) = {"menu", "menuone", "longest", "preview", "noinsert", "noselect", NULL};
  #endif
  
! static void set_option_default(int, int opt_flags, int compatible);
! static void set_options_default(int opt_flags);
! static char_u *term_bg_default(void);
! static void did_set_option(int opt_idx, int opt_flags, int new_value);
! static char_u *illegal_char(char_u *, int);
! static int string_to_key(char_u *arg);
  #ifdef FEAT_CMDWIN
! static char_u *check_cedit(void);
  #endif
  #ifdef FEAT_TITLE
! static void did_set_title(int icon);
  #endif
! static char_u *option_expand(int opt_idx, char_u *val);
! static void didset_options(void);
! static void didset_options2(void);
! static void check_string_option(char_u **pp);
  #if defined(FEAT_EVAL) || defined(PROTO)
! static long_u *insecure_flag(int opt_idx, int opt_flags);
  #else
  # define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)
  #endif
! static void set_string_option_global(int opt_idx, char_u **varp);
! static char_u *set_string_option(int opt_idx, char_u *value, int opt_flags);
! static char_u *did_set_string_option(int opt_idx, char_u **varp, int new_value_alloced, char_u *oldval, char_u *errbuf, int opt_flags);
! static char_u *set_chars_option(char_u **varp);
  #ifdef FEAT_SYN_HL
! static int int_cmp(const void *a, const void *b);
  #endif
  #ifdef FEAT_CLIPBOARD
! static char_u *check_clipboard_option(void);
  #endif
  #ifdef FEAT_SPELL
! static char_u *did_set_spell_option(int is_spellfile);
! static char_u *compile_cap_prog(synblock_T *synblock);
  #endif
  #ifdef FEAT_EVAL
! static void set_option_scriptID_idx(int opt_idx, int opt_flags, int id);
  #endif
! static char_u *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);
! static char_u *set_num_option(int opt_idx, char_u *varp, long value, char_u *errbuf, size_t errbuflen, int opt_flags);
! static void check_redraw(long_u flags);
! static int findoption(char_u *);
! static int find_key_option(char_u *);
! static void showoptions(int all, int opt_flags);
! static int optval_default(struct vimoption *, char_u *varp);
! static void showoneopt(struct vimoption *, int opt_flags);
! static int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, int expand);
! static int put_setnum(FILE *fd, char *cmd, char *name, long *valuep);
! static int put_setbool(FILE *fd, char *cmd, char *name, int value);
! static int  istermoption(struct vimoption *);
! static char_u *get_varp_scope(struct vimoption *p, int opt_flags);
! static char_u *get_varp(struct vimoption *);
! static void option_value2string(struct vimoption *, int opt_flags);
! static void check_winopt(winopt_T *wop);
! static int wc_use_keyname(char_u *varp, long *wcp);
  #ifdef FEAT_LANGMAP
! static void langmap_init(void);
! static void langmap_set(void);
  #endif
! static void paste_option_changed(void);
! static void compatible_set(void);
  #ifdef FEAT_LINEBREAK
! static void fill_breakat_flags(void);
  #endif
! static int opt_strings_flags(char_u *val, char **values, unsigned *flagp, int list);
! static int check_opt_strings(char_u *val, char **values, int);
! static int check_opt_wim(void);
  #ifdef FEAT_LINEBREAK
! static int briopt_check(win_T *wp);
  #endif
  
  /*
***************
*** 4085,4091 ****
  #endif
  
  #ifdef FEAT_GUI
! static char_u *gui_bg_default __ARGS((void));
  
      static char_u *
  gui_bg_default()
--- 4085,4091 ----
  #endif
  
  #ifdef FEAT_GUI
! static char_u *gui_bg_default(void);
  
      static char_u *
  gui_bg_default()
***************
*** 5656,5662 ****
  #endif
  
  #ifdef FEAT_TITLE
! static void redraw_titles __ARGS((void));
  
  /*
   * Redraw the window title and/or tab page text later.
--- 5656,5662 ----
  #endif
  
  #ifdef FEAT_TITLE
! static void redraw_titles(void);
  
  /*
   * Redraw the window title and/or tab page text later.
***************
*** 11486,11492 ****
  } langmap_entry_T;
  
  static garray_T langmap_mapga;
! static void langmap_set_entry __ARGS((int from, int to));
  
  /*
   * Search for an entry in "langmap_mapga" for "from".  If found set the "to"
--- 11486,11492 ----
  } langmap_entry_T;
  
  static garray_T langmap_mapga;
! static void langmap_set_entry(int from, int to);
  
  /*
   * Search for an entry in "langmap_mapga" for "from".  If found set the "to"
*** ../vim-7.4.1198/src/os_amiga.c	2015-03-21 17:32:14.062779961 +0100
--- src/os_amiga.c	2016-01-29 22:38:58.603598687 +0100
***************
*** 71,82 ****
  #ifdef __amigaos4__
  # define	dos_packet(a, b, c)   DoPkt(a, b, c, 0, 0, 0, 0)
  #elif !defined(AZTEC_C) && !defined(__AROS__)
! static long dos_packet __ARGS((struct MsgPort *, long, long));
  #endif
! static int lock2name __ARGS((BPTR lock, char_u *buf, long   len));
! static void out_num __ARGS((long n));
! static struct FileInfoBlock *get_fib __ARGS((char_u *));
! static int sortcmp __ARGS((const void *a, const void *b));
  
  static BPTR		raw_in = (BPTR)NULL;
  static BPTR		raw_out = (BPTR)NULL;
--- 71,82 ----
  #ifdef __amigaos4__
  # define	dos_packet(a, b, c)   DoPkt(a, b, c, 0, 0, 0, 0)
  #elif !defined(AZTEC_C) && !defined(__AROS__)
! static long dos_packet(struct MsgPort *, long, long);
  #endif
! static int lock2name(BPTR lock, char_u *buf, long   len);
! static void out_num(long n);
! static struct FileInfoBlock *get_fib(char_u *);
! static int sortcmp(const void *a, const void *b);
  
  static BPTR		raw_in = (BPTR)NULL;
  static BPTR		raw_out = (BPTR)NULL;
***************
*** 219,225 ****
      int	    ignoreinput;
  {
  #ifndef LATTICE		/* SAS declares void Delay(ULONG) */
!     void	    Delay __ARGS((long));
  #endif
  
      if (msec > 0)
--- 219,225 ----
      int	    ignoreinput;
  {
  #ifndef LATTICE		/* SAS declares void Delay(ULONG) */
!     void	    Delay(long);
  #endif
  
      if (msec > 0)
*** ../vim-7.4.1198/src/os_mac_conv.c	2011-10-20 18:19:45.000000000 +0200
--- src/os_mac_conv.c	2016-01-29 22:39:07.127508786 +0100
***************
*** 31,38 ****
  typedef int CFStringRef;
  # endif
  
! static char_u	    *mac_utf16_to_utf8 __ARGS((UniChar *from, size_t fromLen, size_t *actualLen));
! static UniChar	    *mac_utf8_to_utf16 __ARGS((char_u *from, size_t fromLen, size_t *actualLen));
  
  /* Converter for composing decomposed HFS+ file paths */
  static TECObjectRef gPathConverter;
--- 31,38 ----
  typedef int CFStringRef;
  # endif
  
! static char_u	    *mac_utf16_to_utf8(UniChar *from, size_t fromLen, size_t *actualLen);
! static UniChar	    *mac_utf8_to_utf16(char_u *from, size_t fromLen, size_t *actualLen);
  
  /* Converter for composing decomposed HFS+ file paths */
  static TECObjectRef gPathConverter;
*** ../vim-7.4.1198/src/os_unix.c	2016-01-27 20:47:14.000982975 +0100
--- src/os_unix.c	2016-01-29 22:39:57.814974199 +0100
***************
*** 78,84 ****
  #endif
  
  #if defined(HAVE_SELECT)
! extern int   select __ARGS((int, fd_set *, fd_set *, fd_set *, struct timeval *));
  #endif
  
  #ifdef FEAT_MOUSE_GPM
--- 78,84 ----
  #endif
  
  #if defined(HAVE_SELECT)
! extern int   select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
  #endif
  
  #ifdef FEAT_MOUSE_GPM
***************
*** 98,114 ****
  # define KG_CTRLR	7
  # define KG_CAPSSHIFT	8
  
! static void gpm_close __ARGS((void));
! static int gpm_open __ARGS((void));
! static int mch_gpm_process __ARGS((void));
  #endif
  
  #ifdef FEAT_SYSMOUSE
  # include <sys/consio.h>
  # include <sys/fbio.h>
  
! static int sysmouse_open __ARGS((void));
! static void sysmouse_close __ARGS((void));
  static RETSIGTYPE sig_sysmouse __ARGS(SIGPROTOARG);
  #endif
  
--- 98,114 ----
  # define KG_CTRLR	7
  # define KG_CAPSSHIFT	8
  
! static void gpm_close(void);
! static int gpm_open(void);
! static int mch_gpm_process(void);
  #endif
  
  #ifdef FEAT_SYSMOUSE
  # include <sys/consio.h>
  # include <sys/fbio.h>
  
! static int sysmouse_open(void);
! static void sysmouse_close(void);
  static RETSIGTYPE sig_sysmouse __ARGS(SIGPROTOARG);
  #endif
  
***************
*** 140,147 ****
  #  include <X11/Shell.h>
  #  include <X11/StringDefs.h>
  static Widget	xterm_Shell = (Widget)0;
! static void clip_update __ARGS((void));
! static void xterm_update __ARGS((void));
  # endif
  
  # if defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE)
--- 140,147 ----
  #  include <X11/Shell.h>
  #  include <X11/StringDefs.h>
  static Widget	xterm_Shell = (Widget)0;
! static void clip_update(void);
! static void xterm_update(void);
  # endif
  
  # if defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE)
***************
*** 150,164 ****
  Display	    *x11_display = NULL;
  
  # ifdef FEAT_TITLE
! static int  get_x11_windis __ARGS((void));
! static void set_x11_title __ARGS((char_u *));
! static void set_x11_icon __ARGS((char_u *));
  # endif
  #endif
  
  #ifdef FEAT_TITLE
! static int get_x11_title __ARGS((int));
! static int get_x11_icon __ARGS((int));
  
  static char_u	*oldtitle = NULL;
  static int	did_set_title = FALSE;
--- 150,164 ----
  Display	    *x11_display = NULL;
  
  # ifdef FEAT_TITLE
! static int  get_x11_windis(void);
! static void set_x11_title(char_u *);
! static void set_x11_icon(char_u *);
  # endif
  #endif
  
  #ifdef FEAT_TITLE
! static int get_x11_title(int);
! static int get_x11_icon(int);
  
  static char_u	*oldtitle = NULL;
  static int	did_set_title = FALSE;
***************
*** 166,193 ****
  static int	did_set_icon = FALSE;
  #endif
  
! static void may_core_dump __ARGS((void));
  
  #ifdef HAVE_UNION_WAIT
  typedef union wait waitstatus;
  #else
  typedef int waitstatus;
  #endif
! static pid_t wait4pid __ARGS((pid_t, waitstatus *));
  
! static int  WaitForChar __ARGS((long));
  #if defined(__BEOS__) || defined(VMS)
! int  RealWaitForChar __ARGS((int, long, int *));
  #else
! static int  RealWaitForChar __ARGS((int, long, int *));
  #endif
  
  #ifdef FEAT_XCLIPBOARD
! static int do_xterm_trace __ARGS((void));
  # define XT_TRACE_DELAY	50	/* delay for xterm tracing */
  #endif
  
! static void handle_resize __ARGS((void));
  
  #if defined(SIGWINCH)
  static RETSIGTYPE sig_winch __ARGS(SIGPROTOARG);
--- 166,193 ----
  static int	did_set_icon = FALSE;
  #endif
  
! static void may_core_dump(void);
  
  #ifdef HAVE_UNION_WAIT
  typedef union wait waitstatus;
  #else
  typedef int waitstatus;
  #endif
! static pid_t wait4pid(pid_t, waitstatus *);
  
! static int  WaitForChar(long);
  #if defined(__BEOS__) || defined(VMS)
! int  RealWaitForChar(int, long, int *);
  #else
! static int  RealWaitForChar(int, long, int *);
  #endif
  
  #ifdef FEAT_XCLIPBOARD
! static int do_xterm_trace(void);
  # define XT_TRACE_DELAY	50	/* delay for xterm tracing */
  #endif
  
! static void handle_resize(void);
  
  #if defined(SIGWINCH)
  static RETSIGTYPE sig_winch __ARGS(SIGPROTOARG);
***************
*** 207,222 ****
  #endif
  static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
  
! static void catch_int_signal __ARGS((void));
! static void set_signals __ARGS((void));
! static void catch_signals __ARGS((RETSIGTYPE (*func_deadly)(), RETSIGTYPE (*func_other)()));
  #ifndef __EMX__
! static int  have_wildcard __ARGS((int, char_u **));
! static int  have_dollars __ARGS((int, char_u **));
  #endif
  
  #ifndef __EMX__
! static int save_patterns __ARGS((int num_pat, char_u **pat, int *num_file, char_u ***file));
  #endif
  
  #ifndef SIG_ERR
--- 207,222 ----
  #endif
  static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
  
! static void catch_int_signal(void);
! static void set_signals(void);
! static void catch_signals(RETSIGTYPE (*func_deadly)(), RETSIGTYPE (*func_other)());
  #ifndef __EMX__
! static int  have_wildcard(int, char_u **);
! static int  have_dollars(int, char_u **);
  #endif
  
  #ifndef __EMX__
! static int save_patterns(int num_pat, char_u **pat, int *num_file, char_u ***file);
  #endif
  
  #ifndef SIG_ERR
***************
*** 696,702 ****
   * Return a pointer to an item on the stack.  Used to find out if the stack
   * grows up or down.
   */
! static void check_stack_growth __ARGS((char *p));
  static int stack_grows_downwards;
  
  /*
--- 696,702 ----
   * Return a pointer to an item on the stack.  Used to find out if the stack
   * grows up or down.
   */
! static void check_stack_growth(char *p);
  static int stack_grows_downwards;
  
  /*
***************
*** 820,826 ****
  static struct sigstack sigstk;		/* for sigstack() */
  # endif
  
! static void init_signal_stack __ARGS((void));
  static char *signal_stack;
  
      static void
--- 820,826 ----
  static struct sigstack sigstk;		/* for sigstack() */
  # endif
  
! static void init_signal_stack(void);
  static char *signal_stack;
  
      static void
***************
*** 833,839 ****
  		|| MAC_OS_X_VERSION_MAX_ALLOWED <= 1040)
  	/* missing prototype.  Adding it to osdef?.h.in doesn't work, because
  	 * "struct sigaltstack" needs to be declared. */
! 	extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));
  #  endif
  
  #  ifdef HAVE_SS_BASE
--- 833,839 ----
  		|| MAC_OS_X_VERSION_MAX_ALLOWED <= 1040)
  	/* missing prototype.  Adding it to osdef?.h.in doesn't work, because
  	 * "struct sigaltstack" needs to be declared. */
! 	extern int sigaltstack(const struct sigaltstack *ss, struct sigaltstack *oss);
  #  endif
  
  #  ifdef HAVE_SS_BASE
***************
*** 1151,1160 ****
  #endif
  
  # if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
! static void loose_clipboard __ARGS((void));
  # ifdef USE_SYSTEM
! static void save_clipboard __ARGS((void));
! static void restore_clipboard __ARGS((void));
  
  static void *clip_star_save = NULL;
  static void *clip_plus_save = NULL;
--- 1151,1160 ----
  #endif
  
  # if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
! static void loose_clipboard(void);
  # ifdef USE_SYSTEM
! static void save_clipboard(void);
! static void restore_clipboard(void);
  
  static void *clip_star_save = NULL;
  static void *clip_plus_save = NULL;
***************
*** 1489,1495 ****
  # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H) \
  	&& (defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE))
  
! static void xopen_message __ARGS((struct timeval *tvp));
  
  /*
   * Give a message about the elapsed time for opening the X window.
--- 1489,1495 ----
  # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H) \
  	&& (defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE))
  
! static void xopen_message(struct timeval *tvp);
  
  /*
   * Give a message about the elapsed time for opening the X window.
***************
*** 1513,1522 ****
  /*
   * A few functions shared by X11 title and clipboard code.
   */
! static int x_error_handler __ARGS((Display *dpy, XErrorEvent *error_event));
! static int x_error_check __ARGS((Display *dpy, XErrorEvent *error_event));
! static int x_connect_to_server __ARGS((void));
! static int test_x11_window __ARGS((Display *dpy));
  
  static int	got_x_error = FALSE;
  
--- 1513,1522 ----
  /*
   * A few functions shared by X11 title and clipboard code.
   */
! static int x_error_handler(Display *dpy, XErrorEvent *error_event);
! static int x_error_check(Display *dpy, XErrorEvent *error_event);
! static int x_connect_to_server(void);
! static int test_x11_window(Display *dpy);
  
  static int	got_x_error = FALSE;
  
***************
*** 1556,1562 ****
  /*
   * An X IO Error handler, used to catch error while opening the display.
   */
! static int x_IOerror_check __ARGS((Display *dpy));
  
      static int
  x_IOerror_check(dpy)
--- 1556,1562 ----
  /*
   * An X IO Error handler, used to catch error while opening the display.
   */
! static int x_IOerror_check(Display *dpy);
  
      static int
  x_IOerror_check(dpy)
***************
*** 1573,1580 ****
  /*
   * An X IO Error handler, used to catch terminal errors.
   */
! static int x_IOerror_handler __ARGS((Display *dpy));
! static void may_restore_clipboard __ARGS((void));
  static int xterm_dpy_was_reset = FALSE;
  
      static int
--- 1573,1580 ----
  /*
   * An X IO Error handler, used to catch terminal errors.
   */
! static int x_IOerror_handler(Display *dpy);
! static void may_restore_clipboard(void);
  static int xterm_dpy_was_reset = FALSE;
  
      static int
***************
*** 1676,1682 ****
  
  #ifdef FEAT_X11
  
! static int get_x11_thing __ARGS((int get_title, int test_only));
  
  /*
   * try to get x11 window and display
--- 1676,1682 ----
  
  #ifdef FEAT_X11
  
! static int get_x11_thing(int get_title, int test_only);
  
  /*
   * try to get x11 window and display
***************
*** 2393,2399 ****
  }
  
  #if !defined(HAVE_STRERROR) && defined(USE_GETCWD)
! static char *strerror __ARGS((int));
  
      static char *
  strerror(err)
--- 2393,2399 ----
  }
  
  #if !defined(HAVE_STRERROR) && defined(USE_GETCWD)
! static char *strerror(int);
  
      static char *
  strerror(err)
***************
*** 3037,3043 ****
  #endif
  }
  
! static int executable_file __ARGS((char_u *name));
  
  /*
   * Return 1 if "name" is an executable file, 0 if not or it doesn't exist.
--- 3037,3043 ----
  #endif
  }
  
! static int executable_file(char_u *name);
  
  /*
   * Return 1 if "name" is an executable file, 0 if not or it doesn't exist.
***************
*** 3247,3253 ****
  }
  #endif
  
! static void exit_scroll __ARGS((void));
  
  /*
   * Output a newline when exiting.
--- 3247,3253 ----
  }
  #endif
  
! static void exit_scroll(void);
  
  /*
   * Output a newline when exiting.
***************
*** 7107,7121 ****
  /*
   * Code for X Session Management Protocol.
   */
! static void xsmp_handle_save_yourself __ARGS((SmcConn smc_conn, SmPointer client_data, int save_type, Bool shutdown, int interact_style, Bool fast));
! static void xsmp_die __ARGS((SmcConn smc_conn, SmPointer client_data));
! static void xsmp_save_complete __ARGS((SmcConn smc_conn, SmPointer client_data));
! static void xsmp_shutdown_cancelled __ARGS((SmcConn smc_conn, SmPointer	client_data));
! static void xsmp_ice_connection __ARGS((IceConn iceConn, IcePointer clientData, Bool opening, IcePointer *watchData));
  
  
  # if defined(FEAT_GUI) && defined(USE_XSMP_INTERACT)
! static void xsmp_handle_interaction __ARGS((SmcConn smc_conn, SmPointer client_data));
  
  /*
   * This is our chance to ask the user if they want to save,
--- 7107,7121 ----
  /*
   * Code for X Session Management Protocol.
   */
! static void xsmp_handle_save_yourself(SmcConn smc_conn, SmPointer client_data, int save_type, Bool shutdown, int interact_style, Bool fast);
! static void xsmp_die(SmcConn smc_conn, SmPointer client_data);
! static void xsmp_save_complete(SmcConn smc_conn, SmPointer client_data);
! static void xsmp_shutdown_cancelled(SmcConn smc_conn, SmPointer	client_data);
! static void xsmp_ice_connection(IceConn iceConn, IcePointer clientData, Bool opening, IcePointer *watchData);
  
  
  # if defined(FEAT_GUI) && defined(USE_XSMP_INTERACT)
! static void xsmp_handle_interaction(SmcConn smc_conn, SmPointer client_data);
  
  /*
   * This is our chance to ask the user if they want to save,
*** ../vim-7.4.1198/src/os_vms.c	2015-03-21 17:32:14.066779916 +0100
--- src/os_vms.c	2016-01-29 22:40:02.270927207 +0100
***************
*** 77,84 ****
  
  
  
! static TT_MODE	get_tty __ARGS((void));
! static void	set_tty __ARGS((int row, int col));
  
  #define EXPL_ALLOC_INC 64
  
--- 77,84 ----
  
  
  
! static TT_MODE	get_tty(void);
! static void	set_tty(int row, int col);
  
  #define EXPL_ALLOC_INC 64
  
*** ../vim-7.4.1198/src/os_w32exe.c	2016-01-16 18:05:40.445065341 +0100
--- src/os_w32exe.c	2016-01-29 22:40:22.282716151 +0100
***************
*** 27,33 ****
  #else
      main
  #endif
! 	__ARGS((int argc, char **argv));
  static int (_cdecl *pmain)(int, char **);
  
  #ifndef PROTO
--- 27,33 ----
  #else
      main
  #endif
! 	(int argc, char **argv);
  static int (_cdecl *pmain)(int, char **);
  
  #ifndef PROTO
*** ../vim-7.4.1198/src/popupmnu.c	2015-10-30 14:23:29.154200614 +0100
--- src/popupmnu.c	2016-01-29 22:40:44.966476929 +0100
***************
*** 30,36 ****
  
  static int pum_do_redraw = FALSE;	/* do redraw anyway */
  
! static int pum_set_selected __ARGS((int n, int repeat));
  
  #define PUM_DEF_HEIGHT 10
  #define PUM_DEF_WIDTH  15
--- 30,36 ----
  
  static int pum_do_redraw = FALSE;	/* do redraw anyway */
  
! static int pum_set_selected(int n, int repeat);
  
  #define PUM_DEF_HEIGHT 10
  #define PUM_DEF_WIDTH  15
*** ../vim-7.4.1198/src/pty.c	2012-01-20 21:07:56.000000000 +0100
--- src/pty.c	2016-01-29 22:41:08.694226694 +0100
***************
*** 124,130 ****
  # undef HAVE_SVR4_PTYS
  #endif
  
! static void initmaster __ARGS((int));
  
  /*
   *  Open all ptys with O_NOCTTY, just to be on the safe side.
--- 124,130 ----
  # undef HAVE_SVR4_PTYS
  #endif
  
! static void initmaster(int);
  
  /*
   *  Open all ptys with O_NOCTTY, just to be on the safe side.
***************
*** 282,291 ****
  {
      int		f;
      char	*m;
!     char	*(ptsname __ARGS((int)));
!     int		unlockpt __ARGS((int));
!     int		grantpt __ARGS((int));
!     RETSIGTYPE (*sigcld)__ARGS(SIGPROTOARG);
      /* used for opening a new pty-pair: */
      static char TtyName[32];
  
--- 282,291 ----
  {
      int		f;
      char	*m;
!     char	*(ptsname(int));
!     int		unlockpt(int);
!     int		grantpt(int);
!     RETSIGTYPE (*sigcld) SIGPROTOARG;
      /* used for opening a new pty-pair: */
      static char TtyName[32];
  
*** ../vim-7.4.1198/src/quickfix.c	2016-01-22 22:44:06.373407684 +0100
--- src/quickfix.c	2016-01-29 22:41:24.650058426 +0100
***************
*** 106,141 ****
      int		    conthere;	/* %> used */
  };
  
! static int	qf_init_ext __ARGS((qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title));
! static void	qf_store_title __ARGS((qf_info_T *qi, char_u *title));
! static void	qf_new_list __ARGS((qf_info_T *qi, char_u *qf_title));
! static void	ll_free_all __ARGS((qf_info_T **pqi));
! static int	qf_add_entry __ARGS((qf_info_T *qi, qfline_T **prevp, char_u *dir, char_u *fname, int bufnum, char_u *mesg, long lnum, int col, int vis_col, char_u *pattern, int nr, int type, int valid));
! static qf_info_T *ll_new_list __ARGS((void));
! static void	qf_msg __ARGS((qf_info_T *qi));
! static void	qf_free __ARGS((qf_info_T *qi, int idx));
! static char_u	*qf_types __ARGS((int, int));
! static int	qf_get_fnum __ARGS((char_u *, char_u *));
! static char_u	*qf_push_dir __ARGS((char_u *, struct dir_stack_T **));
! static char_u	*qf_pop_dir __ARGS((struct dir_stack_T **));
! static char_u	*qf_guess_filepath __ARGS((char_u *));
! static void	qf_fmt_text __ARGS((char_u *text, char_u *buf, int bufsize));
! static void	qf_clean_dir_stack __ARGS((struct dir_stack_T **));
  #ifdef FEAT_WINDOWS
! static int	qf_win_pos_update __ARGS((qf_info_T *qi, int old_qf_index));
! static int	is_qf_win __ARGS((win_T *win, qf_info_T *qi));
! static win_T	*qf_find_win __ARGS((qf_info_T *qi));
! static buf_T	*qf_find_buf __ARGS((qf_info_T *qi));
! static void	qf_update_buffer __ARGS((qf_info_T *qi));
! static void	qf_set_title_var __ARGS((qf_info_T *qi));
! static void	qf_fill_buffer __ARGS((qf_info_T *qi));
  #endif
! static char_u	*get_mef_name __ARGS((void));
! static void	restore_start_dir __ARGS((char_u *dirname_start));
! static buf_T	*load_dummy_buffer __ARGS((char_u *fname, char_u *dirname_start, char_u *resulting_dir));
! static void	wipe_dummy_buffer __ARGS((buf_T *buf, char_u *dirname_start));
! static void	unload_dummy_buffer __ARGS((buf_T *buf, char_u *dirname_start));
! static qf_info_T *ll_get_or_alloc_list __ARGS((win_T *));
  
  /* Quickfix window check helper macro */
  #define IS_QF_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref == NULL)
--- 106,141 ----
      int		    conthere;	/* %> used */
  };
  
! static int	qf_init_ext(qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title);
! static void	qf_store_title(qf_info_T *qi, char_u *title);
! static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
! static void	ll_free_all(qf_info_T **pqi);
! static int	qf_add_entry(qf_info_T *qi, qfline_T **prevp, char_u *dir, char_u *fname, int bufnum, char_u *mesg, long lnum, int col, int vis_col, char_u *pattern, int nr, int type, int valid);
! static qf_info_T *ll_new_list(void);
! static void	qf_msg(qf_info_T *qi);
! static void	qf_free(qf_info_T *qi, int idx);
! static char_u	*qf_types(int, int);
! static int	qf_get_fnum(char_u *, char_u *);
! static char_u	*qf_push_dir(char_u *, struct dir_stack_T **);
! static char_u	*qf_pop_dir(struct dir_stack_T **);
! static char_u	*qf_guess_filepath(char_u *);
! static void	qf_fmt_text(char_u *text, char_u *buf, int bufsize);
! static void	qf_clean_dir_stack(struct dir_stack_T **);
  #ifdef FEAT_WINDOWS
! static int	qf_win_pos_update(qf_info_T *qi, int old_qf_index);
! static int	is_qf_win(win_T *win, qf_info_T *qi);
! static win_T	*qf_find_win(qf_info_T *qi);
! static buf_T	*qf_find_buf(qf_info_T *qi);
! static void	qf_update_buffer(qf_info_T *qi);
! static void	qf_set_title_var(qf_info_T *qi);
! static void	qf_fill_buffer(qf_info_T *qi);
  #endif
! static char_u	*get_mef_name(void);
! static void	restore_start_dir(char_u *dirname_start);
! static buf_T	*load_dummy_buffer(char_u *fname, char_u *dirname_start, char_u *resulting_dir);
! static void	wipe_dummy_buffer(buf_T *buf, char_u *dirname_start);
! static void	unload_dummy_buffer(buf_T *buf, char_u *dirname_start);
! static qf_info_T *ll_get_or_alloc_list(win_T *);
  
  /* Quickfix window check helper macro */
  #define IS_QF_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref == NULL)
*** ../vim-7.4.1198/src/regexp.c	2015-08-11 19:13:55.142175641 +0200
--- src/regexp.c	2016-01-29 22:42:00.173683805 +0100
***************
*** 255,262 ****
  #define un_Magic(x)	((x) + 256)
  #define is_Magic(x)	((x) < 0)
  
! static int no_Magic __ARGS((int x));
! static int toggle_Magic __ARGS((int x));
  
      static int
  no_Magic(x)
--- 255,262 ----
  #define un_Magic(x)	((x) + 256)
  #define is_Magic(x)	((x) < 0)
  
! static int no_Magic(int x);
! static int toggle_Magic(int x);
  
      static int
  no_Magic(x)
***************
*** 347,364 ****
  
  #define MAX_LIMIT	(32767L << 16L)
  
! static int re_multi_type __ARGS((int));
! static int cstrncmp __ARGS((char_u *s1, char_u *s2, int *n));
! static char_u *cstrchr __ARGS((char_u *, int));
  
  #ifdef BT_REGEXP_DUMP
! static void	regdump __ARGS((char_u *, bt_regprog_T *));
  #endif
  #ifdef DEBUG
! static char_u	*regprop __ARGS((char_u *));
  #endif
  
! static int re_mult_next __ARGS((char *what));
  
  static char_u e_missingbracket[] = N_("E769: Missing ] after %s[");
  static char_u e_unmatchedpp[] = N_("E53: Unmatched %s%%(");
--- 347,364 ----
  
  #define MAX_LIMIT	(32767L << 16L)
  
! static int re_multi_type(int);
! static int cstrncmp(char_u *s1, char_u *s2, int *n);
! static char_u *cstrchr(char_u *, int);
  
  #ifdef BT_REGEXP_DUMP
! static void	regdump(char_u *, bt_regprog_T *);
  #endif
  #ifdef DEBUG
! static char_u	*regprop(char_u *);
  #endif
  
! static int re_mult_next(char *what);
  
  static char_u e_missingbracket[] = N_("E769: Missing ] after %s[");
  static char_u e_unmatchedpp[] = N_("E53: Unmatched %s%%(");
***************
*** 426,438 ****
  static char_u REGEXP_INRANGE[] = "]^-n\\";
  static char_u REGEXP_ABBR[] = "nrtebdoxuU";
  
! static int	backslash_trans __ARGS((int c));
! static int	get_char_class __ARGS((char_u **pp));
! static int	get_equi_class __ARGS((char_u **pp));
! static void	reg_equi_class __ARGS((int c));
! static int	get_coll_element __ARGS((char_u **pp));
! static char_u	*skip_anyof __ARGS((char_u *p));
! static void	init_class_tab __ARGS((void));
  
  /*
   * Translate '\x' to its control character, except "\n", which is Magic.
--- 426,438 ----
  static char_u REGEXP_INRANGE[] = "]^-n\\";
  static char_u REGEXP_ABBR[] = "nrtebdoxuU";
  
! static int	backslash_trans(int c);
! static int	get_char_class(char_u **pp);
! static int	get_equi_class(char_u **pp);
! static void	reg_equi_class(int c);
! static int	get_coll_element(char_u **pp);
! static char_u	*skip_anyof(char_u *p);
! static void	init_class_tab(void);
  
  /*
   * Translate '\x' to its control character, except "\n", which is Magic.
***************
*** 689,721 ****
  /*
   * Forward declarations for vim_regcomp()'s friends.
   */
! static void	initchr __ARGS((char_u *));
! static void	save_parse_state __ARGS((parse_state_T *ps));
! static void	restore_parse_state __ARGS((parse_state_T *ps));
! static int	getchr __ARGS((void));
! static void	skipchr_keepstart __ARGS((void));
! static int	peekchr __ARGS((void));
! static void	skipchr __ARGS((void));
! static void	ungetchr __ARGS((void));
! static int	gethexchrs __ARGS((int maxinputlen));
! static int	getoctchrs __ARGS((void));
! static int	getdecchrs __ARGS((void));
! static int	coll_get_char __ARGS((void));
! static void	regcomp_start __ARGS((char_u *expr, int flags));
! static char_u	*reg __ARGS((int, int *));
! static char_u	*regbranch __ARGS((int *flagp));
! static char_u	*regconcat __ARGS((int *flagp));
! static char_u	*regpiece __ARGS((int *));
! static char_u	*regatom __ARGS((int *));
! static char_u	*regnode __ARGS((int));
! #ifdef FEAT_MBYTE
! static int	use_multibytecode __ARGS((int c));
! #endif
! static int	prog_magic_wrong __ARGS((void));
! static char_u	*regnext __ARGS((char_u *));
! static void	regc __ARGS((int b));
  #ifdef FEAT_MBYTE
! static void	regmbc __ARGS((int c));
  # define REGMBC(x) regmbc(x);
  # define CASEMBC(x) case x:
  #else
--- 689,721 ----
  /*
   * Forward declarations for vim_regcomp()'s friends.
   */
! static void	initchr(char_u *);
! static void	save_parse_state(parse_state_T *ps);
! static void	restore_parse_state(parse_state_T *ps);
! static int	getchr(void);
! static void	skipchr_keepstart(void);
! static int	peekchr(void);
! static void	skipchr(void);
! static void	ungetchr(void);
! static int	gethexchrs(int maxinputlen);
! static int	getoctchrs(void);
! static int	getdecchrs(void);
! static int	coll_get_char(void);
! static void	regcomp_start(char_u *expr, int flags);
! static char_u	*reg(int, int *);
! static char_u	*regbranch(int *flagp);
! static char_u	*regconcat(int *flagp);
! static char_u	*regpiece(int *);
! static char_u	*regatom(int *);
! static char_u	*regnode(int);
! #ifdef FEAT_MBYTE
! static int	use_multibytecode(int c);
! #endif
! static int	prog_magic_wrong(void);
! static char_u	*regnext(char_u *);
! static void	regc(int b);
  #ifdef FEAT_MBYTE
! static void	regmbc(int c);
  # define REGMBC(x) regmbc(x);
  # define CASEMBC(x) case x:
  #else
***************
*** 723,735 ****
  # define REGMBC(x)
  # define CASEMBC(x)
  #endif
! static void	reginsert __ARGS((int, char_u *));
! static void	reginsert_nr __ARGS((int op, long val, char_u *opnd));
! static void	reginsert_limits __ARGS((int, long, long, char_u *));
! static char_u	*re_put_long __ARGS((char_u *pr, long_u val));
! static int	read_limits __ARGS((long *, long *));
! static void	regtail __ARGS((char_u *, char_u *));
! static void	regoptail __ARGS((char_u *, char_u *));
  
  static regengine_T bt_regengine;
  static regengine_T nfa_regengine;
--- 723,735 ----
  # define REGMBC(x)
  # define CASEMBC(x)
  #endif
! static void	reginsert(int, char_u *);
! static void	reginsert_nr(int op, long val, char_u *opnd);
! static void	reginsert_limits(int, long, long, char_u *);
! static char_u	*re_put_long(char_u *pr, long_u val);
! static int	read_limits(long *, long *);
! static void	regtail(char_u *, char_u *);
! static void	regoptail(char_u *, char_u *);
  
  static regengine_T bt_regengine;
  static regengine_T nfa_regengine;
***************
*** 1178,1184 ****
      return 0;
  }
  
! static void get_cpo_flags __ARGS((void));
  static int reg_cpo_lit; /* 'cpoptions' contains 'l' flag */
  static int reg_cpo_bsl; /* 'cpoptions' contains '\' flag */
  
--- 1178,1184 ----
      return 0;
  }
  
! static void get_cpo_flags(void);
  static int reg_cpo_lit; /* 'cpoptions' contains 'l' flag */
  static int reg_cpo_bsl; /* 'cpoptions' contains '\' flag */
  
***************
*** 1302,1309 ****
      return p;
  }
  
! static regprog_T  *bt_regcomp __ARGS((char_u *expr, int re_flags));
! static void bt_regfree __ARGS((regprog_T *prog));
  
  /*
   * bt_regcomp() - compile a regular expression into internal code for the
--- 1302,1309 ----
      return p;
  }
  
! static regprog_T  *bt_regcomp(char_u *expr, int re_flags);
! static void bt_regfree(regprog_T *prog);
  
  /*
   * bt_regcomp() - compile a regular expression into internal code for the
***************
*** 3514,3534 ****
      save_se_T   save_end[NSUBEXP];
  } regbehind_T;
  
! static char_u	*reg_getline __ARGS((linenr_T lnum));
! static long	bt_regexec_both __ARGS((char_u *line, colnr_T col, proftime_T *tm));
! static long	regtry __ARGS((bt_regprog_T *prog, colnr_T col));
! static void	cleanup_subexpr __ARGS((void));
  #ifdef FEAT_SYN_HL
! static void	cleanup_zsubexpr __ARGS((void));
  #endif
! static void	save_subexpr __ARGS((regbehind_T *bp));
! static void	restore_subexpr __ARGS((regbehind_T *bp));
! static void	reg_nextline __ARGS((void));
! static void	reg_save __ARGS((regsave_T *save, garray_T *gap));
! static void	reg_restore __ARGS((regsave_T *save, garray_T *gap));
! static int	reg_save_equal __ARGS((regsave_T *save));
! static void	save_se_multi __ARGS((save_se_T *savep, lpos_T *posp));
! static void	save_se_one __ARGS((save_se_T *savep, char_u **pp));
  
  /* Save the sub-expressions before attempting a match. */
  #define save_se(savep, posp, pp) \
--- 3514,3534 ----
      save_se_T   save_end[NSUBEXP];
  } regbehind_T;
  
! static char_u	*reg_getline(linenr_T lnum);
! static long	bt_regexec_both(char_u *line, colnr_T col, proftime_T *tm);
! static long	regtry(bt_regprog_T *prog, colnr_T col);
! static void	cleanup_subexpr(void);
  #ifdef FEAT_SYN_HL
! static void	cleanup_zsubexpr(void);
  #endif
! static void	save_subexpr(regbehind_T *bp);
! static void	restore_subexpr(regbehind_T *bp);
! static void	reg_nextline(void);
! static void	reg_save(regsave_T *save, garray_T *gap);
! static void	reg_restore(regsave_T *save, garray_T *gap);
! static int	reg_save_equal(regsave_T *save);
! static void	save_se_multi(save_se_T *savep, lpos_T *posp);
! static void	save_se_one(save_se_T *savep, char_u **pp);
  
  /* Save the sub-expressions before attempting a match. */
  #define save_se(savep, posp, pp) \
***************
*** 3541,3550 ****
      else \
  	*(pp) = (savep)->se_u.ptr; }
  
! static int	re_num_cmp __ARGS((long_u val, char_u *scan));
! static int	match_with_backref __ARGS((linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen));
! static int	regmatch __ARGS((char_u *prog));
! static int	regrepeat __ARGS((char_u *p, long maxcount));
  
  #ifdef DEBUG
  int		regnarrate = 0;
--- 3541,3550 ----
      else \
  	*(pp) = (savep)->se_u.ptr; }
  
! static int	re_num_cmp(long_u val, char_u *scan);
! static int	match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);
! static int	regmatch(char_u *prog);
! static int	regrepeat(char_u *p, long maxcount);
  
  #ifdef DEBUG
  int		regnarrate = 0;
***************
*** 3647,3654 ****
      short	rs_no;		/* submatch nr or BEHIND/NOBEHIND */
  } regitem_T;
  
! static regitem_T *regstack_push __ARGS((regstate_T state, char_u *scan));
! static void regstack_pop __ARGS((char_u **scan));
  
  /* used for STAR, PLUS and BRACE_SIMPLE matching */
  typedef struct regstar_S
--- 3647,3654 ----
      short	rs_no;		/* submatch nr or BEHIND/NOBEHIND */
  } regitem_T;
  
! static regitem_T *regstack_push(regstate_T state, char_u *scan);
! static void regstack_pop(char_u **scan);
  
  /* used for STAR, PLUS and BRACE_SIMPLE matching */
  typedef struct regstar_S
***************
*** 3732,3738 ****
  /* TRUE if using multi-line regexp. */
  #define REG_MULTI	(reg_match == NULL)
  
! static int  bt_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr));
  
  
  /*
--- 3732,3738 ----
  /* TRUE if using multi-line regexp. */
  #define REG_MULTI	(reg_match == NULL)
  
! static int  bt_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr);
  
  
  /*
***************
*** 3765,3771 ****
      return bt_regexec_both(line, col, NULL);
  }
  
! static long bt_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm));
  
  /*
   * Match a regexp against multiple lines.
--- 3765,3771 ----
      return bt_regexec_both(line, col, NULL);
  }
  
! static long bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm);
  
  /*
   * Match a regexp against multiple lines.
***************
*** 4033,4039 ****
  }
  
  #ifdef FEAT_SYN_HL
! static reg_extmatch_T *make_extmatch __ARGS((void));
  
  /*
   * Create a new extmatch and mark it as referenced once.
--- 4033,4039 ----
  }
  
  #ifdef FEAT_SYN_HL
! static reg_extmatch_T *make_extmatch(void);
  
  /*
   * Create a new extmatch and mark it as referenced once.
***************
*** 4162,4168 ****
  }
  
  #ifdef FEAT_MBYTE
! static int reg_prev_class __ARGS((void));
  
  /*
   * Get class of previous character.
--- 4162,4168 ----
  }
  
  #ifdef FEAT_MBYTE
! static int reg_prev_class(void);
  
  /*
   * Get class of previous character.
***************
*** 4177,4183 ****
  }
  #endif
  
! static int reg_match_visual __ARGS((void));
  
  /*
   * Return TRUE if the current reginput position matches the Visual area.
--- 4177,4183 ----
  }
  #endif
  
! static int reg_match_visual(void);
  
  /*
   * Return TRUE if the current reginput position matches the Visual area.
***************
*** 7025,7031 ****
  }
  
  #ifdef FEAT_MBYTE
! static void mb_decompose __ARGS((int c, int *c1, int *c2, int *c3));
  
  typedef struct
  {
--- 7025,7031 ----
  }
  
  #ifdef FEAT_MBYTE
! static void mb_decompose(int c, int *c1, int *c2, int *c3);
  
  typedef struct
  {
***************
*** 7238,7251 ****
   * This is impossible, so we declare a pointer to a function returning a
   * pointer to a function returning void. This should work for all compilers.
   */
! typedef void (*(*fptr_T) __ARGS((int *, int)))();
  
! static fptr_T do_upper __ARGS((int *, int));
! static fptr_T do_Upper __ARGS((int *, int));
! static fptr_T do_lower __ARGS((int *, int));
! static fptr_T do_Lower __ARGS((int *, int));
  
! static int vim_regsub_both __ARGS((char_u *source, char_u *dest, int copy, int magic, int backslash));
  
      static fptr_T
  do_upper(d, c)
--- 7238,7251 ----
   * This is impossible, so we declare a pointer to a function returning a
   * pointer to a function returning void. This should work for all compilers.
   */
! typedef void (*(*fptr_T)(int *, int))();
  
! static fptr_T do_upper(int *, int);
! static fptr_T do_Upper(int *, int);
! static fptr_T do_lower(int *, int);
! static fptr_T do_Lower(int *, int);
  
! static int vim_regsub_both(char_u *source, char_u *dest, int copy, int magic, int backslash);
  
      static fptr_T
  do_upper(d, c)
***************
*** 7809,7815 ****
  }
  
  #ifdef FEAT_EVAL
! static char_u *reg_getline_submatch __ARGS((linenr_T lnum));
  
  /*
   * Call reg_getline() with the line numbers from the submatch.  If a
--- 7809,7815 ----
  }
  
  #ifdef FEAT_EVAL
! static char_u *reg_getline_submatch(linenr_T lnum);
  
  /*
   * Call reg_getline() with the line numbers from the submatch.  If a
***************
*** 8142,8148 ****
  }
  
  #ifdef FEAT_EVAL
! static void report_re_switch __ARGS((char_u *pat));
  
      static void
  report_re_switch(pat)
--- 8142,8148 ----
  }
  
  #ifdef FEAT_EVAL
! static void report_re_switch(char_u *pat);
  
      static void
  report_re_switch(pat)
***************
*** 8158,8164 ****
  }
  #endif
  
! static int vim_regexec_both __ARGS((regmatch_T *rmp, char_u *line, colnr_T col, int nl));
  
  /*
   * Match a regexp against a string.
--- 8158,8164 ----
  }
  #endif
  
! static int vim_regexec_both(regmatch_T *rmp, char_u *line, colnr_T col, int nl);
  
  /*
   * Match a regexp against a string.
*** ../vim-7.4.1198/src/regexp_nfa.c	2015-11-24 15:18:28.032829239 +0100
--- src/regexp_nfa.c	2016-01-29 22:42:16.285513901 +0100
***************
*** 282,324 ****
  /* 0 for first call to nfa_regmatch(), 1 for recursive call. */
  static int nfa_ll_index = 0;
  
! static int nfa_regcomp_start __ARGS((char_u *expr, int re_flags));
! static int nfa_get_reganch __ARGS((nfa_state_T *start, int depth));
! static int nfa_get_regstart __ARGS((nfa_state_T *start, int depth));
! static char_u *nfa_get_match_text __ARGS((nfa_state_T *start));
! static int realloc_post_list __ARGS((void));
! static int nfa_recognize_char_class __ARGS((char_u *start, char_u *end, int extra_newl));
! static int nfa_emit_equi_class __ARGS((int c));
! static int nfa_regatom __ARGS((void));
! static int nfa_regpiece __ARGS((void));
! static int nfa_regconcat __ARGS((void));
! static int nfa_regbranch __ARGS((void));
! static int nfa_reg __ARGS((int paren));
  #ifdef DEBUG
! static void nfa_set_code __ARGS((int c));
! static void nfa_postfix_dump __ARGS((char_u *expr, int retval));
! static void nfa_print_state __ARGS((FILE *debugf, nfa_state_T *state));
! static void nfa_print_state2 __ARGS((FILE *debugf, nfa_state_T *state, garray_T *indent));
! static void nfa_dump __ARGS((nfa_regprog_T *prog));
! #endif
! static int *re2post __ARGS((void));
! static nfa_state_T *alloc_state __ARGS((int c, nfa_state_T *out, nfa_state_T *out1));
! static void st_error __ARGS((int *postfix, int *end, int *p));
! static int nfa_max_width __ARGS((nfa_state_T *startstate, int depth));
! static nfa_state_T *post2nfa __ARGS((int *postfix, int *end, int nfa_calc_size));
! static void nfa_postprocess __ARGS((nfa_regprog_T *prog));
! static int check_char_class __ARGS((int class, int c));
! static void nfa_save_listids __ARGS((nfa_regprog_T *prog, int *list));
! static void nfa_restore_listids __ARGS((nfa_regprog_T *prog, int *list));
! static int nfa_re_num_cmp __ARGS((long_u val, int op, long_u pos));
! static long nfa_regtry __ARGS((nfa_regprog_T *prog, colnr_T col, proftime_T *tm));
! static long nfa_regexec_both __ARGS((char_u *line, colnr_T col, proftime_T *tm));
! static regprog_T *nfa_regcomp __ARGS((char_u *expr, int re_flags));
! static void nfa_regfree __ARGS((regprog_T *prog));
! static int  nfa_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr));
! static long nfa_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm));
! static int match_follows __ARGS((nfa_state_T *startstate, int depth));
! static int failure_chance __ARGS((nfa_state_T *state, int depth));
  
  /* helper functions used when doing re2post() ... regatom() parsing */
  #define EMIT(c)	do {				\
--- 282,324 ----
  /* 0 for first call to nfa_regmatch(), 1 for recursive call. */
  static int nfa_ll_index = 0;
  
! static int nfa_regcomp_start(char_u *expr, int re_flags);
! static int nfa_get_reganch(nfa_state_T *start, int depth);
! static int nfa_get_regstart(nfa_state_T *start, int depth);
! static char_u *nfa_get_match_text(nfa_state_T *start);
! static int realloc_post_list(void);
! static int nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl);
! static int nfa_emit_equi_class(int c);
! static int nfa_regatom(void);
! static int nfa_regpiece(void);
! static int nfa_regconcat(void);
! static int nfa_regbranch(void);
! static int nfa_reg(int paren);
  #ifdef DEBUG
! static void nfa_set_code(int c);
! static void nfa_postfix_dump(char_u *expr, int retval);
! static void nfa_print_state(FILE *debugf, nfa_state_T *state);
! static void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent);
! static void nfa_dump(nfa_regprog_T *prog);
! #endif
! static int *re2post(void);
! static nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1);
! static void st_error(int *postfix, int *end, int *p);
! static int nfa_max_width(nfa_state_T *startstate, int depth);
! static nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size);
! static void nfa_postprocess(nfa_regprog_T *prog);
! static int check_char_class(int class, int c);
! static void nfa_save_listids(nfa_regprog_T *prog, int *list);
! static void nfa_restore_listids(nfa_regprog_T *prog, int *list);
! static int nfa_re_num_cmp(long_u val, int op, long_u pos);
! static long nfa_regtry(nfa_regprog_T *prog, colnr_T col, proftime_T *tm);
! static long nfa_regexec_both(char_u *line, colnr_T col, proftime_T *tm);
! static regprog_T *nfa_regcomp(char_u *expr, int re_flags);
! static void nfa_regfree(regprog_T *prog);
! static int  nfa_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr);
! static long nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm);
! static int match_follows(nfa_state_T *startstate, int depth);
! static int failure_chance(nfa_state_T *state, int depth);
  
  /* helper functions used when doing re2post() ... regatom() parsing */
  #define EMIT(c)	do {				\
***************
*** 2739,2750 ****
  };
  typedef struct Frag Frag_T;
  
! static Frag_T frag __ARGS((nfa_state_T *start, Ptrlist *out));
! static Ptrlist *list1 __ARGS((nfa_state_T **outp));
! static void patch __ARGS((Ptrlist *l, nfa_state_T *s));
! static Ptrlist *append __ARGS((Ptrlist *l1, Ptrlist *l2));
! static void st_push __ARGS((Frag_T s, Frag_T **p, Frag_T *stack_end));
! static Frag_T st_pop __ARGS((Frag_T **p, Frag_T *stack));
  
  /*
   * Initialize a Frag_T struct and return it.
--- 2739,2750 ----
  };
  typedef struct Frag Frag_T;
  
! static Frag_T frag(nfa_state_T *start, Ptrlist *out);
! static Ptrlist *list1(nfa_state_T **outp);
! static void patch(Ptrlist *l, nfa_state_T *s);
! static Ptrlist *append(Ptrlist *l1, Ptrlist *l2);
! static void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end);
! static Frag_T st_pop(Frag_T **p, Frag_T *stack);
  
  /*
   * Initialize a Frag_T struct and return it.
***************
*** 3796,3804 ****
  } nfa_list_T;
  
  #ifdef ENABLE_LOG
! static void log_subsexpr __ARGS((regsubs_T *subs));
! static void log_subexpr __ARGS((regsub_T *sub));
! static char *pim_info __ARGS((nfa_pim_T *pim));
  
      static void
  log_subsexpr(subs)
--- 3796,3804 ----
  } nfa_list_T;
  
  #ifdef ENABLE_LOG
! static void log_subsexpr(regsubs_T *subs);
! static void log_subexpr(regsub_T *sub);
! static char *pim_info(nfa_pim_T *pim);
  
      static void
  log_subsexpr(subs)
***************
*** 3862,3879 ****
  static int         nfa_time_count;
  #endif
  
! static void copy_pim __ARGS((nfa_pim_T *to, nfa_pim_T *from));
! static void clear_sub __ARGS((regsub_T *sub));
! static void copy_sub __ARGS((regsub_T *to, regsub_T *from));
! static void copy_sub_off __ARGS((regsub_T *to, regsub_T *from));
! static void copy_ze_off __ARGS((regsub_T *to, regsub_T *from));
! static int sub_equal __ARGS((regsub_T *sub1, regsub_T *sub2));
! static int match_backref __ARGS((regsub_T *sub, int subidx, int *bytelen));
! static int has_state_with_pos __ARGS((nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim));
! static int pim_equal __ARGS((nfa_pim_T *one, nfa_pim_T *two));
! static int state_in_list __ARGS((nfa_list_T *l, nfa_state_T *state, regsubs_T *subs));
! static regsubs_T *addstate __ARGS((nfa_list_T *l, nfa_state_T *state, regsubs_T *subs_arg, nfa_pim_T *pim, int off));
! static void addstate_here __ARGS((nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim, int *ip));
  
  /*
   * Copy postponed invisible match info from "from" to "to".
--- 3862,3879 ----
  static int         nfa_time_count;
  #endif
  
! static void copy_pim(nfa_pim_T *to, nfa_pim_T *from);
! static void clear_sub(regsub_T *sub);
! static void copy_sub(regsub_T *to, regsub_T *from);
! static void copy_sub_off(regsub_T *to, regsub_T *from);
! static void copy_ze_off(regsub_T *to, regsub_T *from);
! static int sub_equal(regsub_T *sub1, regsub_T *sub2);
! static int match_backref(regsub_T *sub, int subidx, int *bytelen);
! static int has_state_with_pos(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim);
! static int pim_equal(nfa_pim_T *one, nfa_pim_T *two);
! static int state_in_list(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs);
! static regsubs_T *addstate(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs_arg, nfa_pim_T *pim, int off);
! static void addstate_here(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim, int *ip);
  
  /*
   * Copy postponed invisible match info from "from" to "to".
***************
*** 4893,4899 ****
  
  #ifdef FEAT_SYN_HL
  
! static int match_zref __ARGS((int subidx, int *bytelen));
  
  /*
   * Check for a match with \z subexpression "subidx".
--- 4893,4899 ----
  
  #ifdef FEAT_SYN_HL
  
! static int match_zref(int subidx, int *bytelen);
  
  /*
   * Check for a match with \z subexpression "subidx".
***************
*** 4977,4984 ****
      return val == pos;
  }
  
! static int recursive_regmatch __ARGS((nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog, regsubs_T *submatch, regsubs_T *m, int **listids));
! static int nfa_regmatch __ARGS((nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *submatch, regsubs_T *m));
  
  /*
   * Recursively call nfa_regmatch()
--- 4977,4984 ----
      return val == pos;
  }
  
! static int recursive_regmatch(nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog, regsubs_T *submatch, regsubs_T *m, int **listids);
! static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *submatch, regsubs_T *m);
  
  /*
   * Recursively call nfa_regmatch()
***************
*** 5158,5165 ****
      return result;
  }
  
! static int skip_to_start __ARGS((int c, colnr_T *colp));
! static long find_match_text __ARGS((colnr_T startcol, int regstart, char_u *match_text));
  
  /*
   * Estimate the chance of a match with "state" failing.
--- 5158,5165 ----
      return result;
  }
  
! static int skip_to_start(int c, colnr_T *colp);
! static long find_match_text(colnr_T startcol, int regstart, char_u *match_text);
  
  /*
   * Estimate the chance of a match with "state" failing.
*** ../vim-7.4.1198/src/screen.c	2016-01-20 22:47:57.665335718 +0100
--- src/screen.c	2016-01-29 22:42:28.477385332 +0100
***************
*** 109,115 ****
  
  #ifdef FEAT_FOLDING
  static foldinfo_T win_foldinfo;	/* info for 'foldcolumn' */
! static int compute_foldcolumn __ARGS((win_T *wp, int col));
  #endif
  
  /*
--- 109,115 ----
  
  #ifdef FEAT_FOLDING
  static foldinfo_T win_foldinfo;	/* info for 'foldcolumn' */
! static int compute_foldcolumn(win_T *wp, int col);
  #endif
  
  /*
***************
*** 117,183 ****
   */
  static schar_T	*current_ScreenLine;
  
! static void win_update __ARGS((win_T *wp));
! static void win_draw_end __ARGS((win_T *wp, int c1, int c2, int row, int endrow, hlf_T hl));
  #ifdef FEAT_FOLDING
! static void fold_line __ARGS((win_T *wp, long fold_count, foldinfo_T *foldinfo, linenr_T lnum, int row));
! static void fill_foldcolumn __ARGS((char_u *p, win_T *wp, int closed, linenr_T lnum));
! static void copy_text_attr __ARGS((int off, char_u *buf, int len, int attr));
  #endif
! static int win_line __ARGS((win_T *, linenr_T, int, int, int nochange));
! static int char_needs_redraw __ARGS((int off_from, int off_to, int cols));
  #ifdef FEAT_RIGHTLEFT
! static void screen_line __ARGS((int row, int coloff, int endcol, int clear_width, int rlflag));
  # define SCREEN_LINE(r, o, e, c, rl)    screen_line((r), (o), (e), (c), (rl))
  #else
! static void screen_line __ARGS((int row, int coloff, int endcol, int clear_width));
  # define SCREEN_LINE(r, o, e, c, rl)    screen_line((r), (o), (e), (c))
  #endif
  #ifdef FEAT_VERTSPLIT
! static void draw_vsep_win __ARGS((win_T *wp, int row));
  #endif
  #ifdef FEAT_STL_OPT
! static void redraw_custom_statusline __ARGS((win_T *wp));
  #endif
  #ifdef FEAT_SEARCH_EXTRA
  # define SEARCH_HL_PRIORITY 0
! static void start_search_hl __ARGS((void));
! static void end_search_hl __ARGS((void));
! static void init_search_hl __ARGS((win_T *wp));
! static void prepare_search_hl __ARGS((win_T *wp, linenr_T lnum));
! static void next_search_hl __ARGS((win_T *win, match_T *shl, linenr_T lnum, colnr_T mincol, matchitem_T *cur));
! static int next_search_hl_pos __ARGS((match_T *shl, linenr_T lnum, posmatch_T *pos, colnr_T mincol));
! #endif
! static void screen_start_highlight __ARGS((int attr));
! static void screen_char __ARGS((unsigned off, int row, int col));
! #ifdef FEAT_MBYTE
! static void screen_char_2 __ARGS((unsigned off, int row, int col));
! #endif
! static void screenclear2 __ARGS((void));
! static void lineclear __ARGS((unsigned off, int width));
! static void lineinvalid __ARGS((unsigned off, int width));
  #ifdef FEAT_VERTSPLIT
! static void linecopy __ARGS((int to, int from, win_T *wp));
! static void redraw_block __ARGS((int row, int end, win_T *wp));
  #endif
! static int win_do_lines __ARGS((win_T *wp, int row, int line_count, int mayclear, int del));
! static void win_rest_invalid __ARGS((win_T *wp));
! static void msg_pos_mode __ARGS((void));
! static void recording_mode __ARGS((int attr));
  #if defined(FEAT_WINDOWS)
! static void draw_tabline __ARGS((void));
  #endif
  #if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT)
! static int fillchar_status __ARGS((int *attr, int is_curwin));
  #endif
  #ifdef FEAT_VERTSPLIT
! static int fillchar_vsep __ARGS((int *attr));
  #endif
  #ifdef FEAT_STL_OPT
! static void win_redr_custom __ARGS((win_T *wp, int draw_ruler));
  #endif
  #ifdef FEAT_CMDL_INFO
! static void win_redr_ruler __ARGS((win_T *wp, int always));
  #endif
  
  #if defined(FEAT_CLIPBOARD) || defined(FEAT_VERTSPLIT)
--- 117,183 ----
   */
  static schar_T	*current_ScreenLine;
  
! static void win_update(win_T *wp);
! static void win_draw_end(win_T *wp, int c1, int c2, int row, int endrow, hlf_T hl);
  #ifdef FEAT_FOLDING
! static void fold_line(win_T *wp, long fold_count, foldinfo_T *foldinfo, linenr_T lnum, int row);
! static void fill_foldcolumn(char_u *p, win_T *wp, int closed, linenr_T lnum);
! static void copy_text_attr(int off, char_u *buf, int len, int attr);
  #endif
! static int win_line(win_T *, linenr_T, int, int, int nochange);
! static int char_needs_redraw(int off_from, int off_to, int cols);
  #ifdef FEAT_RIGHTLEFT
! static void screen_line(int row, int coloff, int endcol, int clear_width, int rlflag);
  # define SCREEN_LINE(r, o, e, c, rl)    screen_line((r), (o), (e), (c), (rl))
  #else
! static void screen_line(int row, int coloff, int endcol, int clear_width);
  # define SCREEN_LINE(r, o, e, c, rl)    screen_line((r), (o), (e), (c))
  #endif
  #ifdef FEAT_VERTSPLIT
! static void draw_vsep_win(win_T *wp, int row);
  #endif
  #ifdef FEAT_STL_OPT
! static void redraw_custom_statusline(win_T *wp);
  #endif
  #ifdef FEAT_SEARCH_EXTRA
  # define SEARCH_HL_PRIORITY 0
! static void start_search_hl(void);
! static void end_search_hl(void);
! static void init_search_hl(win_T *wp);
! static void prepare_search_hl(win_T *wp, linenr_T lnum);
! static void next_search_hl(win_T *win, match_T *shl, linenr_T lnum, colnr_T mincol, matchitem_T *cur);
! static int next_search_hl_pos(match_T *shl, linenr_T lnum, posmatch_T *pos, colnr_T mincol);
! #endif
! static void screen_start_highlight(int attr);
! static void screen_char(unsigned off, int row, int col);
! #ifdef FEAT_MBYTE
! static void screen_char_2(unsigned off, int row, int col);
! #endif
! static void screenclear2(void);
! static void lineclear(unsigned off, int width);
! static void lineinvalid(unsigned off, int width);
  #ifdef FEAT_VERTSPLIT
! static void linecopy(int to, int from, win_T *wp);
! static void redraw_block(int row, int end, win_T *wp);
  #endif
! static int win_do_lines(win_T *wp, int row, int line_count, int mayclear, int del);
! static void win_rest_invalid(win_T *wp);
! static void msg_pos_mode(void);
! static void recording_mode(int attr);
  #if defined(FEAT_WINDOWS)
! static void draw_tabline(void);
  #endif
  #if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT)
! static int fillchar_status(int *attr, int is_curwin);
  #endif
  #ifdef FEAT_VERTSPLIT
! static int fillchar_vsep(int *attr);
  #endif
  #ifdef FEAT_STL_OPT
! static void win_redr_custom(win_T *wp, int draw_ruler);
  #endif
  #ifdef FEAT_CMDL_INFO
! static void win_redr_ruler(win_T *wp, int always);
  #endif
  
  #if defined(FEAT_CLIPBOARD) || defined(FEAT_VERTSPLIT)
***************
*** 826,833 ****
  #endif
  
  #if defined(FEAT_SIGNS) || defined(FEAT_GUI)
! static void update_prepare __ARGS((void));
! static void update_finish __ARGS((void));
  
  /*
   * Prepare for updating one or more windows.
--- 826,833 ----
  #endif
  
  #if defined(FEAT_SIGNS) || defined(FEAT_GUI)
! static void update_prepare(void);
! static void update_finish(void);
  
  /*
   * Prepare for updating one or more windows.
***************
*** 2205,2211 ****
  }
  
  #ifdef FEAT_SIGNS
! static int draw_signcolumn __ARGS((win_T *wp));
  
  /*
   * Return TRUE when window "wp" has a column to draw signs in.
--- 2205,2211 ----
  }
  
  #ifdef FEAT_SIGNS
! static int draw_signcolumn(win_T *wp);
  
  /*
   * Return TRUE when window "wp" has a column to draw signs in.
***************
*** 2334,2340 ****
  }
  
  #ifdef FEAT_SYN_HL
! static int advance_color_col __ARGS((int vcol, int **color_cols));
  
  /*
   * Advance **color_cols and return TRUE when there are columns to draw.
--- 2334,2340 ----
  }
  
  #ifdef FEAT_SYN_HL
! static int advance_color_col(int vcol, int **color_cols);
  
  /*
   * Advance **color_cols and return TRUE when there are columns to draw.
***************
*** 5744,5750 ****
  }
  
  #ifdef FEAT_MBYTE
! static int comp_char_differs __ARGS((int, int));
  
  /*
   * Return if the composing characters at "off_from" and "off_to" differ.
--- 5744,5750 ----
  }
  
  #ifdef FEAT_MBYTE
! static int comp_char_differs(int, int);
  
  /*
   * Return if the composing characters at "off_from" and "off_to" differ.
***************
*** 6341,6348 ****
  #endif
  
  #ifdef FEAT_WILDMENU
! static int status_match_len __ARGS((expand_T *xp, char_u *s));
! static int skip_status_match_char __ARGS((expand_T *xp, char_u *s));
  
  /*
   * Get the length of an item as it will be shown in the status line.
--- 6341,6348 ----
  #endif
  
  #ifdef FEAT_WILDMENU
! static int status_match_len(expand_T *xp, char_u *s);
! static int skip_status_match_char(expand_T *xp, char_u *s);
  
  /*
   * Get the length of an item as it will be shown in the status line.
***************
*** 7168,7174 ****
  }
  
  #ifdef FEAT_MBYTE
! static int screen_comp_differs __ARGS((int, int*));
  
  /*
   * Return TRUE if composing characters for screen posn "off" differs from
--- 7168,7174 ----
  }
  
  #ifdef FEAT_MBYTE
! static int screen_comp_differs(int, int*);
  
  /*
   * Return TRUE if composing characters for screen posn "off" differs from
*** ../vim-7.4.1198/src/search.c	2015-12-28 19:19:41.546241839 +0100
--- src/search.c	2016-01-29 22:42:37.421291015 +0100
***************
*** 13,37 ****
  #include "vim.h"
  
  #ifdef FEAT_EVAL
! static void set_vv_searchforward __ARGS((void));
! static int first_submatch __ARGS((regmmatch_T *rp));
  #endif
! static int check_prevcol __ARGS((char_u *linep, int col, int ch, int *prevcol));
! static int inmacro __ARGS((char_u *, char_u *));
! static int check_linecomment __ARGS((char_u *line));
! static int cls __ARGS((void));
! static int skip_chars __ARGS((int, int));
  #ifdef FEAT_TEXTOBJ
! static void back_in_line __ARGS((void));
! static void find_first_blank __ARGS((pos_T *));
! static void findsent_forward __ARGS((long count, int at_start_sent));
  #endif
  #ifdef FEAT_FIND_ID
! static void show_pat_in_path __ARGS((char_u *, int,
! 					 int, int, FILE *, linenr_T *, long));
  #endif
  #ifdef FEAT_VIMINFO
! static void wvsp_one __ARGS((FILE *fp, int idx, char *s, int sc));
  #endif
  
  /*
--- 13,37 ----
  #include "vim.h"
  
  #ifdef FEAT_EVAL
! static void set_vv_searchforward(void);
! static int first_submatch(regmmatch_T *rp);
  #endif
! static int check_prevcol(char_u *linep, int col, int ch, int *prevcol);
! static int inmacro(char_u *, char_u *);
! static int check_linecomment(char_u *line);
! static int cls(void);
! static int skip_chars(int, int);
  #ifdef FEAT_TEXTOBJ
! static void back_in_line(void);
! static void find_first_blank(pos_T *);
! static void findsent_forward(long count, int at_start_sent);
  #endif
  #ifdef FEAT_FIND_ID
! static void show_pat_in_path(char_u *, int,
! 					 int, int, FILE *, linenr_T *, long);
  #endif
  #ifdef FEAT_VIMINFO
! static void wvsp_one(FILE *fp, int idx, char *s, int sc);
  #endif
  
  /*
***************
*** 1785,1791 ****
      return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;
  }
  
! static int find_rawstring_end __ARGS((char_u *linep, pos_T *startpos, pos_T *endpos));
  
  /*
   * Raw string start is found at linep[startpos.col - 1].
--- 1785,1791 ----
      return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;
  }
  
! static int find_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos);
  
  /*
   * Raw string start is found at linep[startpos.col - 1].
***************
*** 2678,2684 ****
  {
      pos_T	pos, tpos;
      int		c;
!     int		(*func) __ARGS((pos_T *));
      int		startlnum;
      int		noskip = FALSE;	    /* do not skip blanks */
      int		cpo_J;
--- 2678,2684 ----
  {
      pos_T	pos, tpos;
      int		c;
!     int		(*func)(pos_T *);
      int		startlnum;
      int		noskip = FALSE;	    /* do not skip blanks */
      int		cpo_J;
***************
*** 3831,3837 ****
      return OK;
  }
  
! static int in_html_tag __ARGS((int));
  
  /*
   * Return TRUE if the cursor is on a "<aaa>" tag.  Ignore "<aaa/>".
--- 3831,3837 ----
      return OK;
  }
  
! static int in_html_tag(int);
  
  /*
   * Return TRUE if the cursor is on a "<aaa>" tag.  Ignore "<aaa/>".
***************
*** 4286,4293 ****
      return OK;
  }
  
! static int find_next_quote __ARGS((char_u *top_ptr, int col, int quotechar, char_u *escape));
! static int find_prev_quote __ARGS((char_u *line, int col_start, int quotechar, char_u *escape));
  
  /*
   * Search quote char from string line[col].
--- 4286,4293 ----
      return OK;
  }
  
! static int find_next_quote(char_u *top_ptr, int col, int quotechar, char_u *escape);
! static int find_prev_quote(char_u *line, int col_start, int quotechar, char_u *escape);
  
  /*
   * Search quote char from string line[col].
***************
*** 4598,4604 ****
  
  #endif /* FEAT_TEXTOBJ */
  
! static int is_one_char __ARGS((char_u *pattern, int move));
  
  /*
   * Find next search match under cursor, cursor at end.
--- 4598,4604 ----
  
  #endif /* FEAT_TEXTOBJ */
  
! static int is_one_char(char_u *pattern, int move);
  
  /*
   * Find next search match under cursor, cursor at end.
*** ../vim-7.4.1198/src/sha256.c	2013-02-13 17:25:04.000000000 +0100
--- src/sha256.c	2016-01-29 22:42:42.673235631 +0100
***************
*** 24,30 ****
  
  #if defined(FEAT_CRYPT) || defined(FEAT_PERSISTENT_UNDO)
  
! static void sha256_process __ARGS((context_sha256_T *ctx, char_u data[64]));
  
  #define GET_UINT32(n, b, i)		    \
  {					    \
--- 24,30 ----
  
  #if defined(FEAT_CRYPT) || defined(FEAT_PERSISTENT_UNDO)
  
! static void sha256_process(context_sha256_T *ctx, char_u data[64]);
  
  #define GET_UINT32(n, b, i)		    \
  {					    \
***************
*** 273,279 ****
  #endif /* FEAT_CRYPT || FEAT_PERSISTENT_UNDO */
  
  #if defined(FEAT_CRYPT) || defined(PROTO)
! static unsigned int get_some_time __ARGS((void));
  
  /*
   * Returns hex digest of "buf[buf_len]" in a static array.
--- 273,279 ----
  #endif /* FEAT_CRYPT || FEAT_PERSISTENT_UNDO */
  
  #if defined(FEAT_CRYPT) || defined(PROTO)
! static unsigned int get_some_time(void);
  
  /*
   * Returns hex digest of "buf[buf_len]" in a static array.
*** ../vim-7.4.1198/src/spell.c	2016-01-09 13:51:30.527374972 +0100
--- src/spell.c	2016-01-29 22:43:09.468953068 +0100
***************
*** 762,776 ****
  #define CF_WORD		0x01
  #define CF_UPPER	0x02
  
! static void clear_spell_chartab __ARGS((spelltab_T *sp));
! static int set_spell_finish __ARGS((spelltab_T	*new_st));
! static int spell_iswordp __ARGS((char_u *p, win_T *wp));
! static int spell_iswordp_nmw __ARGS((char_u *p, win_T *wp));
  #ifdef FEAT_MBYTE
! static int spell_mb_isword_class __ARGS((int cl, win_T *wp));
! static int spell_iswordp_w __ARGS((int *p, win_T *wp));
  #endif
! static int write_spell_prefcond __ARGS((FILE *fd, garray_T *gap));
  
  /*
   * For finding suggestions: At each node in the tree these states are tried:
--- 762,776 ----
  #define CF_WORD		0x01
  #define CF_UPPER	0x02
  
! static void clear_spell_chartab(spelltab_T *sp);
! static int set_spell_finish(spelltab_T	*new_st);
! static int spell_iswordp(char_u *p, win_T *wp);
! static int spell_iswordp_nmw(char_u *p, win_T *wp);
  #ifdef FEAT_MBYTE
! static int spell_mb_isword_class(int cl, win_T *wp);
! static int spell_iswordp_w(int *p, win_T *wp);
  #endif
! static int write_spell_prefcond(FILE *fd, garray_T *gap);
  
  /*
   * For finding suggestions: At each node in the tree these states are tried:
***************
*** 852,959 ****
  #define FIND_COMPOUND	    3	/* find case-folded compound word */
  #define FIND_KEEPCOMPOUND   4	/* find keep-case compound word */
  
! static slang_T *slang_alloc __ARGS((char_u *lang));
! static void slang_free __ARGS((slang_T *lp));
! static void slang_clear __ARGS((slang_T *lp));
! static void slang_clear_sug __ARGS((slang_T *lp));
! static void find_word __ARGS((matchinf_T *mip, int mode));
! static int match_checkcompoundpattern __ARGS((char_u *ptr, int wlen, garray_T *gap));
! static int can_compound __ARGS((slang_T *slang, char_u *word, char_u *flags));
! static int can_be_compound __ARGS((trystate_T *sp, slang_T *slang, char_u *compflags, int flag));
! static int match_compoundrule __ARGS((slang_T *slang, char_u *compflags));
! static int valid_word_prefix __ARGS((int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req));
! static void find_prefix __ARGS((matchinf_T *mip, int mode));
! static int fold_more __ARGS((matchinf_T *mip));
! static int spell_valid_case __ARGS((int wordflags, int treeflags));
! static int no_spell_checking __ARGS((win_T *wp));
! static void spell_load_lang __ARGS((char_u *lang));
! static char_u *spell_enc __ARGS((void));
! static void int_wordlist_spl __ARGS((char_u *fname));
! static void spell_load_cb __ARGS((char_u *fname, void *cookie));
! static slang_T *spell_load_file __ARGS((char_u *fname, char_u *lang, slang_T *old_lp, int silent));
! static char_u *read_cnt_string __ARGS((FILE *fd, int cnt_bytes, int *lenp));
! static int read_region_section __ARGS((FILE *fd, slang_T *slang, int len));
! static int read_charflags_section __ARGS((FILE *fd));
! static int read_prefcond_section __ARGS((FILE *fd, slang_T *lp));
! static int read_rep_section __ARGS((FILE *fd, garray_T *gap, short *first));
! static int read_sal_section __ARGS((FILE *fd, slang_T *slang));
! static int read_words_section __ARGS((FILE *fd, slang_T *lp, int len));
! static void count_common_word __ARGS((slang_T *lp, char_u *word, int len, int count));
! static int score_wordcount_adj __ARGS((slang_T *slang, int score, char_u *word, int split));
! static int read_sofo_section __ARGS((FILE *fd, slang_T *slang));
! static int read_compound __ARGS((FILE *fd, slang_T *slang, int len));
! static int byte_in_str __ARGS((char_u *str, int byte));
! static int init_syl_tab __ARGS((slang_T *slang));
! static int count_syllables __ARGS((slang_T *slang, char_u *word));
! static int set_sofo __ARGS((slang_T *lp, char_u *from, char_u *to));
! static void set_sal_first __ARGS((slang_T *lp));
! #ifdef FEAT_MBYTE
! static int *mb_str2wide __ARGS((char_u *s));
! #endif
! static int spell_read_tree __ARGS((FILE *fd, char_u **bytsp, idx_T **idxsp, int prefixtree, int prefixcnt));
! static idx_T read_tree_node __ARGS((FILE *fd, char_u *byts, idx_T *idxs, int maxidx, idx_T startidx, int prefixtree, int maxprefcondnr));
! static void clear_midword __ARGS((win_T *buf));
! static void use_midword __ARGS((slang_T *lp, win_T *buf));
! static int find_region __ARGS((char_u *rp, char_u *region));
! static int captype __ARGS((char_u *word, char_u *end));
! static int badword_captype __ARGS((char_u *word, char_u *end));
! static void spell_reload_one __ARGS((char_u *fname, int added_word));
! static void set_spell_charflags __ARGS((char_u *flags, int cnt, char_u *upp));
! static int set_spell_chartab __ARGS((char_u *fol, char_u *low, char_u *upp));
! static int spell_casefold __ARGS((char_u *p, int len, char_u *buf, int buflen));
! static int check_need_cap __ARGS((linenr_T lnum, colnr_T col));
! static void spell_find_suggest __ARGS((char_u *badptr, int badlen, suginfo_T *su, int maxcount, int banbadword, int need_cap, int interactive));
  #ifdef FEAT_EVAL
! static void spell_suggest_expr __ARGS((suginfo_T *su, char_u *expr));
  #endif
! static void spell_suggest_file __ARGS((suginfo_T *su, char_u *fname));
! static void spell_suggest_intern __ARGS((suginfo_T *su, int interactive));
! static void suggest_load_files __ARGS((void));
! static void tree_count_words __ARGS((char_u *byts, idx_T *idxs));
! static void spell_find_cleanup __ARGS((suginfo_T *su));
! static void onecap_copy __ARGS((char_u *word, char_u *wcopy, int upper));
! static void allcap_copy __ARGS((char_u *word, char_u *wcopy));
! static void suggest_try_special __ARGS((suginfo_T *su));
! static void suggest_try_change __ARGS((suginfo_T *su));
! static void suggest_trie_walk __ARGS((suginfo_T *su, langp_T *lp, char_u *fword, int soundfold));
! static void go_deeper __ARGS((trystate_T *stack, int depth, int score_add));
! #ifdef FEAT_MBYTE
! static int nofold_len __ARGS((char_u *fword, int flen, char_u *word));
! #endif
! static void find_keepcap_word __ARGS((slang_T *slang, char_u *fword, char_u *kword));
! static void score_comp_sal __ARGS((suginfo_T *su));
! static void score_combine __ARGS((suginfo_T *su));
! static int stp_sal_score __ARGS((suggest_T *stp, suginfo_T *su, slang_T *slang, char_u *badsound));
! static void suggest_try_soundalike_prep __ARGS((void));
! static void suggest_try_soundalike __ARGS((suginfo_T *su));
! static void suggest_try_soundalike_finish __ARGS((void));
! static void add_sound_suggest __ARGS((suginfo_T *su, char_u *goodword, int score, langp_T *lp));
! static int soundfold_find __ARGS((slang_T *slang, char_u *word));
! static void make_case_word __ARGS((char_u *fword, char_u *cword, int flags));
! static void set_map_str __ARGS((slang_T *lp, char_u *map));
! static int similar_chars __ARGS((slang_T *slang, int c1, int c2));
! static void add_suggestion __ARGS((suginfo_T *su, garray_T *gap, char_u *goodword, int badlen, int score, int altscore, int had_bonus, slang_T *slang, int maxsf));
! static void check_suggestions __ARGS((suginfo_T *su, garray_T *gap));
! static void add_banned __ARGS((suginfo_T *su, char_u *word));
! static void rescore_suggestions __ARGS((suginfo_T *su));
! static void rescore_one __ARGS((suginfo_T *su, suggest_T *stp));
! static int cleanup_suggestions __ARGS((garray_T *gap, int maxscore, int keep));
! static void spell_soundfold __ARGS((slang_T *slang, char_u *inword, int folded, char_u *res));
! static void spell_soundfold_sofo __ARGS((slang_T *slang, char_u *inword, char_u *res));
! static void spell_soundfold_sal __ARGS((slang_T *slang, char_u *inword, char_u *res));
! #ifdef FEAT_MBYTE
! static void spell_soundfold_wsal __ARGS((slang_T *slang, char_u *inword, char_u *res));
! #endif
! static int soundalike_score __ARGS((char_u *goodsound, char_u *badsound));
! static int spell_edit_score __ARGS((slang_T *slang, char_u *badword, char_u *goodword));
! static int spell_edit_score_limit __ARGS((slang_T *slang, char_u *badword, char_u *goodword, int limit));
! #ifdef FEAT_MBYTE
! static int spell_edit_score_limit_w __ARGS((slang_T *slang, char_u *badword, char_u *goodword, int limit));
! #endif
! static void dump_word __ARGS((slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum));
! static linenr_T dump_prefixes __ARGS((slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum));
! static buf_T *open_spellbuf __ARGS((void));
! static void close_spellbuf __ARGS((buf_T *buf));
  
  /*
   * Use our own character-case definitions, because the current locale may
--- 852,959 ----
  #define FIND_COMPOUND	    3	/* find case-folded compound word */
  #define FIND_KEEPCOMPOUND   4	/* find keep-case compound word */
  
! static slang_T *slang_alloc(char_u *lang);
! static void slang_free(slang_T *lp);
! static void slang_clear(slang_T *lp);
! static void slang_clear_sug(slang_T *lp);
! static void find_word(matchinf_T *mip, int mode);
! static int match_checkcompoundpattern(char_u *ptr, int wlen, garray_T *gap);
! static int can_compound(slang_T *slang, char_u *word, char_u *flags);
! static int can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag);
! static int match_compoundrule(slang_T *slang, char_u *compflags);
! static int valid_word_prefix(int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req);
! static void find_prefix(matchinf_T *mip, int mode);
! static int fold_more(matchinf_T *mip);
! static int spell_valid_case(int wordflags, int treeflags);
! static int no_spell_checking(win_T *wp);
! static void spell_load_lang(char_u *lang);
! static char_u *spell_enc(void);
! static void int_wordlist_spl(char_u *fname);
! static void spell_load_cb(char_u *fname, void *cookie);
! static slang_T *spell_load_file(char_u *fname, char_u *lang, slang_T *old_lp, int silent);
! static char_u *read_cnt_string(FILE *fd, int cnt_bytes, int *lenp);
! static int read_region_section(FILE *fd, slang_T *slang, int len);
! static int read_charflags_section(FILE *fd);
! static int read_prefcond_section(FILE *fd, slang_T *lp);
! static int read_rep_section(FILE *fd, garray_T *gap, short *first);
! static int read_sal_section(FILE *fd, slang_T *slang);
! static int read_words_section(FILE *fd, slang_T *lp, int len);
! static void count_common_word(slang_T *lp, char_u *word, int len, int count);
! static int score_wordcount_adj(slang_T *slang, int score, char_u *word, int split);
! static int read_sofo_section(FILE *fd, slang_T *slang);
! static int read_compound(FILE *fd, slang_T *slang, int len);
! static int byte_in_str(char_u *str, int byte);
! static int init_syl_tab(slang_T *slang);
! static int count_syllables(slang_T *slang, char_u *word);
! static int set_sofo(slang_T *lp, char_u *from, char_u *to);
! static void set_sal_first(slang_T *lp);
! #ifdef FEAT_MBYTE
! static int *mb_str2wide(char_u *s);
! #endif
! static int spell_read_tree(FILE *fd, char_u **bytsp, idx_T **idxsp, int prefixtree, int prefixcnt);
! static idx_T read_tree_node(FILE *fd, char_u *byts, idx_T *idxs, int maxidx, idx_T startidx, int prefixtree, int maxprefcondnr);
! static void clear_midword(win_T *buf);
! static void use_midword(slang_T *lp, win_T *buf);
! static int find_region(char_u *rp, char_u *region);
! static int captype(char_u *word, char_u *end);
! static int badword_captype(char_u *word, char_u *end);
! static void spell_reload_one(char_u *fname, int added_word);
! static void set_spell_charflags(char_u *flags, int cnt, char_u *upp);
! static int set_spell_chartab(char_u *fol, char_u *low, char_u *upp);
! static int spell_casefold(char_u *p, int len, char_u *buf, int buflen);
! static int check_need_cap(linenr_T lnum, colnr_T col);
! static void spell_find_suggest(char_u *badptr, int badlen, suginfo_T *su, int maxcount, int banbadword, int need_cap, int interactive);
  #ifdef FEAT_EVAL
! static void spell_suggest_expr(suginfo_T *su, char_u *expr);
  #endif
! static void spell_suggest_file(suginfo_T *su, char_u *fname);
! static void spell_suggest_intern(suginfo_T *su, int interactive);
! static void suggest_load_files(void);
! static void tree_count_words(char_u *byts, idx_T *idxs);
! static void spell_find_cleanup(suginfo_T *su);
! static void onecap_copy(char_u *word, char_u *wcopy, int upper);
! static void allcap_copy(char_u *word, char_u *wcopy);
! static void suggest_try_special(suginfo_T *su);
! static void suggest_try_change(suginfo_T *su);
! static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, int soundfold);
! static void go_deeper(trystate_T *stack, int depth, int score_add);
! #ifdef FEAT_MBYTE
! static int nofold_len(char_u *fword, int flen, char_u *word);
! #endif
! static void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword);
! static void score_comp_sal(suginfo_T *su);
! static void score_combine(suginfo_T *su);
! static int stp_sal_score(suggest_T *stp, suginfo_T *su, slang_T *slang, char_u *badsound);
! static void suggest_try_soundalike_prep(void);
! static void suggest_try_soundalike(suginfo_T *su);
! static void suggest_try_soundalike_finish(void);
! static void add_sound_suggest(suginfo_T *su, char_u *goodword, int score, langp_T *lp);
! static int soundfold_find(slang_T *slang, char_u *word);
! static void make_case_word(char_u *fword, char_u *cword, int flags);
! static void set_map_str(slang_T *lp, char_u *map);
! static int similar_chars(slang_T *slang, int c1, int c2);
! static void add_suggestion(suginfo_T *su, garray_T *gap, char_u *goodword, int badlen, int score, int altscore, int had_bonus, slang_T *slang, int maxsf);
! static void check_suggestions(suginfo_T *su, garray_T *gap);
! static void add_banned(suginfo_T *su, char_u *word);
! static void rescore_suggestions(suginfo_T *su);
! static void rescore_one(suginfo_T *su, suggest_T *stp);
! static int cleanup_suggestions(garray_T *gap, int maxscore, int keep);
! static void spell_soundfold(slang_T *slang, char_u *inword, int folded, char_u *res);
! static void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);
! static void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);
! #ifdef FEAT_MBYTE
! static void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);
! #endif
! static int soundalike_score(char_u *goodsound, char_u *badsound);
! static int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword);
! static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit);
! #ifdef FEAT_MBYTE
! static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit);
! #endif
! static void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);
! static linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);
! static buf_T *open_spellbuf(void);
! static void close_spellbuf(buf_T *buf);
  
  /*
   * Use our own character-case definitions, because the current locale may
***************
*** 5042,5093 ****
      int		si_newcompID;	/* current value for compound ID */
  } spellinfo_T;
  
! static afffile_T *spell_read_aff __ARGS((spellinfo_T *spin, char_u *fname));
! static int is_aff_rule __ARGS((char_u **items, int itemcnt, char *rulename, int	 mincount));
! static void aff_process_flags __ARGS((afffile_T *affile, affentry_T *entry));
! static int spell_info_item __ARGS((char_u *s));
! static unsigned affitem2flag __ARGS((int flagtype, char_u *item, char_u	*fname, int lnum));
! static unsigned get_affitem __ARGS((int flagtype, char_u **pp));
! static void process_compflags __ARGS((spellinfo_T *spin, afffile_T *aff, char_u *compflags));
! static void check_renumber __ARGS((spellinfo_T *spin));
! static int flag_in_afflist __ARGS((int flagtype, char_u *afflist, unsigned flag));
! static void aff_check_number __ARGS((int spinval, int affval, char *name));
! static void aff_check_string __ARGS((char_u *spinval, char_u *affval, char *name));
! static int str_equal __ARGS((char_u *s1, char_u	*s2));
! static void add_fromto __ARGS((spellinfo_T *spin, garray_T *gap, char_u	*from, char_u *to));
! static int sal_to_bool __ARGS((char_u *s));
! static void spell_free_aff __ARGS((afffile_T *aff));
! static int spell_read_dic __ARGS((spellinfo_T *spin, char_u *fname, afffile_T *affile));
! static int get_affix_flags __ARGS((afffile_T *affile, char_u *afflist));
! static int get_pfxlist __ARGS((afffile_T *affile, char_u *afflist, char_u *store_afflist));
! static void get_compflags __ARGS((afffile_T *affile, char_u *afflist, char_u *store_afflist));
! static int store_aff_word __ARGS((spellinfo_T *spin, char_u *word, char_u *afflist, afffile_T *affile, hashtab_T *ht, hashtab_T *xht, int condit, int flags, char_u *pfxlist, int pfxlen));
! static int spell_read_wordfile __ARGS((spellinfo_T *spin, char_u *fname));
! static void *getroom __ARGS((spellinfo_T *spin, size_t len, int align));
! static char_u *getroom_save __ARGS((spellinfo_T *spin, char_u *s));
! static void free_blocks __ARGS((sblock_T *bl));
! static wordnode_T *wordtree_alloc __ARGS((spellinfo_T *spin));
! static int store_word __ARGS((spellinfo_T *spin, char_u *word, int flags, int region, char_u *pfxlist, int need_affix));
! static int tree_add_word __ARGS((spellinfo_T *spin, char_u *word, wordnode_T *tree, int flags, int region, int affixID));
! static wordnode_T *get_wordnode __ARGS((spellinfo_T *spin));
! static int deref_wordnode __ARGS((spellinfo_T *spin, wordnode_T *node));
! static void free_wordnode __ARGS((spellinfo_T *spin, wordnode_T *n));
! static void wordtree_compress __ARGS((spellinfo_T *spin, wordnode_T *root));
! static int node_compress __ARGS((spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, int *tot));
! static int node_equal __ARGS((wordnode_T *n1, wordnode_T *n2));
! static int write_vim_spell __ARGS((spellinfo_T *spin, char_u *fname));
! static void clear_node __ARGS((wordnode_T *node));
! static int put_node __ARGS((FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree));
! static void spell_make_sugfile __ARGS((spellinfo_T *spin, char_u *wfname));
! static int sug_filltree __ARGS((spellinfo_T *spin, slang_T *slang));
! static int sug_maketable __ARGS((spellinfo_T *spin));
! static int sug_filltable __ARGS((spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap));
! static int offset2bytes __ARGS((int nr, char_u *buf));
! static int bytes2offset __ARGS((char_u **pp));
! static void sug_write __ARGS((spellinfo_T *spin, char_u *fname));
! static void mkspell __ARGS((int fcount, char_u **fnames, int ascii, int over_write, int added_word));
! static void spell_message __ARGS((spellinfo_T *spin, char_u *str));
! static void init_spellfile __ARGS((void));
  
  /* In the postponed prefixes tree wn_flags is used to store the WFP_ flags,
   * but it must be negative to indicate the prefix tree to tree_add_word().
--- 5042,5093 ----
      int		si_newcompID;	/* current value for compound ID */
  } spellinfo_T;
  
! static afffile_T *spell_read_aff(spellinfo_T *spin, char_u *fname);
! static int is_aff_rule(char_u **items, int itemcnt, char *rulename, int	 mincount);
! static void aff_process_flags(afffile_T *affile, affentry_T *entry);
! static int spell_info_item(char_u *s);
! static unsigned affitem2flag(int flagtype, char_u *item, char_u	*fname, int lnum);
! static unsigned get_affitem(int flagtype, char_u **pp);
! static void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags);
! static void check_renumber(spellinfo_T *spin);
! static int flag_in_afflist(int flagtype, char_u *afflist, unsigned flag);
! static void aff_check_number(int spinval, int affval, char *name);
! static void aff_check_string(char_u *spinval, char_u *affval, char *name);
! static int str_equal(char_u *s1, char_u	*s2);
! static void add_fromto(spellinfo_T *spin, garray_T *gap, char_u	*from, char_u *to);
! static int sal_to_bool(char_u *s);
! static void spell_free_aff(afffile_T *aff);
! static int spell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile);
! static int get_affix_flags(afffile_T *affile, char_u *afflist);
! static int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist);
! static void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist);
! static int store_aff_word(spellinfo_T *spin, char_u *word, char_u *afflist, afffile_T *affile, hashtab_T *ht, hashtab_T *xht, int condit, int flags, char_u *pfxlist, int pfxlen);
! static int spell_read_wordfile(spellinfo_T *spin, char_u *fname);
! static void *getroom(spellinfo_T *spin, size_t len, int align);
! static char_u *getroom_save(spellinfo_T *spin, char_u *s);
! static void free_blocks(sblock_T *bl);
! static wordnode_T *wordtree_alloc(spellinfo_T *spin);
! static int store_word(spellinfo_T *spin, char_u *word, int flags, int region, char_u *pfxlist, int need_affix);
! static int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *tree, int flags, int region, int affixID);
! static wordnode_T *get_wordnode(spellinfo_T *spin);
! static int deref_wordnode(spellinfo_T *spin, wordnode_T *node);
! static void free_wordnode(spellinfo_T *spin, wordnode_T *n);
! static void wordtree_compress(spellinfo_T *spin, wordnode_T *root);
! static int node_compress(spellinfo_T *spin, wordnode_T *node, hashtab_T *ht, int *tot);
! static int node_equal(wordnode_T *n1, wordnode_T *n2);
! static int write_vim_spell(spellinfo_T *spin, char_u *fname);
! static void clear_node(wordnode_T *node);
! static int put_node(FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree);
! static void spell_make_sugfile(spellinfo_T *spin, char_u *wfname);
! static int sug_filltree(spellinfo_T *spin, slang_T *slang);
! static int sug_maketable(spellinfo_T *spin);
! static int sug_filltable(spellinfo_T *spin, wordnode_T *node, int startwordnr, garray_T *gap);
! static int offset2bytes(int nr, char_u *buf);
! static int bytes2offset(char_u **pp);
! static void sug_write(spellinfo_T *spin, char_u *fname);
! static void mkspell(int fcount, char_u **fnames, int ascii, int over_write, int added_word);
! static void spell_message(spellinfo_T *spin, char_u *str);
! static void init_spellfile(void);
  
  /* In the postponed prefixes tree wn_flags is used to store the WFP_ flags,
   * but it must be negative to indicate the prefix tree to tree_add_word().
***************
*** 7988,7994 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! rep_compare __ARGS((const void *s1, const void *s2));
  
  /*
   * Function given to qsort() to sort the REP items on "from" string.
--- 7988,7994 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! rep_compare(const void *s1, const void *s2);
  
  /*
   * Function given to qsort() to sort the REP items on "from" string.
***************
*** 14149,14155 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sug_compare __ARGS((const void *s1, const void *s2));
  
  /*
   * Function given to qsort() to sort the suggestions on st_score.
--- 14149,14155 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sug_compare(const void *s1, const void *s2);
  
  /*
   * Function given to qsort() to sort the suggestions on st_score.
*** ../vim-7.4.1198/src/syntax.c	2016-01-19 22:28:54.615592984 +0100
--- src/syntax.c	2016-01-29 22:43:22.808812401 +0100
***************
*** 87,111 ****
  static int hl_attr_table[] =
      {HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE, HL_INVERSE, 0};
  
! static int get_attr_entry  __ARGS((garray_T *table, attrentry_T *aep));
! static void syn_unadd_group __ARGS((void));
! static void set_hl_attr __ARGS((int idx));
! static void highlight_list_one __ARGS((int id));
! static int highlight_list_arg __ARGS((int id, int didh, int type, int iarg, char_u *sarg, char *name));
! static int syn_add_group __ARGS((char_u *name));
! static int syn_list_header __ARGS((int did_header, int outlen, int id));
! static int hl_has_settings __ARGS((int idx, int check_link));
! static void highlight_clear __ARGS((int idx));
  
  #ifdef FEAT_GUI
! static void gui_do_one_color __ARGS((int idx, int do_menu, int do_tooltip));
! static int  set_group_colors __ARGS((char_u *name, guicolor_T *fgp, guicolor_T *bgp, int do_menu, int use_norm, int do_tooltip));
! static guicolor_T color_name2handle __ARGS((char_u *name));
! static GuiFont font_name2handle __ARGS((char_u *name));
  # ifdef FEAT_XFONTSET
! static GuiFontset fontset_name2handle __ARGS((char_u *name, int fixed_width));
  # endif
! static void hl_do_font __ARGS((int idx, char_u *arg, int do_normal, int do_menu, int do_tooltip, int free_font));
  #endif
  
  /*
--- 87,111 ----
  static int hl_attr_table[] =
      {HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE, HL_INVERSE, 0};
  
! static int get_attr_entry(garray_T *table, attrentry_T *aep);
! static void syn_unadd_group(void);
! static void set_hl_attr(int idx);
! static void highlight_list_one(int id);
! static int highlight_list_arg(int id, int didh, int type, int iarg, char_u *sarg, char *name);
! static int syn_add_group(char_u *name);
! static int syn_list_header(int did_header, int outlen, int id);
! static int hl_has_settings(int idx, int check_link);
! static void highlight_clear(int idx);
  
  #ifdef FEAT_GUI
! static void gui_do_one_color(int idx, int do_menu, int do_tooltip);
! static int  set_group_colors(char_u *name, guicolor_T *fgp, guicolor_T *bgp, int do_menu, int use_norm, int do_tooltip);
! static guicolor_T color_name2handle(char_u *name);
! static GuiFont font_name2handle(char_u *name);
  # ifdef FEAT_XFONTSET
! static GuiFontset fontset_name2handle(char_u *name, int fixed_width);
  # endif
! static void hl_do_font(int idx, char_u *arg, int do_normal, int do_menu, int do_tooltip, int free_font);
  #endif
  
  /*
***************
*** 375,416 ****
  
  #define CUR_STATE(idx)	((stateitem_T *)(current_state.ga_data))[idx]
  
! static void syn_sync __ARGS((win_T *wp, linenr_T lnum, synstate_T *last_valid));
  static void save_chartab(char_u *chartab);
  static void restore_chartab(char_u *chartab);
! static int syn_match_linecont __ARGS((linenr_T lnum));
! static void syn_start_line __ARGS((void));
! static void syn_update_ends __ARGS((int startofline));
! static void syn_stack_alloc __ARGS((void));
! static int syn_stack_cleanup __ARGS((void));
! static void syn_stack_free_entry __ARGS((synblock_T *block, synstate_T *p));
! static synstate_T *syn_stack_find_entry __ARGS((linenr_T lnum));
! static synstate_T *store_current_state __ARGS((void));
! static void load_current_state __ARGS((synstate_T *from));
! static void invalidate_current_state __ARGS((void));
! static int syn_stack_equal __ARGS((synstate_T *sp));
! static void validate_current_state __ARGS((void));
! static int syn_finish_line __ARGS((int syncing));
! static int syn_current_attr __ARGS((int syncing, int displaying, int *can_spell, int keep_state));
! static int did_match_already __ARGS((int idx, garray_T *gap));
! static stateitem_T *push_next_match __ARGS((stateitem_T *cur_si));
! static void check_state_ends __ARGS((void));
! static void update_si_attr __ARGS((int idx));
! static void check_keepend __ARGS((void));
! static void update_si_end __ARGS((stateitem_T *sip, int startcol, int force));
! static short *copy_id_list __ARGS((short *list));
! static int in_id_list __ARGS((stateitem_T *item, short *cont_list, struct sp_syn *ssp, int contained));
! static int push_current_state __ARGS((int idx));
! static void pop_current_state __ARGS((void));
  #ifdef FEAT_PROFILE
! static void syn_clear_time __ARGS((syn_time_T *tt));
! static void syntime_clear __ARGS((void));
  #ifdef __BORLANDC__
! static int _RTLENTRYF syn_compare_syntime __ARGS((const void *v1, const void *v2));
  #else
! static int syn_compare_syntime __ARGS((const void *v1, const void *v2));
  #endif
! static void syntime_report __ARGS((void));
  static int syn_time_on = FALSE;
  # define IF_SYN_TIME(p) (p)
  #else
--- 375,416 ----
  
  #define CUR_STATE(idx)	((stateitem_T *)(current_state.ga_data))[idx]
  
! static void syn_sync(win_T *wp, linenr_T lnum, synstate_T *last_valid);
  static void save_chartab(char_u *chartab);
  static void restore_chartab(char_u *chartab);
! static int syn_match_linecont(linenr_T lnum);
! static void syn_start_line(void);
! static void syn_update_ends(int startofline);
! static void syn_stack_alloc(void);
! static int syn_stack_cleanup(void);
! static void syn_stack_free_entry(synblock_T *block, synstate_T *p);
! static synstate_T *syn_stack_find_entry(linenr_T lnum);
! static synstate_T *store_current_state(void);
! static void load_current_state(synstate_T *from);
! static void invalidate_current_state(void);
! static int syn_stack_equal(synstate_T *sp);
! static void validate_current_state(void);
! static int syn_finish_line(int syncing);
! static int syn_current_attr(int syncing, int displaying, int *can_spell, int keep_state);
! static int did_match_already(int idx, garray_T *gap);
! static stateitem_T *push_next_match(stateitem_T *cur_si);
! static void check_state_ends(void);
! static void update_si_attr(int idx);
! static void check_keepend(void);
! static void update_si_end(stateitem_T *sip, int startcol, int force);
! static short *copy_id_list(short *list);
! static int in_id_list(stateitem_T *item, short *cont_list, struct sp_syn *ssp, int contained);
! static int push_current_state(int idx);
! static void pop_current_state(void);
  #ifdef FEAT_PROFILE
! static void syn_clear_time(syn_time_T *tt);
! static void syntime_clear(void);
  #ifdef __BORLANDC__
! static int _RTLENTRYF syn_compare_syntime(const void *v1, const void *v2);
  #else
! static int syn_compare_syntime(const void *v1, const void *v2);
  #endif
! static void syntime_report(void);
  static int syn_time_on = FALSE;
  # define IF_SYN_TIME(p) (p)
  #else
***************
*** 418,485 ****
  typedef int syn_time_T;
  #endif
  
! static void syn_stack_apply_changes_block __ARGS((synblock_T *block, buf_T *buf));
! static void find_endpos __ARGS((int idx, lpos_T *startpos, lpos_T *m_endpos, lpos_T *hl_endpos, long *flagsp, lpos_T *end_endpos, int *end_idx, reg_extmatch_T *start_ext));
! static void clear_syn_state __ARGS((synstate_T *p));
! static void clear_current_state __ARGS((void));
! 
! static void limit_pos __ARGS((lpos_T *pos, lpos_T *limit));
! static void limit_pos_zero __ARGS((lpos_T *pos, lpos_T *limit));
! static void syn_add_end_off __ARGS((lpos_T *result, regmmatch_T *regmatch, synpat_T *spp, int idx, int extra));
! static void syn_add_start_off __ARGS((lpos_T *result, regmmatch_T *regmatch, synpat_T *spp, int idx, int extra));
! static char_u *syn_getcurline __ARGS((void));
! static int syn_regexec __ARGS((regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st));
! static int check_keyword_id __ARGS((char_u *line, int startcol, int *endcol, long *flags, short **next_list, stateitem_T *cur_si, int *ccharp));
! static void syn_cmd_case __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_spell __ARGS((exarg_T *eap, int syncing));
! static void syntax_sync_clear __ARGS((void));
! static void syn_remove_pattern __ARGS((synblock_T *block, int idx));
! static void syn_clear_pattern __ARGS((synblock_T *block, int i));
! static void syn_clear_cluster __ARGS((synblock_T *block, int i));
! static void syn_cmd_clear __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_conceal __ARGS((exarg_T *eap, int syncing));
! static void syn_clear_one __ARGS((int id, int syncing));
! static void syn_cmd_on __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_enable __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_reset __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_manual __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_off __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_onoff __ARGS((exarg_T *eap, char *name));
! static void syn_cmd_list __ARGS((exarg_T *eap, int syncing));
! static void syn_lines_msg __ARGS((void));
! static void syn_match_msg __ARGS((void));
! static void syn_stack_free_block __ARGS((synblock_T *block));
! static void syn_list_one __ARGS((int id, int syncing, int link_only));
! static void syn_list_cluster __ARGS((int id));
! static void put_id_list __ARGS((char_u *name, short *list, int attr));
! static void put_pattern __ARGS((char *s, int c, synpat_T *spp, int attr));
! static int syn_list_keywords __ARGS((int id, hashtab_T *ht, int did_header, int attr));
! static void syn_clear_keyword __ARGS((int id, hashtab_T *ht));
! static void clear_keywtab __ARGS((hashtab_T *ht));
! static void add_keyword __ARGS((char_u *name, int id, int flags, short *cont_in_list, short *next_list, int conceal_char));
! static char_u *get_group_name __ARGS((char_u *arg, char_u **name_end));
! static char_u *get_syn_options __ARGS((char_u *arg, syn_opt_arg_T *opt, int *conceal_char));
! static void syn_cmd_include __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_iskeyword __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_keyword __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_match __ARGS((exarg_T *eap, int syncing));
! static void syn_cmd_region __ARGS((exarg_T *eap, int syncing));
  #ifdef __BORLANDC__
! static int _RTLENTRYF syn_compare_stub __ARGS((const void *v1, const void *v2));
  #else
! static int syn_compare_stub __ARGS((const void *v1, const void *v2));
  #endif
! static void syn_cmd_cluster __ARGS((exarg_T *eap, int syncing));
! static int syn_scl_name2id __ARGS((char_u *name));
! static int syn_scl_namen2id __ARGS((char_u *linep, int len));
! static int syn_check_cluster __ARGS((char_u *pp, int len));
! static int syn_add_cluster __ARGS((char_u *name));
! static void init_syn_patterns __ARGS((void));
! static char_u *get_syn_pattern __ARGS((char_u *arg, synpat_T *ci));
! static void syn_cmd_sync __ARGS((exarg_T *eap, int syncing));
! static int get_id_list __ARGS((char_u **arg, int keylen, short **list));
! static void syn_combine_list __ARGS((short **clstr1, short **clstr2, int list_op));
! static void syn_incl_toplevel __ARGS((int id, int *flagsp));
  
  /*
   * Start the syntax recognition for a line.  This function is normally called
--- 418,485 ----
  typedef int syn_time_T;
  #endif
  
! static void syn_stack_apply_changes_block(synblock_T *block, buf_T *buf);
! static void find_endpos(int idx, lpos_T *startpos, lpos_T *m_endpos, lpos_T *hl_endpos, long *flagsp, lpos_T *end_endpos, int *end_idx, reg_extmatch_T *start_ext);
! static void clear_syn_state(synstate_T *p);
! static void clear_current_state(void);
! 
! static void limit_pos(lpos_T *pos, lpos_T *limit);
! static void limit_pos_zero(lpos_T *pos, lpos_T *limit);
! static void syn_add_end_off(lpos_T *result, regmmatch_T *regmatch, synpat_T *spp, int idx, int extra);
! static void syn_add_start_off(lpos_T *result, regmmatch_T *regmatch, synpat_T *spp, int idx, int extra);
! static char_u *syn_getcurline(void);
! static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st);
! static int check_keyword_id(char_u *line, int startcol, int *endcol, long *flags, short **next_list, stateitem_T *cur_si, int *ccharp);
! static void syn_cmd_case(exarg_T *eap, int syncing);
! static void syn_cmd_spell(exarg_T *eap, int syncing);
! static void syntax_sync_clear(void);
! static void syn_remove_pattern(synblock_T *block, int idx);
! static void syn_clear_pattern(synblock_T *block, int i);
! static void syn_clear_cluster(synblock_T *block, int i);
! static void syn_cmd_clear(exarg_T *eap, int syncing);
! static void syn_cmd_conceal(exarg_T *eap, int syncing);
! static void syn_clear_one(int id, int syncing);
! static void syn_cmd_on(exarg_T *eap, int syncing);
! static void syn_cmd_enable(exarg_T *eap, int syncing);
! static void syn_cmd_reset(exarg_T *eap, int syncing);
! static void syn_cmd_manual(exarg_T *eap, int syncing);
! static void syn_cmd_off(exarg_T *eap, int syncing);
! static void syn_cmd_onoff(exarg_T *eap, char *name);
! static void syn_cmd_list(exarg_T *eap, int syncing);
! static void syn_lines_msg(void);
! static void syn_match_msg(void);
! static void syn_stack_free_block(synblock_T *block);
! static void syn_list_one(int id, int syncing, int link_only);
! static void syn_list_cluster(int id);
! static void put_id_list(char_u *name, short *list, int attr);
! static void put_pattern(char *s, int c, synpat_T *spp, int attr);
! static int syn_list_keywords(int id, hashtab_T *ht, int did_header, int attr);
! static void syn_clear_keyword(int id, hashtab_T *ht);
! static void clear_keywtab(hashtab_T *ht);
! static void add_keyword(char_u *name, int id, int flags, short *cont_in_list, short *next_list, int conceal_char);
! static char_u *get_group_name(char_u *arg, char_u **name_end);
! static char_u *get_syn_options(char_u *arg, syn_opt_arg_T *opt, int *conceal_char);
! static void syn_cmd_include(exarg_T *eap, int syncing);
! static void syn_cmd_iskeyword(exarg_T *eap, int syncing);
! static void syn_cmd_keyword(exarg_T *eap, int syncing);
! static void syn_cmd_match(exarg_T *eap, int syncing);
! static void syn_cmd_region(exarg_T *eap, int syncing);
  #ifdef __BORLANDC__
! static int _RTLENTRYF syn_compare_stub(const void *v1, const void *v2);
  #else
! static int syn_compare_stub(const void *v1, const void *v2);
  #endif
! static void syn_cmd_cluster(exarg_T *eap, int syncing);
! static int syn_scl_name2id(char_u *name);
! static int syn_scl_namen2id(char_u *linep, int len);
! static int syn_check_cluster(char_u *pp, int len);
! static int syn_add_cluster(char_u *name);
! static void init_syn_patterns(void);
! static char_u *get_syn_pattern(char_u *arg, synpat_T *ci);
! static void syn_cmd_sync(exarg_T *eap, int syncing);
! static int get_id_list(char_u **arg, int keylen, short **list);
! static void syn_combine_list(short **clstr1, short **clstr2, int list_op);
! static void syn_incl_toplevel(int id, int *flagsp);
  
  /*
   * Start the syntax recognition for a line.  This function is normally called
***************
*** 4052,4058 ****
      char	*name;
  };
  
! static void syn_list_flags __ARGS((struct name_list *nl, int flags, int attr));
  
  /*
   * List one syntax item, for ":syntax" or "syntax list syntax_name".
--- 4052,4058 ----
      char	*name;
  };
  
! static void syn_list_flags(struct name_list *nl, int flags, int attr);
  
  /*
   * List one syntax item, for ":syntax" or "syntax list syntax_name".
***************
*** 9806,9813 ****
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
! static void highlight_list __ARGS((void));
! static void highlight_list_two __ARGS((int cnt, int attr));
  
  /*
   * Handle command line completion for :highlight command.
--- 9806,9813 ----
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
! static void highlight_list(void);
! static void highlight_list_two(int cnt, int attr);
  
  /*
   * Handle command line completion for :highlight command.
*** ../vim-7.4.1198/src/tag.c	2015-11-24 18:45:52.641646980 +0100
--- src/tag.c	2016-01-29 22:43:38.348648539 +0100
***************
*** 59,82 ****
  #define NOTAGFILE	99		/* return value for jumpto_tag */
  static char_u	*nofile_fname = NULL;	/* fname for NOTAGFILE error */
  
! static void taglen_advance __ARGS((int l));
  
! static int jumpto_tag __ARGS((char_u *lbuf, int forceit, int keep_help));
  #ifdef FEAT_EMACS_TAGS
! static int parse_tag_line __ARGS((char_u *lbuf, int is_etag, tagptrs_T *tagp));
  #else
! static int parse_tag_line __ARGS((char_u *lbuf, tagptrs_T *tagp));
  #endif
! static int test_for_static __ARGS((tagptrs_T *));
! static int parse_match __ARGS((char_u *lbuf, tagptrs_T *tagp));
! static char_u *tag_full_fname __ARGS((tagptrs_T *tagp));
! static char_u *expand_tag_fname __ARGS((char_u *fname, char_u *tag_fname, int expand));
  #ifdef FEAT_EMACS_TAGS
! static int test_for_current __ARGS((int, char_u *, char_u *, char_u *, char_u *));
  #else
! static int test_for_current __ARGS((char_u *, char_u *, char_u *, char_u *));
  #endif
! static int find_extra __ARGS((char_u **pp));
  
  static char_u *bottommsg = (char_u *)N_("E555: at bottom of tag stack");
  static char_u *topmsg = (char_u *)N_("E556: at top of tag stack");
--- 59,82 ----
  #define NOTAGFILE	99		/* return value for jumpto_tag */
  static char_u	*nofile_fname = NULL;	/* fname for NOTAGFILE error */
  
! static void taglen_advance(int l);
  
! static int jumpto_tag(char_u *lbuf, int forceit, int keep_help);
  #ifdef FEAT_EMACS_TAGS
! static int parse_tag_line(char_u *lbuf, int is_etag, tagptrs_T *tagp);
  #else
! static int parse_tag_line(char_u *lbuf, tagptrs_T *tagp);
  #endif
! static int test_for_static(tagptrs_T *);
! static int parse_match(char_u *lbuf, tagptrs_T *tagp);
! static char_u *tag_full_fname(tagptrs_T *tagp);
! static char_u *expand_tag_fname(char_u *fname, char_u *tag_fname, int expand);
  #ifdef FEAT_EMACS_TAGS
! static int test_for_current(int, char_u *, char_u *, char_u *, char_u *);
  #else
! static int test_for_current(char_u *, char_u *, char_u *, char_u *);
  #endif
! static int find_extra(char_u **pp);
  
  static char_u *bottommsg = (char_u *)N_("E555: at bottom of tag stack");
  static char_u *topmsg = (char_u *)N_("E556: at top of tag stack");
***************
*** 1161,1167 ****
  #endif
  
  #ifdef FEAT_TAG_BINS
! static int tag_strnicmp __ARGS((char_u *s1, char_u *s2, size_t len));
  
  /*
   * Compare two strings, for length "len", ignoring case the ASCII way.
--- 1161,1167 ----
  #endif
  
  #ifdef FEAT_TAG_BINS
! static int tag_strnicmp(char_u *s1, char_u *s2, size_t len);
  
  /*
   * Compare two strings, for length "len", ignoring case the ASCII way.
***************
*** 1203,1209 ****
      regmatch_T	regmatch;	/* regexp program, may be NULL */
  } pat_T;
  
! static void prepare_pats __ARGS((pat_T *pats, int has_re));
  
  /*
   * Extract info from the tag search pattern "pats->pat".
--- 1203,1209 ----
      regmatch_T	regmatch;	/* regexp program, may be NULL */
  } pat_T;
  
! static void prepare_pats(pat_T *pats, int has_re);
  
  /*
   * Extract info from the tag search pattern "pats->pat".
***************
*** 2570,2576 ****
  }
  
  static garray_T tag_fnames = GA_EMPTY;
! static void found_tagfile_cb __ARGS((char_u *fname, void *cookie));
  
  /*
   * Callback function for finding all "tags" and "tags-??" files in
--- 2570,2576 ----
  }
  
  static garray_T tag_fnames = GA_EMPTY;
! static void found_tagfile_cb(char_u *fname, void *cookie);
  
  /*
   * Callback function for finding all "tags" and "tags-??" files in
***************
*** 3815,3821 ****
  #endif
  
  #if defined(FEAT_EVAL) || defined(PROTO)
! static int add_tag_field __ARGS((dict_T *dict, char *field_name, char_u *start, char_u *end));
  
  /*
   * Add a tag field to the dictionary "dict".
--- 3815,3821 ----
  #endif
  
  #if defined(FEAT_EVAL) || defined(PROTO)
! static int add_tag_field(dict_T *dict, char *field_name, char_u *start, char_u *end);
  
  /*
   * Add a tag field to the dictionary "dict".
*** ../vim-7.4.1198/src/term.c	2015-12-31 19:53:16.266087765 +0100
--- src/term.c	2016-01-29 22:43:57.536446210 +0100
***************
*** 74,109 ****
  /* start of keys that are not directly used by Vim but can be mapped */
  #define BT_EXTRA_KEYS	0x101
  
! static struct builtin_term *find_builtin_term __ARGS((char_u *name));
! static void parse_builtin_tcap __ARGS((char_u *s));
! static void term_color __ARGS((char_u *s, int n));
! static void gather_termleader __ARGS((void));
  #ifdef FEAT_TERMRESPONSE
! static void req_codes_from_term __ARGS((void));
! static void req_more_codes_from_term __ARGS((void));
! static void got_code_from_term __ARGS((char_u *code, int len));
! static void check_for_codes_from_term __ARGS((void));
  #endif
  #if defined(FEAT_GUI) \
      || (defined(FEAT_MOUSE) && (!defined(UNIX) || defined(FEAT_MOUSE_XTERM) \
  		|| defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)))
! static int get_bytes_from_buf __ARGS((char_u *, char_u *, int));
  #endif
! static void del_termcode_idx __ARGS((int idx));
! static int term_is_builtin __ARGS((char_u *name));
! static int term_7to8bit __ARGS((char_u *p));
  #ifdef FEAT_TERMRESPONSE
! static void switch_to_8bit __ARGS((void));
  #endif
  
  #ifdef HAVE_TGETENT
! static char_u *tgetent_error __ARGS((char_u *, char_u *));
  
  /*
   * Here is our own prototype for tgetstr(), any prototypes from the include
   * files have been disabled by the define at the start of this file.
   */
! char		*tgetstr __ARGS((char *, char **));
  
  # ifdef FEAT_TERMRESPONSE
      /* Change this to "if 1" to debug what happens with termresponse. */
--- 74,109 ----
  /* start of keys that are not directly used by Vim but can be mapped */
  #define BT_EXTRA_KEYS	0x101
  
! static struct builtin_term *find_builtin_term(char_u *name);
! static void parse_builtin_tcap(char_u *s);
! static void term_color(char_u *s, int n);
! static void gather_termleader(void);
  #ifdef FEAT_TERMRESPONSE
! static void req_codes_from_term(void);
! static void req_more_codes_from_term(void);
! static void got_code_from_term(char_u *code, int len);
! static void check_for_codes_from_term(void);
  #endif
  #if defined(FEAT_GUI) \
      || (defined(FEAT_MOUSE) && (!defined(UNIX) || defined(FEAT_MOUSE_XTERM) \
  		|| defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE)))
! static int get_bytes_from_buf(char_u *, char_u *, int);
  #endif
! static void del_termcode_idx(int idx);
! static int term_is_builtin(char_u *name);
! static int term_7to8bit(char_u *p);
  #ifdef FEAT_TERMRESPONSE
! static void switch_to_8bit(void);
  #endif
  
  #ifdef HAVE_TGETENT
! static char_u *tgetent_error(char_u *, char_u *);
  
  /*
   * Here is our own prototype for tgetstr(), any prototypes from the include
   * files have been disabled by the define at the start of this file.
   */
! char		*tgetstr(char *, char **);
  
  # ifdef FEAT_TERMRESPONSE
      /* Change this to "if 1" to debug what happens with termresponse. */
***************
*** 155,161 ****
  
  # define TGETSTR(s, p)	vim_tgetstr((s), (p))
  # define TGETENT(b, t)	tgetent((char *)(b), (char *)(t))
! static char_u *vim_tgetstr __ARGS((char *s, char_u **pp));
  #endif /* HAVE_TGETENT */
  
  static int  detected_8bit = FALSE;	/* detected 8-bit terminal */
--- 155,161 ----
  
  # define TGETSTR(s, p)	vim_tgetstr((s), (p))
  # define TGETENT(b, t)	tgetent((char *)(b), (char *)(t))
! static char_u *vim_tgetstr(char *s, char_u **pp);
  #endif /* HAVE_TGETENT */
  
  static int  detected_8bit = FALSE;	/* detected 8-bit terminal */
***************
*** 1502,1508 ****
      }
  }
  #if defined(HAVE_TGETENT) || defined(FEAT_TERMRESPONSE)
! static void set_color_count __ARGS((int nr));
  
  /*
   * Set number of colors.
--- 1502,1508 ----
      }
  }
  #if defined(HAVE_TGETENT) || defined(FEAT_TERMRESPONSE)
! static void set_color_count(int nr);
  
  /*
   * Set number of colors.
***************
*** 2398,2404 ****
   * minimal tgoto() implementation.
   * no padding and we only parse for %i %d and %+char
   */
! static char *tgoto __ARGS((char *, int, int));
  
      static char *
  tgoto(cm, x, y)
--- 2398,2404 ----
   * minimal tgoto() implementation.
   * no padding and we only parse for %i %d and %+char
   */
! static char *tgoto(char *, int, int);
  
      static char *
  tgoto(cm, x, y)
***************
*** 2570,2576 ****
  	out_flush();
  }
  
! static void out_char_nf __ARGS((unsigned));
  
  /*
   * out_char_nf(c): like out_char(), but don't flush when p_wd is set
--- 2570,2576 ----
  	out_flush();
  }
  
! static void out_char_nf(unsigned);
  
  /*
   * out_char_nf(c): like out_char(), but don't flush when p_wd is set
***************
*** 2898,2904 ****
      }
  }
  
! static int get_long_from_buf __ARGS((char_u *buf, long_u *val));
  
  /*
   * Interpret the next string of bytes in buf as a long integer, with the most
--- 2898,2904 ----
      }
  }
  
! static int get_long_from_buf(char_u *buf, long_u *val);
  
  /*
   * Interpret the next string of bytes in buf as a long integer, with the most
***************
*** 3692,3698 ****
  static int  tc_max_len = 0; /* number of entries that termcodes[] can hold */
  static int  tc_len = 0;	    /* current number of entries in termcodes[] */
  
! static int termcode_star __ARGS((char_u *code, int len));
  
      void
  clear_termcodes()
--- 3692,3698 ----
  static int  tc_max_len = 0; /* number of entries that termcodes[] can hold */
  static int  tc_len = 0;	    /* current number of entries in termcodes[] */
  
! static int termcode_star(char_u *code, int len);
  
      void
  clear_termcodes()
*** ../vim-7.4.1198/src/termlib.c	2011-05-10 16:31:58.000000000 +0200
--- src/termlib.c	2016-01-29 22:44:09.420320896 +0100
***************
*** 17,27 ****
  # include <sgtty.h>
  #endif
  
! static int  getent __ARGS((char *, char *, FILE *, int));
! static int  nextent __ARGS((char *, FILE *, int));
! static int  _match __ARGS((char *, char *));
! static char *_addfmt __ARGS((char *, char *, int));
! static char *_find __ARGS((char *, char *));
  
  /*
   * Global variables for termlib
--- 17,27 ----
  # include <sgtty.h>
  #endif
  
! static int  getent(char *, char *, FILE *, int);
! static int  nextent(char *, FILE *, int);
! static int  _match(char *, char *);
! static char *_addfmt(char *, char *, int);
! static char *_find(char *, char *);
  
  /*
   * Global variables for termlib
***************
*** 536,546 ****
  tputs(cp, affcnt, outc)
      char *cp;				/* string to print */
      int affcnt;				/* Number of lines affected */
!     void (*outc) __ARGS((unsigned int));/* routine to output 1 character */
  {
      long    frac,			/* 10^(#digits after decimal point) */
  	counter,			/* digits */
! 	atol __ARGS((const char *));
  
      if (VIM_ISDIGIT(*cp)) {
  	counter = 0;
--- 536,546 ----
  tputs(cp, affcnt, outc)
      char *cp;				/* string to print */
      int affcnt;				/* Number of lines affected */
!     void (*outc)(unsigned int);/* routine to output 1 character */
  {
      long    frac,			/* 10^(#digits after decimal point) */
  	counter,			/* digits */
! 	atol(const char *);
  
      if (VIM_ISDIGIT(*cp)) {
  	counter = 0;
*** ../vim-7.4.1198/src/ui.c	2016-01-24 20:36:18.862082391 +0100
--- src/ui.c	2016-01-29 22:44:22.688180996 +0100
***************
*** 381,387 ****
  
  #if defined(FEAT_CLIPBOARD) || defined(PROTO)
  
! static void clip_copy_selection __ARGS((VimClipboard *clip));
  
  /*
   * Selection stuff using Visual mode, for cutting and pasting text to other
--- 381,387 ----
  
  #if defined(FEAT_CLIPBOARD) || defined(PROTO)
  
! static void clip_copy_selection(VimClipboard *clip);
  
  /*
   * Selection stuff using Visual mode, for cutting and pasting text to other
***************
*** 660,672 ****
   * Stuff for general mouse selection, without using Visual mode.
   */
  
! static int clip_compare_pos __ARGS((int row1, int col1, int row2, int col2));
! static void clip_invert_area __ARGS((int, int, int, int, int how));
! static void clip_invert_rectangle __ARGS((int row, int col, int height, int width, int invert));
! static void clip_get_word_boundaries __ARGS((VimClipboard *, int, int));
! static int  clip_get_line_end __ARGS((int));
! static void clip_update_modeless_selection __ARGS((VimClipboard *, int, int,
! 						    int, int));
  
  /* flags for clip_invert_area() */
  #define CLIP_CLEAR	1
--- 660,672 ----
   * Stuff for general mouse selection, without using Visual mode.
   */
  
! static int clip_compare_pos(int row1, int col1, int row2, int col2);
! static void clip_invert_area(int, int, int, int, int how);
! static void clip_invert_rectangle(int row, int col, int height, int width, int invert);
! static void clip_get_word_boundaries(VimClipboard *, int, int);
! static int  clip_get_line_end(int);
! static void clip_update_modeless_selection(VimClipboard *, int, int,
! 						    int, int);
  
  /* flags for clip_invert_area() */
  #define CLIP_CLEAR	1
***************
*** 2064,2073 ****
   * X Selection stuff, for cutting and pasting text to other windows.
   */
  
! static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
! static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
! static void clip_x11_timestamp_cb __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
! static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
  
  /*
   * Property callback to get a timestamp for XtOwnSelection.
--- 2064,2073 ----
   * X Selection stuff, for cutting and pasting text to other windows.
   */
  
! static Boolean	clip_x11_convert_selection_cb(Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *);
! static void  clip_x11_lose_ownership_cb(Widget, Atom *);
! static void clip_x11_timestamp_cb(Widget w, XtPointer n, XEvent *event, Boolean *cont);
! static void  clip_x11_request_selection_cb(Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *);
  
  /*
   * Property callback to get a timestamp for XtOwnSelection.
*** ../vim-7.4.1198/src/undo.c	2015-04-21 16:12:01.208114832 +0200
--- src/undo.c	2016-01-29 22:44:32.408078506 +0100
***************
*** 100,144 ****
  } bufinfo_T;
  
  
! static long get_undolevel __ARGS((void));
! static void u_unch_branch __ARGS((u_header_T *uhp));
! static u_entry_T *u_get_headentry __ARGS((void));
! static void u_getbot __ARGS((void));
! static void u_doit __ARGS((int count));
! static void u_undoredo __ARGS((int undo));
! static void u_undo_end __ARGS((int did_undo, int absolute));
! static void u_add_time __ARGS((char_u *buf, size_t buflen, time_t tt));
! static void u_freeheader __ARGS((buf_T *buf, u_header_T *uhp, u_header_T **uhpp));
! static void u_freebranch __ARGS((buf_T *buf, u_header_T *uhp, u_header_T **uhpp));
! static void u_freeentries __ARGS((buf_T *buf, u_header_T *uhp, u_header_T **uhpp));
! static void u_freeentry __ARGS((u_entry_T *, long));
  #ifdef FEAT_PERSISTENT_UNDO
! static void corruption_error __ARGS((char *mesg, char_u *file_name));
! static void u_free_uhp __ARGS((u_header_T *uhp));
! static int undo_write __ARGS((bufinfo_T *bi, char_u *ptr, size_t len));
! static int undo_flush __ARGS((bufinfo_T *bi));
! static int fwrite_crypt __ARGS((bufinfo_T *bi, char_u *ptr, size_t len));
! static int undo_write_bytes __ARGS((bufinfo_T *bi, long_u nr, int len));
! static void put_header_ptr __ARGS((bufinfo_T *bi, u_header_T *uhp));
! static int undo_read_4c __ARGS((bufinfo_T *bi));
! static int undo_read_2c __ARGS((bufinfo_T *bi));
! static int undo_read_byte __ARGS((bufinfo_T *bi));
! static time_t undo_read_time __ARGS((bufinfo_T *bi));
! static int undo_read __ARGS((bufinfo_T *bi, char_u *buffer, size_t size));
! static char_u *read_string_decrypt __ARGS((bufinfo_T *bi, int len));
! static int serialize_header __ARGS((bufinfo_T *bi, char_u *hash));
! static int serialize_uhp __ARGS((bufinfo_T *bi, u_header_T *uhp));
! static u_header_T *unserialize_uhp __ARGS((bufinfo_T *bi, char_u *file_name));
! static int serialize_uep __ARGS((bufinfo_T *bi, u_entry_T *uep));
! static u_entry_T *unserialize_uep __ARGS((bufinfo_T *bi, int *error, char_u *file_name));
! static void serialize_pos __ARGS((bufinfo_T *bi, pos_T pos));
! static void unserialize_pos __ARGS((bufinfo_T *bi, pos_T *pos));
! static void serialize_visualinfo __ARGS((bufinfo_T *bi, visualinfo_T *info));
! static void unserialize_visualinfo __ARGS((bufinfo_T *bi, visualinfo_T *info));
  #endif
  
  #define U_ALLOC_LINE(size) lalloc((long_u)(size), FALSE)
! static char_u *u_save_line __ARGS((linenr_T));
  
  /* used in undo_end() to report number of added and deleted lines */
  static long	u_newcount, u_oldcount;
--- 100,144 ----
  } bufinfo_T;
  
  
! static long get_undolevel(void);
! static void u_unch_branch(u_header_T *uhp);
! static u_entry_T *u_get_headentry(void);
! static void u_getbot(void);
! static void u_doit(int count);
! static void u_undoredo(int undo);
! static void u_undo_end(int did_undo, int absolute);
! static void u_add_time(char_u *buf, size_t buflen, time_t tt);
! static void u_freeheader(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);
! static void u_freebranch(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);
! static void u_freeentries(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);
! static void u_freeentry(u_entry_T *, long);
  #ifdef FEAT_PERSISTENT_UNDO
! static void corruption_error(char *mesg, char_u *file_name);
! static void u_free_uhp(u_header_T *uhp);
! static int undo_write(bufinfo_T *bi, char_u *ptr, size_t len);
! static int undo_flush(bufinfo_T *bi);
! static int fwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len);
! static int undo_write_bytes(bufinfo_T *bi, long_u nr, int len);
! static void put_header_ptr(bufinfo_T *bi, u_header_T *uhp);
! static int undo_read_4c(bufinfo_T *bi);
! static int undo_read_2c(bufinfo_T *bi);
! static int undo_read_byte(bufinfo_T *bi);
! static time_t undo_read_time(bufinfo_T *bi);
! static int undo_read(bufinfo_T *bi, char_u *buffer, size_t size);
! static char_u *read_string_decrypt(bufinfo_T *bi, int len);
! static int serialize_header(bufinfo_T *bi, char_u *hash);
! static int serialize_uhp(bufinfo_T *bi, u_header_T *uhp);
! static u_header_T *unserialize_uhp(bufinfo_T *bi, char_u *file_name);
! static int serialize_uep(bufinfo_T *bi, u_entry_T *uep);
! static u_entry_T *unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name);
! static void serialize_pos(bufinfo_T *bi, pos_T pos);
! static void unserialize_pos(bufinfo_T *bi, pos_T *pos);
! static void serialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);
! static void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);
  #endif
  
  #define U_ALLOC_LINE(size) lalloc((long_u)(size), FALSE)
! static char_u *u_save_line(linenr_T);
  
  /* used in undo_end() to report number of added and deleted lines */
  static long	u_newcount, u_oldcount;
*** ../vim-7.4.1198/src/version.c	2016-01-29 22:36:41.237047563 +0100
--- src/version.c	2016-01-29 22:44:42.431972810 +0100
***************
*** 55,62 ****
  char	*longVersion = VIM_VERSION_LONG;
  #endif
  
! static void list_features __ARGS((void));
! static void version_msg __ARGS((char *s));
  
  static char *(features[]) =
  {
--- 55,62 ----
  char	*longVersion = VIM_VERSION_LONG;
  #endif
  
! static void list_features(void);
! static void version_msg(char *s);
  
  static char *(features[]) =
  {
***************
*** 3578,3584 ****
  	MSG_PUTS(s);
  }
  
! static void do_intro_line __ARGS((int row, char_u *mesg, int add_version, int attr));
  
  /*
   * Show the intro message when not editing a file.
--- 3580,3586 ----
  	MSG_PUTS(s);
  }
  
! static void do_intro_line(int row, char_u *mesg, int add_version, int attr);
  
  /*
   * Show the intro message when not editing a file.
*** ../vim-7.4.1198/src/window.c	2016-01-19 14:51:49.555315465 +0100
--- src/window.c	2016-01-29 22:45:06.247721864 +0100
***************
*** 9,80 ****
  
  #include "vim.h"
  
! static int path_is_url __ARGS((char_u *p));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
! static void cmd_with_count __ARGS((char *cmd, char_u *bufp, size_t bufsize, long Prenum));
! static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
! static void win_init_some __ARGS((win_T *newp, win_T *oldp));
! static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
! static void frame_setheight __ARGS((frame_T *curfrp, int height));
! #ifdef FEAT_VERTSPLIT
! static void frame_setwidth __ARGS((frame_T *curfrp, int width));
! #endif
! static void win_exchange __ARGS((long));
! static void win_rotate __ARGS((int, int));
! static void win_totop __ARGS((int size, int flags));
! static void win_equal_rec __ARGS((win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height));
! static int last_window __ARGS((void));
! static int close_last_window_tabpage __ARGS((win_T *win, int free_buf, tabpage_T *prev_curtab));
! static win_T *win_free_mem __ARGS((win_T *win, int *dirp, tabpage_T *tp));
! static frame_T *win_altframe __ARGS((win_T *win, tabpage_T *tp));
! static tabpage_T *alt_tabpage __ARGS((void));
! static win_T *frame2win __ARGS((frame_T *frp));
! static int frame_has_win __ARGS((frame_T *frp, win_T *wp));
! static void frame_new_height __ARGS((frame_T *topfrp, int height, int topfirst, int wfh));
! static int frame_fixed_height __ARGS((frame_T *frp));
! #ifdef FEAT_VERTSPLIT
! static int frame_fixed_width __ARGS((frame_T *frp));
! static void frame_add_statusline __ARGS((frame_T *frp));
! static void frame_new_width __ARGS((frame_T *topfrp, int width, int leftfirst, int wfw));
! static void frame_add_vsep __ARGS((frame_T *frp));
! static int frame_minwidth __ARGS((frame_T *topfrp, win_T *next_curwin));
! static void frame_fix_width __ARGS((win_T *wp));
  #endif
  #endif
! static int win_alloc_firstwin __ARGS((win_T *oldwin));
! static void new_frame __ARGS((win_T *wp));
  #if defined(FEAT_WINDOWS) || defined(PROTO)
! static tabpage_T *alloc_tabpage __ARGS((void));
! static int leave_tabpage __ARGS((buf_T *new_curbuf, int trigger_leave_autocmds));
! static void enter_tabpage __ARGS((tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds));
! static void frame_fix_height __ARGS((win_T *wp));
! static int frame_minheight __ARGS((frame_T *topfrp, win_T *next_curwin));
! static void win_enter_ext __ARGS((win_T *wp, int undo_sync, int no_curwin, int trigger_enter_autocmds, int trigger_leave_autocmds));
! static void win_free __ARGS((win_T *wp, tabpage_T *tp));
! static void frame_append __ARGS((frame_T *after, frame_T *frp));
! static void frame_insert __ARGS((frame_T *before, frame_T *frp));
! static void frame_remove __ARGS((frame_T *frp));
  # ifdef FEAT_VERTSPLIT
! static void win_goto_ver __ARGS((int up, long count));
! static void win_goto_hor __ARGS((int left, long count));
  # endif
! static void frame_add_height __ARGS((frame_T *frp, int n));
! static void last_status_rec __ARGS((frame_T *fr, int statusline));
  
! static void make_snapshot_rec __ARGS((frame_T *fr, frame_T **frp));
! static void clear_snapshot __ARGS((tabpage_T *tp, int idx));
! static void clear_snapshot_rec __ARGS((frame_T *fr));
! static int check_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
! static win_T *restore_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
  
! static int frame_check_height __ARGS((frame_T *topfrp, int height));
  #ifdef FEAT_VERTSPLIT
! static int frame_check_width __ARGS((frame_T *topfrp, int width));
  #endif
  
  #endif /* FEAT_WINDOWS */
  
! static win_T *win_alloc __ARGS((win_T *after, int hidden));
  
  #define URL_SLASH	1		/* path_is_url() has found "://" */
  #define URL_BACKSLASH	2		/* path_is_url() has found ":\\" */
--- 9,80 ----
  
  #include "vim.h"
  
! static int path_is_url(char_u *p);
  #if defined(FEAT_WINDOWS) || defined(PROTO)
! static void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);
! static void win_init(win_T *newp, win_T *oldp, int flags);
! static void win_init_some(win_T *newp, win_T *oldp);
! static void frame_comp_pos(frame_T *topfrp, int *row, int *col);
! static void frame_setheight(frame_T *curfrp, int height);
! #ifdef FEAT_VERTSPLIT
! static void frame_setwidth(frame_T *curfrp, int width);
! #endif
! static void win_exchange(long);
! static void win_rotate(int, int);
! static void win_totop(int size, int flags);
! static void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);
! static int last_window(void);
! static int close_last_window_tabpage(win_T *win, int free_buf, tabpage_T *prev_curtab);
! static win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);
! static frame_T *win_altframe(win_T *win, tabpage_T *tp);
! static tabpage_T *alt_tabpage(void);
! static win_T *frame2win(frame_T *frp);
! static int frame_has_win(frame_T *frp, win_T *wp);
! static void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);
! static int frame_fixed_height(frame_T *frp);
! #ifdef FEAT_VERTSPLIT
! static int frame_fixed_width(frame_T *frp);
! static void frame_add_statusline(frame_T *frp);
! static void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);
! static void frame_add_vsep(frame_T *frp);
! static int frame_minwidth(frame_T *topfrp, win_T *next_curwin);
! static void frame_fix_width(win_T *wp);
  #endif
  #endif
! static int win_alloc_firstwin(win_T *oldwin);
! static void new_frame(win_T *wp);
  #if defined(FEAT_WINDOWS) || defined(PROTO)
! static tabpage_T *alloc_tabpage(void);
! static int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);
! static void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);
! static void frame_fix_height(win_T *wp);
! static int frame_minheight(frame_T *topfrp, win_T *next_curwin);
! static void win_enter_ext(win_T *wp, int undo_sync, int no_curwin, int trigger_enter_autocmds, int trigger_leave_autocmds);
! static void win_free(win_T *wp, tabpage_T *tp);
! static void frame_append(frame_T *after, frame_T *frp);
! static void frame_insert(frame_T *before, frame_T *frp);
! static void frame_remove(frame_T *frp);
  # ifdef FEAT_VERTSPLIT
! static void win_goto_ver(int up, long count);
! static void win_goto_hor(int left, long count);
  # endif
! static void frame_add_height(frame_T *frp, int n);
! static void last_status_rec(frame_T *fr, int statusline);
  
! static void make_snapshot_rec(frame_T *fr, frame_T **frp);
! static void clear_snapshot(tabpage_T *tp, int idx);
! static void clear_snapshot_rec(frame_T *fr);
! static int check_snapshot_rec(frame_T *sn, frame_T *fr);
! static win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);
  
! static int frame_check_height(frame_T *topfrp, int height);
  #ifdef FEAT_VERTSPLIT
! static int frame_check_width(frame_T *topfrp, int width);
  #endif
  
  #endif /* FEAT_WINDOWS */
  
! static win_T *win_alloc(win_T *after, int hidden);
  
  #define URL_SLASH	1		/* path_is_url() has found "://" */
  #define URL_BACKSLASH	2		/* path_is_url() has found ":\\" */
***************
*** 6372,6378 ****
  }
  
  # if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
! static char_u *eval_includeexpr __ARGS((char_u *ptr, int len));
  
      static char_u *
  eval_includeexpr(ptr, len)
--- 6372,6378 ----
  }
  
  # if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
! static char_u *eval_includeexpr(char_u *ptr, int len);
  
      static char_u *
  eval_includeexpr(ptr, len)
*** ../vim-7.4.1198/src/version.c	2016-01-29 22:36:41.237047563 +0100
--- src/version.c	2016-01-29 22:44:42.431972810 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1199,
  /**/

-- 
If bankers can count, how come they have eight windows and
only four tellers?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
