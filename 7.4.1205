To: vim_dev@googlegroups.com
Subject: Patch 7.4.1205
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1205
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/arabic.c, src/blowfish.c, src/buffer.c, src/channel.c,
            src/charset.c, src/crypt.c, src/crypt_zip.c, src/diff.c,
            src/digraph.c, src/edit.c, src/eval.c


*** ../vim-7.4.1204/src/arabic.c	2016-01-29 22:03:43.469945951 +0100
--- src/arabic.c	2016-01-30 13:58:32.150287066 +0100
***************
*** 43,50 ****
   * Returns True if c is an ISO-8859-6 shaped ARABIC letter (user entered)
   */
      static int
! A_is_a(cur_c)
!     int cur_c;
  {
      switch (cur_c)
      {
--- 43,49 ----
   * Returns True if c is an ISO-8859-6 shaped ARABIC letter (user entered)
   */
      static int
! A_is_a(int cur_c)
  {
      switch (cur_c)
      {
***************
*** 96,103 ****
   * Returns True if c is an Isolated Form-B ARABIC letter
   */
      static int
! A_is_s(cur_c)
!     int cur_c;
  {
      switch (cur_c)
      {
--- 95,101 ----
   * Returns True if c is an Isolated Form-B ARABIC letter
   */
      static int
! A_is_s(int cur_c)
  {
      switch (cur_c)
      {
***************
*** 148,155 ****
   * Returns True if c is a Final shape of an ARABIC letter
   */
      static int
! A_is_f(cur_c)
!     int cur_c;
  {
      switch (cur_c)
      {
--- 146,152 ----
   * Returns True if c is a Final shape of an ARABIC letter
   */
      static int
! A_is_f(int cur_c)
  {
      switch (cur_c)
      {
***************
*** 202,209 ****
   * Change shape - from ISO-8859-6/Isolated to Form-B Isolated
   */
      static int
! chg_c_a2s(cur_c)
!     int cur_c;
  {
      int tempc;
  
--- 199,205 ----
   * Change shape - from ISO-8859-6/Isolated to Form-B Isolated
   */
      static int
! chg_c_a2s(int cur_c)
  {
      int tempc;
  
***************
*** 332,339 ****
   * Change shape - from ISO-8859-6/Isolated to Initial
   */
      static int
! chg_c_a2i(cur_c)
!     int cur_c;
  {
      int tempc;
  
--- 328,334 ----
   * Change shape - from ISO-8859-6/Isolated to Initial
   */
      static int
! chg_c_a2i(int cur_c)
  {
      int tempc;
  
***************
*** 462,469 ****
   * Change shape - from ISO-8859-6/Isolated to Medial
   */
      static int
! chg_c_a2m(cur_c)
!     int cur_c;
  {
      int tempc;
  
--- 457,463 ----
   * Change shape - from ISO-8859-6/Isolated to Medial
   */
      static int
! chg_c_a2m(int cur_c)
  {
      int tempc;
  
***************
*** 592,599 ****
   * Change shape - from ISO-8859-6/Isolated to final
   */
      static int
! chg_c_a2f(cur_c)
!     int cur_c;
  {
      int tempc;
  
--- 586,592 ----
   * Change shape - from ISO-8859-6/Isolated to final
   */
      static int
! chg_c_a2f(int cur_c)
  {
      int tempc;
  
***************
*** 732,739 ****
   * Change shape - from Initial to Medial
   */
      static int
! chg_c_i2m(cur_c)
!     int cur_c;
  {
      int tempc;
  
--- 725,731 ----
   * Change shape - from Initial to Medial
   */
      static int
! chg_c_i2m(int cur_c)
  {
      int tempc;
  
***************
*** 820,827 ****
   * Change shape - from Final to Medial
   */
      static int
! chg_c_f2m(cur_c)
!     int cur_c;
  {
      int tempc;
  
--- 812,818 ----
   * Change shape - from Final to Medial
   */
      static int
! chg_c_f2m(int cur_c)
  {
      int tempc;
  
***************
*** 930,937 ****
   * Change shape - from Combination (2 char) to an Isolated
   */
      static int
! chg_c_laa2i(hid_c)
!     int hid_c;
  {
      int tempc;
  
--- 921,927 ----
   * Change shape - from Combination (2 char) to an Isolated
   */
      static int
! chg_c_laa2i(int hid_c)
  {
      int tempc;
  
***************
*** 961,968 ****
   * Change shape - from Combination-Isolated to Final
   */
      static int
! chg_c_laa2f(hid_c)
!     int hid_c;
  {
      int tempc;
  
--- 951,957 ----
   * Change shape - from Combination-Isolated to Final
   */
      static int
! chg_c_laa2f(int hid_c)
  {
      int tempc;
  
***************
*** 991,998 ****
   * Do "half-shaping" on character "c".  Return zero if no shaping.
   */
      static int
! half_shape(c)
!     int		c;
  {
      if (A_is_a(c))
  	return chg_c_a2i(c);
--- 980,986 ----
   * Do "half-shaping" on character "c".  Return zero if no shaping.
   */
      static int
! half_shape(int c)
  {
      if (A_is_a(c))
  	return chg_c_a2i(c);
***************
*** 1011,1023 ****
   * in:     "next_c"  is the next character (not shaped).
   */
      int
! arabic_shape(c, ccp, c1p, prev_c, prev_c1, next_c)
!     int		c;
!     int		*ccp;
!     int		*c1p;
!     int		prev_c;
!     int		prev_c1;
!     int		next_c;
  {
      int		curr_c;
      int		shape_c;
--- 999,1011 ----
   * in:     "next_c"  is the next character (not shaped).
   */
      int
! arabic_shape(
!     int		c,
!     int		*ccp,
!     int		*c1p,
!     int		prev_c,
!     int		prev_c1,
!     int		next_c)
  {
      int		curr_c;
      int		shape_c;
***************
*** 1082,1090 ****
   * A_firstc_laa returns first character of LAA combination if it exists
   */
      static int
! A_firstc_laa(c, c1)
!     int c;	/* base character */
!     int c1;	/* first composing character */
  {
      if (c1 != NUL && c == a_LAM && !A_is_harakat(c1))
  	return c1;
--- 1070,1078 ----
   * A_firstc_laa returns first character of LAA combination if it exists
   */
      static int
! A_firstc_laa(
!     int c,	/* base character */
!     int c1)	/* first composing character */
  {
      if (c1 != NUL && c == a_LAM && !A_is_harakat(c1))
  	return c1;
***************
*** 1097,1104 ****
   *		(harakat/tanween)
   */
      static int
! A_is_harakat(c)
!     int c;
  {
      return (c >= a_FATHATAN && c <= a_SUKUN);
  }
--- 1085,1091 ----
   *		(harakat/tanween)
   */
      static int
! A_is_harakat(int c)
  {
      return (c >= a_FATHATAN && c <= a_SUKUN);
  }
***************
*** 1109,1116 ****
   *		(alphabet/number/punctuation)
   */
      static int
! A_is_iso(c)
!     int c;
  {
      return ((c >= a_HAMZA && c <= a_GHAIN)
  	    || (c >= a_TATWEEL && c <= a_HAMZA_BELOW)
--- 1096,1102 ----
   *		(alphabet/number/punctuation)
   */
      static int
! A_is_iso(int c)
  {
      return ((c >= a_HAMZA && c <= a_GHAIN)
  	    || (c >= a_TATWEEL && c <= a_HAMZA_BELOW)
***************
*** 1123,1130 ****
   *		(alphabet/number/punctuation)
   */
      static int
! A_is_formb(c)
!     int c;
  {
      return ((c >= a_s_FATHATAN && c <= a_s_DAMMATAN)
  	    || c == a_s_KASRATAN
--- 1109,1115 ----
   *		(alphabet/number/punctuation)
   */
      static int
! A_is_formb(int c)
  {
      return ((c >= a_s_FATHATAN && c <= a_s_DAMMATAN)
  	    || c == a_s_KASRATAN
***************
*** 1137,1144 ****
   * A_is_ok returns TRUE if 'c' is an Arabic 10646 (8859-6 or Form-B)
   */
      static int
! A_is_ok(c)
!     int c;
  {
      return (A_is_iso(c) || A_is_formb(c));
  }
--- 1122,1128 ----
   * A_is_ok returns TRUE if 'c' is an Arabic 10646 (8859-6 or Form-B)
   */
      static int
! A_is_ok(int c)
  {
      return (A_is_iso(c) || A_is_formb(c));
  }
***************
*** 1149,1156 ****
   *		with some exceptions/exclusions
   */
      static int
! A_is_valid(c)
!     int c;
  {
      return (A_is_ok(c) && !A_is_special(c));
  }
--- 1133,1139 ----
   *		with some exceptions/exclusions
   */
      static int
! A_is_valid(int c)
  {
      return (A_is_ok(c) && !A_is_special(c));
  }
***************
*** 1161,1168 ****
   *		Specials don't adhere to most of the rules.
   */
      static int
! A_is_special(c)
!     int c;
  {
      return (c == a_HAMZA || c == a_s_HAMZA);
  }
--- 1144,1150 ----
   *		Specials don't adhere to most of the rules.
   */
      static int
! A_is_special(int c)
  {
      return (c == a_HAMZA || c == a_s_HAMZA);
  }
*** ../vim-7.4.1204/src/blowfish.c	2016-01-29 23:20:35.297308288 +0100
--- src/blowfish.c	2016-01-30 14:00:49.396867791 +0100
***************
*** 348,357 ****
      bfs->sbx[3][xr & 0xFF];
  
      static void
! bf_e_block(bfs, p_xl, p_xr)
!     bf_state_T *bfs;
!     UINT32_T *p_xl;
!     UINT32_T *p_xr;
  {
      UINT32_T temp;
      UINT32_T xl = *p_xl;
--- 348,357 ----
      bfs->sbx[3][xr & 0xFF];
  
      static void
! bf_e_block(
!     bf_state_T *bfs,
!     UINT32_T *p_xl,
!     UINT32_T *p_xr)
  {
      UINT32_T temp;
      UINT32_T xl = *p_xl;
***************
*** 384,392 ****
  #endif
  
      static void
! bf_e_cblock(bfs, block)
!     bf_state_T *bfs;
!     char_u *block;
  {
      block8	bk;
  
--- 384,392 ----
  #endif
  
      static void
! bf_e_cblock(
!     bf_state_T *bfs,
!     char_u *block)
  {
      block8	bk;
  
***************
*** 404,414 ****
   * "salt[salt_len]" as the salt.
   */
      static void
! bf_key_init(bfs, password, salt, salt_len)
!     bf_state_T	*bfs;
!     char_u	*password;
!     char_u	*salt;
!     int		salt_len;
  {
      int      i, j, keypos = 0;
      unsigned u;
--- 404,414 ----
   * "salt[salt_len]" as the salt.
   */
      static void
! bf_key_init(
!     bf_state_T	*bfs,
!     char_u	*password,
!     char_u	*salt,
!     int		salt_len)
  {
      int      i, j, keypos = 0;
      unsigned u;
***************
*** 470,479 ****
   * Blowfish self-test for corrupted tables or instructions.
   */
      static int
! bf_check_tables(pax, sbx, val)
!     UINT32_T pax[18];
!     UINT32_T sbx[4][256];
!     UINT32_T val;
  {
      int i, j;
      UINT32_T c = 0;
--- 470,479 ----
   * Blowfish self-test for corrupted tables or instructions.
   */
      static int
! bf_check_tables(
!     UINT32_T pax[18],
!     UINT32_T sbx[4][256],
!     UINT32_T val)
  {
      int i, j;
      UINT32_T c = 0;
***************
*** 514,520 ****
   * Return FAIL when there is something wrong with blowfish encryption.
   */
      static int
! bf_self_test()
  {
      int    i, bn;
      int    err = 0;
--- 514,520 ----
   * Return FAIL when there is something wrong with blowfish encryption.
   */
      static int
! bf_self_test(void)
  {
      int    i, bn;
      int    err = 0;
***************
*** 566,575 ****
   * Initialize with seed "seed[seed_len]".
   */
      static void
! bf_cfb_init(bfs, seed, seed_len)
!     bf_state_T	*bfs;
!     char_u	*seed;
!     int		seed_len;
  {
      int i, mi;
  
--- 566,575 ----
   * Initialize with seed "seed[seed_len]".
   */
      static void
! bf_cfb_init(
!     bf_state_T	*bfs,
!     char_u	*seed,
!     int		seed_len)
  {
      int i, mi;
  
***************
*** 602,612 ****
   * "from" and "to" can be equal to encrypt in place.
   */
      void
! crypt_blowfish_encode(state, from, len, to)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	*to;
  {
      bf_state_T *bfs = state->method_state;
      size_t	i;
--- 602,612 ----
   * "from" and "to" can be equal to encrypt in place.
   */
      void
! crypt_blowfish_encode(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	*to)
  {
      bf_state_T *bfs = state->method_state;
      size_t	i;
***************
*** 625,635 ****
   * Decrypt "from[len]" into "to[len]".
   */
      void
! crypt_blowfish_decode(state, from, len, to)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	*to;
  {
      bf_state_T *bfs = state->method_state;
      size_t	i;
--- 625,635 ----
   * Decrypt "from[len]" into "to[len]".
   */
      void
! crypt_blowfish_decode(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	*to)
  {
      bf_state_T *bfs = state->method_state;
      size_t	i;
***************
*** 644,656 ****
  }
  
      void
! crypt_blowfish_init(state, key, salt, salt_len, seed, seed_len)
!     cryptstate_T	*state;
!     char_u*		key;
!     char_u*		salt;
!     int			salt_len;
!     char_u*		seed;
!     int			seed_len;
  {
      bf_state_T	*bfs = (bf_state_T *)alloc_clear(sizeof(bf_state_T));
  
--- 644,656 ----
  }
  
      void
! crypt_blowfish_init(
!     cryptstate_T	*state,
!     char_u*		key,
!     char_u*		salt,
!     int			salt_len,
!     char_u*		seed,
!     int			seed_len)
  {
      bf_state_T	*bfs = (bf_state_T *)alloc_clear(sizeof(bf_state_T));
  
***************
*** 672,678 ****
   * Give an error and return FAIL when not.
   */
      int
! blowfish_self_test()
  {
      if (sha256_self_test() == FAIL)
      {
--- 672,678 ----
   * Give an error and return FAIL when not.
   */
      int
! blowfish_self_test(void)
  {
      if (sha256_self_test() == FAIL)
      {
*** ../vim-7.4.1204/src/buffer.c	2016-01-29 22:03:43.473945909 +0100
--- src/buffer.c	2016-01-30 14:20:46.196482938 +0100
***************
*** 73,82 ****
   * Return FAIL for failure, OK otherwise.
   */
      int
! open_buffer(read_stdin, eap, flags)
!     int		read_stdin;	    /* read file from stdin */
!     exarg_T	*eap;		    /* for forced 'ff' and 'fenc' or NULL */
!     int		flags;		    /* extra flags for readfile() */
  {
      int		retval = OK;
  #ifdef FEAT_AUTOCMD
--- 73,82 ----
   * Return FAIL for failure, OK otherwise.
   */
      int
! open_buffer(
!     int		read_stdin,	    /* read file from stdin */
!     exarg_T	*eap,		    /* for forced 'ff' and 'fenc' or NULL */
!     int		flags)		    /* extra flags for readfile() */
  {
      int		retval = OK;
  #ifdef FEAT_AUTOCMD
***************
*** 307,314 ****
   * Return TRUE if "buf" points to a valid buffer (in the buffer list).
   */
      int
! buf_valid(buf)
!     buf_T	*buf;
  {
      buf_T	*bp;
  
--- 307,313 ----
   * Return TRUE if "buf" points to a valid buffer (in the buffer list).
   */
      int
! buf_valid(buf_T *buf)
  {
      buf_T	*bp;
  
***************
*** 336,346 ****
   * supposed to close the window but autocommands close all other windows.
   */
      void
! close_buffer(win, buf, action, abort_if_last)
!     win_T	*win;		/* if not NULL, set b_last_cursor */
!     buf_T	*buf;
!     int		action;
!     int		abort_if_last UNUSED;
  {
  #ifdef FEAT_AUTOCMD
      int		is_curbuf;
--- 335,345 ----
   * supposed to close the window but autocommands close all other windows.
   */
      void
! close_buffer(
!     win_T	*win,		/* if not NULL, set b_last_cursor */
!     buf_T	*buf,
!     int		action,
!     int		abort_if_last UNUSED)
  {
  #ifdef FEAT_AUTOCMD
      int		is_curbuf;
***************
*** 538,545 ****
   * Make buffer not contain a file.
   */
      void
! buf_clear_file(buf)
!     buf_T	*buf;
  {
      buf->b_ml.ml_line_count = 1;
      unchanged(buf, TRUE);
--- 537,543 ----
   * Make buffer not contain a file.
   */
      void
! buf_clear_file(buf_T *buf)
  {
      buf->b_ml.ml_line_count = 1;
      unchanged(buf, TRUE);
***************
*** 567,575 ****
   * BFA_KEEP_UNDO  do not free undo information
   */
      void
! buf_freeall(buf, flags)
!     buf_T	*buf;
!     int		flags;
  {
  #ifdef FEAT_AUTOCMD
      int		is_curbuf = (buf == curbuf);
--- 565,571 ----
   * BFA_KEEP_UNDO  do not free undo information
   */
      void
! buf_freeall(buf_T *buf, int flags)
  {
  #ifdef FEAT_AUTOCMD
      int		is_curbuf = (buf == curbuf);
***************
*** 653,660 ****
   * itself (not the file, that must have been done already).
   */
      static void
! free_buffer(buf)
!     buf_T	*buf;
  {
      free_buffer_stuff(buf, TRUE);
  #ifdef FEAT_EVAL
--- 649,655 ----
   * itself (not the file, that must have been done already).
   */
      static void
! free_buffer(buf_T *buf)
  {
      free_buffer_stuff(buf, TRUE);
  #ifdef FEAT_EVAL
***************
*** 696,704 ****
   * Free stuff in the buffer for ":bdel" and when wiping out the buffer.
   */
      static void
! free_buffer_stuff(buf, free_options)
!     buf_T	*buf;
!     int		free_options;		/* free options as well */
  {
      if (free_options)
      {
--- 691,699 ----
   * Free stuff in the buffer for ":bdel" and when wiping out the buffer.
   */
      static void
! free_buffer_stuff(
!     buf_T	*buf,
!     int		free_options)		/* free options as well */
  {
      if (free_options)
      {
***************
*** 735,742 ****
   * Free the b_wininfo list for buffer "buf".
   */
      static void
! clear_wininfo(buf)
!     buf_T	*buf;
  {
      wininfo_T	*wip;
  
--- 730,736 ----
   * Free the b_wininfo list for buffer "buf".
   */
      static void
! clear_wininfo(buf_T *buf)
  {
      wininfo_T	*wip;
  
***************
*** 760,770 ****
   * Go to another buffer.  Handles the result of the ATTENTION dialog.
   */
      void
! goto_buffer(eap, start, dir, count)
!     exarg_T	*eap;
!     int		start;
!     int		dir;
!     int		count;
  {
  # if defined(FEAT_WINDOWS) && defined(HAS_SWAP_EXISTS_ACTION)
      buf_T	*old_curbuf = curbuf;
--- 754,764 ----
   * Go to another buffer.  Handles the result of the ATTENTION dialog.
   */
      void
! goto_buffer(
!     exarg_T	*eap,
!     int		start,
!     int		dir,
!     int		count)
  {
  # if defined(FEAT_WINDOWS) && defined(HAS_SWAP_EXISTS_ACTION)
      buf_T	*old_curbuf = curbuf;
***************
*** 807,814 ****
   * It is allowed for "old_curbuf" to be NULL or invalid.
   */
      void
! handle_swap_exists(old_curbuf)
!     buf_T	*old_curbuf;
  {
  # if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
      cleanup_T	cs;
--- 801,807 ----
   * It is allowed for "old_curbuf" to be NULL or invalid.
   */
      void
! handle_swap_exists(buf_T *old_curbuf)
  {
  # if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
      cleanup_T	cs;
***************
*** 889,901 ****
   * Returns error message or NULL
   */
      char_u *
! do_bufdel(command, arg, addr_count, start_bnr, end_bnr, forceit)
!     int		command;
!     char_u	*arg;		/* pointer to extra arguments */
!     int		addr_count;
!     int		start_bnr;	/* first buffer number in a range */
!     int		end_bnr;	/* buffer nr or last buffer nr in a range */
!     int		forceit;
  {
      int		do_current = 0;	/* delete current buffer? */
      int		deleted = 0;	/* number of buffers deleted */
--- 882,894 ----
   * Returns error message or NULL
   */
      char_u *
! do_bufdel(
!     int		command,
!     char_u	*arg,		/* pointer to extra arguments */
!     int		addr_count,
!     int		start_bnr,	/* first buffer number in a range */
!     int		end_bnr,	/* buffer nr or last buffer nr in a range */
!     int		forceit)
  {
      int		do_current = 0;	/* delete current buffer? */
      int		deleted = 0;	/* number of buffers deleted */
***************
*** 1013,1022 ****
   * Used when it is wiped out and it's the last buffer.
   */
      static int
! empty_curbuf(close_others, forceit, action)
!     int close_others;
!     int forceit;
!     int action;
  {
      int	    retval;
      buf_T   *buf = curbuf;
--- 1006,1015 ----
   * Used when it is wiped out and it's the last buffer.
   */
      static int
! empty_curbuf(
!     int close_others,
!     int forceit,
!     int action)
  {
      int	    retval;
      buf_T   *buf = curbuf;
***************
*** 1067,1078 ****
   * Return FAIL or OK.
   */
      int
! do_buffer(action, start, dir, count, forceit)
!     int		action;
!     int		start;
!     int		dir;		/* FORWARD or BACKWARD */
!     int		count;		/* buffer number or number of buffers */
!     int		forceit;	/* TRUE for :...! */
  {
      buf_T	*buf;
      buf_T	*bp;
--- 1060,1071 ----
   * Return FAIL or OK.
   */
      int
! do_buffer(
!     int		action,
!     int		start,
!     int		dir,		/* FORWARD or BACKWARD */
!     int		count,		/* buffer number or number of buffers */
!     int		forceit)	/* TRUE for :...! */
  {
      buf_T	*buf;
      buf_T	*bp;
***************
*** 1428,1436 ****
   * DOBUF_WIPE	    wipe it out
   */
      void
! set_curbuf(buf, action)
!     buf_T	*buf;
!     int		action;
  {
      buf_T	*prevbuf;
      int		unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL
--- 1421,1427 ----
   * DOBUF_WIPE	    wipe it out
   */
      void
! set_curbuf(buf_T *buf, int action)
  {
      buf_T	*prevbuf;
      int		unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL
***************
*** 1517,1524 ****
   * be pointing to freed memory.
   */
      void
! enter_buffer(buf)
!     buf_T	*buf;
  {
      /* Copy buffer and window local option values.  Not for a help buffer. */
      buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);
--- 1508,1514 ----
   * be pointing to freed memory.
   */
      void
! enter_buffer(buf_T *buf)
  {
      /* Copy buffer and window local option values.  Not for a help buffer. */
      buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);
***************
*** 1629,1635 ****
   * Change to the directory of the current buffer.
   */
      void
! do_autochdir()
  {
      if (curbuf->b_ffname != NULL && vim_chdirfile(curbuf->b_ffname) == OK)
  	shorten_fnames(TRUE);
--- 1619,1625 ----
   * Change to the directory of the current buffer.
   */
      void
! do_autochdir(void)
  {
      if (curbuf->b_ffname != NULL && vim_chdirfile(curbuf->b_ffname) == OK)
  	shorten_fnames(TRUE);
***************
*** 1652,1662 ****
  static int  top_file_num = 1;		/* highest file number */
  
      buf_T *
! buflist_new(ffname, sfname, lnum, flags)
!     char_u	*ffname;	/* full path of fname or relative */
!     char_u	*sfname;	/* short fname or NULL */
!     linenr_T	lnum;		/* preferred cursor line */
!     int		flags;		/* BLN_ defines */
  {
      buf_T	*buf;
  #ifdef UNIX
--- 1642,1652 ----
  static int  top_file_num = 1;		/* highest file number */
  
      buf_T *
! buflist_new(
!     char_u	*ffname,	/* full path of fname or relative */
!     char_u	*sfname,	/* short fname or NULL */
!     linenr_T	lnum,		/* preferred cursor line */
!     int		flags)		/* BLN_ defines */
  {
      buf_T	*buf;
  #ifdef UNIX
***************
*** 1899,1907 ****
   * 'fileencoding'.
   */
      void
! free_buf_options(buf, free_p_ff)
!     buf_T	*buf;
!     int		free_p_ff;
  {
      if (free_p_ff)
      {
--- 1889,1897 ----
   * 'fileencoding'.
   */
      void
! free_buf_options(
!     buf_T	*buf,
!     int		free_p_ff)
  {
      if (free_p_ff)
      {
***************
*** 2019,2029 ****
   * return FAIL for failure, OK for success
   */
      int
! buflist_getfile(n, lnum, options, forceit)
!     int		n;
!     linenr_T	lnum;
!     int		options;
!     int		forceit;
  {
      buf_T	*buf;
  #ifdef FEAT_WINDOWS
--- 2009,2019 ----
   * return FAIL for failure, OK for success
   */
      int
! buflist_getfile(
!     int		n,
!     linenr_T	lnum,
!     int		options,
!     int		forceit)
  {
      buf_T	*buf;
  #ifdef FEAT_WINDOWS
***************
*** 2120,2126 ****
   * go to the last know line number for the current buffer
   */
      void
! buflist_getfpos()
  {
      pos_T	*fpos;
  
--- 2110,2116 ----
   * go to the last know line number for the current buffer
   */
      void
! buflist_getfpos(void)
  {
      pos_T	*fpos;
  
***************
*** 2148,2155 ****
   * Returns NULL if not found.
   */
      buf_T *
! buflist_findname_exp(fname)
!     char_u *fname;
  {
      char_u	*ffname;
      buf_T	*buf = NULL;
--- 2138,2144 ----
   * Returns NULL if not found.
   */
      buf_T *
! buflist_findname_exp(char_u *fname)
  {
      char_u	*ffname;
      buf_T	*buf = NULL;
***************
*** 2178,2185 ****
   * Returns NULL if not found.
   */
      buf_T *
! buflist_findname(ffname)
!     char_u	*ffname;
  {
  #ifdef UNIX
      struct stat st;
--- 2167,2173 ----
   * Returns NULL if not found.
   */
      buf_T *
! buflist_findname(char_u *ffname)
  {
  #ifdef UNIX
      struct stat st;
***************
*** 2195,2203 ****
   * Returns NULL if not found.
   */
      static buf_T *
! buflist_findname_stat(ffname, stp)
!     char_u	*ffname;
!     struct stat	*stp;
  {
  #endif
      buf_T	*buf;
--- 2183,2191 ----
   * Returns NULL if not found.
   */
      static buf_T *
! buflist_findname_stat(
!     char_u	*ffname,
!     struct stat	*stp)
  {
  #endif
      buf_T	*buf;
***************
*** 2220,2231 ****
   * Return < 0 for error.
   */
      int
! buflist_findpat(pattern, pattern_end, unlisted, diffmode, curtab_only)
!     char_u	*pattern;
!     char_u	*pattern_end;	/* pointer to first char after pattern */
!     int		unlisted;	/* find unlisted buffers */
!     int		diffmode UNUSED; /* find diff-mode buffers only */
!     int		curtab_only;	/* find buffers in current tab only */
  {
      buf_T	*buf;
      int		match = -1;
--- 2208,2219 ----
   * Return < 0 for error.
   */
      int
! buflist_findpat(
!     char_u	*pattern,
!     char_u	*pattern_end,	/* pointer to first char after pattern */
!     int		unlisted,	/* find unlisted buffers */
!     int		diffmode UNUSED, /* find diff-mode buffers only */
!     int		curtab_only)	/* find buffers in current tab only */
  {
      buf_T	*buf;
      int		match = -1;
***************
*** 2350,2360 ****
   * Return OK if matches found, FAIL otherwise.
   */
      int
! ExpandBufnames(pat, num_file, file, options)
!     char_u	*pat;
!     int		*num_file;
!     char_u	***file;
!     int		options;
  {
      int		count = 0;
      buf_T	*buf;
--- 2338,2348 ----
   * Return OK if matches found, FAIL otherwise.
   */
      int
! ExpandBufnames(
!     char_u	*pat,
!     int		*num_file,
!     char_u	***file,
!     int		options)
  {
      int		count = 0;
      buf_T	*buf;
***************
*** 2455,2464 ****
   * Check for a match on the file name for buffer "buf" with regprog "prog".
   */
      static char_u *
! buflist_match(rmp, buf, ignore_case)
!     regmatch_T	*rmp;
!     buf_T	*buf;
!     int		ignore_case;  /* when TRUE ignore case, when FALSE use 'fic' */
  {
      char_u	*match;
  
--- 2443,2452 ----
   * Check for a match on the file name for buffer "buf" with regprog "prog".
   */
      static char_u *
! buflist_match(
!     regmatch_T	*rmp,
!     buf_T	*buf,
!     int		ignore_case)  /* when TRUE ignore case, when FALSE use 'fic' */
  {
      char_u	*match;
  
***************
*** 2475,2484 ****
   * Return "name" when there is a match, NULL when not.
   */
      static char_u *
! fname_match(rmp, name, ignore_case)
!     regmatch_T	*rmp;
!     char_u	*name;
!     int		ignore_case;  /* when TRUE ignore case, when FALSE use 'fic' */
  {
      char_u	*match = NULL;
      char_u	*p;
--- 2463,2472 ----
   * Return "name" when there is a match, NULL when not.
   */
      static char_u *
! fname_match(
!     regmatch_T	*rmp,
!     char_u	*name,
!     int		ignore_case)  /* when TRUE ignore case, when FALSE use 'fic' */
  {
      char_u	*match = NULL;
      char_u	*p;
***************
*** 2507,2514 ****
   * find file in buffer list by number
   */
      buf_T *
! buflist_findnr(nr)
!     int		nr;
  {
      buf_T	*buf;
  
--- 2495,2501 ----
   * find file in buffer list by number
   */
      buf_T *
! buflist_findnr(int nr)
  {
      buf_T	*buf;
  
***************
*** 2527,2536 ****
   * Returns a pointer to allocated memory, of NULL when failed.
   */
      char_u *
! buflist_nr2name(n, fullname, helptail)
!     int		n;
!     int		fullname;
!     int		helptail;	/* for help buffers return tail only */
  {
      buf_T	*buf;
  
--- 2514,2523 ----
   * Returns a pointer to allocated memory, of NULL when failed.
   */
      char_u *
! buflist_nr2name(
!     int		n,
!     int		fullname,
!     int		helptail)	/* for help buffers return tail only */
  {
      buf_T	*buf;
  
***************
*** 2547,2558 ****
   * When "lnum" is 0 only do the options.
   */
      static void
! buflist_setfpos(buf, win, lnum, col, copy_options)
!     buf_T	*buf;
!     win_T	*win;
!     linenr_T	lnum;
!     colnr_T	col;
!     int		copy_options;
  {
      wininfo_T	*wip;
  
--- 2534,2545 ----
   * When "lnum" is 0 only do the options.
   */
      static void
! buflist_setfpos(
!     buf_T	*buf,
!     win_T	*win,
!     linenr_T	lnum,
!     colnr_T	col,
!     int		copy_options)
  {
      wininfo_T	*wip;
  
***************
*** 2620,2627 ****
   * page.  That's because a diff is local to a tab page.
   */
      static int
! wininfo_other_tab_diff(wip)
!     wininfo_T	*wip;
  {
      win_T	*wp;
  
--- 2607,2613 ----
   * page.  That's because a diff is local to a tab page.
   */
      static int
! wininfo_other_tab_diff(wininfo_T *wip)
  {
      win_T	*wp;
  
***************
*** 2646,2654 ****
   * Returns NULL when there isn't any info.
   */
      static wininfo_T *
! find_wininfo(buf, skip_diff_buffer)
!     buf_T	*buf;
!     int		skip_diff_buffer UNUSED;
  {
      wininfo_T	*wip;
  
--- 2632,2640 ----
   * Returns NULL when there isn't any info.
   */
      static wininfo_T *
! find_wininfo(
!     buf_T	*buf,
!     int		skip_diff_buffer UNUSED)
  {
      wininfo_T	*wip;
  
***************
*** 2685,2692 ****
   * global values for the window.
   */
      void
! get_winopts(buf)
!     buf_T	*buf;
  {
      wininfo_T	*wip;
  
--- 2671,2677 ----
   * global values for the window.
   */
      void
! get_winopts(buf_T *buf)
  {
      wininfo_T	*wip;
  
***************
*** 2724,2731 ****
   * Returns a pointer to no_position if no position is found.
   */
      pos_T *
! buflist_findfpos(buf)
!     buf_T	*buf;
  {
      wininfo_T	*wip;
      static pos_T no_position = INIT_POS_T(1, 0, 0);
--- 2709,2715 ----
   * Returns a pointer to no_position if no position is found.
   */
      pos_T *
! buflist_findfpos(buf_T *buf)
  {
      wininfo_T	*wip;
      static pos_T no_position = INIT_POS_T(1, 0, 0);
***************
*** 2741,2748 ****
   * Find the lnum for the buffer 'buf' for the current window.
   */
      linenr_T
! buflist_findlnum(buf)
!     buf_T	*buf;
  {
      return buflist_findfpos(buf)->lnum;
  }
--- 2725,2731 ----
   * Find the lnum for the buffer 'buf' for the current window.
   */
      linenr_T
! buflist_findlnum(buf_T *buf)
  {
      return buflist_findfpos(buf)->lnum;
  }
***************
*** 2752,2759 ****
   * List all know file names (for :files and :buffers command).
   */
      void
! buflist_list(eap)
!     exarg_T	*eap;
  {
      buf_T	*buf;
      int		len;
--- 2735,2741 ----
   * List all know file names (for :files and :buffers command).
   */
      void
! buflist_list(exarg_T *eap)
  {
      buf_T	*buf;
      int		len;
***************
*** 2820,2829 ****
   * Return FAIL if not found, OK for success.
   */
      int
! buflist_name_nr(fnum, fname, lnum)
!     int		fnum;
!     char_u	**fname;
!     linenr_T	*lnum;
  {
      buf_T	*buf;
  
--- 2802,2811 ----
   * Return FAIL if not found, OK for success.
   */
      int
! buflist_name_nr(
!     int		fnum,
!     char_u	**fname,
!     linenr_T	*lnum)
  {
      buf_T	*buf;
  
***************
*** 2844,2853 ****
   *	OK otherwise.
   */
      int
! setfname(buf, ffname, sfname, message)
!     buf_T	*buf;
!     char_u	*ffname, *sfname;
!     int		message;	/* give message when buffer already exists */
  {
      buf_T	*obuf = NULL;
  #ifdef UNIX
--- 2826,2836 ----
   *	OK otherwise.
   */
      int
! setfname(
!     buf_T	*buf,
!     char_u	*ffname,
!     char_u	*sfname,
!     int		message)	/* give message when buffer already exists */
  {
      buf_T	*obuf = NULL;
  #ifdef UNIX
***************
*** 2941,2949 ****
   * The name should be relative to the current directory.
   */
      void
! buf_set_name(fnum, name)
!     int		fnum;
!     char_u	*name;
  {
      buf_T	*buf;
  
--- 2924,2930 ----
   * The name should be relative to the current directory.
   */
      void
! buf_set_name(int fnum, char_u *name)
  {
      buf_T	*buf;
  
***************
*** 2966,2973 ****
   * changed.
   */
      void
! buf_name_changed(buf)
!     buf_T	*buf;
  {
      /*
       * If the file name changed, also change the name of the swapfile
--- 2947,2953 ----
   * changed.
   */
      void
! buf_name_changed(buf_T *buf)
  {
      /*
       * If the file name changed, also change the name of the swapfile
***************
*** 2994,3003 ****
   * Return the buffer.
   */
      buf_T *
! setaltfname(ffname, sfname, lnum)
!     char_u	*ffname;
!     char_u	*sfname;
!     linenr_T	lnum;
  {
      buf_T	*buf;
  
--- 2974,2983 ----
   * Return the buffer.
   */
      buf_T *
! setaltfname(
!     char_u	*ffname,
!     char_u	*sfname,
!     linenr_T	lnum)
  {
      buf_T	*buf;
  
***************
*** 3013,3020 ****
   * Return NULL if there isn't any, and give error message if requested.
   */
      char_u  *
! getaltfname(errmsg)
!     int		errmsg;		/* give error message */
  {
      char_u	*fname;
      linenr_T	dummy;
--- 2993,3000 ----
   * Return NULL if there isn't any, and give error message if requested.
   */
      char_u  *
! getaltfname(
!     int		errmsg)		/* give error message */
  {
      char_u	*fname;
      linenr_T	dummy;
***************
*** 3035,3043 ****
   * used by qf_init(), main() and doarglist()
   */
      int
! buflist_add(fname, flags)
!     char_u	*fname;
!     int		flags;
  {
      buf_T	*buf;
  
--- 3015,3021 ----
   * used by qf_init(), main() and doarglist()
   */
      int
! buflist_add(char_u *fname, int flags)
  {
      buf_T	*buf;
  
***************
*** 3052,3058 ****
   * Adjust slashes in file names.  Called after 'shellslash' was set.
   */
      void
! buflist_slash_adjust()
  {
      buf_T	*bp;
  
--- 3030,3036 ----
   * Adjust slashes in file names.  Called after 'shellslash' was set.
   */
      void
! buflist_slash_adjust(void)
  {
      buf_T	*bp;
  
***************
*** 3071,3078 ****
   * Also save the local window option values.
   */
      void
! buflist_altfpos(win)
!     win_T *win;
  {
      buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);
  }
--- 3049,3055 ----
   * Also save the local window option values.
   */
      void
! buflist_altfpos(win_T *win)
  {
      buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);
  }
***************
*** 3082,3089 ****
   * Fname must have a full path (expanded by mch_FullName()).
   */
      int
! otherfile(ffname)
!     char_u	*ffname;
  {
      return otherfile_buf(curbuf, ffname
  #ifdef UNIX
--- 3059,3065 ----
   * Fname must have a full path (expanded by mch_FullName()).
   */
      int
! otherfile(char_u *ffname)
  {
      return otherfile_buf(curbuf, ffname
  #ifdef UNIX
***************
*** 3093,3108 ****
  }
  
      static int
! otherfile_buf(buf, ffname
  #ifdef UNIX
! 	, stp
! #endif
! 	)
!     buf_T	*buf;
!     char_u	*ffname;
! #ifdef UNIX
!     struct stat	*stp;
  #endif
  {
      /* no name is different */
      if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)
--- 3069,3081 ----
  }
  
      static int
! otherfile_buf(
!     buf_T		*buf,
!     char_u		*ffname
  #ifdef UNIX
!     , struct stat	*stp
  #endif
+     )
  {
      /* no name is different */
      if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)
***************
*** 3146,3153 ****
   * Must always be called when b_fname is changed!.
   */
      void
! buf_setino(buf)
!     buf_T	*buf;
  {
      struct stat	st;
  
--- 3119,3125 ----
   * Must always be called when b_fname is changed!.
   */
      void
! buf_setino(buf_T *buf)
  {
      struct stat	st;
  
***************
*** 3165,3173 ****
   * Return TRUE if dev/ino in buffer "buf" matches with "stp".
   */
      static int
! buf_same_ino(buf, stp)
!     buf_T	*buf;
!     struct stat *stp;
  {
      return (buf->b_dev_valid
  	    && stp->st_dev == buf->b_dev
--- 3137,3145 ----
   * Return TRUE if dev/ino in buffer "buf" matches with "stp".
   */
      static int
! buf_same_ino(
!     buf_T	*buf,
!     struct stat *stp)
  {
      return (buf->b_dev_valid
  	    && stp->st_dev == buf->b_dev
***************
*** 3179,3188 ****
   * Print info about the current buffer.
   */
      void
! fileinfo(fullname, shorthelp, dont_truncate)
!     int fullname;	    /* when non-zero print full path */
!     int shorthelp;
!     int	dont_truncate;
  {
      char_u	*name;
      int		n;
--- 3151,3160 ----
   * Print info about the current buffer.
   */
      void
! fileinfo(
!     int fullname,	    /* when non-zero print full path */
!     int shorthelp,
!     int	dont_truncate)
  {
      char_u	*name;
      int		n;
***************
*** 3298,3308 ****
  }
  
      void
! col_print(buf, buflen, col, vcol)
!     char_u  *buf;
!     size_t  buflen;
!     int	    col;
!     int	    vcol;
  {
      if (col == vcol)
  	vim_snprintf((char *)buf, buflen, "%d", col);
--- 3270,3280 ----
  }
  
      void
! col_print(
!     char_u  *buf,
!     size_t  buflen,
!     int	    col,
!     int	    vcol)
  {
      if (col == vcol)
  	vim_snprintf((char *)buf, buflen, "%d", col);
***************
*** 3319,3325 ****
  static char_u *lasticon = NULL;
  
      void
! maketitle()
  {
      char_u	*p;
      char_u	*t_str = NULL;
--- 3291,3297 ----
  static char_u *lasticon = NULL;
  
      void
! maketitle(void)
  {
      char_u	*p;
      char_u	*t_str = NULL;
***************
*** 3528,3536 ****
   * Return TRUE when "*last" changed.
   */
      static int
! ti_change(str, last)
!     char_u	*str;
!     char_u	**last;
  {
      if ((str == NULL) != (*last == NULL)
  	    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))
--- 3500,3506 ----
   * Return TRUE when "*last" changed.
   */
      static int
! ti_change(char_u *str, char_u **last)
  {
      if ((str == NULL) != (*last == NULL)
  	    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))
***************
*** 3549,3562 ****
   * Put current window title back (used after calling a shell)
   */
      void
! resettitle()
  {
      mch_settitle(lasttitle, lasticon);
  }
  
  # if defined(EXITFREE) || defined(PROTO)
      void
! free_titles()
  {
      vim_free(lasttitle);
      vim_free(lasticon);
--- 3519,3532 ----
   * Put current window title back (used after calling a shell)
   */
      void
! resettitle(void)
  {
      mch_settitle(lasttitle, lasticon);
  }
  
  # if defined(EXITFREE) || defined(PROTO)
      void
! free_titles(void)
  {
      vim_free(lasttitle);
      vim_free(lasticon);
***************
*** 3581,3597 ****
   * or truncated if too long, fillchar is used for all whitespace.
   */
      int
! build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar,
! 						      maxwidth, hltab, tabtab)
!     win_T	*wp;
!     char_u	*out;		/* buffer to write into != NameBuff */
!     size_t	outlen;		/* length of out[] */
!     char_u	*fmt;
!     int		use_sandbox UNUSED; /* "fmt" was set insecurely, use sandbox */
!     int		fillchar;
!     int		maxwidth;
!     struct stl_hlrec *hltab;	/* return: HL attributes (can be NULL) */
!     struct stl_hlrec *tabtab;	/* return: tab page nrs (can be NULL) */
  {
      char_u	*p;
      char_u	*s;
--- 3551,3566 ----
   * or truncated if too long, fillchar is used for all whitespace.
   */
      int
! build_stl_str_hl(
!     win_T	*wp,
!     char_u	*out,		/* buffer to write into != NameBuff */
!     size_t	outlen,		/* length of out[] */
!     char_u	*fmt,
!     int		use_sandbox UNUSED, /* "fmt" was set insecurely, use sandbox */
!     int		fillchar,
!     int		maxwidth,
!     struct stl_hlrec *hltab,	/* return: HL attributes (can be NULL) */
!     struct stl_hlrec *tabtab)	/* return: tab page nrs (can be NULL) */
  {
      char_u	*p;
      char_u	*s;
***************
*** 4424,4433 ****
   * using "Top", "Bot" or "All" when appropriate.
   */
      void
! get_rel_pos(wp, buf, buflen)
!     win_T	*wp;
!     char_u	*buf;
!     int		buflen;
  {
      long	above; /* number of lines above window */
      long	below; /* number of lines below window */
--- 4393,4402 ----
   * using "Top", "Bot" or "All" when appropriate.
   */
      void
! get_rel_pos(
!     win_T	*wp,
!     char_u	*buf,
!     int		buflen)
  {
      long	above; /* number of lines above window */
      long	below; /* number of lines below window */
***************
*** 4460,4470 ****
   * Return TRUE if it was appended.
   */
      static int
! append_arg_number(wp, buf, buflen, add_file)
!     win_T	*wp;
!     char_u	*buf;
!     int		buflen;
!     int		add_file;	/* Add "file" before the arg number */
  {
      char_u	*p;
  
--- 4429,4439 ----
   * Return TRUE if it was appended.
   */
      static int
! append_arg_number(
!     win_T	*wp,
!     char_u	*buf,
!     int		buflen,
!     int		add_file)	/* Add "file" before the arg number */
  {
      char_u	*p;
  
***************
*** 4492,4499 ****
   * Returns pointer to allocated memory (NULL for failure).
   */
      char_u  *
! fix_fname(fname)
!     char_u  *fname;
  {
      /*
       * Force expanding the path always for Unix, because symbolic links may
--- 4461,4467 ----
   * Returns pointer to allocated memory (NULL for failure).
   */
      char_u  *
! fix_fname(char_u  *fname)
  {
      /*
       * Force expanding the path always for Unix, because symbolic links may
***************
*** 4539,4548 ****
   * "ffname" becomes a pointer to allocated memory (or NULL).
   */
      void
! fname_expand(buf, ffname, sfname)
!     buf_T	*buf UNUSED;
!     char_u	**ffname;
!     char_u	**sfname;
  {
      if (*ffname == NULL)	/* if no file name given, nothing to do */
  	return;
--- 4507,4516 ----
   * "ffname" becomes a pointer to allocated memory (or NULL).
   */
      void
! fname_expand(
!     buf_T	*buf UNUSED,
!     char_u	**ffname,
!     char_u	**sfname)
  {
      if (*ffname == NULL)	/* if no file name given, nothing to do */
  	return;
***************
*** 4571,4578 ****
   * Get the file name for an argument list entry.
   */
      char_u *
! alist_name(aep)
!     aentry_T	*aep;
  {
      buf_T	*bp;
  
--- 4539,4545 ----
   * Get the file name for an argument list entry.
   */
      char_u *
! alist_name(aentry_T *aep)
  {
      buf_T	*bp;
  
***************
*** 4588,4597 ****
   * do_arg_all(): Open up to 'count' windows, one for each argument.
   */
      void
! do_arg_all(count, forceit, keep_tabs)
!     int	count;
!     int	forceit;		/* hide buffers in current windows */
!     int keep_tabs;		/* keep current tabs, for ":tab drop file" */
  {
      int		i;
      win_T	*wp, *wpnext;
--- 4555,4564 ----
   * do_arg_all(): Open up to 'count' windows, one for each argument.
   */
      void
! do_arg_all(
!     int	count,
!     int	forceit,		/* hide buffers in current windows */
!     int keep_tabs)		/* keep current tabs, for ":tab drop file" */
  {
      int		i;
      win_T	*wp, *wpnext;
***************
*** 4885,4892 ****
   * Open a window for a number of buffers.
   */
      void
! ex_buffer_all(eap)
!     exarg_T	*eap;
  {
      buf_T	*buf;
      win_T	*wp, *wpnext;
--- 4852,4858 ----
   * Open a window for a number of buffers.
   */
      void
! ex_buffer_all(exarg_T *eap)
  {
      buf_T	*buf;
      win_T	*wp, *wpnext;
***************
*** 5130,5137 ****
   * Returns immediately if the "ml" option isn't set.
   */
      void
! do_modelines(flags)
!     int		flags;
  {
      linenr_T	lnum;
      int		nmlines;
--- 5096,5102 ----
   * Returns immediately if the "ml" option isn't set.
   */
      void
! do_modelines(int flags)
  {
      linenr_T	lnum;
      int		nmlines;
***************
*** 5165,5173 ****
   * Return FAIL if an error encountered.
   */
      static int
! chk_modeline(lnum, flags)
!     linenr_T	lnum;
!     int		flags;		/* Same as for do_modelines(). */
  {
      char_u	*s;
      char_u	*e;
--- 5130,5138 ----
   * Return FAIL if an error encountered.
   */
      static int
! chk_modeline(
!     linenr_T	lnum,
!     int		flags)		/* Same as for do_modelines(). */
  {
      char_u	*s;
      char_u	*e;
***************
*** 5287,5295 ****
  
  #if defined(FEAT_VIMINFO) || defined(PROTO)
      int
! read_viminfo_bufferlist(virp, writing)
!     vir_T	*virp;
!     int		writing;
  {
      char_u	*tab;
      linenr_T	lnum;
--- 5252,5260 ----
  
  #if defined(FEAT_VIMINFO) || defined(PROTO)
      int
! read_viminfo_bufferlist(
!     vir_T	*virp,
!     int		writing)
  {
      char_u	*tab;
      linenr_T	lnum;
***************
*** 5341,5348 ****
  }
  
      void
! write_viminfo_bufferlist(fp)
!     FILE    *fp;
  {
      buf_T	*buf;
  #ifdef FEAT_WINDOWS
--- 5306,5312 ----
  }
  
      void
! write_viminfo_bufferlist(FILE *fp)
  {
      buf_T	*buf;
  #ifdef FEAT_WINDOWS
***************
*** 5401,5408 ****
   * Returns NULL when the buffer has a normal file name.
   */
      char_u *
! buf_spname(buf)
!     buf_T	*buf;
  {
  #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
--- 5365,5371 ----
   * Returns NULL when the buffer has a normal file name.
   */
      char_u *
! buf_spname(buf_T *buf)
  {
  #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
***************
*** 5444,5453 ****
   * If not found FAIL is returned.
   */
      int
! find_win_for_buf(buf, wp, tp)
!     buf_T     *buf;
!     win_T     **wp;
!     tabpage_T **tp;
  {
      FOR_ALL_TAB_WINDOWS(*tp, *wp)
  	if ((*wp)->w_buffer == buf)
--- 5407,5416 ----
   * If not found FAIL is returned.
   */
      int
! find_win_for_buf(
!     buf_T     *buf,
!     win_T     **wp,
!     tabpage_T **tp)
  {
      FOR_ALL_TAB_WINDOWS(*tp, *wp)
  	if ((*wp)->w_buffer == buf)
***************
*** 5463,5475 ****
   * Insert the sign into the signlist.
   */
      static void
! insert_sign(buf, prev, next, id, lnum, typenr)
!     buf_T	*buf;		/* buffer to store sign in */
!     signlist_T	*prev;		/* previous sign entry */
!     signlist_T	*next;		/* next sign entry */
!     int		id;		/* sign ID */
!     linenr_T	lnum;		/* line number which gets the mark */
!     int		typenr;		/* typenr of sign we are adding */
  {
      signlist_T	*newsign;
  
--- 5426,5438 ----
   * Insert the sign into the signlist.
   */
      static void
! insert_sign(
!     buf_T	*buf,		/* buffer to store sign in */
!     signlist_T	*prev,		/* previous sign entry */
!     signlist_T	*next,		/* next sign entry */
!     int		id,		/* sign ID */
!     linenr_T	lnum,		/* line number which gets the mark */
!     int		typenr)		/* typenr of sign we are adding */
  {
      signlist_T	*newsign;
  
***************
*** 5512,5522 ****
   * Add the sign into the signlist. Find the right spot to do it though.
   */
      void
! buf_addsign(buf, id, lnum, typenr)
!     buf_T	*buf;		/* buffer to store sign in */
!     int		id;		/* sign ID */
!     linenr_T	lnum;		/* line number which gets the mark */
!     int		typenr;		/* typenr of sign we are adding */
  {
      signlist_T	*sign;		/* a sign in the signlist */
      signlist_T	*prev;		/* the previous sign */
--- 5475,5485 ----
   * Add the sign into the signlist. Find the right spot to do it though.
   */
      void
! buf_addsign(
!     buf_T	*buf,		/* buffer to store sign in */
!     int		id,		/* sign ID */
!     linenr_T	lnum,		/* line number which gets the mark */
!     int		typenr)		/* typenr of sign we are adding */
  {
      signlist_T	*sign;		/* a sign in the signlist */
      signlist_T	*prev;		/* the previous sign */
***************
*** 5571,5580 ****
   * Returns the line number of the sign, or zero if the sign is not found.
   */
      linenr_T
! buf_change_sign_type(buf, markId, typenr)
!     buf_T	*buf;		/* buffer to store sign in */
!     int		markId;		/* sign ID */
!     int		typenr;		/* typenr of sign we are adding */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
--- 5534,5543 ----
   * Returns the line number of the sign, or zero if the sign is not found.
   */
      linenr_T
! buf_change_sign_type(
!     buf_T	*buf,		/* buffer to store sign in */
!     int		markId,		/* sign ID */
!     int		typenr)		/* typenr of sign we are adding */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
***************
*** 5591,5600 ****
  }
  
      int
! buf_getsigntype(buf, lnum, type)
!     buf_T	*buf;
!     linenr_T	lnum;
!     int		type;	/* SIGN_ICON, SIGN_TEXT, SIGN_ANY, SIGN_LINEHL */
  {
      signlist_T	*sign;		/* a sign in a b_signlist */
  
--- 5554,5563 ----
  }
  
      int
! buf_getsigntype(
!     buf_T	*buf,
!     linenr_T	lnum,
!     int		type)	/* SIGN_ICON, SIGN_TEXT, SIGN_ANY, SIGN_LINEHL */
  {
      signlist_T	*sign;		/* a sign in a b_signlist */
  
***************
*** 5615,5623 ****
  
  
      linenr_T
! buf_delsign(buf, id)
!     buf_T	*buf;		/* buffer sign is stored in */
!     int		id;		/* sign id */
  {
      signlist_T	**lastp;	/* pointer to pointer to current sign */
      signlist_T	*sign;		/* a sign in a b_signlist */
--- 5578,5586 ----
  
  
      linenr_T
! buf_delsign(
!     buf_T	*buf,		/* buffer sign is stored in */
!     int		id)		/* sign id */
  {
      signlist_T	**lastp;	/* pointer to pointer to current sign */
      signlist_T	*sign;		/* a sign in a b_signlist */
***************
*** 5662,5670 ****
   * get loaded.
   */
      int
! buf_findsign(buf, id)
!     buf_T	*buf;		/* buffer to store sign in */
!     int		id;		/* sign ID */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
--- 5625,5633 ----
   * get loaded.
   */
      int
! buf_findsign(
!     buf_T	*buf,		/* buffer to store sign in */
!     int		id)		/* sign ID */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
***************
*** 5676,5684 ****
  }
  
      int
! buf_findsign_id(buf, lnum)
!     buf_T	*buf;		/* buffer whose sign we are searching for */
!     linenr_T	lnum;		/* line number of sign */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
--- 5639,5647 ----
  }
  
      int
! buf_findsign_id(
!     buf_T	*buf,		/* buffer whose sign we are searching for */
!     linenr_T	lnum)		/* line number of sign */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
***************
*** 5693,5702 ****
  # if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
  /* see if a given type of sign exists on a specific line */
      int
! buf_findsigntype_id(buf, lnum, typenr)
!     buf_T	*buf;		/* buffer whose sign we are searching for */
!     linenr_T	lnum;		/* line number of sign */
!     int		typenr;		/* sign type number */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
--- 5656,5665 ----
  # if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
  /* see if a given type of sign exists on a specific line */
      int
! buf_findsigntype_id(
!     buf_T	*buf,		/* buffer whose sign we are searching for */
!     linenr_T	lnum,		/* line number of sign */
!     int		typenr)		/* sign type number */
  {
      signlist_T	*sign;		/* a sign in the signlist */
  
***************
*** 5711,5719 ****
  #  if defined(FEAT_SIGN_ICONS) || defined(PROTO)
  /* return the number of icons on the given line */
      int
! buf_signcount(buf, lnum)
!     buf_T	*buf;
!     linenr_T	lnum;
  {
      signlist_T	*sign;		/* a sign in the signlist */
      int		count = 0;
--- 5674,5680 ----
  #  if defined(FEAT_SIGN_ICONS) || defined(PROTO)
  /* return the number of icons on the given line */
      int
! buf_signcount(buf_T *buf, linenr_T lnum)
  {
      signlist_T	*sign;		/* a sign in the signlist */
      int		count = 0;
***************
*** 5733,5740 ****
   * Delete signs in buffer "buf".
   */
      void
! buf_delete_signs(buf)
!     buf_T	*buf;
  {
      signlist_T	*next;
  
--- 5694,5700 ----
   * Delete signs in buffer "buf".
   */
      void
! buf_delete_signs(buf_T *buf)
  {
      signlist_T	*next;
  
***************
*** 5758,5764 ****
   * Delete all signs in all buffers.
   */
      void
! buf_delete_all_signs()
  {
      buf_T	*buf;		/* buffer we are checking for signs */
  
--- 5718,5724 ----
   * Delete all signs in all buffers.
   */
      void
! buf_delete_all_signs(void)
  {
      buf_T	*buf;		/* buffer we are checking for signs */
  
***************
*** 5771,5778 ****
   * List placed signs for "rbuf".  If "rbuf" is NULL do it for all buffers.
   */
      void
! sign_list_placed(rbuf)
!     buf_T	*rbuf;
  {
      buf_T	*buf;
      signlist_T	*p;
--- 5731,5737 ----
   * List placed signs for "rbuf".  If "rbuf" is NULL do it for all buffers.
   */
      void
! sign_list_placed(buf_T *rbuf)
  {
      buf_T	*buf;
      signlist_T	*p;
***************
*** 5809,5819 ****
   * Adjust a placed sign for inserted/deleted lines.
   */
      void
! sign_mark_adjust(line1, line2, amount, amount_after)
!     linenr_T	line1;
!     linenr_T	line2;
!     long	amount;
!     long	amount_after;
  {
      signlist_T	*sign;		/* a sign in a b_signlist */
  
--- 5768,5778 ----
   * Adjust a placed sign for inserted/deleted lines.
   */
      void
! sign_mark_adjust(
!     linenr_T	line1,
!     linenr_T	line2,
!     long	amount,
!     long	amount_after)
  {
      signlist_T	*sign;		/* a sign in a b_signlist */
  
***************
*** 5836,5843 ****
   * Set 'buflisted' for curbuf to "on" and trigger autocommands if it changed.
   */
      void
! set_buflisted(on)
!     int		on;
  {
      if (on != curbuf->b_p_bl)
      {
--- 5795,5801 ----
   * Set 'buflisted' for curbuf to "on" and trigger autocommands if it changed.
   */
      void
! set_buflisted(int on)
  {
      if (on != curbuf->b_p_bl)
      {
***************
*** 5856,5863 ****
   * Return TRUE if it changed or this could not be checked.
   */
      int
! buf_contents_changed(buf)
!     buf_T	*buf;
  {
      buf_T	*newbuf;
      int		differ = TRUE;
--- 5814,5820 ----
   * Return TRUE if it changed or this could not be checked.
   */
      int
! buf_contents_changed(buf_T *buf)
  {
      buf_T	*newbuf;
      int		differ = TRUE;
***************
*** 5914,5922 ****
   * marks.
   */
      void
! wipe_buffer(buf, aucmd)
!     buf_T	*buf;
!     int		aucmd UNUSED;	    /* When TRUE trigger autocommands. */
  {
      if (buf->b_fnum == top_file_num - 1)
  	--top_file_num;
--- 5871,5879 ----
   * marks.
   */
      void
! wipe_buffer(
!     buf_T	*buf,
!     int		aucmd UNUSED)	    /* When TRUE trigger autocommands. */
  {
      if (buf->b_fnum == top_file_num - 1)
  	--top_file_num;
*** ../vim-7.4.1204/src/channel.c	2016-01-29 21:11:20.963061406 +0100
--- src/channel.c	2016-01-30 14:21:13.196203374 +0100
***************
*** 745,751 ****
   * Return a unique ID to be used in a message.
   */
      int
! channel_get_id()
  {
      static int next_id = 1;
  
--- 745,751 ----
   * Return a unique ID to be used in a message.
   */
      int
! channel_get_id(void)
  {
      static int next_id = 1;
  
*** ../vim-7.4.1204/src/charset.c	2016-01-29 22:03:43.473945909 +0100
--- src/charset.c	2016-01-30 14:26:13.133097328 +0100
***************
*** 68,82 ****
   * error, OK otherwise.
   */
      int
! init_chartab()
  {
      return buf_init_chartab(curbuf, TRUE);
  }
  
      int
! buf_init_chartab(buf, global)
!     buf_T	*buf;
!     int		global;		/* FALSE: only set buf->b_chartab[] */
  {
      int		c;
      int		c2;
--- 68,82 ----
   * error, OK otherwise.
   */
      int
! init_chartab(void)
  {
      return buf_init_chartab(curbuf, TRUE);
  }
  
      int
! buf_init_chartab(
!     buf_T	*buf,
!     int		global)		/* FALSE: only set buf->b_chartab[] */
  {
      int		c;
      int		c2;
***************
*** 313,321 ****
   * enough room, not all characters will be translated.
   */
      void
! trans_characters(buf, bufsize)
!     char_u	*buf;
!     int		bufsize;
  {
      int		len;		/* length of string needing translation */
      int		room;		/* room in buffer after string */
--- 313,321 ----
   * enough room, not all characters will be translated.
   */
      void
! trans_characters(
!     char_u	*buf,
!     int		bufsize)
  {
      int		len;		/* length of string needing translation */
      int		room;		/* room in buffer after string */
***************
*** 356,363 ****
   * printable chars.  Returns NULL when out of memory.
   */
      char_u *
! transstr(s)
!     char_u	*s;
  {
      char_u	*res;
      char_u	*p;
--- 356,362 ----
   * printable chars.  Returns NULL when out of memory.
   */
      char_u *
! transstr(char_u *s)
  {
      char_u	*res;
      char_u	*p;
***************
*** 434,444 ****
   * Otherwise puts the result in "buf[buflen]".
   */
      char_u *
! str_foldcase(str, orglen, buf, buflen)
!     char_u	*str;
!     int		orglen;
!     char_u	*buf;
!     int		buflen;
  {
      garray_T	ga;
      int		i;
--- 433,443 ----
   * Otherwise puts the result in "buf[buflen]".
   */
      char_u *
! str_foldcase(
!     char_u	*str,
!     int		orglen,
!     char_u	*buf,
!     int		buflen)
  {
      garray_T	ga;
      int		i;
***************
*** 552,559 ****
  static char_u	transchar_buf[7];
  
      char_u *
! transchar(c)
!     int		c;
  {
      int			i;
  
--- 551,557 ----
  static char_u	transchar_buf[7];
  
      char_u *
! transchar(int c)
  {
      int			i;
  
***************
*** 592,599 ****
   * for an illegal UTF-8 byte.
   */
      char_u *
! transchar_byte(c)
!     int		c;
  {
      if (enc_utf8 && c >= 0x80)
      {
--- 590,596 ----
   * for an illegal UTF-8 byte.
   */
      char_u *
! transchar_byte(int c)
  {
      if (enc_utf8 && c >= 0x80)
      {
***************
*** 610,618 ****
   * Does NOT work for multi-byte characters, c must be <= 255.
   */
      void
! transchar_nonprint(buf, c)
!     char_u	*buf;
!     int		c;
  {
      if (c == NL)
  	c = NUL;		/* we use newline in place of a NUL */
--- 607,613 ----
   * Does NOT work for multi-byte characters, c must be <= 255.
   */
      void
! transchar_nonprint(char_u *buf, int c)
  {
      if (c == NL)
  	c = NUL;		/* we use newline in place of a NUL */
***************
*** 679,687 ****
  }
  
      void
! transchar_hex(buf, c)
!     char_u	*buf;
!     int		c;
  {
      int		i = 0;
  
--- 674,680 ----
  }
  
      void
! transchar_hex(char_u *buf, int c)
  {
      int		i = 0;
  
***************
*** 705,712 ****
   * function key 1.
   */
      static unsigned
! nr2hex(c)
!     unsigned	c;
  {
      if ((c & 0xf) <= 9)
  	return (c & 0xf) + '0';
--- 698,704 ----
   * function key 1.
   */
      static unsigned
! nr2hex(unsigned c)
  {
      if ((c & 0xf) <= 9)
  	return (c & 0xf) + '0';
***************
*** 722,729 ****
   * cells depends on further bytes.
   */
      int
! byte2cells(b)
!     int		b;
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && b >= 0x80)
--- 714,720 ----
   * cells depends on further bytes.
   */
      int
! byte2cells(int b)
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && b >= 0x80)
***************
*** 738,745 ****
   * A TAB is counted as two cells: "^I" or four: "<09>".
   */
      int
! char2cells(c)
!     int		c;
  {
      if (IS_SPECIAL(c))
  	return char2cells(K_SECOND(c)) + 2;
--- 729,735 ----
   * A TAB is counted as two cells: "^I" or four: "<09>".
   */
      int
! char2cells(int c)
  {
      if (IS_SPECIAL(c))
  	return char2cells(K_SECOND(c)) + 2;
***************
*** 767,774 ****
   * A TAB is counted as two cells: "^I" or four: "<09>".
   */
      int
! ptr2cells(p)
!     char_u	*p;
  {
  #ifdef FEAT_MBYTE
      /* For UTF-8 we need to look at more bytes if the first byte is >= 0x80. */
--- 757,763 ----
   * A TAB is counted as two cells: "^I" or four: "<09>".
   */
      int
! ptr2cells(char_u *p)
  {
  #ifdef FEAT_MBYTE
      /* For UTF-8 we need to look at more bytes if the first byte is >= 0x80. */
***************
*** 784,791 ****
   * counting TABs as two characters: "^I".
   */
      int
! vim_strsize(s)
!     char_u	*s;
  {
      return vim_strnsize(s, (int)MAXCOL);
  }
--- 773,779 ----
   * counting TABs as two characters: "^I".
   */
      int
! vim_strsize(char_u *s)
  {
      return vim_strnsize(s, (int)MAXCOL);
  }
***************
*** 795,803 ****
   * screen, counting TABs as two characters: "^I".
   */
      int
! vim_strnsize(s, len)
!     char_u	*s;
!     int		len;
  {
      int		size = 0;
  
--- 783,789 ----
   * screen, counting TABs as two characters: "^I".
   */
      int
! vim_strnsize(char_u *s, int len)
  {
      int		size = 0;
  
***************
*** 839,847 ****
  #if defined(FEAT_VREPLACE) || defined(FEAT_EX_EXTRA) || defined(FEAT_GUI) \
  	|| defined(FEAT_VIRTUALEDIT) || defined(PROTO)
      int
! chartabsize(p, col)
!     char_u	*p;
!     colnr_T	col;
  {
      RET_WIN_BUF_CHARTABSIZE(curwin, curbuf, p, col)
  }
--- 825,831 ----
  #if defined(FEAT_VREPLACE) || defined(FEAT_EX_EXTRA) || defined(FEAT_GUI) \
  	|| defined(FEAT_VIRTUALEDIT) || defined(PROTO)
      int
! chartabsize(char_u *p, colnr_T col)
  {
      RET_WIN_BUF_CHARTABSIZE(curwin, curbuf, p, col)
  }
***************
*** 849,858 ****
  
  #ifdef FEAT_LINEBREAK
      static int
! win_chartabsize(wp, p, col)
!     win_T	*wp;
!     char_u	*p;
!     colnr_T	col;
  {
      RET_WIN_BUF_CHARTABSIZE(wp, wp->w_buffer, p, col)
  }
--- 833,839 ----
  
  #ifdef FEAT_LINEBREAK
      static int
! win_chartabsize(win_T *wp, char_u *p, colnr_T col)
  {
      RET_WIN_BUF_CHARTABSIZE(wp, wp->w_buffer, p, col)
  }
***************
*** 863,870 ****
   * taking into account the size of a tab.
   */
      int
! linetabsize(s)
!     char_u	*s;
  {
      return linetabsize_col(0, s);
  }
--- 844,850 ----
   * taking into account the size of a tab.
   */
      int
! linetabsize(char_u *s)
  {
      return linetabsize_col(0, s);
  }
***************
*** 873,881 ****
   * Like linetabsize(), but starting at column "startcol".
   */
      int
! linetabsize_col(startcol, s)
!     int		startcol;
!     char_u	*s;
  {
      colnr_T	col = startcol;
      char_u	*line = s; /* pointer to start of line, for breakindent */
--- 853,859 ----
   * Like linetabsize(), but starting at column "startcol".
   */
      int
! linetabsize_col(int startcol, char_u *s)
  {
      colnr_T	col = startcol;
      char_u	*line = s; /* pointer to start of line, for breakindent */
***************
*** 889,898 ****
   * Like linetabsize(), but for a given window instead of the current one.
   */
      int
! win_linetabsize(wp, line, len)
!     win_T	*wp;
!     char_u	*line;
!     colnr_T	len;
  {
      colnr_T	col = 0;
      char_u	*s;
--- 867,873 ----
   * Like linetabsize(), but for a given window instead of the current one.
   */
      int
! win_linetabsize(win_T *wp, char_u *line, colnr_T len)
  {
      colnr_T	col = 0;
      char_u	*s;
***************
*** 908,915 ****
   * Letters and characters from the 'isident' option.
   */
      int
! vim_isIDc(c)
!     int c;
  {
      return (c > 0 && c < 0x100 && (g_chartab[c] & CT_ID_CHAR));
  }
--- 883,889 ----
   * Letters and characters from the 'isident' option.
   */
      int
! vim_isIDc(int c)
  {
      return (c > 0 && c < 0x100 && (g_chartab[c] & CT_ID_CHAR));
  }
***************
*** 920,935 ****
   * For multi-byte characters mb_get_class() is used (builtin rules).
   */
      int
! vim_iswordc(c)
!     int c;
  {
      return vim_iswordc_buf(c, curbuf);
  }
  
      int
! vim_iswordc_buf(c, buf)
!     int		c;
!     buf_T	*buf;
  {
  #ifdef FEAT_MBYTE
      if (c >= 0x100)
--- 894,906 ----
   * For multi-byte characters mb_get_class() is used (builtin rules).
   */
      int
! vim_iswordc(int c)
  {
      return vim_iswordc_buf(c, curbuf);
  }
  
      int
! vim_iswordc_buf(int c, buf_T *buf)
  {
  #ifdef FEAT_MBYTE
      if (c >= 0x100)
***************
*** 947,954 ****
   * Just like vim_iswordc() but uses a pointer to the (multi-byte) character.
   */
      int
! vim_iswordp(p)
!     char_u *p;
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte && MB_BYTE2LEN(*p) > 1)
--- 918,924 ----
   * Just like vim_iswordc() but uses a pointer to the (multi-byte) character.
   */
      int
! vim_iswordp(char_u *p)
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte && MB_BYTE2LEN(*p) > 1)
***************
*** 958,966 ****
  }
  
      int
! vim_iswordp_buf(p, buf)
!     char_u	*p;
!     buf_T	*buf;
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte && MB_BYTE2LEN(*p) > 1)
--- 928,934 ----
  }
  
      int
! vim_iswordp_buf(char_u *p, buf_T *buf)
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte && MB_BYTE2LEN(*p) > 1)
***************
*** 974,981 ****
   * Assume characters above 0x100 are valid (multi-byte).
   */
      int
! vim_isfilec(c)
!     int	c;
  {
      return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_FNAME_CHAR)));
  }
--- 942,948 ----
   * Assume characters above 0x100 are valid (multi-byte).
   */
      int
! vim_isfilec(int c)
  {
      return (c >= 0x100 || (c > 0 && (g_chartab[c] & CT_FNAME_CHAR)));
  }
***************
*** 987,994 ****
   * returns false.
   */
      int
! vim_isfilec_or_wc(c)
!     int c;
  {
      char_u buf[2];
  
--- 954,960 ----
   * returns false.
   */
      int
! vim_isfilec_or_wc(int c)
  {
      char_u buf[2];
  
***************
*** 1003,1010 ****
   * Unicode.
   */
      int
! vim_isprintc(c)
!     int c;
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && c >= 0x100)
--- 969,975 ----
   * Unicode.
   */
      int
! vim_isprintc(int c)
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && c >= 0x100)
***************
*** 1018,1025 ****
   * byte of a double-byte character.
   */
      int
! vim_isprintc_strict(c)
!     int	c;
  {
  #ifdef FEAT_MBYTE
      if (enc_dbcs != 0 && c < 0x100 && MB_BYTE2LEN(c) > 1)
--- 983,989 ----
   * byte of a double-byte character.
   */
      int
! vim_isprintc_strict(int c)
  {
  #ifdef FEAT_MBYTE
      if (enc_dbcs != 0 && c < 0x100 && MB_BYTE2LEN(c) > 1)
***************
*** 1034,1043 ****
   * like chartabsize(), but also check for line breaks on the screen
   */
      int
! lbr_chartabsize(line, s, col)
!     char_u		*line UNUSED; /* start of the line */
!     unsigned char	*s;
!     colnr_T		col;
  {
  #ifdef FEAT_LINEBREAK
      if (!curwin->w_p_lbr && *p_sbr == NUL && !curwin->w_p_bri)
--- 998,1007 ----
   * like chartabsize(), but also check for line breaks on the screen
   */
      int
! lbr_chartabsize(
!     char_u		*line UNUSED, /* start of the line */
!     unsigned char	*s,
!     colnr_T		col)
  {
  #ifdef FEAT_LINEBREAK
      if (!curwin->w_p_lbr && *p_sbr == NUL && !curwin->w_p_bri)
***************
*** 1058,1067 ****
   * Call lbr_chartabsize() and advance the pointer.
   */
      int
! lbr_chartabsize_adv(line, s, col)
!     char_u	*line; /* start of the line */
!     char_u	**s;
!     colnr_T	col;
  {
      int		retval;
  
--- 1022,1031 ----
   * Call lbr_chartabsize() and advance the pointer.
   */
      int
! lbr_chartabsize_adv(
!     char_u	*line, /* start of the line */
!     char_u	**s,
!     colnr_T	col)
  {
      int		retval;
  
***************
*** 1078,1089 ****
   * value, init to 0 before calling.
   */
      int
! win_lbr_chartabsize(wp, line, s, col, headp)
!     win_T	*wp;
!     char_u	*line UNUSED; /* start of the line */
!     char_u	*s;
!     colnr_T	col;
!     int		*headp UNUSED;
  {
  #ifdef FEAT_LINEBREAK
      int		c;
--- 1042,1053 ----
   * value, init to 0 before calling.
   */
      int
! win_lbr_chartabsize(
!     win_T	*wp,
!     char_u	*line UNUSED, /* start of the line */
!     char_u	*s,
!     colnr_T	col,
!     int		*headp UNUSED)
  {
  #ifdef FEAT_LINEBREAK
      int		c;
***************
*** 1254,1264 ****
   * doesn't fit at the end of the screen line.
   */
      static int
! win_nolbr_chartabsize(wp, s, col, headp)
!     win_T	*wp;
!     char_u	*s;
!     colnr_T	col;
!     int		*headp;
  {
      int		n;
  
--- 1218,1228 ----
   * doesn't fit at the end of the screen line.
   */
      static int
! win_nolbr_chartabsize(
!     win_T	*wp,
!     char_u	*s,
!     colnr_T	col,
!     int		*headp)
  {
      int		n;
  
***************
*** 1284,1292 ****
   * "wp".
   */
      int
! in_win_border(wp, vcol)
!     win_T	*wp;
!     colnr_T	vcol;
  {
      int		width1;		/* width of first line (after line number) */
      int		width2;		/* width of further lines */
--- 1248,1254 ----
   * "wp".
   */
      int
! in_win_border(win_T *wp, colnr_T vcol)
  {
      int		width1;		/* width of first line (after line number) */
      int		width2;		/* width of further lines */
***************
*** 1316,1327 ****
   * This is used very often, keep it fast!
   */
      void
! getvcol(wp, pos, start, cursor, end)
!     win_T	*wp;
!     pos_T	*pos;
!     colnr_T	*start;
!     colnr_T	*cursor;
!     colnr_T	*end;
  {
      colnr_T	vcol;
      char_u	*ptr;		/* points to current char */
--- 1278,1289 ----
   * This is used very often, keep it fast!
   */
      void
! getvcol(
!     win_T	*wp,
!     pos_T	*pos,
!     colnr_T	*start,
!     colnr_T	*cursor,
!     colnr_T	*end)
  {
      colnr_T	vcol;
      char_u	*ptr;		/* points to current char */
***************
*** 1446,1453 ****
   * Get virtual cursor column in the current window, pretending 'list' is off.
   */
      colnr_T
! getvcol_nolist(posp)
!     pos_T	*posp;
  {
      int		list_save = curwin->w_p_list;
      colnr_T	vcol;
--- 1408,1414 ----
   * Get virtual cursor column in the current window, pretending 'list' is off.
   */
      colnr_T
! getvcol_nolist(pos_T *posp)
  {
      int		list_save = curwin->w_p_list;
      colnr_T	vcol;
***************
*** 1463,1474 ****
   * Get virtual column in virtual mode.
   */
      void
! getvvcol(wp, pos, start, cursor, end)
!     win_T	*wp;
!     pos_T	*pos;
!     colnr_T	*start;
!     colnr_T	*cursor;
!     colnr_T	*end;
  {
      colnr_T	col;
      colnr_T	coladd;
--- 1424,1435 ----
   * Get virtual column in virtual mode.
   */
      void
! getvvcol(
!     win_T	*wp,
!     pos_T	*pos,
!     colnr_T	*start,
!     colnr_T	*cursor,
!     colnr_T	*end)
  {
      colnr_T	col;
      colnr_T	coladd;
***************
*** 1519,1528 ****
   * Used for Visual block mode.
   */
      void
! getvcols(wp, pos1, pos2, left, right)
!     win_T	*wp;
!     pos_T	*pos1, *pos2;
!     colnr_T	*left, *right;
  {
      colnr_T	from1, from2, to1, to2;
  
--- 1480,1491 ----
   * Used for Visual block mode.
   */
      void
! getvcols(
!     win_T	*wp,
!     pos_T	*pos1,
!     pos_T	*pos2,
!     colnr_T	*left,
!     colnr_T	*right)
  {
      colnr_T	from1, from2, to1, to2;
  
***************
*** 1555,1562 ****
   * skipwhite: skip over ' ' and '\t'.
   */
      char_u *
! skipwhite(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1518,1524 ----
   * skipwhite: skip over ' ' and '\t'.
   */
      char_u *
! skipwhite(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1569,1576 ****
   * skip over digits
   */
      char_u *
! skipdigits(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1531,1537 ----
   * skip over digits
   */
      char_u *
! skipdigits(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1584,1591 ****
   * skip over binary digits
   */
      char_u *
! skipbin(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1545,1551 ----
   * skip over binary digits
   */
      char_u *
! skipbin(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1598,1605 ****
   * skip over digits and hex characters
   */
      char_u *
! skiphex(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1558,1564 ----
   * skip over digits and hex characters
   */
      char_u *
! skiphex(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1614,1621 ****
   * skip to bin digit (or NUL after the string)
   */
      char_u *
! skiptobin(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1573,1579 ----
   * skip to bin digit (or NUL after the string)
   */
      char_u *
! skiptobin(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1628,1635 ****
   * skip to digit (or NUL after the string)
   */
      char_u *
! skiptodigit(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1586,1592 ----
   * skip to digit (or NUL after the string)
   */
      char_u *
! skiptodigit(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1642,1649 ****
   * skip to hex character (or NUL after the string)
   */
      char_u *
! skiptohex(q)
!     char_u	*q;
  {
      char_u	*p = q;
  
--- 1599,1605 ----
   * skip to hex character (or NUL after the string)
   */
      char_u *
! skiptohex(char_u *q)
  {
      char_u	*p = q;
  
***************
*** 1660,1667 ****
   * Use the VIM_ISDIGIT() macro for simple arguments.
   */
      int
! vim_isdigit(c)
!     int		c;
  {
      return (c >= '0' && c <= '9');
  }
--- 1616,1622 ----
   * Use the VIM_ISDIGIT() macro for simple arguments.
   */
      int
! vim_isdigit(int c)
  {
      return (c >= '0' && c <= '9');
  }
***************
*** 1672,1679 ****
   * superscript 1 to be a digit.
   */
      int
! vim_isxdigit(c)
!     int		c;
  {
      return (c >= '0' && c <= '9')
  	|| (c >= 'a' && c <= 'f')
--- 1627,1633 ----
   * superscript 1 to be a digit.
   */
      int
! vim_isxdigit(int c)
  {
      return (c >= '0' && c <= '9')
  	|| (c >= 'a' && c <= 'f')
***************
*** 1685,1692 ****
   * characters > 0x100.
   */
      int
! vim_isbdigit(c)
!     int		c;
  {
      return (c == '0' || c == '1');
  }
--- 1639,1645 ----
   * characters > 0x100.
   */
      int
! vim_isbdigit(int c)
  {
      return (c == '0' || c == '1');
  }
***************
*** 1706,1713 ****
  static char_u latin1lower[257] = "                                 !\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xd7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
  
      int
! vim_islower(c)
!     int	    c;
  {
      if (c <= '@')
  	return FALSE;
--- 1659,1665 ----
  static char_u latin1lower[257] = "                                 !\"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xd7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
  
      int
! vim_islower(int c)
  {
      if (c <= '@')
  	return FALSE;
***************
*** 1731,1738 ****
  }
  
      int
! vim_isupper(c)
!     int	    c;
  {
      if (c <= '@')
  	return FALSE;
--- 1683,1689 ----
  }
  
      int
! vim_isupper(int c)
  {
      if (c <= '@')
  	return FALSE;
***************
*** 1756,1763 ****
  }
  
      int
! vim_toupper(c)
!     int	    c;
  {
      if (c <= '@')
  	return c;
--- 1707,1713 ----
  }
  
      int
! vim_toupper(int c)
  {
      if (c <= '@')
  	return c;
***************
*** 1781,1788 ****
  }
  
      int
! vim_tolower(c)
!     int	    c;
  {
      if (c <= '@')
  	return c;
--- 1731,1737 ----
  }
  
      int
! vim_tolower(int c)
  {
      if (c <= '@')
  	return c;
***************
*** 1810,1817 ****
   * skiptowhite: skip over text until ' ' or '\t' or NUL.
   */
      char_u *
! skiptowhite(p)
!     char_u	*p;
  {
      while (*p != ' ' && *p != '\t' && *p != NUL)
  	++p;
--- 1759,1765 ----
   * skiptowhite: skip over text until ' ' or '\t' or NUL.
   */
      char_u *
! skiptowhite(char_u *p)
  {
      while (*p != ' ' && *p != '\t' && *p != NUL)
  	++p;
***************
*** 1824,1831 ****
   * skiptowhite_esc: Like skiptowhite(), but also skip escaped chars
   */
      char_u *
! skiptowhite_esc(p)
!     char_u	*p;
  {
      while (*p != ' ' && *p != '\t' && *p != NUL)
      {
--- 1772,1778 ----
   * skiptowhite_esc: Like skiptowhite(), but also skip escaped chars
   */
      char_u *
! skiptowhite_esc(char_u *p)
  {
      while (*p != ' ' && *p != '\t' && *p != NUL)
      {
***************
*** 1842,1849 ****
   * Note: the argument is a pointer to a char_u pointer!
   */
      long
! getdigits(pp)
!     char_u **pp;
  {
      char_u	*p;
      long	retval;
--- 1789,1795 ----
   * Note: the argument is a pointer to a char_u pointer!
   */
      long
! getdigits(char_u **pp)
  {
      char_u	*p;
      long	retval;
***************
*** 1861,1868 ****
   * Return TRUE if "lbuf" is empty or only contains blanks.
   */
      int
! vim_isblankline(lbuf)
!     char_u	*lbuf;
  {
      char_u	*p;
  
--- 1807,1813 ----
   * Return TRUE if "lbuf" is empty or only contains blanks.
   */
      int
! vim_isblankline(char_u *lbuf)
  {
      char_u	*p;
  
***************
*** 1890,1905 ****
   * If maxlen > 0, check at a maximum maxlen chars
   */
      void
! vim_str2nr(start, prep, len, what, nptr, unptr, maxlen)
!     char_u		*start;
!     int			*prep;	    /* return: type of number 0 = decimal, 'x'
  				       or 'X' is hex, '0' = octal, 'b' or 'B'
  				       is bin */
!     int			*len;	    /* return: detected length of number */
!     int			what;	    /* what numbers to recognize */
!     long		*nptr;	    /* return: signed result */
!     unsigned long	*unptr;	    /* return: unsigned result */
!     int			maxlen;     /* max length of string to check */
  {
      char_u	    *ptr = start;
      int		    pre = 0;		/* default is decimal */
--- 1835,1850 ----
   * If maxlen > 0, check at a maximum maxlen chars
   */
      void
! vim_str2nr(
!     char_u		*start,
!     int			*prep,	    /* return: type of number 0 = decimal, 'x'
  				       or 'X' is hex, '0' = octal, 'b' or 'B'
  				       is bin */
!     int			*len,	    /* return: detected length of number */
!     int			what,	    /* what numbers to recognize */
!     long		*nptr,	    /* return: signed result */
!     unsigned long	*unptr,	    /* return: unsigned result */
!     int			maxlen)     /* max length of string to check */
  {
      char_u	    *ptr = start;
      int		    pre = 0;		/* default is decimal */
***************
*** 2024,2031 ****
   * Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.
   */
      int
! hex2nr(c)
!     int		c;
  {
      if (c >= 'a' && c <= 'f')
  	return c - 'a' + 10;
--- 1969,1975 ----
   * Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.
   */
      int
! hex2nr(int c)
  {
      if (c >= 'a' && c <= 'f')
  	return c - 'a' + 10;
***************
*** 2041,2048 ****
   * Return -1 if one of the characters is not hex.
   */
      int
! hexhex2nr(p)
!     char_u	*p;
  {
      if (!vim_isxdigit(p[0]) || !vim_isxdigit(p[1]))
  	return -1;
--- 1985,1991 ----
   * Return -1 if one of the characters is not hex.
   */
      int
! hexhex2nr(char_u *p)
  {
      if (!vim_isxdigit(p[0]) || !vim_isxdigit(p[1]))
  	return -1;
***************
*** 2064,2071 ****
   * characters.
   */
      int
! rem_backslash(str)
!     char_u  *str;
  {
  #ifdef BACKSLASH_IN_FILENAME
      return (str[0] == '\\'
--- 2007,2013 ----
   * characters.
   */
      int
! rem_backslash(char_u *str)
  {
  #ifdef BACKSLASH_IN_FILENAME
      return (str[0] == '\\'
***************
*** 2088,2095 ****
   * is not a normal file character.
   */
      void
! backslash_halve(p)
!     char_u	*p;
  {
      for ( ; *p; ++p)
  	if (rem_backslash(p))
--- 2030,2036 ----
   * is not a normal file character.
   */
      void
! backslash_halve(char_u *p)
  {
      for ( ; *p; ++p)
  	if (rem_backslash(p))
***************
*** 2100,2107 ****
   * backslash_halve() plus save the result in allocated memory.
   */
      char_u *
! backslash_halve_save(p)
!     char_u	*p;
  {
      char_u	*res;
  
--- 2041,2047 ----
   * backslash_halve() plus save the result in allocated memory.
   */
      char_u *
! backslash_halve_save(char_u *p)
  {
      char_u	*res;
  
***************
*** 2159,2167 ****
   * wanting 7-bit ASCII characters out the other end.
   */
      void
! ebcdic2ascii(buffer, len)
!     char_u	*buffer;
!     int		len;
  {
      int		i;
  
--- 2099,2105 ----
   * wanting 7-bit ASCII characters out the other end.
   */
      void
! ebcdic2ascii(char_u *buffer, int len)
  {
      int		i;
  
*** ../vim-7.4.1204/src/crypt.c	2014-11-12 15:15:34.971882203 +0100
--- src/crypt.c	2016-01-30 14:28:15.531829592 +0100
***************
*** 130,137 ****
   * 2 for "blowfish2".
   */
      int
! crypt_method_nr_from_name(name)
!     char_u  *name;
  {
      int i;
  
--- 130,136 ----
   * 2 for "blowfish2".
   */
      int
! crypt_method_nr_from_name(char_u *name)
  {
      int i;
  
***************
*** 147,155 ****
   * Returns -1 when no encryption used.
   */
      int
! crypt_method_nr_from_magic(ptr, len)
!     char  *ptr;
!     int   len;
  {
      int i;
  
--- 146,152 ----
   * Returns -1 when no encryption used.
   */
      int
! crypt_method_nr_from_magic(char *ptr, int len)
  {
      int i;
  
***************
*** 171,178 ****
   * Return TRUE if the crypt method for "method_nr" can be done in-place.
   */
      int
! crypt_works_inplace(state)
!     cryptstate_T *state;
  {
      return cryptmethods[state->method_nr].works_inplace;
  }
--- 168,174 ----
   * Return TRUE if the crypt method for "method_nr" can be done in-place.
   */
      int
! crypt_works_inplace(cryptstate_T *state)
  {
      return cryptmethods[state->method_nr].works_inplace;
  }
***************
*** 181,188 ****
   * Get the crypt method for buffer "buf" as a number.
   */
      int
! crypt_get_method_nr(buf)
!     buf_T *buf;
  {
      return crypt_method_nr_from_name(*buf->b_p_cm == NUL ? p_cm : buf->b_p_cm);
  }
--- 177,183 ----
   * Get the crypt method for buffer "buf" as a number.
   */
      int
! crypt_get_method_nr(buf_T *buf)
  {
      return crypt_method_nr_from_name(*buf->b_p_cm == NUL ? p_cm : buf->b_p_cm);
  }
***************
*** 192,199 ****
   * whole undo file, not only the text.
   */
      int
! crypt_whole_undofile(method_nr)
!     int method_nr;
  {
      return cryptmethods[method_nr].whole_undofile;
  }
--- 187,193 ----
   * whole undo file, not only the text.
   */
      int
! crypt_whole_undofile(int method_nr)
  {
      return cryptmethods[method_nr].whole_undofile;
  }
***************
*** 202,209 ****
   * Get crypt method specifc length of the file header in bytes.
   */
      int
! crypt_get_header_len(method_nr)
!     int method_nr;
  {
      return CRYPT_MAGIC_LEN
  	+ cryptmethods[method_nr].salt_len
--- 196,202 ----
   * Get crypt method specifc length of the file header in bytes.
   */
      int
! crypt_get_header_len(int method_nr)
  {
      return CRYPT_MAGIC_LEN
  	+ cryptmethods[method_nr].salt_len
***************
*** 215,223 ****
   * returned by crypt_method_nr_from_name().
   */
      void
! crypt_set_cm_option(buf, method_nr)
!     buf_T   *buf;
!     int	    method_nr;
  {
      free_string_option(buf->b_p_cm);
      buf->b_p_cm = vim_strsave((char_u *)cryptmethods[method_nr].name);
--- 208,214 ----
   * returned by crypt_method_nr_from_name().
   */
      void
! crypt_set_cm_option(buf_T *buf, int method_nr)
  {
      free_string_option(buf->b_p_cm);
      buf->b_p_cm = vim_strsave((char_u *)cryptmethods[method_nr].name);
***************
*** 228,234 ****
   * return OK/FAIL.
   */
      int
! crypt_self_test()
  {
      int method_nr = crypt_get_method_nr(curbuf);
  
--- 219,225 ----
   * return OK/FAIL.
   */
      int
! crypt_self_test(void)
  {
      int method_nr = crypt_get_method_nr(curbuf);
  
***************
*** 241,253 ****
   * Allocate a crypt state and initialize it.
   */
      cryptstate_T *
! crypt_create(method_nr, key, salt, salt_len, seed, seed_len)
!     int		method_nr;
!     char_u	*key;
!     char_u	*salt;
!     int		salt_len;
!     char_u	*seed;
!     int		seed_len;
  {
      cryptstate_T *state = (cryptstate_T *)alloc((int)sizeof(cryptstate_T));
  
--- 232,244 ----
   * Allocate a crypt state and initialize it.
   */
      cryptstate_T *
! crypt_create(
!     int		method_nr,
!     char_u	*key,
!     char_u	*salt,
!     int		salt_len,
!     char_u	*seed,
!     int		seed_len)
  {
      cryptstate_T *state = (cryptstate_T *)alloc((int)sizeof(cryptstate_T));
  
***************
*** 262,271 ****
   * crypt_get_header_len() returns for "method_nr".
   */
      cryptstate_T *
! crypt_create_from_header(method_nr, key, header)
!     int		method_nr;
!     char_u	*key;
!     char_u	*header;
  {
      char_u	*salt = NULL;
      char_u	*seed = NULL;
--- 253,262 ----
   * crypt_get_header_len() returns for "method_nr".
   */
      cryptstate_T *
! crypt_create_from_header(
!     int		method_nr,
!     char_u	*key,
!     char_u	*header)
  {
      char_u	*salt = NULL;
      char_u	*seed = NULL;
***************
*** 285,293 ****
   * Return an allocated cryptstate_T or NULL on error.
   */
      cryptstate_T *
! crypt_create_from_file(fp, key)
!     FILE    *fp;
!     char_u  *key;
  {
      int		method_nr;
      int		header_len;
--- 276,282 ----
   * Return an allocated cryptstate_T or NULL on error.
   */
      cryptstate_T *
! crypt_create_from_file(FILE *fp, char_u *key)
  {
      int		method_nr;
      int		header_len;
***************
*** 326,336 ****
   * Returns the state or NULL on failure.
   */
      cryptstate_T *
! crypt_create_for_writing(method_nr, key, header, header_len)
!     int	    method_nr;
!     char_u  *key;
!     char_u  **header;
!     int	    *header_len;
  {
      int	    len = crypt_get_header_len(method_nr);
      char_u  *salt = NULL;
--- 315,325 ----
   * Returns the state or NULL on failure.
   */
      cryptstate_T *
! crypt_create_for_writing(
!     int	    method_nr,
!     char_u  *key,
!     char_u  **header,
!     int	    *header_len)
  {
      int	    len = crypt_get_header_len(method_nr);
      char_u  *salt = NULL;
***************
*** 371,378 ****
   * Free the crypt state.
   */
      void
! crypt_free_state(state)
!     cryptstate_T	*state;
  {
      vim_free(state->method_state);
      vim_free(state);
--- 360,366 ----
   * Free the crypt state.
   */
      void
! crypt_free_state(cryptstate_T *state)
  {
      vim_free(state->method_state);
      vim_free(state);
***************
*** 384,394 ****
   * Return number of bytes in "newptr", 0 for need more or -1 on error.
   */
      long
! crypt_encode_alloc(state, from, len, newptr)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	**newptr;
  {
      cryptmethod_T *method = &cryptmethods[state->method_nr];
  
--- 372,382 ----
   * Return number of bytes in "newptr", 0 for need more or -1 on error.
   */
      long
! crypt_encode_alloc(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	**newptr)
  {
      cryptmethod_T *method = &cryptmethods[state->method_nr];
  
***************
*** 412,422 ****
   * Return number of bytes in "newptr", 0 for need more or -1 on error.
   */
      long
! crypt_decode_alloc(state, ptr, len, newptr)
!     cryptstate_T *state;
!     char_u	*ptr;
!     long	len;
!     char_u      **newptr;
  {
      cryptmethod_T *method = &cryptmethods[state->method_nr];
  
--- 400,410 ----
   * Return number of bytes in "newptr", 0 for need more or -1 on error.
   */
      long
! crypt_decode_alloc(
!     cryptstate_T *state,
!     char_u	*ptr,
!     long	len,
!     char_u      **newptr)
  {
      cryptmethod_T *method = &cryptmethods[state->method_nr];
  
***************
*** 439,449 ****
   * Encrypting "from[len]" into "to[len]".
   */
      void
! crypt_encode(state, from, len, to)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	*to;
  {
      cryptmethods[state->method_nr].encode_fn(state, from, len, to);
  }
--- 427,437 ----
   * Encrypting "from[len]" into "to[len]".
   */
      void
! crypt_encode(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	*to)
  {
      cryptmethods[state->method_nr].encode_fn(state, from, len, to);
  }
***************
*** 452,462 ****
   * decrypting "from[len]" into "to[len]".
   */
      void
! crypt_decode(state, from, len, to)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	*to;
  {
      cryptmethods[state->method_nr].decode_fn(state, from, len, to);
  }
--- 440,450 ----
   * decrypting "from[len]" into "to[len]".
   */
      void
! crypt_decode(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	*to)
  {
      cryptmethods[state->method_nr].decode_fn(state, from, len, to);
  }
***************
*** 465,474 ****
   * Simple inplace encryption, modifies "buf[len]" in place.
   */
      void
! crypt_encode_inplace(state, buf, len)
!     cryptstate_T *state;
!     char_u	*buf;
!     size_t	len;
  {
      cryptmethods[state->method_nr].encode_inplace_fn(state, buf, len, buf);
  }
--- 453,462 ----
   * Simple inplace encryption, modifies "buf[len]" in place.
   */
      void
! crypt_encode_inplace(
!     cryptstate_T *state,
!     char_u	*buf,
!     size_t	len)
  {
      cryptmethods[state->method_nr].encode_inplace_fn(state, buf, len, buf);
  }
***************
*** 477,486 ****
   * Simple inplace decryption, modifies "buf[len]" in place.
   */
      void
! crypt_decode_inplace(state, buf, len)
!     cryptstate_T *state;
!     char_u	*buf;
!     size_t	len;
  {
      cryptmethods[state->method_nr].decode_inplace_fn(state, buf, len, buf);
  }
--- 465,474 ----
   * Simple inplace decryption, modifies "buf[len]" in place.
   */
      void
! crypt_decode_inplace(
!     cryptstate_T *state,
!     char_u	*buf,
!     size_t	len)
  {
      cryptmethods[state->method_nr].decode_inplace_fn(state, buf, len, buf);
  }
***************
*** 490,497 ****
   * in memory anywhere.
   */
      void
! crypt_free_key(key)
!     char_u *key;
  {
      char_u *p;
  
--- 478,484 ----
   * in memory anywhere.
   */
      void
! crypt_free_key(char_u *key)
  {
      char_u *p;
  
***************
*** 507,514 ****
   * Check the crypt method and give a warning if it's outdated.
   */
      void
! crypt_check_method(method)
!     int method;
  {
      if (method < CRYPT_M_BF2)
      {
--- 494,500 ----
   * Check the crypt method and give a warning if it's outdated.
   */
      void
! crypt_check_method(int method)
  {
      if (method < CRYPT_M_BF2)
      {
***************
*** 518,524 ****
  }
  
      void
! crypt_check_current_method()
  {
      crypt_check_method(crypt_get_method_nr(curbuf));
  }
--- 504,510 ----
  }
  
      void
! crypt_check_current_method(void)
  {
      crypt_check_method(crypt_get_method_nr(curbuf));
  }
***************
*** 531,539 ****
   * Returns NULL on failure.
   */
      char_u *
! crypt_get_key(store, twice)
!     int		store;
!     int		twice;	    /* Ask for the key twice. */
  {
      char_u	*p1, *p2 = NULL;
      int		round;
--- 517,525 ----
   * Returns NULL on failure.
   */
      char_u *
! crypt_get_key(
!     int		store,
!     int		twice)	    /* Ask for the key twice. */
  {
      char_u	*p1, *p2 = NULL;
      int		round;
***************
*** 589,596 ****
   * Append a message to IObuff for the encryption/decryption method being used.
   */
      void
! crypt_append_msg(buf)
!     buf_T *buf;
  {
      if (crypt_get_method_nr(buf) == 0)
  	STRCAT(IObuff, _("[crypted]"));
--- 575,582 ----
   * Append a message to IObuff for the encryption/decryption method being used.
   */
      void
! crypt_append_msg(
!     buf_T *buf)
  {
      if (crypt_get_method_nr(buf) == 0)
  	STRCAT(IObuff, _("[crypted]"));
*** ../vim-7.4.1204/src/crypt_zip.c	2016-01-29 22:03:43.473945909 +0100
--- src/crypt_zip.c	2016-01-30 14:28:48.475488357 +0100
***************
*** 44,50 ****
   * Fill the CRC table, if not done already.
   */
      static void
! make_crc_tab()
  {
      u32_T	s, t, v;
      static int	done = FALSE;
--- 44,50 ----
   * Fill the CRC table, if not done already.
   */
      static void
! make_crc_tab(void)
  {
      u32_T	s, t, v;
      static int	done = FALSE;
***************
*** 85,97 ****
   * Initialize for encryption/decryption.
   */
      void
! crypt_zip_init(state, key, salt, salt_len, seed, seed_len)
!     cryptstate_T    *state;
!     char_u	    *key;
!     char_u	    *salt UNUSED;
!     int		    salt_len UNUSED;
!     char_u	    *seed UNUSED;
!     int		    seed_len UNUSED;
  {
      char_u	*p;
      zip_state_T	*zs;
--- 85,97 ----
   * Initialize for encryption/decryption.
   */
      void
! crypt_zip_init(
!     cryptstate_T    *state,
!     char_u	    *key,
!     char_u	    *salt UNUSED,
!     int		    salt_len UNUSED,
!     char_u	    *seed UNUSED,
!     int		    seed_len UNUSED)
  {
      char_u	*p;
      zip_state_T	*zs;
***************
*** 114,124 ****
   * "from" and "to" can be equal to encrypt in place.
   */
      void
! crypt_zip_encode(state, from, len, to)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	*to;
  {
      zip_state_T *zs = state->method_state;
      size_t	i;
--- 114,124 ----
   * "from" and "to" can be equal to encrypt in place.
   */
      void
! crypt_zip_encode(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	*to)
  {
      zip_state_T *zs = state->method_state;
      size_t	i;
***************
*** 137,147 ****
   * Decrypt "from[len]" into "to[len]".
   */
      void
! crypt_zip_decode(state, from, len, to)
!     cryptstate_T *state;
!     char_u	*from;
!     size_t	len;
!     char_u	*to;
  {
      zip_state_T *zs = state->method_state;
      size_t	i;
--- 137,147 ----
   * Decrypt "from[len]" into "to[len]".
   */
      void
! crypt_zip_decode(
!     cryptstate_T *state,
!     char_u	*from,
!     size_t	len,
!     char_u	*to)
  {
      zip_state_T *zs = state->method_state;
      size_t	i;
*** ../vim-7.4.1204/src/diff.c	2016-01-29 22:03:43.473945909 +0100
--- src/diff.c	2016-01-30 14:31:20.557912976 +0100
***************
*** 60,67 ****
   * Called when deleting or unloading a buffer: No longer make a diff with it.
   */
      void
! diff_buf_delete(buf)
!     buf_T	*buf;
  {
      int		i;
      tabpage_T	*tp;
--- 60,66 ----
   * Called when deleting or unloading a buffer: No longer make a diff with it.
   */
      void
! diff_buf_delete(buf_T *buf)
  {
      int		i;
      tabpage_T	*tp;
***************
*** 84,91 ****
   * diff buffers.
   */
      void
! diff_buf_adjust(win)
!     win_T	*win;
  {
      win_T	*wp;
      int		i;
--- 83,89 ----
   * diff buffers.
   */
      void
! diff_buf_adjust(win_T *win)
  {
      win_T	*wp;
      int		i;
***************
*** 121,128 ****
   * about the screen contents.
   */
      void
! diff_buf_add(buf)
!     buf_T	*buf;
  {
      int		i;
  
--- 119,125 ----
   * about the screen contents.
   */
      void
! diff_buf_add(buf_T *buf)
  {
      int		i;
  
***************
*** 146,153 ****
   * Return its index or DB_COUNT if not found.
   */
      static int
! diff_buf_idx(buf)
!     buf_T	*buf;
  {
      int		idx;
  
--- 143,149 ----
   * Return its index or DB_COUNT if not found.
   */
      static int
! diff_buf_idx(buf_T *buf)
  {
      int		idx;
  
***************
*** 162,170 ****
   * Return its index or DB_COUNT if not found.
   */
      static int
! diff_buf_idx_tp(buf, tp)
!     buf_T	*buf;
!     tabpage_T	*tp;
  {
      int		idx;
  
--- 158,164 ----
   * Return its index or DB_COUNT if not found.
   */
      static int
! diff_buf_idx_tp(buf_T *buf, tabpage_T *tp)
  {
      int		idx;
  
***************
*** 179,186 ****
   * when info is requested.
   */
      void
! diff_invalidate(buf)
!     buf_T	*buf;
  {
      tabpage_T	*tp;
      int		i;
--- 173,179 ----
   * when info is requested.
   */
      void
! diff_invalidate(buf_T *buf)
  {
      tabpage_T	*tp;
      int		i;
***************
*** 201,211 ****
   * Called by mark_adjust(): update line numbers in "curbuf".
   */
      void
! diff_mark_adjust(line1, line2, amount, amount_after)
!     linenr_T	line1;
!     linenr_T	line2;
!     long	amount;
!     long	amount_after;
  {
      int		idx;
      tabpage_T	*tp;
--- 194,204 ----
   * Called by mark_adjust(): update line numbers in "curbuf".
   */
      void
! diff_mark_adjust(
!     linenr_T	line1,
!     linenr_T	line2,
!     long	amount,
!     long	amount_after)
  {
      int		idx;
      tabpage_T	*tp;
***************
*** 227,239 ****
   * When inserting/deleting lines in existing change blocks, update them.
   */
      static void
! diff_mark_adjust_tp(tp, idx, line1, line2, amount, amount_after)
!     tabpage_T	*tp;
!     int		idx;
!     linenr_T	line1;
!     linenr_T	line2;
!     long	amount;
!     long	amount_after;
  {
      diff_T	*dp;
      diff_T	*dprev;
--- 220,232 ----
   * When inserting/deleting lines in existing change blocks, update them.
   */
      static void
! diff_mark_adjust_tp(
!     tabpage_T	*tp,
!     int		idx,
!     linenr_T	line1,
!     linenr_T	line2,
!     long	amount,
!     long	amount_after)
  {
      diff_T	*dp;
      diff_T	*dprev;
***************
*** 479,488 ****
   * Allocate a new diff block and link it between "dprev" and "dp".
   */
      static diff_T *
! diff_alloc_new(tp, dprev, dp)
!     tabpage_T	*tp;
!     diff_T	*dprev;
!     diff_T	*dp;
  {
      diff_T	*dnew;
  
--- 472,478 ----
   * Allocate a new diff block and link it between "dprev" and "dp".
   */
      static diff_T *
! diff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp)
  {
      diff_T	*dnew;
  
***************
*** 505,513 ****
   * must take care of removing it.
   */
      static void
! diff_check_unchanged(tp, dp)
!     tabpage_T	*tp;
!     diff_T	*dp;
  {
      int		i_org;
      int		i_new;
--- 495,501 ----
   * must take care of removing it.
   */
      static void
! diff_check_unchanged(tabpage_T *tp, diff_T *dp)
  {
      int		i_org;
      int		i_new;
***************
*** 581,589 ****
   * This can happen when the diff program returns invalid results.
   */
      static int
! diff_check_sanity(tp, dp)
!     tabpage_T	*tp;
!     diff_T	*dp;
  {
      int		i;
  
--- 569,575 ----
   * This can happen when the diff program returns invalid results.
   */
      static int
! diff_check_sanity(tabpage_T *tp, diff_T *dp)
  {
      int		i;
  
***************
*** 599,606 ****
   * Mark all diff buffers in the current tab page for redraw.
   */
      static void
! diff_redraw(dofold)
!     int		dofold;	    /* also recompute the folds */
  {
      win_T	*wp;
      int		n;
--- 585,592 ----
   * Mark all diff buffers in the current tab page for redraw.
   */
      static void
! diff_redraw(
!     int		dofold)	    /* also recompute the folds */
  {
      win_T	*wp;
      int		n;
***************
*** 633,641 ****
   * Return FAIL for failure
   */
      static int
! diff_write(buf, fname)
!     buf_T	*buf;
!     char_u	*fname;
  {
      int		r;
      char_u	*save_ff;
--- 619,625 ----
   * Return FAIL for failure
   */
      static int
! diff_write(buf_T *buf, char_u *fname)
  {
      int		r;
      char_u	*save_ff;
***************
*** 656,663 ****
   * could have been produced by autocommands, e.g. the netrw plugin).
   */
      void
! ex_diffupdate(eap)
!     exarg_T	*eap UNUSED;	    /* can be NULL */
  {
      buf_T	*buf;
      int		idx_orig;
--- 640,647 ----
   * could have been produced by autocommands, e.g. the netrw plugin).
   */
      void
! ex_diffupdate(
!     exarg_T	*eap UNUSED)	    /* can be NULL */
  {
      buf_T	*buf;
      int		idx_orig;
***************
*** 832,841 ****
   * Make a diff between files "tmp_orig" and "tmp_new", results in "tmp_diff".
   */
      static void
! diff_file(tmp_orig, tmp_new, tmp_diff)
!     char_u	*tmp_orig;
!     char_u	*tmp_new;
!     char_u	*tmp_diff;
  {
      char_u	*cmd;
      size_t	len;
--- 816,825 ----
   * Make a diff between files "tmp_orig" and "tmp_new", results in "tmp_diff".
   */
      static void
! diff_file(
!     char_u	*tmp_orig,
!     char_u	*tmp_new,
!     char_u	*tmp_diff)
  {
      char_u	*cmd;
      size_t	len;
***************
*** 888,895 ****
   * could have been produced by autocommands, e.g. the netrw plugin).
   */
      void
! ex_diffpatch(eap)
!     exarg_T	*eap;
  {
      char_u	*tmp_orig;	/* name of original temp file */
      char_u	*tmp_new;	/* name of patched temp file */
--- 872,878 ----
   * could have been produced by autocommands, e.g. the netrw plugin).
   */
      void
! ex_diffpatch(exarg_T *eap)
  {
      char_u	*tmp_orig;	/* name of original temp file */
      char_u	*tmp_new;	/* name of patched temp file */
***************
*** 1083,1090 ****
   * Split the window and edit another file, setting options to show the diffs.
   */
      void
! ex_diffsplit(eap)
!     exarg_T	*eap;
  {
      win_T	*old_curwin = curwin;
      buf_T	*old_curbuf = curbuf;
--- 1066,1072 ----
   * Split the window and edit another file, setting options to show the diffs.
   */
      void
! ex_diffsplit(exarg_T *eap)
  {
      win_T	*old_curwin = curwin;
      buf_T	*old_curbuf = curbuf;
***************
*** 1126,1133 ****
   * Set options to show diffs for the current window.
   */
      void
! ex_diffthis(eap)
!     exarg_T	*eap UNUSED;
  {
      /* Set 'diff', 'scrollbind' on and 'wrap' off. */
      diff_win_options(curwin, TRUE);
--- 1108,1114 ----
   * Set options to show diffs for the current window.
   */
      void
! ex_diffthis(exarg_T *eap UNUSED)
  {
      /* Set 'diff', 'scrollbind' on and 'wrap' off. */
      diff_win_options(curwin, TRUE);
***************
*** 1137,1145 ****
   * Set options in window "wp" for diff mode.
   */
      void
! diff_win_options(wp, addbuf)
!     win_T	*wp;
!     int		addbuf;		/* Add buffer to diff. */
  {
  # ifdef FEAT_FOLDING
      win_T *old_curwin = curwin;
--- 1118,1126 ----
   * Set options in window "wp" for diff mode.
   */
      void
! diff_win_options(
!     win_T	*wp,
!     int		addbuf)		/* Add buffer to diff. */
  {
  # ifdef FEAT_FOLDING
      win_T *old_curwin = curwin;
***************
*** 1209,1216 ****
   * Only in the current tab page.
   */
      void
! ex_diffoff(eap)
!     exarg_T	*eap;
  {
      win_T	*wp;
  #ifdef FEAT_SCROLLBIND
--- 1190,1196 ----
   * Only in the current tab page.
   */
      void
! ex_diffoff(exarg_T *eap)
  {
      win_T	*wp;
  #ifdef FEAT_SCROLLBIND
***************
*** 1279,1288 ****
   * Read the diff output and add each entry to the diff list.
   */
      static void
! diff_read(idx_orig, idx_new, fname)
!     int		idx_orig;	/* idx of original file */
!     int		idx_new;	/* idx of new file */
!     char_u	*fname;		/* name of diff output file */
  {
      FILE	*fd;
      diff_T	*dprev = NULL;
--- 1259,1268 ----
   * Read the diff output and add each entry to the diff list.
   */
      static void
! diff_read(
!     int		idx_orig,	/* idx of original file */
!     int		idx_new,	/* idx of new file */
!     char_u	*fname)		/* name of diff output file */
  {
      FILE	*fd;
      diff_T	*dprev = NULL;
***************
*** 1473,1483 ****
   * Copy an entry at "dp" from "idx_orig" to "idx_new".
   */
      static void
! diff_copy_entry(dprev, dp, idx_orig, idx_new)
!     diff_T	*dprev;
!     diff_T	*dp;
!     int		idx_orig;
!     int		idx_new;
  {
      long	off;
  
--- 1453,1463 ----
   * Copy an entry at "dp" from "idx_orig" to "idx_new".
   */
      static void
! diff_copy_entry(
!     diff_T	*dprev,
!     diff_T	*dp,
!     int		idx_orig,
!     int		idx_new)
  {
      long	off;
  
***************
*** 1494,1501 ****
   * Clear the list of diffblocks for tab page "tp".
   */
      void
! diff_clear(tp)
!     tabpage_T	*tp;
  {
      diff_T	*p, *next_p;
  
--- 1474,1480 ----
   * Clear the list of diffblocks for tab page "tp".
   */
      void
! diff_clear(tabpage_T *tp)
  {
      diff_T	*p, *next_p;
  
***************
*** 1517,1525 ****
   * This should only be used for windows where 'diff' is set.
   */
      int
! diff_check(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      int		idx;		/* index in tp_diffbuf[] for this buffer */
      diff_T	*dp;
--- 1496,1502 ----
   * This should only be used for windows where 'diff' is set.
   */
      int
! diff_check(win_T *wp, linenr_T lnum)
  {
      int		idx;		/* index in tp_diffbuf[] for this buffer */
      diff_T	*dp;
***************
*** 1611,1620 ****
   * Compare two entries in diff "*dp" and return TRUE if they are equal.
   */
      static int
! diff_equal_entry(dp, idx1, idx2)
!     diff_T	*dp;
!     int		idx1;
!     int		idx2;
  {
      int		i;
      char_u	*line;
--- 1588,1594 ----
   * Compare two entries in diff "*dp" and return TRUE if they are equal.
   */
      static int
! diff_equal_entry(diff_T *dp, int idx1, int idx2)
  {
      int		i;
      char_u	*line;
***************
*** 1644,1652 ****
   * Return non-zero when they are different.
   */
      static int
! diff_cmp(s1, s2)
!     char_u	*s1;
!     char_u	*s2;
  {
      char_u	*p1, *p2;
  #ifdef FEAT_MBYTE
--- 1618,1624 ----
   * Return non-zero when they are different.
   */
      static int
! diff_cmp(char_u *s1, char_u *s2)
  {
      char_u	*p1, *p2;
  #ifdef FEAT_MBYTE
***************
*** 1709,1717 ****
   * Return the number of filler lines above "lnum".
   */
      int
! diff_check_fill(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      int		n;
  
--- 1681,1687 ----
   * Return the number of filler lines above "lnum".
   */
      int
! diff_check_fill(win_T *wp, linenr_T lnum)
  {
      int		n;
  
***************
*** 1729,1737 ****
   * show the same diff'ed lines.
   */
      void
! diff_set_topline(fromwin, towin)
!     win_T	*fromwin;
!     win_T	*towin;
  {
      buf_T	*frombuf = fromwin->w_buffer;
      linenr_T	lnum = fromwin->w_topline;
--- 1699,1705 ----
   * show the same diff'ed lines.
   */
      void
! diff_set_topline(win_T *fromwin, win_T *towin)
  {
      buf_T	*frombuf = fromwin->w_buffer;
      linenr_T	lnum = fromwin->w_topline;
***************
*** 1851,1857 ****
   * This is called when 'diffopt' is changed.
   */
      int
! diffopt_changed()
  {
      char_u	*p;
      int		diff_context_new = 6;
--- 1819,1825 ----
   * This is called when 'diffopt' is changed.
   */
      int
! diffopt_changed(void)
  {
      char_u	*p;
      int		diff_context_new = 6;
***************
*** 1929,1935 ****
   * Return TRUE if 'diffopt' contains "horizontal".
   */
      int
! diffopt_horizontal()
  {
      return (diff_flags & DIFF_HORIZONTAL) != 0;
  }
--- 1897,1903 ----
   * Return TRUE if 'diffopt' contains "horizontal".
   */
      int
! diffopt_horizontal(void)
  {
      return (diff_flags & DIFF_HORIZONTAL) != 0;
  }
***************
*** 1939,1949 ****
   * Returns TRUE if the line was added, no other buffer has it.
   */
      int
! diff_find_change(wp, lnum, startp, endp)
!     win_T	*wp;
!     linenr_T	lnum;
!     int		*startp;	/* first char of the change */
!     int		*endp;		/* last char of the change */
  {
      char_u	*line_org;
      char_u	*line_new;
--- 1907,1917 ----
   * Returns TRUE if the line was added, no other buffer has it.
   */
      int
! diff_find_change(
!     win_T	*wp,
!     linenr_T	lnum,
!     int		*startp,	/* first char of the change */
!     int		*endp)		/* last char of the change */
  {
      char_u	*line_org;
      char_u	*line_new;
***************
*** 2063,2071 ****
   * Return FALSE if there are no diff blocks at all in this window.
   */
      int
! diff_infold(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      int		i;
      int		idx = -1;
--- 2031,2037 ----
   * Return FALSE if there are no diff blocks at all in this window.
   */
      int
! diff_infold(win_T *wp, linenr_T lnum)
  {
      int		i;
      int		idx = -1;
***************
*** 2112,2120 ****
   * "dp" and "do" commands.
   */
      void
! nv_diffgetput(put, count)
!     int		put;
!     long	count;
  {
      exarg_T	ea;
      char_u	buf[30];
--- 2078,2084 ----
   * "dp" and "do" commands.
   */
      void
! nv_diffgetput(int put, long count)
  {
      exarg_T	ea;
      char_u	buf[30];
***************
*** 2141,2148 ****
   * ":diffput"
   */
      void
! ex_diffgetput(eap)
!     exarg_T	*eap;
  {
      linenr_T	lnum;
      int		count;
--- 2105,2111 ----
   * ":diffput"
   */
      void
! ex_diffgetput(exarg_T *eap)
  {
      linenr_T	lnum;
      int		count;
***************
*** 2464,2472 ****
   * When there are no diffs, all folds are removed.
   */
      static void
! diff_fold_update(dp, skip_idx)
!     diff_T	*dp;
!     int		skip_idx;
  {
      int		i;
      win_T	*wp;
--- 2427,2433 ----
   * When there are no diffs, all folds are removed.
   */
      static void
! diff_fold_update(diff_T *dp, int skip_idx)
  {
      int		i;
      win_T	*wp;
***************
*** 2483,2490 ****
   * Return TRUE if buffer "buf" is in diff-mode.
   */
      int
! diff_mode_buf(buf)
!     buf_T	*buf;
  {
      tabpage_T	*tp;
  
--- 2444,2450 ----
   * Return TRUE if buffer "buf" is in diff-mode.
   */
      int
! diff_mode_buf(buf_T *buf)
  {
      tabpage_T	*tp;
  
***************
*** 2499,2507 ****
   * Return FAIL if there isn't such a diff block.
   */
      int
! diff_move_to(dir, count)
!     int		dir;
!     long	count;
  {
      int		idx;
      linenr_T	lnum = curwin->w_cursor.lnum;
--- 2459,2465 ----
   * Return FAIL if there isn't such a diff block.
   */
      int
! diff_move_to(int dir, long count)
  {
      int		idx;
      linenr_T	lnum = curwin->w_cursor.lnum;
***************
*** 2554,2564 ****
  }
  
      linenr_T
! diff_get_corresponding_line(buf1, lnum1, buf2, lnum3)
!     buf_T	*buf1;
!     linenr_T	lnum1;
!     buf_T	*buf2;
!     linenr_T	lnum3;
  {
      int		idx1;
      int		idx2;
--- 2512,2522 ----
  }
  
      linenr_T
! diff_get_corresponding_line(
!     buf_T	*buf1,
!     linenr_T	lnum1,
!     buf_T	*buf2,
!     linenr_T	lnum3)
  {
      int		idx1;
      int		idx2;
***************
*** 2628,2636 ****
   * "wp", compensating for inserted/deleted lines.
   */
      linenr_T
! diff_lnum_win(lnum, wp)
!     linenr_T	lnum;
!     win_T	*wp;
  {
      diff_T	*dp;
      int		idx;
--- 2586,2592 ----
   * "wp", compensating for inserted/deleted lines.
   */
      linenr_T
! diff_lnum_win(linenr_T lnum, win_T *wp)
  {
      diff_T	*dp;
      int		idx;
*** ../vim-7.4.1204/src/digraph.c	2016-01-29 22:03:43.477945866 +0100
--- src/digraph.c	2016-01-30 14:32:14.685352240 +0100
***************
*** 2013,2020 ****
   * handle digraphs after typing a character
   */
      int
! do_digraph(c)
!     int	    c;
  {
      static int	backspaced;	/* character before K_BS */
      static int	lastchar;	/* last typed character */
--- 2013,2019 ----
   * handle digraphs after typing a character
   */
      int
! do_digraph(int c)
  {
      static int	backspaced;	/* character before K_BS */
      static int	lastchar;	/* last typed character */
***************
*** 2041,2048 ****
   * Returns composed character, or NUL when ESC was used.
   */
      int
! get_digraph(cmdline)
!     int		cmdline;	/* TRUE when called from the cmdline */
  {
      int		c, cc;
  
--- 2040,2047 ----
   * Returns composed character, or NUL when ESC was used.
   */
      int
! get_digraph(
!     int		cmdline)	/* TRUE when called from the cmdline */
  {
      int		c, cc;
  
***************
*** 2085,2094 ****
   * If "meta_char" is TRUE and "char1" is a space, return "char2" | 0x80.
   */
      static int
! getexactdigraph(char1, char2, meta_char)
!     int		char1;
!     int		char2;
!     int		meta_char;
  {
      int		i;
      int		retval = 0;
--- 2084,2090 ----
   * If "meta_char" is TRUE and "char1" is a space, return "char2" | 0x80.
   */
      static int
! getexactdigraph(int char1, int char2, int meta_char)
  {
      int		i;
      int		retval = 0;
***************
*** 2173,2182 ****
   * Allow for both char1-char2 and char2-char1
   */
      int
! getdigraph(char1, char2, meta_char)
!     int	char1;
!     int	char2;
!     int	meta_char;
  {
      int	    retval;
  
--- 2169,2175 ----
   * Allow for both char1-char2 and char2-char1
   */
      int
! getdigraph(int char1, int char2, int meta_char)
  {
      int	    retval;
  
***************
*** 2192,2199 ****
   * format: {c1}{c2} char {c1}{c2} char ...
   */
      void
! putdigraph(str)
!     char_u *str;
  {
      int		char1, char2, n;
      int		i;
--- 2185,2191 ----
   * format: {c1}{c2} char {c1}{c2} char ...
   */
      void
! putdigraph(char_u *str)
  {
      int		char1, char2, n;
      int		i;
***************
*** 2252,2258 ****
  }
  
      void
! listdigraphs()
  {
      int		i;
      digr_T	*dp;
--- 2244,2250 ----
  }
  
      void
! listdigraphs(void)
  {
      int		i;
      digr_T	*dp;
***************
*** 2297,2304 ****
  }
  
      static void
! printdigraph(dp)
!     digr_T	*dp;
  {
      char_u	buf[30];
      char_u	*p;
--- 2289,2295 ----
  }
  
      static void
! printdigraph(digr_T *dp)
  {
      char_u	buf[30];
      char_u	*p;
***************
*** 2366,2372 ****
   * checked.
   */
      char_u *
! keymap_init()
  {
      curbuf->b_kmap_state &= ~KEYMAP_INIT;
  
--- 2357,2363 ----
   * checked.
   */
      char_u *
! keymap_init(void)
  {
      curbuf->b_kmap_state &= ~KEYMAP_INIT;
  
***************
*** 2419,2426 ****
   * ":loadkeymap" command: load the following lines as the keymap.
   */
      void
! ex_loadkeymap(eap)
!     exarg_T	*eap;
  {
      char_u	*line;
      char_u	*p;
--- 2410,2416 ----
   * ":loadkeymap" command: load the following lines as the keymap.
   */
      void
! ex_loadkeymap(exarg_T *eap)
  {
      char_u	*line;
      char_u	*p;
***************
*** 2505,2511 ****
   * Stop using 'keymap'.
   */
      static void
! keymap_unload()
  {
      char_u	buf[KMAP_MAXLEN + 10];
      int		i;
--- 2495,2501 ----
   * Stop using 'keymap'.
   */
      static void
! keymap_unload(void)
  {
      char_u	buf[KMAP_MAXLEN + 10];
      int		i;
*** ../vim-7.4.1204/src/edit.c	2016-01-29 22:03:43.477945866 +0100
--- src/edit.c	2016-01-30 14:47:02.480185729 +0100
***************
*** 321,330 ****
   * Return TRUE if a CTRL-O command caused the return (insert mode pending).
   */
      int
! edit(cmdchar, startln, count)
!     int		cmdchar;
!     int		startln;	/* if set, insert at start of line */
!     long	count;
  {
      int		c = 0;
      char_u	*ptr;
--- 321,330 ----
   * Return TRUE if a CTRL-O command caused the return (insert mode pending).
   */
      int
! edit(
!     int		cmdchar,
!     int		startln,	/* if set, insert at start of line */
!     long	count)
  {
      int		c = 0;
      char_u	*ptr;
***************
*** 1569,1576 ****
   * inserting sequences of characters (e.g., for CTRL-R).
   */
      static void
! ins_redraw(ready)
!     int		ready UNUSED;	    /* not busy with something */
  {
  #ifdef FEAT_CONCEAL
      linenr_T	conceal_old_cursor_line = 0;
--- 1569,1576 ----
   * inserting sequences of characters (e.g., for CTRL-R).
   */
      static void
! ins_redraw(
!     int		ready UNUSED)	    /* not busy with something */
  {
  #ifdef FEAT_CONCEAL
      linenr_T	conceal_old_cursor_line = 0;
***************
*** 1667,1673 ****
   * Handle a CTRL-V or CTRL-Q typed in Insert mode.
   */
      static void
! ins_ctrl_v()
  {
      int		c;
      int		did_putchar = FALSE;
--- 1667,1673 ----
   * Handle a CTRL-V or CTRL-Q typed in Insert mode.
   */
      static void
! ins_ctrl_v(void)
  {
      int		c;
      int		did_putchar = FALSE;
***************
*** 1716,1724 ****
  static int  pc_col;
  
      void
! edit_putchar(c, highlight)
!     int	    c;
!     int	    highlight;
  {
      int	    attr;
  
--- 1716,1722 ----
  static int  pc_col;
  
      void
! edit_putchar(int c, int highlight)
  {
      int	    attr;
  
***************
*** 1779,1785 ****
   * Undo the previous edit_putchar().
   */
      void
! edit_unputchar()
  {
      if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled)
      {
--- 1777,1783 ----
   * Undo the previous edit_putchar().
   */
      void
! edit_unputchar(void)
  {
      if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled)
      {
***************
*** 1799,1806 ****
   * Only works when cursor is in the line that changes.
   */
      void
! display_dollar(col)
!     colnr_T	col;
  {
      colnr_T save_col;
  
--- 1797,1803 ----
   * Only works when cursor is in the line that changes.
   */
      void
! display_dollar(colnr_T col)
  {
      colnr_T save_col;
  
***************
*** 1834,1840 ****
   * in insert mode.
   */
      static void
! undisplay_dollar()
  {
      if (dollar_vcol >= 0)
      {
--- 1831,1837 ----
   * in insert mode.
   */
      static void
! undisplay_dollar(void)
  {
      if (dollar_vcol >= 0)
      {
***************
*** 1852,1863 ****
   * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).
   */
      void
! change_indent(type, amount, round, replaced, call_changed_bytes)
!     int		type;
!     int		amount;
!     int		round;
!     int		replaced;	/* replaced character, put on replace stack */
!     int		call_changed_bytes;	/* call changed_bytes() */
  {
      int		vcol;
      int		last_vcol;
--- 1849,1860 ----
   * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).
   */
      void
! change_indent(
!     int		type,
!     int		amount,
!     int		round,
!     int		replaced,	/* replaced character, put on replace stack */
!     int		call_changed_bytes)	/* call changed_bytes() */
  {
      int		vcol;
      int		last_vcol;
***************
*** 2101,2108 ****
   * modes.
   */
      void
! truncate_spaces(line)
!     char_u  *line;
  {
      int	    i;
  
--- 2098,2104 ----
   * modes.
   */
      void
! truncate_spaces(char_u *line)
  {
      int	    i;
  
***************
*** 2124,2131 ****
   * character.
   */
      void
! backspace_until_column(col)
!     int	    col;
  {
      while ((int)curwin->w_cursor.col > col)
      {
--- 2120,2126 ----
   * character.
   */
      void
! backspace_until_column(int col)
  {
      while ((int)curwin->w_cursor.col > col)
      {
***************
*** 2144,2151 ****
   * Return TRUE when something was deleted.
   */
     static int
! del_char_after_col(limit_col)
!     int limit_col UNUSED;
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && limit_col >= 0)
--- 2139,2145 ----
   * Return TRUE when something was deleted.
   */
     static int
! del_char_after_col(int limit_col UNUSED)
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 && limit_col >= 0)
***************
*** 2179,2185 ****
   * CTRL-X pressed in Insert mode.
   */
      static void
! ins_ctrl_x()
  {
      /* CTRL-X after CTRL-X CTRL-V doesn't do anything, so that CTRL-X
       * CTRL-V works like CTRL-N */
--- 2173,2179 ----
   * CTRL-X pressed in Insert mode.
   */
      static void
! ins_ctrl_x(void)
  {
      /* CTRL-X after CTRL-X CTRL-V doesn't do anything, so that CTRL-X
       * CTRL-V works like CTRL-N */
***************
*** 2203,2210 ****
   * Return TRUE if the 'dict' or 'tsr' option can be used.
   */
      static int
! has_compl_option(dict_opt)
!     int	    dict_opt;
  {
      if (dict_opt ? (*curbuf->b_p_dict == NUL && *p_dict == NUL
  # ifdef FEAT_SPELL
--- 2197,2203 ----
   * Return TRUE if the 'dict' or 'tsr' option can be used.
   */
      static int
! has_compl_option(int dict_opt)
  {
      if (dict_opt ? (*curbuf->b_p_dict == NUL && *p_dict == NUL
  # ifdef FEAT_SPELL
***************
*** 2235,2242 ****
   * This depends on the current mode.
   */
      int
! vim_is_ctrl_x_key(c)
!     int	    c;
  {
      /* Always allow ^R - let it's results then be checked */
      if (c == Ctrl_R)
--- 2228,2234 ----
   * This depends on the current mode.
   */
      int
! vim_is_ctrl_x_key(int c)
  {
      /* Always allow ^R - let it's results then be checked */
      if (c == Ctrl_R)
***************
*** 2299,2306 ****
   * is visible.
   */
      static int
! ins_compl_accept_char(c)
!     int c;
  {
      if (ctrl_x_mode & CTRL_X_WANT_IDENT)
  	/* When expanding an identifier only accept identifier chars. */
--- 2291,2297 ----
   * is visible.
   */
      static int
! ins_compl_accept_char(int c)
  {
      if (ctrl_x_mode & CTRL_X_WANT_IDENT)
  	/* When expanding an identifier only accept identifier chars. */
***************
*** 2334,2346 ****
   * the rest of the word to be in -- webb
   */
      int
! ins_compl_add_infercase(str, len, icase, fname, dir, flags)
!     char_u	*str;
!     int		len;
!     int		icase;
!     char_u	*fname;
!     int		dir;
!     int		flags;
  {
      char_u	*p;
      int		i, c;
--- 2325,2337 ----
   * the rest of the word to be in -- webb
   */
      int
! ins_compl_add_infercase(
!     char_u	*str,
!     int		len,
!     int		icase,
!     char_u	*fname,
!     int		dir,
!     int		flags)
  {
      char_u	*p;
      int		i, c;
***************
*** 2503,2517 ****
   * maybe because alloc() returns NULL, then FAIL is returned.
   */
      static int
! ins_compl_add(str, len, icase, fname, cptext, cdir, flags, adup)
!     char_u	*str;
!     int		len;
!     int		icase;
!     char_u	*fname;
!     char_u	**cptext;   /* extra text for popup menu or NULL */
!     int		cdir;
!     int		flags;
!     int		adup;	    /* accept duplicate match */
  {
      compl_T	*match;
      int		dir = (cdir == 0 ? compl_direction : cdir);
--- 2494,2508 ----
   * maybe because alloc() returns NULL, then FAIL is returned.
   */
      static int
! ins_compl_add(
!     char_u	*str,
!     int		len,
!     int		icase,
!     char_u	*fname,
!     char_u	**cptext,   /* extra text for popup menu or NULL */
!     int		cdir,
!     int		flags,
!     int		adup)	    /* accept duplicate match */
  {
      compl_T	*match;
      int		dir = (cdir == 0 ? compl_direction : cdir);
***************
*** 2622,2631 ****
   * match->cp_icase.
   */
      static int
! ins_compl_equal(match, str, len)
!     compl_T	*match;
!     char_u	*str;
!     int		len;
  {
      if (match->cp_icase)
  	return STRNICMP(match->cp_str, str, (size_t)len) == 0;
--- 2613,2619 ----
   * match->cp_icase.
   */
      static int
! ins_compl_equal(compl_T *match, char_u *str, int len)
  {
      if (match->cp_icase)
  	return STRNICMP(match->cp_str, str, (size_t)len) == 0;
***************
*** 2636,2643 ****
   * Reduce the longest common string for match "match".
   */
      static void
! ins_compl_longest_match(match)
!     compl_T	*match;
  {
      char_u	*p, *s;
      int		c1, c2;
--- 2624,2630 ----
   * Reduce the longest common string for match "match".
   */
      static void
! ins_compl_longest_match(compl_T *match)
  {
      char_u	*p, *s;
      int		c1, c2;
***************
*** 2721,2730 ****
   * Frees matches[].
   */
      static void
! ins_compl_add_matches(num_matches, matches, icase)
!     int		num_matches;
!     char_u	**matches;
!     int		icase;
  {
      int		i;
      int		add_r = OK;
--- 2708,2717 ----
   * Frees matches[].
   */
      static void
! ins_compl_add_matches(
!     int		num_matches,
!     char_u	**matches,
!     int		icase)
  {
      int		i;
      int		add_r = OK;
***************
*** 2742,2748 ****
   * Return the number of matches (excluding the original).
   */
      static int
! ins_compl_make_cyclic()
  {
      compl_T *match;
      int	    count = 0;
--- 2729,2735 ----
   * Return the number of matches (excluding the original).
   */
      static int
! ins_compl_make_cyclic(void)
  {
      compl_T *match;
      int	    count = 0;
***************
*** 2771,2779 ****
   * "list" is the list of matches.
   */
      void
! set_completion(startcol, list)
!     colnr_T startcol;
!     list_T  *list;
  {
      /* If already doing completions stop it. */
      if (ctrl_x_mode != 0)
--- 2758,2764 ----
   * "list" is the list of matches.
   */
      void
! set_completion(colnr_T startcol, list_T *list)
  {
      /* If already doing completions stop it. */
      if (ctrl_x_mode != 0)
***************
*** 2822,2828 ****
   * Update the screen and when there is any scrolling remove the popup menu.
   */
      static void
! ins_compl_upd_pum()
  {
      int		h;
  
--- 2807,2813 ----
   * Update the screen and when there is any scrolling remove the popup menu.
   */
      static void
! ins_compl_upd_pum(void)
  {
      int		h;
  
***************
*** 2839,2845 ****
   * Remove any popup menu.
   */
      static void
! ins_compl_del_pum()
  {
      if (compl_match_array != NULL)
      {
--- 2824,2830 ----
   * Remove any popup menu.
   */
      static void
! ins_compl_del_pum(void)
  {
      if (compl_match_array != NULL)
      {
***************
*** 2853,2859 ****
   * Return TRUE if the popup menu should be displayed.
   */
      static int
! pum_wanted()
  {
      /* 'completeopt' must contain "menu" or "menuone" */
      if (vim_strchr(p_cot, 'm') == NULL)
--- 2838,2844 ----
   * Return TRUE if the popup menu should be displayed.
   */
      static int
! pum_wanted(void)
  {
      /* 'completeopt' must contain "menu" or "menuone" */
      if (vim_strchr(p_cot, 'm') == NULL)
***************
*** 2874,2880 ****
   * One if 'completopt' contains "menuone".
   */
      static int
! pum_enough_matches()
  {
      compl_T     *compl;
      int		i;
--- 2859,2865 ----
   * One if 'completopt' contains "menuone".
   */
      static int
! pum_enough_matches(void)
  {
      compl_T     *compl;
      int		i;
***************
*** 2901,2907 ****
   * Also adjusts "compl_shown_match" to an entry that is actually displayed.
   */
      void
! ins_compl_show_pum()
  {
      compl_T     *compl;
      compl_T     *shown_compl = NULL;
--- 2886,2892 ----
   * Also adjusts "compl_shown_match" to an entry that is actually displayed.
   */
      void
! ins_compl_show_pum(void)
  {
      compl_T     *compl;
      compl_T     *shown_compl = NULL;
***************
*** 3049,3059 ****
   * files "dict_start" to the list of completions.
   */
      static void
! ins_compl_dictionaries(dict_start, pat, flags, thesaurus)
!     char_u	*dict_start;
!     char_u	*pat;
!     int		flags;		/* DICT_FIRST and/or DICT_EXACT */
!     int		thesaurus;	/* Thesaurus completion */
  {
      char_u	*dict = dict_start;
      char_u	*ptr;
--- 3034,3044 ----
   * files "dict_start" to the list of completions.
   */
      static void
! ins_compl_dictionaries(
!     char_u	*dict_start,
!     char_u	*pat,
!     int		flags,		/* DICT_FIRST and/or DICT_EXACT */
!     int		thesaurus)	/* Thesaurus completion */
  {
      char_u	*dict = dict_start;
      char_u	*ptr;
***************
*** 3173,3186 ****
  }
  
      static void
! ins_compl_files(count, files, thesaurus, flags, regmatch, buf, dir)
!     int		count;
!     char_u	**files;
!     int		thesaurus;
!     int		flags;
!     regmatch_T	*regmatch;
!     char_u	*buf;
!     int		*dir;
  {
      char_u	*ptr;
      int		i;
--- 3158,3171 ----
  }
  
      static void
! ins_compl_files(
!     int		count,
!     char_u	**files,
!     int		thesaurus,
!     int		flags,
!     regmatch_T	*regmatch,
!     char_u	*buf,
!     int		*dir)
  {
      char_u	*ptr;
      int		i;
***************
*** 3282,3289 ****
   * Returns a pointer to the first char of the word.  Also stops at a NUL.
   */
      char_u *
! find_word_start(ptr)
!     char_u	*ptr;
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
--- 3267,3273 ----
   * Returns a pointer to the first char of the word.  Also stops at a NUL.
   */
      char_u *
! find_word_start(char_u *ptr)
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
***************
*** 3301,3308 ****
   * Returns a pointer to just after the word.
   */
      char_u *
! find_word_end(ptr)
!     char_u	*ptr;
  {
  #ifdef FEAT_MBYTE
      int		start_class;
--- 3285,3291 ----
   * Returns a pointer to just after the word.
   */
      char_u *
! find_word_end(char_u *ptr)
  {
  #ifdef FEAT_MBYTE
      int		start_class;
***************
*** 3330,3337 ****
   * Returns a pointer to just after the line.
   */
      static char_u *
! find_line_end(ptr)
!     char_u	*ptr;
  {
      char_u	*s;
  
--- 3313,3319 ----
   * Returns a pointer to just after the line.
   */
      static char_u *
! find_line_end(char_u *ptr)
  {
      char_u	*s;
  
***************
*** 3345,3351 ****
   * Free the list of completions
   */
      static void
! ins_compl_free()
  {
      compl_T *match;
      int	    i;
--- 3327,3333 ----
   * Free the list of completions
   */
      static void
! ins_compl_free(void)
  {
      compl_T *match;
      int	    i;
***************
*** 3379,3385 ****
  }
  
      static void
! ins_compl_clear()
  {
      compl_cont_status = 0;
      compl_started = FALSE;
--- 3361,3367 ----
  }
  
      static void
! ins_compl_clear(void)
  {
      compl_cont_status = 0;
      compl_started = FALSE;
***************
*** 3400,3406 ****
   * Return TRUE when Insert completion is active.
   */
      int
! ins_compl_active()
  {
      return compl_started;
  }
--- 3382,3388 ----
   * Return TRUE when Insert completion is active.
   */
      int
! ins_compl_active(void)
  {
      return compl_started;
  }
***************
*** 3412,3418 ****
   * to be got from the user.
   */
      static int
! ins_compl_bs()
  {
      char_u	*line;
      char_u	*p;
--- 3394,3400 ----
   * to be got from the user.
   */
      static int
! ins_compl_bs(void)
  {
      char_u	*line;
      char_u	*p;
***************
*** 3452,3458 ****
   * be called.
   */
      static int
! ins_compl_need_restart()
  {
      /* Return TRUE if we didn't complete finding matches or when the
       * 'completefunc' returned "always" in the "refresh" dictionary item. */
--- 3434,3440 ----
   * be called.
   */
      static int
! ins_compl_need_restart(void)
  {
      /* Return TRUE if we didn't complete finding matches or when the
       * 'completefunc' returned "always" in the "refresh" dictionary item. */
***************
*** 3467,3473 ****
   * May also search for matches again if the previous search was interrupted.
   */
      static void
! ins_compl_new_leader()
  {
      ins_compl_del_pum();
      ins_compl_delete();
--- 3449,3455 ----
   * May also search for matches again if the previous search was interrupted.
   */
      static void
! ins_compl_new_leader(void)
  {
      ins_compl_del_pum();
      ins_compl_delete();
***************
*** 3517,3523 ****
   * the cursor column.  Making sure it never goes below zero.
   */
      static int
! ins_compl_len()
  {
      int off = (int)curwin->w_cursor.col - (int)compl_col;
  
--- 3499,3505 ----
   * the cursor column.  Making sure it never goes below zero.
   */
      static int
! ins_compl_len(void)
  {
      int off = (int)curwin->w_cursor.col - (int)compl_col;
  
***************
*** 3531,3538 ****
   * matches.
   */
      static void
! ins_compl_addleader(c)
!     int		c;
  {
  #ifdef FEAT_MBYTE
      int		cc;
--- 3513,3519 ----
   * matches.
   */
      static void
! ins_compl_addleader(int c)
  {
  #ifdef FEAT_MBYTE
      int		cc;
***************
*** 3577,3583 ****
   * BS or a key was typed while still searching for matches.
   */
      static void
! ins_compl_restart()
  {
      ins_compl_free();
      compl_started = FALSE;
--- 3558,3564 ----
   * BS or a key was typed while still searching for matches.
   */
      static void
! ins_compl_restart(void)
  {
      ins_compl_free();
      compl_started = FALSE;
***************
*** 3590,3597 ****
   * Set the first match, the original text.
   */
      static void
! ins_compl_set_original_text(str)
!     char_u	*str;
  {
      char_u	*p;
  
--- 3571,3577 ----
   * Set the first match, the original text.
   */
      static void
! ins_compl_set_original_text(char_u *str)
  {
      char_u	*p;
  
***************
*** 3612,3618 ****
   * matches.
   */
      static void
! ins_compl_addfrommatch()
  {
      char_u	*p;
      int		len = (int)curwin->w_cursor.col - (int)compl_col;
--- 3592,3598 ----
   * matches.
   */
      static void
! ins_compl_addfrommatch(void)
  {
      char_u	*p;
      int		len = (int)curwin->w_cursor.col - (int)compl_col;
***************
*** 3655,3662 ****
   * Returns TRUE when the character is not to be inserted;
   */
      static int
! ins_compl_prep(c)
!     int	    c;
  {
      char_u	*ptr;
      int		want_cindent;
--- 3635,3641 ----
   * Returns TRUE when the character is not to be inserted;
   */
      static int
! ins_compl_prep(int c)
  {
      char_u	*ptr;
      int		want_cindent;
***************
*** 3947,3954 ****
   * "ptr" is the known leader text or NUL.
   */
      static void
! ins_compl_fixRedoBufForLeader(ptr_arg)
!     char_u *ptr_arg;
  {
      int	    len;
      char_u  *p;
--- 3926,3932 ----
   * "ptr" is the known leader text or NUL.
   */
      static void
! ins_compl_fixRedoBufForLeader(char_u *ptr_arg)
  {
      int	    len;
      char_u  *p;
***************
*** 3988,3996 ****
   * Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo
   */
      static buf_T *
! ins_compl_next_buf(buf, flag)
!     buf_T	*buf;
!     int		flag;
  {
  #ifdef FEAT_WINDOWS
      static win_T *wp;
--- 3966,3972 ----
   * Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo
   */
      static buf_T *
! ins_compl_next_buf(buf_T *buf, int flag)
  {
  #ifdef FEAT_WINDOWS
      static win_T *wp;
***************
*** 4031,4039 ****
   * get matches in "matches".
   */
      static void
! expand_by_function(type, base)
!     int		type;	    /* CTRL_X_OMNI or CTRL_X_FUNCTION */
!     char_u	*base;
  {
      list_T      *matchlist = NULL;
      dict_T	*matchdict = NULL;
--- 4007,4015 ----
   * get matches in "matches".
   */
      static void
! expand_by_function(
!     int		type,	    /* CTRL_X_OMNI or CTRL_X_FUNCTION */
!     char_u	*base)
  {
      list_T      *matchlist = NULL;
      dict_T	*matchdict = NULL;
***************
*** 4105,4112 ****
   * Add completions from a list.
   */
      static void
! ins_compl_add_list(list)
!     list_T	*list;
  {
      listitem_T	*li;
      int		dir = compl_direction;
--- 4081,4087 ----
   * Add completions from a list.
   */
      static void
! ins_compl_add_list(list_T *list)
  {
      listitem_T	*li;
      int		dir = compl_direction;
***************
*** 4126,4133 ****
   * Add completions from a dict.
   */
      static void
! ins_compl_add_dict(dict)
!     dict_T	*dict;
  {
      dictitem_T	*di_refresh;
      dictitem_T	*di_words;
--- 4101,4107 ----
   * Add completions from a dict.
   */
      static void
! ins_compl_add_dict(dict_T *dict)
  {
      dictitem_T	*di_refresh;
      dictitem_T	*di_words;
***************
*** 4156,4164 ****
   * maybe because alloc() returns NULL, then FAIL is returned.
   */
      int
! ins_compl_add_tv(tv, dir)
!     typval_T	*tv;
!     int		dir;
  {
      char_u	*word;
      int		icase = FALSE;
--- 4130,4136 ----
   * maybe because alloc() returns NULL, then FAIL is returned.
   */
      int
! ins_compl_add_tv(typval_T *tv, int dir)
  {
      char_u	*word;
      int		icase = FALSE;
***************
*** 4205,4212 ****
   * Return the total number of matches or -1 if still unknown -- Acevedo
   */
      static int
! ins_compl_get_exp(ini)
!     pos_T	*ini;
  {
      static pos_T	first_match_pos;
      static pos_T	last_match_pos;
--- 4177,4183 ----
   * Return the total number of matches or -1 if still unknown -- Acevedo
   */
      static int
! ins_compl_get_exp(pos_T *ini)
  {
      static pos_T	first_match_pos;
      static pos_T	last_match_pos;
***************
*** 4628,4634 ****
  
  /* Delete the old text being completed. */
      static void
! ins_compl_delete()
  {
      int	    i;
  
--- 4599,4605 ----
  
  /* Delete the old text being completed. */
      static void
! ins_compl_delete(void)
  {
      int	    i;
  
***************
*** 4648,4654 ****
  
  /* Insert the new text being completed. */
      static void
! ins_compl_insert()
  {
      dict_T	*dict;
  
--- 4619,4625 ----
  
  /* Insert the new text being completed. */
      static void
! ins_compl_insert(void)
  {
      dict_T	*dict;
  
***************
*** 4694,4704 ****
   * calls this function with "allow_get_expansion" FALSE.
   */
      static int
! ins_compl_next(allow_get_expansion, count, insert_match)
!     int	    allow_get_expansion;
!     int	    count;		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match;	/* Insert the newly selected match */
  {
      int	    num_matches = -1;
      int	    i;
--- 4665,4675 ----
   * calls this function with "allow_get_expansion" FALSE.
   */
      static int
! ins_compl_next(
!     int	    allow_get_expansion,
!     int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match)	/* Insert the newly selected match */
  {
      int	    num_matches = -1;
      int	    i;
***************
*** 4915,4922 ****
   * "frequency" specifies out of how many calls we actually check.
   */
      void
! ins_compl_check_keys(frequency)
!     int		frequency;
  {
      static int	count = 0;
  
--- 4886,4892 ----
   * "frequency" specifies out of how many calls we actually check.
   */
      void
! ins_compl_check_keys(int frequency)
  {
      static int	count = 0;
  
***************
*** 4974,4981 ****
   * Returns BACKWARD or FORWARD.
   */
      static int
! ins_compl_key2dir(c)
!     int		c;
  {
      if (c == Ctrl_P || c == Ctrl_L
  	    || (pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP
--- 4944,4950 ----
   * Returns BACKWARD or FORWARD.
   */
      static int
! ins_compl_key2dir(int c)
  {
      if (c == Ctrl_P || c == Ctrl_L
  	    || (pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP
***************
*** 4989,4996 ****
   * is visible.
   */
      static int
! ins_compl_pum_key(c)
!     int		c;
  {
      return pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP
  		     || c == K_PAGEDOWN || c == K_KPAGEDOWN || c == K_S_DOWN
--- 4958,4964 ----
   * is visible.
   */
      static int
! ins_compl_pum_key(int c)
  {
      return pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP
  		     || c == K_PAGEDOWN || c == K_KPAGEDOWN || c == K_S_DOWN
***************
*** 5002,5009 ****
   * Returns 1 for most keys, height of the popup menu for page-up/down keys.
   */
      static int
! ins_compl_key2count(c)
!     int		c;
  {
      int		h;
  
--- 4970,4976 ----
   * Returns 1 for most keys, height of the popup menu for page-up/down keys.
   */
      static int
! ins_compl_key2count(int c)
  {
      int		h;
  
***************
*** 5022,5029 ****
   * to change the currently selected completion.
   */
      static int
! ins_compl_use_match(c)
!     int		c;
  {
      switch (c)
      {
--- 4989,4995 ----
   * to change the currently selected completion.
   */
      static int
! ins_compl_use_match(int c)
  {
      switch (c)
      {
***************
*** 5046,5053 ****
   * Returns OK if completion was done, FAIL if something failed (out of mem).
   */
      static int
! ins_complete(c)
!     int		c;
  {
      char_u	*line;
      int		startcol = 0;	    /* column where searched text starts */
--- 5012,5018 ----
   * Returns OK if completion was done, FAIL if something failed (out of mem).
   */
      static int
! ins_complete(int c)
  {
      char_u	*line;
      int		startcol = 0;	    /* column where searched text starts */
***************
*** 5668,5677 ****
   * Returns the length (needed) of dest
   */
      static unsigned
! quote_meta(dest, src, len)
!     char_u	*dest;
!     char_u	*src;
!     int		len;
  {
      unsigned	m = (unsigned)len + 1;  /* one extra for the NUL */
  
--- 5633,5639 ----
   * Returns the length (needed) of dest
   */
      static unsigned
! quote_meta(char_u *dest, char_u *src, int len)
  {
      unsigned	m = (unsigned)len + 1;  /* one extra for the NUL */
  
***************
*** 5733,5739 ****
   * For Unicode a character > 255 may be returned.
   */
      int
! get_literal()
  {
      int		cc;
      int		nc;
--- 5695,5701 ----
   * For Unicode a character > 255 may be returned.
   */
      int
! get_literal(void)
  {
      int		cc;
      int		nc;
***************
*** 5870,5879 ****
   * Insert character, taking care of special keys and mod_mask
   */
      static void
! insert_special(c, allow_modmask, ctrlv)
!     int	    c;
!     int	    allow_modmask;
!     int	    ctrlv;	    /* c was typed after CTRL-V */
  {
      char_u  *p;
      int	    len;
--- 5832,5841 ----
   * Insert character, taking care of special keys and mod_mask
   */
      static void
! insert_special(
!     int	    c,
!     int	    allow_modmask,
!     int	    ctrlv)	    /* c was typed after CTRL-V */
  {
      char_u  *p;
      int	    len;
***************
*** 5941,5950 ****
   *	    INSCHAR_COM_LIST - format comments with num list or 2nd line indent
   */
      void
! insertchar(c, flags, second_indent)
!     int		c;			/* character to insert or NUL */
!     int		flags;			/* INSCHAR_FORMAT, etc. */
!     int		second_indent;		/* indent for second line if >= 0 */
  {
      int		textwidth;
  #ifdef FEAT_COMMENTS
--- 5903,5912 ----
   *	    INSCHAR_COM_LIST - format comments with num list or 2nd line indent
   */
      void
! insertchar(
!     int		c,			/* character to insert or NUL */
!     int		flags,			/* INSCHAR_FORMAT, etc. */
!     int		second_indent)		/* indent for second line if >= 0 */
  {
      int		textwidth;
  #ifdef FEAT_COMMENTS
***************
*** 6191,6202 ****
   * will be the comment leader length sent to open_line().
   */
      static void
! internal_format(textwidth, second_indent, flags, format_only, c)
!     int		textwidth;
!     int		second_indent;
!     int		flags;
!     int		format_only;
!     int		c; /* character to be inserted (can be NUL) */
  {
      int		cc;
      int		save_char = NUL;
--- 6153,6164 ----
   * will be the comment leader length sent to open_line().
   */
      static void
! internal_format(
!     int		textwidth,
!     int		second_indent,
!     int		flags,
!     int		format_only,
!     int		c) /* character to be inserted (can be NUL) */
  {
      int		cc;
      int		save_char = NUL;
***************
*** 6588,6596 ****
   * saved here.
   */
      void
! auto_format(trailblank, prev_line)
!     int		trailblank;	/* when TRUE also format with trailing blank */
!     int		prev_line;	/* may start in previous line */
  {
      pos_T	pos;
      colnr_T	len;
--- 6550,6558 ----
   * saved here.
   */
      void
! auto_format(
!     int		trailblank,	/* when TRUE also format with trailing blank */
!     int		prev_line)	/* may start in previous line */
  {
      pos_T	pos;
      colnr_T	len;
***************
*** 6699,6706 ****
   * position.
   */
      static void
! check_auto_format(end_insert)
!     int		end_insert;	    /* TRUE when ending Insert mode */
  {
      int		c = ' ';
      int		cc;
--- 6661,6668 ----
   * position.
   */
      static void
! check_auto_format(
!     int		end_insert)	    /* TRUE when ending Insert mode */
  {
      int		c = ' ';
      int		cc;
***************
*** 6737,6744 ****
   *	Set default to window width (maximum 79) for "gq" operator.
   */
      int
! comp_textwidth(ff)
!     int		ff;	/* force formatting (for "gq" command) */
  {
      int		textwidth;
  
--- 6699,6706 ----
   *	Set default to window width (maximum 79) for "gq" operator.
   */
      int
! comp_textwidth(
!     int		ff)	/* force formatting (for "gq" command) */
  {
      int		textwidth;
  
***************
*** 6781,6788 ****
   * Put a character in the redo buffer, for when just after a CTRL-V.
   */
      static void
! redo_literal(c)
!     int	    c;
  {
      char_u	buf[10];
  
--- 6743,6749 ----
   * Put a character in the redo buffer, for when just after a CTRL-V.
   */
      static void
! redo_literal(int c)
  {
      char_u	buf[10];
  
***************
*** 6802,6809 ****
   * For undo/redo it resembles hitting the <ESC> key.
   */
      static void
! start_arrow(end_insert_pos)
!     pos_T    *end_insert_pos;		/* can be NULL */
  {
      start_arrow_common(end_insert_pos, TRUE);
  }
--- 6763,6770 ----
   * For undo/redo it resembles hitting the <ESC> key.
   */
      static void
! start_arrow(
!     pos_T    *end_insert_pos)		/* can be NULL */
  {
      start_arrow_common(end_insert_pos, TRUE);
  }
***************
*** 6813,6821 ****
   * Will prepare for redo of CTRL-G U if "end_change" is FALSE.
   */
      static void
! start_arrow_with_change(end_insert_pos, end_change)
!     pos_T    *end_insert_pos;		/* can be NULL */
!     int	      end_change;		/* end undoable change */
  {
      start_arrow_common(end_insert_pos, end_change);
      if (!end_change)
--- 6774,6782 ----
   * Will prepare for redo of CTRL-G U if "end_change" is FALSE.
   */
      static void
! start_arrow_with_change(
!     pos_T    *end_insert_pos,		/* can be NULL */
!     int	      end_change)		/* end undoable change */
  {
      start_arrow_common(end_insert_pos, end_change);
      if (!end_change)
***************
*** 6826,6834 ****
  }
  
      static void
! start_arrow_common(end_insert_pos, end_change)
!     pos_T    *end_insert_pos;		/* can be NULL */
!     int	      end_change;		/* end undoable change */
  {
      if (!arrow_used && end_change)	/* something has been inserted */
      {
--- 6787,6795 ----
  }
  
      static void
! start_arrow_common(
!     pos_T    *end_insert_pos,		/* can be NULL */
!     int	      end_change)		/* end undoable change */
  {
      if (!arrow_used && end_change)	/* something has been inserted */
      {
***************
*** 6847,6853 ****
   * It may be skipped again, thus reset spell_redraw_lnum first.
   */
      static void
! check_spell_redraw()
  {
      if (spell_redraw_lnum != 0)
      {
--- 6808,6814 ----
   * It may be skipped again, thus reset spell_redraw_lnum first.
   */
      static void
! check_spell_redraw(void)
  {
      if (spell_redraw_lnum != 0)
      {
***************
*** 6863,6869 ****
   * spelled word, if there is one.
   */
      static void
! spell_back_to_badword()
  {
      pos_T	tpos = curwin->w_cursor;
  
--- 6824,6830 ----
   * spelled word, if there is one.
   */
      static void
! spell_back_to_badword(void)
  {
      pos_T	tpos = curwin->w_cursor;
  
***************
*** 6879,6885 ****
   * Returns FAIL if undo is impossible, shouldn't insert then.
   */
      int
! stop_arrow()
  {
      if (arrow_used)
      {
--- 6840,6846 ----
   * Returns FAIL if undo is impossible, shouldn't insert then.
   */
      int
! stop_arrow(void)
  {
      if (arrow_used)
      {
***************
*** 6928,6937 ****
   * to another window/buffer.
   */
      static void
! stop_insert(end_insert_pos, esc, nomove)
!     pos_T	*end_insert_pos;
!     int		esc;			/* called by ins_esc() */
!     int		nomove;			/* <c-\><c-o>, don't move cursor */
  {
      int		cc;
      char_u	*ptr;
--- 6889,6898 ----
   * to another window/buffer.
   */
      static void
! stop_insert(
!     pos_T	*end_insert_pos,
!     int		esc,			/* called by ins_esc() */
!     int		nomove)			/* <c-\><c-o>, don't move cursor */
  {
      int		cc;
      char_u	*ptr;
***************
*** 7069,7076 ****
   * Used for the replace command.
   */
      void
! set_last_insert(c)
!     int		c;
  {
      char_u	*s;
  
--- 7030,7036 ----
   * Used for the replace command.
   */
      void
! set_last_insert(int c)
  {
      char_u	*s;
  
***************
*** 7091,7097 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_last_insert()
  {
      vim_free(last_insert);
      last_insert = NULL;
--- 7051,7057 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_last_insert(void)
  {
      vim_free(last_insert);
      last_insert = NULL;
***************
*** 7108,7116 ****
   * Returns a pointer to after the added bytes.
   */
      char_u *
! add_char2buf(c, s)
!     int		c;
!     char_u	*s;
  {
  #ifdef FEAT_MBYTE
      char_u	temp[MB_MAXBYTES + 1];
--- 7068,7074 ----
   * Returns a pointer to after the added bytes.
   */
      char_u *
! add_char2buf(int c, char_u *s)
  {
  #ifdef FEAT_MBYTE
      char_u	temp[MB_MAXBYTES + 1];
***************
*** 7153,7160 ****
   * if flags & BL_FIX	don't leave the cursor on a NUL.
   */
      void
! beginline(flags)
!     int		flags;
  {
      if ((flags & BL_SOL) && !p_sol)
  	coladvance(curwin->w_curswant);
--- 7111,7117 ----
   * if flags & BL_FIX	don't leave the cursor on a NUL.
   */
      void
! beginline(int flags)
  {
      if ((flags & BL_SOL) && !p_sol)
  	coladvance(curwin->w_curswant);
***************
*** 7186,7192 ****
   */
  
      int
! oneright()
  {
      char_u	*ptr;
      int		l;
--- 7143,7149 ----
   */
  
      int
! oneright(void)
  {
      char_u	*ptr;
      int		l;
***************
*** 7239,7245 ****
  }
  
      int
! oneleft()
  {
  #ifdef FEAT_VIRTUALEDIT
      if (virtual_active())
--- 7196,7202 ----
  }
  
      int
! oneleft(void)
  {
  #ifdef FEAT_VIRTUALEDIT
      if (virtual_active())
***************
*** 7308,7316 ****
  }
  
      int
! cursor_up(n, upd_topline)
!     long	n;
!     int		upd_topline;	    /* When TRUE: update topline */
  {
      linenr_T	lnum;
  
--- 7265,7273 ----
  }
  
      int
! cursor_up(
!     long	n,
!     int		upd_topline)	    /* When TRUE: update topline */
  {
      linenr_T	lnum;
  
***************
*** 7367,7375 ****
   * Cursor down a number of logical lines.
   */
      int
! cursor_down(n, upd_topline)
!     long	n;
!     int		upd_topline;	    /* When TRUE: update topline */
  {
      linenr_T	lnum;
  
--- 7324,7332 ----
   * Cursor down a number of logical lines.
   */
      int
! cursor_down(
!     long	n,
!     int		upd_topline)	    /* When TRUE: update topline */
  {
      linenr_T	lnum;
  
***************
*** 7428,7437 ****
   * first have to remove the command.
   */
      int
! stuff_inserted(c, count, no_esc)
!     int	    c;		/* Command character to be inserted */
!     long    count;	/* Repeat this many times */
!     int	    no_esc;	/* Don't add an ESC at the end */
  {
      char_u	*esc_ptr;
      char_u	*ptr;
--- 7385,7394 ----
   * first have to remove the command.
   */
      int
! stuff_inserted(
!     int	    c,		/* Command character to be inserted */
!     long    count,	/* Repeat this many times */
!     int	    no_esc)	/* Don't add an ESC at the end */
  {
      char_u	*esc_ptr;
      char_u	*ptr;
***************
*** 7488,7494 ****
  }
  
      char_u *
! get_last_insert()
  {
      if (last_insert == NULL)
  	return NULL;
--- 7445,7451 ----
  }
  
      char_u *
! get_last_insert(void)
  {
      if (last_insert == NULL)
  	return NULL;
***************
*** 7500,7506 ****
   * Returns pointer to allocated memory (must be freed) or NULL.
   */
      char_u *
! get_last_insert_save()
  {
      char_u	*s;
      int		len;
--- 7457,7463 ----
   * Returns pointer to allocated memory (must be freed) or NULL.
   */
      char_u *
! get_last_insert_save(void)
  {
      char_u	*s;
      int		len;
***************
*** 7524,7531 ****
   * the replacement string is inserted in typebuf.tb_buf[], followed by "c".
   */
      static int
! echeck_abbr(c)
!     int c;
  {
      /* Don't check for abbreviation in paste mode, when disabled and just
       * after moving around with cursor keys. */
--- 7481,7487 ----
   * the replacement string is inserted in typebuf.tb_buf[], followed by "c".
   */
      static int
! echeck_abbr(int c)
  {
      /* Don't check for abbreviation in paste mode, when disabled and just
       * after moving around with cursor keys. */
***************
*** 7560,7567 ****
  static long	replace_stack_len = 0;	    /* max. number of entries */
  
      void
! replace_push(c)
!     int	    c;	    /* character that is replaced (NUL is none) */
  {
      char_u  *p;
  
--- 7516,7523 ----
  static long	replace_stack_len = 0;	    /* max. number of entries */
  
      void
! replace_push(
!     int	    c)	    /* character that is replaced (NUL is none) */
  {
      char_u  *p;
  
***************
*** 7598,7605 ****
   * Return the number of bytes done (includes composing characters).
   */
      int
! replace_push_mb(p)
!     char_u *p;
  {
      int l = (*mb_ptr2len)(p);
      int j;
--- 7554,7560 ----
   * Return the number of bytes done (includes composing characters).
   */
      int
! replace_push_mb(char_u *p)
  {
      int l = (*mb_ptr2len)(p);
      int j;
***************
*** 7616,7622 ****
   * return replaced character or NUL otherwise
   */
      static int
! replace_pop()
  {
      if (replace_stack_nr == 0)
  	return -1;
--- 7571,7577 ----
   * return replaced character or NUL otherwise
   */
      static int
! replace_pop(void)
  {
      if (replace_stack_nr == 0)
  	return -1;
***************
*** 7628,7635 ****
   * encountered.
   */
      static void
! replace_join(off)
!     int	    off;	/* offset for which NUL to remove */
  {
      int	    i;
  
--- 7583,7590 ----
   * encountered.
   */
      static void
! replace_join(
!     int	    off)	/* offset for which NUL to remove */
  {
      int	    i;
  
***************
*** 7648,7654 ****
   * before the cursor.  Can only be used in REPLACE or VREPLACE mode.
   */
      static void
! replace_pop_ins()
  {
      int	    cc;
      int	    oldState = State;
--- 7603,7609 ----
   * before the cursor.  Can only be used in REPLACE or VREPLACE mode.
   */
      static void
! replace_pop_ins(void)
  {
      int	    cc;
      int	    oldState = State;
***************
*** 7672,7679 ****
   * indicates a multi-byte char, pop the other bytes too.
   */
      static void
! mb_replace_pop_ins(cc)
!     int		cc;
  {
      int		n;
      char_u	buf[MB_MAXBYTES + 1];
--- 7627,7633 ----
   * indicates a multi-byte char, pop the other bytes too.
   */
      static void
! mb_replace_pop_ins(int cc)
  {
      int		n;
      char_u	buf[MB_MAXBYTES + 1];
***************
*** 7727,7733 ****
   * (called when exiting replace mode)
   */
      static void
! replace_flush()
  {
      vim_free(replace_stack);
      replace_stack = NULL;
--- 7681,7687 ----
   * (called when exiting replace mode)
   */
      static void
! replace_flush(void)
  {
      vim_free(replace_stack);
      replace_stack = NULL;
***************
*** 7745,7752 ****
   * using composing characters, use del_char_after_col() instead of del_char().
   */
      static void
! replace_do_bs(limit_col)
!     int		limit_col;
  {
      int		cc;
  #ifdef FEAT_VREPLACE
--- 7699,7705 ----
   * using composing characters, use del_char_after_col() instead of del_char().
   */
      static void
! replace_do_bs(int limit_col)
  {
      int		cc;
  #ifdef FEAT_VREPLACE
***************
*** 7832,7838 ****
   * Return TRUE if C-indenting is on.
   */
      static int
! cindent_on()
  {
      return (!p_paste && (curbuf->b_p_cin
  # ifdef FEAT_EVAL
--- 7785,7791 ----
   * Return TRUE if C-indenting is on.
   */
      static int
! cindent_on(void)
  {
      return (!p_paste && (curbuf->b_p_cin
  # ifdef FEAT_EVAL
***************
*** 7851,7858 ****
   */
  
      void
! fixthisline(get_the_indent)
!     int (*get_the_indent)(void);
  {
      int amount = get_the_indent();
  
--- 7804,7810 ----
   */
  
      void
! fixthisline(int (*get_the_indent)(void))
  {
      int amount = get_the_indent();
  
***************
*** 7865,7871 ****
  }
  
      void
! fix_indent()
  {
      if (p_paste)
  	return;
--- 7817,7823 ----
  }
  
      void
! fix_indent(void)
  {
      if (p_paste)
  	return;
***************
*** 7899,7908 ****
   * If line_is_empty is TRUE accept keys with '0' before them.
   */
      int
! in_cinkeys(keytyped, when, line_is_empty)
!     int		keytyped;
!     int		when;
!     int		line_is_empty;
  {
      char_u	*look;
      int		try_match;
--- 7851,7860 ----
   * If line_is_empty is TRUE accept keys with '0' before them.
   */
      int
! in_cinkeys(
!     int		keytyped,
!     int		when,
!     int		line_is_empty)
  {
      char_u	*look;
      int		try_match;
***************
*** 8161,8168 ****
   * Map Hebrew keyboard when in hkmap mode.
   */
      int
! hkmap(c)
!     int c;
  {
      if (p_hkmapp)   /* phonetic mapping, by Ilya Dogolazky */
      {
--- 8113,8119 ----
   * Map Hebrew keyboard when in hkmap mode.
   */
      int
! hkmap(int c)
  {
      if (p_hkmapp)   /* phonetic mapping, by Ilya Dogolazky */
      {
***************
*** 8242,8248 ****
  #endif
  
      static void
! ins_reg()
  {
      int		need_redraw = FALSE;
      int		regname;
--- 8193,8199 ----
  #endif
  
      static void
! ins_reg(void)
  {
      int		need_redraw = FALSE;
      int		regname;
***************
*** 8360,8366 ****
   * CTRL-G commands in Insert mode.
   */
      static void
! ins_ctrl_g()
  {
      int		c;
  
--- 8311,8317 ----
   * CTRL-G commands in Insert mode.
   */
      static void
! ins_ctrl_g(void)
  {
      int		c;
  
***************
*** 8416,8422 ****
   * CTRL-^ in Insert mode.
   */
      static void
! ins_ctrl_hat()
  {
      if (map_to_exists_mode((char_u *)"", LANGMAP, FALSE))
      {
--- 8367,8373 ----
   * CTRL-^ in Insert mode.
   */
      static void
! ins_ctrl_hat(void)
  {
      if (map_to_exists_mode((char_u *)"", LANGMAP, FALSE))
      {
***************
*** 8471,8480 ****
   * insert.
   */
      static int
! ins_esc(count, cmdchar, nomove)
!     long	*count;
!     int		cmdchar;
!     int		nomove;	    /* don't move cursor */
  {
      int		temp;
      static int	disabled_redraw = FALSE;
--- 8422,8431 ----
   * insert.
   */
      static int
! ins_esc(
!     long	*count,
!     int		cmdchar,
!     int		nomove)	    /* don't move cursor */
  {
      int		temp;
      static int	disabled_redraw = FALSE;
***************
*** 8620,8626 ****
   * Move to end of reverse inserted text.
   */
      static void
! ins_ctrl_()
  {
      if (revins_on && revins_chars && revins_scol >= 0)
      {
--- 8571,8577 ----
   * Move to end of reverse inserted text.
   */
      static void
! ins_ctrl_(void)
  {
      if (revins_on && revins_chars && revins_scol >= 0)
      {
***************
*** 8664,8671 ****
   * Returns TRUE when a CTRL-O and other keys stuffed.
   */
      static int
! ins_start_select(c)
!     int		c;
  {
      if (km_startsel)
  	switch (c)
--- 8615,8621 ----
   * Returns TRUE when a CTRL-O and other keys stuffed.
   */
      static int
! ins_start_select(int c)
  {
      if (km_startsel)
  	switch (c)
***************
*** 8719,8726 ****
   * <Insert> key in Insert mode: toggle insert/replace mode.
   */
      static void
! ins_insert(replaceState)
!     int	    replaceState;
  {
  #ifdef FEAT_FKMAP
      if (p_fkmap && p_ri)
--- 8669,8675 ----
   * <Insert> key in Insert mode: toggle insert/replace mode.
   */
      static void
! ins_insert(int replaceState)
  {
  #ifdef FEAT_FKMAP
      if (p_fkmap && p_ri)
***************
*** 8757,8763 ****
   * Pressed CTRL-O in Insert mode.
   */
      static void
! ins_ctrl_o()
  {
  #ifdef FEAT_VREPLACE
      if (State & VREPLACE_FLAG)
--- 8706,8712 ----
   * Pressed CTRL-O in Insert mode.
   */
      static void
! ins_ctrl_o(void)
  {
  #ifdef FEAT_VREPLACE
      if (State & VREPLACE_FLAG)
***************
*** 8784,8792 ****
   * autoindent, we support it everywhere.
   */
      static void
! ins_shift(c, lastc)
!     int	    c;
!     int	    lastc;
  {
      if (stop_arrow() == FAIL)
  	return;
--- 8733,8739 ----
   * autoindent, we support it everywhere.
   */
      static void
! ins_shift(int c, int lastc)
  {
      if (stop_arrow() == FAIL)
  	return;
***************
*** 8823,8829 ****
  }
  
      static void
! ins_del()
  {
      int	    temp;
  
--- 8770,8776 ----
  }
  
      static void
! ins_del(void)
  {
      int	    temp;
  
***************
*** 8855,8862 ****
   * Delete one character for ins_bs().
   */
      static void
! ins_bs_one(vcolp)
!     colnr_T	*vcolp;
  {
      dec_cursor();
      getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);
--- 8802,8808 ----
   * Delete one character for ins_bs().
   */
      static void
! ins_bs_one(colnr_T *vcolp)
  {
      dec_cursor();
      getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);
***************
*** 8877,8886 ****
   * Return TRUE when backspace was actually used.
   */
      static int
! ins_bs(c, mode, inserted_space_p)
!     int		c;
!     int		mode;
!     int		*inserted_space_p;
  {
      linenr_T	lnum;
      int		cc;
--- 8823,8832 ----
   * Return TRUE when backspace was actually used.
   */
      static int
! ins_bs(
!     int		c,
!     int		mode,
!     int		*inserted_space_p)
  {
      linenr_T	lnum;
      int		cc;
***************
*** 9287,9294 ****
  
  #ifdef FEAT_MOUSE
      static void
! ins_mouse(c)
!     int	    c;
  {
      pos_T	tpos;
      win_T	*old_curwin = curwin;
--- 9233,9239 ----
  
  #ifdef FEAT_MOUSE
      static void
! ins_mouse(int c)
  {
      pos_T	tpos;
      win_T	*old_curwin = curwin;
***************
*** 9335,9342 ****
  }
  
      static void
! ins_mousescroll(dir)
!     int		dir;
  {
      pos_T	tpos;
  # if defined(FEAT_WINDOWS)
--- 9280,9286 ----
  }
  
      static void
! ins_mousescroll(int dir)
  {
      pos_T	tpos;
  # if defined(FEAT_WINDOWS)
***************
*** 9429,9436 ****
  
  #if defined(FEAT_GUI_TABLINE) || defined(PROTO)
      static void
! ins_tabline(c)
!     int		c;
  {
      /* We will be leaving the current window, unless closing another tab. */
      if (c != K_TABMENU || current_tabmenu != TABLINE_MENU_CLOSE
--- 9373,9379 ----
  
  #if defined(FEAT_GUI_TABLINE) || defined(PROTO)
      static void
! ins_tabline(int c)
  {
      /* We will be leaving the current window, unless closing another tab. */
      if (c != K_TABMENU || current_tabmenu != TABLINE_MENU_CLOSE
***************
*** 9455,9461 ****
  
  #if defined(FEAT_GUI) || defined(PROTO)
      void
! ins_scroll()
  {
      pos_T	tpos;
  
--- 9398,9404 ----
  
  #if defined(FEAT_GUI) || defined(PROTO)
      void
! ins_scroll(void)
  {
      pos_T	tpos;
  
***************
*** 9471,9477 ****
  }
  
      void
! ins_horscroll()
  {
      pos_T	tpos;
  
--- 9414,9420 ----
  }
  
      void
! ins_horscroll(void)
  {
      pos_T	tpos;
  
***************
*** 9488,9495 ****
  #endif
  
      static void
! ins_left(end_change)
!     int	    end_change; /* end undoable change */
  {
      pos_T	tpos;
  
--- 9431,9438 ----
  #endif
  
      static void
! ins_left(
!     int	    end_change) /* end undoable change */
  {
      pos_T	tpos;
  
***************
*** 9537,9544 ****
  }
  
      static void
! ins_home(c)
!     int		c;
  {
      pos_T	tpos;
  
--- 9480,9486 ----
  }
  
      static void
! ins_home(int c)
  {
      pos_T	tpos;
  
***************
*** 9559,9566 ****
  }
  
      static void
! ins_end(c)
!     int		c;
  {
      pos_T	tpos;
  
--- 9501,9507 ----
  }
  
      static void
! ins_end(int c)
  {
      pos_T	tpos;
  
***************
*** 9579,9585 ****
  }
  
      static void
! ins_s_left()
  {
  #ifdef FEAT_FOLDING
      if ((fdo_flags & FDO_HOR) && KeyTyped)
--- 9520,9526 ----
  }
  
      static void
! ins_s_left(void)
  {
  #ifdef FEAT_FOLDING
      if ((fdo_flags & FDO_HOR) && KeyTyped)
***************
*** 9597,9604 ****
  }
  
      static void
! ins_right(end_change)
!     int	    end_change; /* end undoable change */
  {
  #ifdef FEAT_FOLDING
      if ((fdo_flags & FDO_HOR) && KeyTyped)
--- 9538,9545 ----
  }
  
      static void
! ins_right(
!     int	    end_change) /* end undoable change */
  {
  #ifdef FEAT_FOLDING
      if ((fdo_flags & FDO_HOR) && KeyTyped)
***************
*** 9651,9657 ****
  }
  
      static void
! ins_s_right()
  {
  #ifdef FEAT_FOLDING
      if ((fdo_flags & FDO_HOR) && KeyTyped)
--- 9592,9598 ----
  }
  
      static void
! ins_s_right(void)
  {
  #ifdef FEAT_FOLDING
      if ((fdo_flags & FDO_HOR) && KeyTyped)
***************
*** 9670,9677 ****
  }
  
      static void
! ins_up(startcol)
!     int		startcol;	/* when TRUE move to Insstart.col */
  {
      pos_T	tpos;
      linenr_T	old_topline = curwin->w_topline;
--- 9611,9618 ----
  }
  
      static void
! ins_up(
!     int		startcol)	/* when TRUE move to Insstart.col */
  {
      pos_T	tpos;
      linenr_T	old_topline = curwin->w_topline;
***************
*** 9701,9707 ****
  }
  
      static void
! ins_pageup()
  {
      pos_T	tpos;
  
--- 9642,9648 ----
  }
  
      static void
! ins_pageup(void)
  {
      pos_T	tpos;
  
***************
*** 9733,9740 ****
  }
  
      static void
! ins_down(startcol)
!     int		startcol;	/* when TRUE move to Insstart.col */
  {
      pos_T	tpos;
      linenr_T	old_topline = curwin->w_topline;
--- 9674,9681 ----
  }
  
      static void
! ins_down(
!     int		startcol)	/* when TRUE move to Insstart.col */
  {
      pos_T	tpos;
      linenr_T	old_topline = curwin->w_topline;
***************
*** 9764,9770 ****
  }
  
      static void
! ins_pagedown()
  {
      pos_T	tpos;
  
--- 9705,9711 ----
  }
  
      static void
! ins_pagedown(void)
  {
      pos_T	tpos;
  
***************
*** 9797,9803 ****
  
  #ifdef FEAT_DND
      static void
! ins_drop()
  {
      do_put('~', BACKWARD, 1L, PUT_CURSEND);
  }
--- 9738,9744 ----
  
  #ifdef FEAT_DND
      static void
! ins_drop(void)
  {
      do_put('~', BACKWARD, 1L, PUT_CURSEND);
  }
***************
*** 9808,9814 ****
   * Return TRUE when the TAB needs to be inserted like a normal character.
   */
      static int
! ins_tab()
  {
      int		ind;
      int		i;
--- 9749,9755 ----
   * Return TRUE when the TAB needs to be inserted like a normal character.
   */
      static int
! ins_tab(void)
  {
      int		ind;
      int		i;
***************
*** 10035,10042 ****
   * Return TRUE when out of memory or can't undo.
   */
      static int
! ins_eol(c)
!     int		c;
  {
      int	    i;
  
--- 9976,9982 ----
   * Return TRUE when out of memory or can't undo.
   */
      static int
! ins_eol(int c)
  {
      int	    i;
  
***************
*** 10108,10114 ****
   * done.
   */
      static int
! ins_digraph()
  {
      int	    c;
      int	    cc;
--- 10048,10054 ----
   * done.
   */
      static int
! ins_digraph(void)
  {
      int	    c;
      int	    cc;
***************
*** 10200,10207 ****
   * Returns the char to be inserted, or NUL if none found.
   */
      int
! ins_copychar(lnum)
!     linenr_T	lnum;
  {
      int	    c;
      int	    temp;
--- 10140,10146 ----
   * Returns the char to be inserted, or NUL if none found.
   */
      int
! ins_copychar(linenr_T lnum)
  {
      int	    c;
      int	    temp;
***************
*** 10241,10248 ****
   * CTRL-Y or CTRL-E typed in Insert mode.
   */
      static int
! ins_ctrl_ey(tc)
!     int	    tc;
  {
      int	    c = tc;
  
--- 10180,10186 ----
   * CTRL-Y or CTRL-E typed in Insert mode.
   */
      static int
! ins_ctrl_ey(int tc)
  {
      int	    c = tc;
  
***************
*** 10290,10297 ****
   * Used when inserting a "normal" character.
   */
      static void
! ins_try_si(c)
!     int	    c;
  {
      pos_T	*pos, old_pos;
      char_u	*ptr;
--- 10228,10234 ----
   * Used when inserting a "normal" character.
   */
      static void
! ins_try_si(int c)
  {
      pos_T	*pos, old_pos;
      char_u	*ptr;
***************
*** 10383,10389 ****
   * Unless 'cpo' contains the 'L' flag.
   */
      static colnr_T
! get_nolist_virtcol()
  {
      if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)
  	return getvcol_nolist(&curwin->w_cursor);
--- 10320,10326 ----
   * Unless 'cpo' contains the 'L' flag.
   */
      static colnr_T
! get_nolist_virtcol(void)
  {
      if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)
  	return getvcol_nolist(&curwin->w_cursor);
***************
*** 10399,10406 ****
   * Return NULL to continue inserting "c".
   */
      static char_u *
! do_insert_char_pre(c)
!     int c;
  {
      char_u	*res;
      char_u	buf[MB_MAXBYTES + 1];
--- 10336,10342 ----
   * Return NULL to continue inserting "c".
   */
      static char_u *
! do_insert_char_pre(int c)
  {
      char_u	*res;
      char_u	buf[MB_MAXBYTES + 1];
*** ../vim-7.4.1204/src/eval.c	2016-01-28 22:36:15.052065044 +0100
--- src/eval.c	2016-01-30 15:10:36.013580950 +0100
***************
*** 890,896 ****
   * Initialize the global and v: variables.
   */
      void
! eval_init()
  {
      int		    i;
      struct vimvar   *p;
--- 890,896 ----
   * Initialize the global and v: variables.
   */
      void
! eval_init(void)
  {
      int		    i;
      struct vimvar   *p;
***************
*** 941,947 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! eval_clear()
  {
      int		    i;
      struct vimvar   *p;
--- 941,947 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! eval_clear(void)
  {
      int		    i;
      struct vimvar   *p;
***************
*** 1006,1013 ****
   * Return the address holding the next breakpoint line for a funccall cookie.
   */
      linenr_T *
! func_breakpoint(cookie)
!     void *cookie;
  {
      return &((funccall_T *)cookie)->breakpoint;
  }
--- 1006,1012 ----
   * Return the address holding the next breakpoint line for a funccall cookie.
   */
      linenr_T *
! func_breakpoint(void *cookie)
  {
      return &((funccall_T *)cookie)->breakpoint;
  }
***************
*** 1041,1047 ****
   * Return TRUE when a function was ended by a ":return" command.
   */
      int
! current_func_returned()
  {
      return current_funccal->returned;
  }
--- 1040,1046 ----
   * Return TRUE when a function was ended by a ":return" command.
   */
      int
! current_func_returned(void)
  {
      return current_funccal->returned;
  }
***************
*** 1183,1189 ****
   * Frees the allocated memory.
   */
      void
! var_redir_stop()
  {
      typval_T	tv;
  
--- 1182,1188 ----
   * Frees the allocated memory.
   */
      void
! var_redir_stop(void)
  {
      typval_T	tv;
  
***************
*** 1244,1252 ****
  
  # if defined(FEAT_POSTSCRIPT) || defined(PROTO)
      int
! eval_printexpr(fname, args)
!     char_u	*fname;
!     char_u	*args;
  {
      int		err = FALSE;
  
--- 1243,1249 ----
  
  # if defined(FEAT_POSTSCRIPT) || defined(PROTO)
      int
! eval_printexpr(char_u *fname, char_u *args)
  {
      int		err = FALSE;
  
***************
*** 1268,1277 ****
  
  # if defined(FEAT_DIFF) || defined(PROTO)
      void
! eval_diff(origfile, newfile, outfile)
!     char_u	*origfile;
!     char_u	*newfile;
!     char_u	*outfile;
  {
      int		err = FALSE;
  
--- 1265,1274 ----
  
  # if defined(FEAT_DIFF) || defined(PROTO)
      void
! eval_diff(
!     char_u	*origfile,
!     char_u	*newfile,
!     char_u	*outfile)
  {
      int		err = FALSE;
  
***************
*** 1285,1294 ****
  }
  
      void
! eval_patch(origfile, difffile, outfile)
!     char_u	*origfile;
!     char_u	*difffile;
!     char_u	*outfile;
  {
      int		err;
  
--- 1282,1291 ----
  }
  
      void
! eval_patch(
!     char_u	*origfile,
!     char_u	*difffile,
!     char_u	*outfile)
  {
      int		err;
  
***************
*** 1308,1318 ****
   * Return TRUE or FALSE.
   */
      int
! eval_to_bool(arg, error, nextcmd, skip)
!     char_u	*arg;
!     int		*error;
!     char_u	**nextcmd;
!     int		skip;	    /* only parse, don't execute */
  {
      typval_T	tv;
      int		retval = FALSE;
--- 1305,1315 ----
   * Return TRUE or FALSE.
   */
      int
! eval_to_bool(
!     char_u	*arg,
!     int		*error,
!     char_u	**nextcmd,
!     int		skip)	    /* only parse, don't execute */
  {
      typval_T	tv;
      int		retval = FALSE;
***************
*** 1342,1351 ****
   * pointer to allocated memory, or NULL for failure or when "skip" is TRUE.
   */
      char_u *
! eval_to_string_skip(arg, nextcmd, skip)
!     char_u	*arg;
!     char_u	**nextcmd;
!     int		skip;	    /* only parse, don't execute */
  {
      typval_T	tv;
      char_u	*retval;
--- 1339,1348 ----
   * pointer to allocated memory, or NULL for failure or when "skip" is TRUE.
   */
      char_u *
! eval_to_string_skip(
!     char_u	*arg,
!     char_u	**nextcmd,
!     int		skip)	    /* only parse, don't execute */
  {
      typval_T	tv;
      char_u	*retval;
***************
*** 1370,1377 ****
   * Return FAIL for an error, OK otherwise.
   */
      int
! skip_expr(pp)
!     char_u	**pp;
  {
      typval_T	rettv;
  
--- 1367,1373 ----
   * Return FAIL for an error, OK otherwise.
   */
      int
! skip_expr(char_u **pp)
  {
      typval_T	rettv;
  
***************
*** 1386,1395 ****
   * Return pointer to allocated memory, or NULL for failure.
   */
      char_u *
! eval_to_string(arg, nextcmd, convert)
!     char_u	*arg;
!     char_u	**nextcmd;
!     int		convert;
  {
      typval_T	tv;
      char_u	*retval;
--- 1382,1391 ----
   * Return pointer to allocated memory, or NULL for failure.
   */
      char_u *
! eval_to_string(
!     char_u	*arg,
!     char_u	**nextcmd,
!     int		convert)
  {
      typval_T	tv;
      char_u	*retval;
***************
*** 1434,1443 ****
   * textlock.  When "use_sandbox" is TRUE use the sandbox.
   */
      char_u *
! eval_to_string_safe(arg, nextcmd, use_sandbox)
!     char_u	*arg;
!     char_u	**nextcmd;
!     int		use_sandbox;
  {
      char_u	*retval;
      void	*save_funccalp;
--- 1430,1439 ----
   * textlock.  When "use_sandbox" is TRUE use the sandbox.
   */
      char_u *
! eval_to_string_safe(
!     char_u	*arg,
!     char_u	**nextcmd,
!     int		use_sandbox)
  {
      char_u	*retval;
      void	*save_funccalp;
***************
*** 1460,1467 ****
   * Returns -1 for an error.
   */
      int
! eval_to_number(expr)
!     char_u	*expr;
  {
      typval_T	rettv;
      int		retval;
--- 1456,1462 ----
   * Returns -1 for an error.
   */
      int
! eval_to_number(char_u *expr)
  {
      typval_T	rettv;
      int		retval;
***************
*** 1487,1495 ****
   * When not used yet add the variable to the v: hashtable.
   */
      static void
! prepare_vimvar(idx, save_tv)
!     int		idx;
!     typval_T	*save_tv;
  {
      *save_tv = vimvars[idx].vv_tv;
      if (vimvars[idx].vv_type == VAR_UNKNOWN)
--- 1482,1488 ----
   * When not used yet add the variable to the v: hashtable.
   */
      static void
! prepare_vimvar(int idx, typval_T *save_tv)
  {
      *save_tv = vimvars[idx].vv_tv;
      if (vimvars[idx].vv_type == VAR_UNKNOWN)
***************
*** 1501,1509 ****
   * When no longer defined, remove the variable from the v: hashtable.
   */
      static void
! restore_vimvar(idx, save_tv)
!     int		idx;
!     typval_T	*save_tv;
  {
      hashitem_T	*hi;
  
--- 1494,1500 ----
   * When no longer defined, remove the variable from the v: hashtable.
   */
      static void
! restore_vimvar(int idx, typval_T *save_tv)
  {
      hashitem_T	*hi;
  
***************
*** 1525,1533 ****
   * Returns NULL when there is an error.
   */
      list_T *
! eval_spell_expr(badword, expr)
!     char_u	*badword;
!     char_u	*expr;
  {
      typval_T	save_val;
      typval_T	rettv;
--- 1516,1522 ----
   * Returns NULL when there is an error.
   */
      list_T *
! eval_spell_expr(char_u *badword, char_u *expr)
  {
      typval_T	save_val;
      typval_T	rettv;
***************
*** 1563,1571 ****
   * Used to get the good word and score from the eval_spell_expr() result.
   */
      int
! get_spellword(list, pp)
!     list_T	*list;
!     char_u	**pp;
  {
      listitem_T	*li;
  
--- 1552,1558 ----
   * Used to get the good word and score from the eval_spell_expr() result.
   */
      int
! get_spellword(list_T *list, char_u **pp)
  {
      listitem_T	*li;
  
***************
*** 1587,1595 ****
   * Returns NULL when there is an error.
   */
      typval_T *
! eval_expr(arg, nextcmd)
!     char_u	*arg;
!     char_u	**nextcmd;
  {
      typval_T	*tv;
  
--- 1574,1580 ----
   * Returns NULL when there is an error.
   */
      typval_T *
! eval_expr(char_u *arg, char_u **nextcmd)
  {
      typval_T	*tv;
  
***************
*** 1611,1623 ****
   * Returns OK or FAIL.
   */
      int
! call_vim_function(func, argc, argv, safe, str_arg_only, rettv)
!     char_u      *func;
!     int		argc;
!     char_u      **argv;
!     int		safe;		/* use the sandbox */
!     int		str_arg_only;	/* all arguments are strings */
!     typval_T	*rettv;
  {
      typval_T	*argvars;
      long	n;
--- 1596,1608 ----
   * Returns OK or FAIL.
   */
      int
! call_vim_function(
!     char_u      *func,
!     int		argc,
!     char_u      **argv,
!     int		safe,		/* use the sandbox */
!     int		str_arg_only,	/* all arguments are strings */
!     typval_T	*rettv)
  {
      typval_T	*argvars;
      long	n;
***************
*** 1687,1697 ****
   * Uses argv[argc] for the function arguments.
   */
      long
! call_func_retnr(func, argc, argv, safe)
!     char_u      *func;
!     int		argc;
!     char_u      **argv;
!     int		safe;		/* use the sandbox */
  {
      typval_T	rettv;
      long	retval;
--- 1672,1682 ----
   * Uses argv[argc] for the function arguments.
   */
      long
! call_func_retnr(
!     char_u      *func,
!     int		argc,
!     char_u      **argv,
!     int		safe)		/* use the sandbox */
  {
      typval_T	rettv;
      long	retval;
***************
*** 1715,1725 ****
   * Uses argv[argc] for the function arguments.
   */
      void *
! call_func_retstr(func, argc, argv, safe)
!     char_u      *func;
!     int		argc;
!     char_u      **argv;
!     int		safe;		/* use the sandbox */
  {
      typval_T	rettv;
      char_u	*retval;
--- 1700,1710 ----
   * Uses argv[argc] for the function arguments.
   */
      void *
! call_func_retstr(
!     char_u      *func,
!     int		argc,
!     char_u      **argv,
!     int		safe)		/* use the sandbox */
  {
      typval_T	rettv;
      char_u	*retval;
***************
*** 1740,1750 ****
   * Returns NULL when there is something wrong.
   */
      void *
! call_func_retlist(func, argc, argv, safe)
!     char_u      *func;
!     int		argc;
!     char_u      **argv;
!     int		safe;		/* use the sandbox */
  {
      typval_T	rettv;
  
--- 1725,1735 ----
   * Returns NULL when there is something wrong.
   */
      void *
! call_func_retlist(
!     char_u      *func,
!     int		argc,
!     char_u      **argv,
!     int		safe)		/* use the sandbox */
  {
      typval_T	rettv;
  
***************
*** 1767,1773 ****
   * Used when executing autocommands and for ":source".
   */
      void *
! save_funccal()
  {
      funccall_T *fc = current_funccal;
  
--- 1752,1758 ----
   * Used when executing autocommands and for ":source".
   */
      void *
! save_funccal(void)
  {
      funccall_T *fc = current_funccal;
  
***************
*** 1776,1783 ****
  }
  
      void
! restore_funccal(vfc)
!     void *vfc;
  {
      funccall_T *fc = (funccall_T *)vfc;
  
--- 1761,1767 ----
  }
  
      void
! restore_funccal(void *vfc)
  {
      funccall_T *fc = (funccall_T *)vfc;
  
***************
*** 1791,1798 ****
   * Should always be called in pair with prof_child_exit().
   */
      void
! prof_child_enter(tm)
!     proftime_T *tm;	/* place to store waittime */
  {
      funccall_T *fc = current_funccal;
  
--- 1775,1782 ----
   * Should always be called in pair with prof_child_exit().
   */
      void
! prof_child_enter(
!     proftime_T *tm)	/* place to store waittime */
  {
      funccall_T *fc = current_funccal;
  
***************
*** 1806,1813 ****
   * Should always be called after prof_child_enter().
   */
      void
! prof_child_exit(tm)
!     proftime_T *tm;	/* where waittime was stored */
  {
      funccall_T *fc = current_funccal;
  
--- 1790,1797 ----
   * Should always be called after prof_child_enter().
   */
      void
! prof_child_exit(
!     proftime_T *tm)	/* where waittime was stored */
  {
      funccall_T *fc = current_funccal;
  
***************
*** 1829,1837 ****
   * it in "*cp".  Doesn't give error messages.
   */
      int
! eval_foldexpr(arg, cp)
!     char_u	*arg;
!     int		*cp;
  {
      typval_T	tv;
      int		retval;
--- 1813,1819 ----
   * it in "*cp".  Doesn't give error messages.
   */
      int
! eval_foldexpr(char_u *arg, int *cp)
  {
      typval_T	tv;
      int		retval;
***************
*** 1883,1890 ****
   * ":let [var1, var2] = expr"	unpack list.
   */
      void
! ex_let(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      char_u	*expr = NULL;
--- 1865,1871 ----
   * ":let [var1, var2] = expr"	unpack list.
   */
      void
! ex_let(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      char_u	*expr = NULL;
***************
*** 1968,1980 ****
   * Returns OK or FAIL;
   */
      static int
! ex_let_vars(arg_start, tv, copy, semicolon, var_count, nextchars)
!     char_u	*arg_start;
!     typval_T	*tv;
!     int		copy;		/* copy values from "tv", don't move */
!     int		semicolon;	/* from skip_var_list() */
!     int		var_count;	/* from skip_var_list() */
!     char_u	*nextchars;
  {
      char_u	*arg = arg_start;
      list_T	*l;
--- 1949,1961 ----
   * Returns OK or FAIL;
   */
      static int
! ex_let_vars(
!     char_u	*arg_start,
!     typval_T	*tv,
!     int		copy,		/* copy values from "tv", don't move */
!     int		semicolon,	/* from skip_var_list() */
!     int		var_count,	/* from skip_var_list() */
!     char_u	*nextchars)
  {
      char_u	*arg = arg_start;
      list_T	*l;
***************
*** 2066,2075 ****
   * Return NULL for an error.
   */
      static char_u *
! skip_var_list(arg, var_count, semicolon)
!     char_u	*arg;
!     int		*var_count;
!     int		*semicolon;
  {
      char_u	*p, *s;
  
--- 2047,2056 ----
   * Return NULL for an error.
   */
      static char_u *
! skip_var_list(
!     char_u	*arg,
!     int		*var_count,
!     int		*semicolon)
  {
      char_u	*p, *s;
  
***************
*** 2117,2124 ****
   * l[idx].
   */
      static char_u *
! skip_var_one(arg)
!     char_u	*arg;
  {
      if (*arg == '@' && arg[1] != NUL)
  	return arg + 2;
--- 2098,2104 ----
   * l[idx].
   */
      static char_u *
! skip_var_one(char_u *arg)
  {
      if (*arg == '@' && arg[1] != NUL)
  	return arg + 2;
***************
*** 2131,2141 ****
   * If "empty" is TRUE also list NULL strings as empty strings.
   */
      static void
! list_hashtable_vars(ht, prefix, empty, first)
!     hashtab_T	*ht;
!     char_u	*prefix;
!     int		empty;
!     int		*first;
  {
      hashitem_T	*hi;
      dictitem_T	*di;
--- 2111,2121 ----
   * If "empty" is TRUE also list NULL strings as empty strings.
   */
      static void
! list_hashtable_vars(
!     hashtab_T	*ht,
!     char_u	*prefix,
!     int		empty,
!     int		*first)
  {
      hashitem_T	*hi;
      dictitem_T	*di;
***************
*** 2159,2166 ****
   * List global variables.
   */
      static void
! list_glob_vars(first)
!     int *first;
  {
      list_hashtable_vars(&globvarht, (char_u *)"", TRUE, first);
  }
--- 2139,2145 ----
   * List global variables.
   */
      static void
! list_glob_vars(int *first)
  {
      list_hashtable_vars(&globvarht, (char_u *)"", TRUE, first);
  }
***************
*** 2169,2176 ****
   * List buffer variables.
   */
      static void
! list_buf_vars(first)
!     int *first;
  {
      char_u	numbuf[NUMBUFLEN];
  
--- 2148,2154 ----
   * List buffer variables.
   */
      static void
! list_buf_vars(int *first)
  {
      char_u	numbuf[NUMBUFLEN];
  
***************
*** 2186,2193 ****
   * List window variables.
   */
      static void
! list_win_vars(first)
!     int *first;
  {
      list_hashtable_vars(&curwin->w_vars->dv_hashtab,
  						 (char_u *)"w:", TRUE, first);
--- 2164,2170 ----
   * List window variables.
   */
      static void
! list_win_vars(int *first)
  {
      list_hashtable_vars(&curwin->w_vars->dv_hashtab,
  						 (char_u *)"w:", TRUE, first);
***************
*** 2198,2205 ****
   * List tab page variables.
   */
      static void
! list_tab_vars(first)
!     int *first;
  {
      list_hashtable_vars(&curtab->tp_vars->dv_hashtab,
  						 (char_u *)"t:", TRUE, first);
--- 2175,2181 ----
   * List tab page variables.
   */
      static void
! list_tab_vars(int *first)
  {
      list_hashtable_vars(&curtab->tp_vars->dv_hashtab,
  						 (char_u *)"t:", TRUE, first);
***************
*** 2210,2217 ****
   * List Vim variables.
   */
      static void
! list_vim_vars(first)
!     int *first;
  {
      list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE, first);
  }
--- 2186,2192 ----
   * List Vim variables.
   */
      static void
! list_vim_vars(int *first)
  {
      list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE, first);
  }
***************
*** 2220,2227 ****
   * List script-local variables, if there is a script.
   */
      static void
! list_script_vars(first)
!     int *first;
  {
      if (current_SID > 0 && current_SID <= ga_scripts.ga_len)
  	list_hashtable_vars(&SCRIPT_VARS(current_SID),
--- 2195,2201 ----
   * List script-local variables, if there is a script.
   */
      static void
! list_script_vars(int *first)
  {
      if (current_SID > 0 && current_SID <= ga_scripts.ga_len)
  	list_hashtable_vars(&SCRIPT_VARS(current_SID),
***************
*** 2232,2239 ****
   * List function variables, if there is a function.
   */
      static void
! list_func_vars(first)
!     int *first;
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
--- 2206,2212 ----
   * List function variables, if there is a function.
   */
      static void
! list_func_vars(int *first)
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
***************
*** 2244,2253 ****
   * List variables in "arg".
   */
      static char_u *
! list_arg_vars(eap, arg, first)
!     exarg_T	*eap;
!     char_u	*arg;
!     int		*first;
  {
      int		error = FALSE;
      int		len;
--- 2217,2223 ----
   * List variables in "arg".
   */
      static char_u *
! list_arg_vars(exarg_T *eap, char_u *arg, int *first)
  {
      int		error = FALSE;
      int		len;
***************
*** 2355,2366 ****
   * Returns NULL if there is an error.
   */
      static char_u *
! ex_let_one(arg, tv, copy, endchars, op)
!     char_u	*arg;		/* points to variable name */
!     typval_T	*tv;		/* value to assign to variable */
!     int		copy;		/* copy value from "tv" */
!     char_u	*endchars;	/* valid chars after variable name  or NULL */
!     char_u	*op;		/* "+", "-", "."  or NULL*/
  {
      int		c1;
      char_u	*name;
--- 2325,2336 ----
   * Returns NULL if there is an error.
   */
      static char_u *
! ex_let_one(
!     char_u	*arg,		/* points to variable name */
!     typval_T	*tv,		/* value to assign to variable */
!     int		copy,		/* copy value from "tv" */
!     char_u	*endchars,	/* valid chars after variable name  or NULL */
!     char_u	*op)		/* "+", "-", "."  or NULL*/
  {
      int		c1;
      char_u	*name;
***************
*** 2549,2556 ****
   * If "arg" is equal to "b:changedtick" give an error and return TRUE.
   */
      static int
! check_changedtick(arg)
!     char_u	*arg;
  {
      if (STRNCMP(arg, "b:changedtick", 13) == 0 && !eval_isnamec(arg[13]))
      {
--- 2519,2525 ----
   * If "arg" is equal to "b:changedtick" give an error and return TRUE.
   */
      static int
! check_changedtick(char_u *arg)
  {
      if (STRNCMP(arg, "b:changedtick", 13) == 0 && !eval_isnamec(arg[13]))
      {
***************
*** 2579,2592 ****
   * Returns NULL for a parsing error.  Still need to free items in "lp"!
   */
      static char_u *
! get_lval(name, rettv, lp, unlet, skip, flags, fne_flags)
!     char_u	*name;
!     typval_T	*rettv;
!     lval_T	*lp;
!     int		unlet;
!     int		skip;
!     int		flags;	    /* GLV_ values */
!     int		fne_flags;  /* flags for find_name_end() */
  {
      char_u	*p;
      char_u	*expr_start, *expr_end;
--- 2548,2561 ----
   * Returns NULL for a parsing error.  Still need to free items in "lp"!
   */
      static char_u *
! get_lval(
!     char_u	*name,
!     typval_T	*rettv,
!     lval_T	*lp,
!     int		unlet,
!     int		skip,
!     int		flags,	    /* GLV_ values */
!     int		fne_flags)  /* flags for find_name_end() */
  {
      char_u	*p;
      char_u	*expr_start, *expr_end;
***************
*** 2924,2931 ****
   * Clear lval "lp" that was filled by get_lval().
   */
      static void
! clear_lval(lp)
!     lval_T	*lp;
  {
      vim_free(lp->ll_exp_name);
      vim_free(lp->ll_newkey);
--- 2893,2899 ----
   * Clear lval "lp" that was filled by get_lval().
   */
      static void
! clear_lval(lval_T *lp)
  {
      vim_free(lp->ll_exp_name);
      vim_free(lp->ll_newkey);
***************
*** 2937,2948 ****
   * "op" is NULL, "+" for "+=", "-" for "-=", "." for ".=" or "=" for "=".
   */
      static void
! set_var_lval(lp, endp, rettv, copy, op)
!     lval_T	*lp;
!     char_u	*endp;
!     typval_T	*rettv;
!     int		copy;
!     char_u	*op;
  {
      int		cc;
      listitem_T	*ri;
--- 2905,2916 ----
   * "op" is NULL, "+" for "+=", "-" for "-=", "." for ".=" or "=" for "=".
   */
      static void
! set_var_lval(
!     lval_T	*lp,
!     char_u	*endp,
!     typval_T	*rettv,
!     int		copy,
!     char_u	*op)
  {
      int		cc;
      listitem_T	*ri;
***************
*** 3085,3094 ****
   * Returns OK or FAIL.
   */
      static int
! tv_op(tv1, tv2, op)
!     typval_T *tv1;
!     typval_T *tv2;
!     char_u  *op;
  {
      long	n;
      char_u	numbuf[NUMBUFLEN];
--- 3053,3059 ----
   * Returns OK or FAIL.
   */
      static int
! tv_op(typval_T *tv1, typval_T *tv2, char_u *op)
  {
      long	n;
      char_u	numbuf[NUMBUFLEN];
***************
*** 3191,3199 ****
   * Add a watcher to a list.
   */
      void
! list_add_watch(l, lw)
!     list_T	*l;
!     listwatch_T	*lw;
  {
      lw->lw_next = l->lv_watch;
      l->lv_watch = lw;
--- 3156,3162 ----
   * Add a watcher to a list.
   */
      void
! list_add_watch(list_T *l, listwatch_T *lw)
  {
      lw->lw_next = l->lv_watch;
      l->lv_watch = lw;
***************
*** 3204,3212 ****
   * No warning when it isn't found...
   */
      void
! list_rem_watch(l, lwrem)
!     list_T	*l;
!     listwatch_T	*lwrem;
  {
      listwatch_T	*lw, **lwp;
  
--- 3167,3173 ----
   * No warning when it isn't found...
   */
      void
! list_rem_watch(list_T *l, listwatch_T *lwrem)
  {
      listwatch_T	*lw, **lwp;
  
***************
*** 3227,3235 ****
   * item.
   */
      static void
! list_fix_watch(l, item)
!     list_T	*l;
!     listitem_T	*item;
  {
      listwatch_T	*lw;
  
--- 3188,3194 ----
   * item.
   */
      static void
! list_fix_watch(list_T *l, listitem_T *item)
  {
      listwatch_T	*lw;
  
***************
*** 3245,3255 ****
   * Return a pointer that holds the info.  Null when there is an error.
   */
      void *
! eval_for_line(arg, errp, nextcmdp, skip)
!     char_u	*arg;
!     int		*errp;
!     char_u	**nextcmdp;
!     int		skip;
  {
      forinfo_T	*fi;
      char_u	*expr;
--- 3204,3214 ----
   * Return a pointer that holds the info.  Null when there is an error.
   */
      void *
! eval_for_line(
!     char_u	*arg,
!     int		*errp,
!     char_u	**nextcmdp,
!     int		skip)
  {
      forinfo_T	*fi;
      char_u	*expr;
***************
*** 3309,3317 ****
   * something wrong.
   */
      int
! next_for_item(fi_void, arg)
!     void	*fi_void;
!     char_u	*arg;
  {
      forinfo_T	*fi = (forinfo_T *)fi_void;
      int		result;
--- 3268,3274 ----
   * something wrong.
   */
      int
! next_for_item(void *fi_void, char_u *arg)
  {
      forinfo_T	*fi = (forinfo_T *)fi_void;
      int		result;
***************
*** 3333,3340 ****
   * Free the structure used to store info used by ":for".
   */
      void
! free_for_info(fi_void)
!     void *fi_void;
  {
      forinfo_T    *fi = (forinfo_T *)fi_void;
  
--- 3290,3296 ----
   * Free the structure used to store info used by ":for".
   */
      void
! free_for_info(void *fi_void)
  {
      forinfo_T    *fi = (forinfo_T *)fi_void;
  
***************
*** 3349,3358 ****
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
      void
! set_context_for_expression(xp, arg, cmdidx)
!     expand_T	*xp;
!     char_u	*arg;
!     cmdidx_T	cmdidx;
  {
      int		got_eq = FALSE;
      int		c;
--- 3305,3314 ----
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
      void
! set_context_for_expression(
!     expand_T	*xp,
!     char_u	*arg,
!     cmdidx_T	cmdidx)
  {
      int		got_eq = FALSE;
      int		c;
***************
*** 3462,3469 ****
   * ":1,25call func(arg1, arg2)"	function call.
   */
      void
! ex_call(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      char_u	*startarg;
--- 3418,3424 ----
   * ":1,25call func(arg1, arg2)"	function call.
   */
      void
! ex_call(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      char_u	*startarg;
***************
*** 3592,3599 ****
   * ":unlet[!] var1 ... " command.
   */
      void
! ex_unlet(eap)
!     exarg_T	*eap;
  {
      ex_unletlock(eap, eap->arg, 0);
  }
--- 3547,3553 ----
   * ":unlet[!] var1 ... " command.
   */
      void
! ex_unlet(exarg_T *eap)
  {
      ex_unletlock(eap, eap->arg, 0);
  }
***************
*** 3602,3609 ****
   * ":lockvar" and ":unlockvar" commands
   */
      void
! ex_lockvar(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      int		deep = 2;
--- 3556,3562 ----
   * ":lockvar" and ":unlockvar" commands
   */
      void
! ex_lockvar(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      int		deep = 2;
***************
*** 3623,3632 ****
   * ":unlet", ":lockvar" and ":unlockvar" are quite similar.
   */
      static void
! ex_unletlock(eap, argstart, deep)
!     exarg_T	*eap;
!     char_u	*argstart;
!     int		deep;
  {
      char_u	*arg = argstart;
      char_u	*name_end;
--- 3576,3585 ----
   * ":unlet", ":lockvar" and ":unlockvar" are quite similar.
   */
      static void
! ex_unletlock(
!     exarg_T	*eap,
!     char_u	*argstart,
!     int		deep)
  {
      char_u	*arg = argstart;
      char_u	*name_end;
***************
*** 3678,3687 ****
  }
  
      static int
! do_unlet_var(lp, name_end, forceit)
!     lval_T	*lp;
!     char_u	*name_end;
!     int		forceit;
  {
      int		ret = OK;
      int		cc;
--- 3631,3640 ----
  }
  
      static int
! do_unlet_var(
!     lval_T	*lp,
!     char_u	*name_end,
!     int		forceit)
  {
      int		ret = OK;
      int		cc;
***************
*** 3745,3753 ****
   * When "forceit" is TRUE don't complain if the variable doesn't exist.
   */
      int
! do_unlet(name, forceit)
!     char_u	*name;
!     int		forceit;
  {
      hashtab_T	*ht;
      hashitem_T	*hi;
--- 3698,3704 ----
   * When "forceit" is TRUE don't complain if the variable doesn't exist.
   */
      int
! do_unlet(char_u *name, int forceit)
  {
      hashtab_T	*ht;
      hashitem_T	*hi;
***************
*** 3800,3810 ****
   * "lock" is TRUE for ":lockvar", FALSE for ":unlockvar".
   */
      static int
! do_lock_var(lp, name_end, deep, lock)
!     lval_T	*lp;
!     char_u	*name_end;
!     int		deep;
!     int		lock;
  {
      int		ret = OK;
      int		cc;
--- 3751,3761 ----
   * "lock" is TRUE for ":lockvar", FALSE for ":unlockvar".
   */
      static int
! do_lock_var(
!     lval_T	*lp,
!     char_u	*name_end,
!     int		deep,
!     int		lock)
  {
      int		ret = OK;
      int		cc;
***************
*** 3863,3872 ****
   * Lock or unlock an item.  "deep" is nr of levels to go.
   */
      static void
! item_lock(tv, deep, lock)
!     typval_T	*tv;
!     int		deep;
!     int		lock;
  {
      static int	recurse = 0;
      list_T	*l;
--- 3814,3820 ----
   * Lock or unlock an item.  "deep" is nr of levels to go.
   */
      static void
! item_lock(typval_T *tv, int deep, int lock)
  {
      static int	recurse = 0;
      list_T	*l;
***************
*** 3935,3942 ****
   * or it refers to a List or Dictionary that is locked.
   */
      static int
! tv_islocked(tv)
!     typval_T	*tv;
  {
      return (tv->v_lock & VAR_LOCKED)
  	|| (tv->v_type == VAR_LIST
--- 3883,3889 ----
   * or it refers to a List or Dictionary that is locked.
   */
      static int
! tv_islocked(typval_T *tv)
  {
      return (tv->v_lock & VAR_LOCKED)
  	|| (tv->v_type == VAR_LIST
***************
*** 3952,3958 ****
   * Delete all "menutrans_" variables.
   */
      void
! del_menutrans_vars()
  {
      hashitem_T	*hi;
      int		todo;
--- 3899,3905 ----
   * Delete all "menutrans_" variables.
   */
      void
! del_menutrans_vars(void)
  {
      hashitem_T	*hi;
      int		todo;
***************
*** 3989,3997 ****
   * Function to concatenate a prefix and a variable name.
   */
      static char_u *
! cat_prefix_varname(prefix, name)
!     int		prefix;
!     char_u	*name;
  {
      int		len;
  
--- 3936,3942 ----
   * Function to concatenate a prefix and a variable name.
   */
      static char_u *
! cat_prefix_varname(int prefix, char_u *name)
  {
      int		len;
  
***************
*** 4019,4027 ****
   * (global/buffer/window/built-in) variable names.
   */
      char_u *
! get_user_var_name(xp, idx)
!     expand_T	*xp;
!     int		idx;
  {
      static long_u	gdone;
      static long_u	bdone;
--- 3964,3970 ----
   * (global/buffer/window/built-in) variable names.
   */
      char_u *
! get_user_var_name(expand_T *xp, int idx)
  {
      static long_u	gdone;
      static long_u	bdone;
***************
*** 4143,4153 ****
   * Return OK or FAIL.
   */
      static int
! eval0(arg, rettv, nextcmd, evaluate)
!     char_u	*arg;
!     typval_T	*rettv;
!     char_u	**nextcmd;
!     int		evaluate;
  {
      int		ret;
      char_u	*p;
--- 4086,4096 ----
   * Return OK or FAIL.
   */
      static int
! eval0(
!     char_u	*arg,
!     typval_T	*rettv,
!     char_u	**nextcmd,
!     int		evaluate)
  {
      int		ret;
      char_u	*p;
***************
*** 4185,4194 ****
   * Return OK or FAIL.
   */
      static int
! eval1(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      int		result;
      typval_T	var2;
--- 4128,4134 ----
   * Return OK or FAIL.
   */
      static int
! eval1(char_u **arg, typval_T *rettv, int evaluate)
  {
      int		result;
      typval_T	var2;
***************
*** 4258,4267 ****
   * Return OK or FAIL.
   */
      static int
! eval2(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      typval_T	var2;
      long	result;
--- 4198,4204 ----
   * Return OK or FAIL.
   */
      static int
! eval2(char_u **arg, typval_T *rettv, int evaluate)
  {
      typval_T	var2;
      long	result;
***************
*** 4329,4338 ****
   * Return OK or FAIL.
   */
      static int
! eval3(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      typval_T	var2;
      long	result;
--- 4266,4272 ----
   * Return OK or FAIL.
   */
      static int
! eval3(char_u **arg, typval_T *rettv, int evaluate)
  {
      typval_T	var2;
      long	result;
***************
*** 4409,4418 ****
   * Return OK or FAIL.
   */
      static int
! eval4(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      typval_T	var2;
      char_u	*p;
--- 4343,4349 ----
   * Return OK or FAIL.
   */
      static int
! eval4(char_u **arg, typval_T *rettv, int evaluate)
  {
      typval_T	var2;
      char_u	*p;
***************
*** 4719,4728 ****
   * Return OK or FAIL.
   */
      static int
! eval5(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      typval_T	var2;
      typval_T	var3;
--- 4650,4656 ----
   * Return OK or FAIL.
   */
      static int
! eval5(char_u **arg, typval_T *rettv, int evaluate)
  {
      typval_T	var2;
      typval_T	var3;
***************
*** 4904,4914 ****
   * Return OK or FAIL.
   */
      static int
! eval6(arg, rettv, evaluate, want_string)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
!     int		want_string;  /* after "." operator */
  {
      typval_T	var2;
      int		op;
--- 4832,4842 ----
   * Return OK or FAIL.
   */
      static int
! eval6(
!     char_u	**arg,
!     typval_T	*rettv,
!     int		evaluate,
!     int		want_string)  /* after "." operator */
  {
      typval_T	var2;
      int		op;
***************
*** 5086,5096 ****
   * Return OK or FAIL.
   */
      static int
! eval7(arg, rettv, evaluate, want_string)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
!     int		want_string UNUSED;	/* after "." operator */
  {
      long	n;
      int		len;
--- 5014,5024 ----
   * Return OK or FAIL.
   */
      static int
! eval7(
!     char_u	**arg,
!     typval_T	*rettv,
!     int		evaluate,
!     int		want_string UNUSED)	/* after "." operator */
  {
      long	n;
      int		len;
***************
*** 5378,5388 ****
   * Returns FAIL or OK. "*arg" is advanced to after the ']'.
   */
      static int
! eval_index(arg, rettv, evaluate, verbose)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
!     int		verbose;	/* give error messages */
  {
      int		empty1 = FALSE, empty2 = FALSE;
      typval_T	var1, var2;
--- 5306,5316 ----
   * Returns FAIL or OK. "*arg" is advanced to after the ']'.
   */
      static int
! eval_index(
!     char_u	**arg,
!     typval_T	*rettv,
!     int		evaluate,
!     int		verbose)	/* give error messages */
  {
      int		empty1 = FALSE, empty2 = FALSE;
      typval_T	var1, var2;
***************
*** 5645,5654 ****
   * Return OK or FAIL.
   */
      static int
! get_option_tv(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;	/* when NULL, only check if option exists */
!     int		evaluate;
  {
      char_u	*option_end;
      long	numval;
--- 5573,5582 ----
   * Return OK or FAIL.
   */
      static int
! get_option_tv(
!     char_u	**arg,
!     typval_T	*rettv,	/* when NULL, only check if option exists */
!     int		evaluate)
  {
      char_u	*option_end;
      long	numval;
***************
*** 5724,5733 ****
   * Return OK or FAIL.
   */
      static int
! get_string_tv(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      char_u	*p;
      char_u	*name;
--- 5652,5658 ----
   * Return OK or FAIL.
   */
      static int
! get_string_tv(char_u **arg, typval_T *rettv, int evaluate)
  {
      char_u	*p;
      char_u	*name;
***************
*** 5863,5872 ****
   * Return OK or FAIL.
   */
      static int
! get_lit_string_tv(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      char_u	*p;
      char_u	*str;
--- 5788,5794 ----
   * Return OK or FAIL.
   */
      static int
! get_lit_string_tv(char_u **arg, typval_T *rettv, int evaluate)
  {
      char_u	*p;
      char_u	*str;
***************
*** 5929,5938 ****
   * Return OK or FAIL.
   */
      static int
! get_list_tv(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      list_T	*l = NULL;
      typval_T	tv;
--- 5851,5857 ----
   * Return OK or FAIL.
   */
      static int
! get_list_tv(char_u **arg, typval_T *rettv, int evaluate)
  {
      list_T	*l = NULL;
      typval_T	tv;
***************
*** 5998,6004 ****
   * Caller should take care of the reference count.
   */
      list_T *
! list_alloc()
  {
      list_T  *l;
  
--- 5917,5923 ----
   * Caller should take care of the reference count.
   */
      list_T *
! list_alloc(void)
  {
      list_T  *l;
  
***************
*** 6020,6027 ****
   * Returns OK or FAIL.
   */
      int
! rettv_list_alloc(rettv)
!     typval_T	*rettv;
  {
      list_T	*l = list_alloc();
  
--- 5939,5945 ----
   * Returns OK or FAIL.
   */
      int
! rettv_list_alloc(typval_T *rettv)
  {
      list_T	*l = list_alloc();
  
***************
*** 6039,6046 ****
   * becomes zero.
   */
      void
! list_unref(l)
!     list_T *l;
  {
      if (l != NULL && --l->lv_refcount <= 0)
  	list_free(l, TRUE);
--- 5957,5963 ----
   * becomes zero.
   */
      void
! list_unref(list_T *l)
  {
      if (l != NULL && --l->lv_refcount <= 0)
  	list_free(l, TRUE);
***************
*** 6051,6059 ****
   * Ignores the reference count.
   */
      void
! list_free(l, recurse)
!     list_T  *l;
!     int	    recurse;	/* Free Lists and Dictionaries recursively. */
  {
      listitem_T *item;
  
--- 5968,5976 ----
   * Ignores the reference count.
   */
      void
! list_free(
!     list_T  *l,
!     int	    recurse)	/* Free Lists and Dictionaries recursively. */
  {
      listitem_T *item;
  
***************
*** 6091,6098 ****
   * Free a list item.  Also clears the value.  Does not notify watchers.
   */
      void
! listitem_free(item)
!     listitem_T *item;
  {
      clear_tv(&item->li_tv);
      vim_free(item);
--- 6008,6014 ----
   * Free a list item.  Also clears the value.  Does not notify watchers.
   */
      void
! listitem_free(listitem_T *item)
  {
      clear_tv(&item->li_tv);
      vim_free(item);
***************
*** 6102,6110 ****
   * Remove a list item from a List and free it.  Also clears the value.
   */
      void
! listitem_remove(l, item)
!     list_T  *l;
!     listitem_T *item;
  {
      vimlist_remove(l, item, item);
      listitem_free(item);
--- 6018,6024 ----
   * Remove a list item from a List and free it.  Also clears the value.
   */
      void
! listitem_remove(list_T *l, listitem_T *item)
  {
      vimlist_remove(l, item, item);
      listitem_free(item);
***************
*** 6114,6121 ****
   * Get the number of items in a list.
   */
      static long
! list_len(l)
!     list_T	*l;
  {
      if (l == NULL)
  	return 0L;
--- 6028,6034 ----
   * Get the number of items in a list.
   */
      static long
! list_len(list_T *l)
  {
      if (l == NULL)
  	return 0L;
***************
*** 6126,6136 ****
   * Return TRUE when two lists have exactly the same values.
   */
      static int
! list_equal(l1, l2, ic, recursive)
!     list_T	*l1;
!     list_T	*l2;
!     int		ic;	/* ignore case for strings */
!     int		recursive;  /* TRUE when used recursively */
  {
      listitem_T	*item1, *item2;
  
--- 6039,6049 ----
   * Return TRUE when two lists have exactly the same values.
   */
      static int
! list_equal(
!     list_T	*l1,
!     list_T	*l2,
!     int		ic,	/* ignore case for strings */
!     int		recursive)  /* TRUE when used recursively */
  {
      listitem_T	*item1, *item2;
  
***************
*** 6153,6160 ****
   * Return the dictitem that an entry in a hashtable points to.
   */
      dictitem_T *
! dict_lookup(hi)
!     hashitem_T *hi;
  {
      return HI2DI(hi);
  }
--- 6066,6072 ----
   * Return the dictitem that an entry in a hashtable points to.
   */
      dictitem_T *
! dict_lookup(hashitem_T *hi)
  {
      return HI2DI(hi);
  }
***************
*** 6163,6173 ****
   * Return TRUE when two dictionaries have exactly the same key/values.
   */
      static int
! dict_equal(d1, d2, ic, recursive)
!     dict_T	*d1;
!     dict_T	*d2;
!     int		ic;	/* ignore case for strings */
!     int		recursive; /* TRUE when used recursively */
  {
      hashitem_T	*hi;
      dictitem_T	*item2;
--- 6075,6085 ----
   * Return TRUE when two dictionaries have exactly the same key/values.
   */
      static int
! dict_equal(
!     dict_T	*d1,
!     dict_T	*d2,
!     int		ic,	/* ignore case for strings */
!     int		recursive) /* TRUE when used recursively */
  {
      hashitem_T	*hi;
      dictitem_T	*item2;
***************
*** 6204,6214 ****
   * numbers are different.  Floats and numbers are also different.
   */
      static int
! tv_equal(tv1, tv2, ic, recursive)
!     typval_T *tv1;
!     typval_T *tv2;
!     int	     ic;	    /* ignore case */
!     int	     recursive;	    /* TRUE when used recursively */
  {
      char_u	buf1[NUMBUFLEN], buf2[NUMBUFLEN];
      char_u	*s1, *s2;
--- 6116,6126 ----
   * numbers are different.  Floats and numbers are also different.
   */
      static int
! tv_equal(
!     typval_T *tv1,
!     typval_T *tv2,
!     int	     ic,	    /* ignore case */
!     int	     recursive)	    /* TRUE when used recursively */
  {
      char_u	buf1[NUMBUFLEN], buf2[NUMBUFLEN];
      char_u	*s1, *s2;
***************
*** 6278,6286 ****
   * Returns NULL when "n" is out of range.
   */
      listitem_T *
! list_find(l, n)
!     list_T	*l;
!     long	n;
  {
      listitem_T	*item;
      long	idx;
--- 6190,6196 ----
   * Returns NULL when "n" is out of range.
   */
      listitem_T *
! list_find(list_T *l, long n)
  {
      listitem_T	*item;
      long	idx;
***************
*** 6358,6367 ****
   * Get list item "l[idx]" as a number.
   */
      static long
! list_find_nr(l, idx, errorp)
!     list_T	*l;
!     long	idx;
!     int		*errorp;	/* set to TRUE when something wrong */
  {
      listitem_T	*li;
  
--- 6268,6277 ----
   * Get list item "l[idx]" as a number.
   */
      static long
! list_find_nr(
!     list_T	*l,
!     long	idx,
!     int		*errorp)	/* set to TRUE when something wrong */
  {
      listitem_T	*li;
  
***************
*** 6379,6387 ****
   * Get list item "l[idx - 1]" as a string.  Returns NULL for failure.
   */
      char_u *
! list_find_str(l, idx)
!     list_T	*l;
!     long	idx;
  {
      listitem_T	*li;
  
--- 6289,6295 ----
   * Get list item "l[idx - 1]" as a string.  Returns NULL for failure.
   */
      char_u *
! list_find_str(list_T *l, long idx)
  {
      listitem_T	*li;
  
***************
*** 6399,6407 ****
   * Returns -1 when "item" is not in the list.
   */
      static long
! list_idx_of_item(l, item)
!     list_T	*l;
!     listitem_T	*item;
  {
      long	idx = 0;
      listitem_T	*li;
--- 6307,6313 ----
   * Returns -1 when "item" is not in the list.
   */
      static long
! list_idx_of_item(list_T *l, listitem_T *item)
  {
      long	idx = 0;
      listitem_T	*li;
***************
*** 6420,6428 ****
   * Append item "item" to the end of list "l".
   */
      void
! list_append(l, item)
!     list_T	*l;
!     listitem_T	*item;
  {
      if (l->lv_last == NULL)
      {
--- 6326,6332 ----
   * Append item "item" to the end of list "l".
   */
      void
! list_append(list_T *l, listitem_T *item)
  {
      if (l->lv_last == NULL)
      {
***************
*** 6446,6454 ****
   * Return FAIL when out of memory.
   */
      int
! list_append_tv(l, tv)
!     list_T	*l;
!     typval_T	*tv;
  {
      listitem_T	*li = listitem_alloc();
  
--- 6350,6356 ----
   * Return FAIL when out of memory.
   */
      int
! list_append_tv(list_T *l, typval_T *tv)
  {
      listitem_T	*li = listitem_alloc();
  
***************
*** 6464,6472 ****
   * Return FAIL when out of memory.
   */
      int
! list_append_dict(list, dict)
!     list_T	*list;
!     dict_T	*dict;
  {
      listitem_T	*li = listitem_alloc();
  
--- 6366,6372 ----
   * Return FAIL when out of memory.
   */
      int
! list_append_dict(list_T *list, dict_T *dict)
  {
      listitem_T	*li = listitem_alloc();
  
***************
*** 6486,6495 ****
   * Returns FAIL when out of memory.
   */
      int
! list_append_string(l, str, len)
!     list_T	*l;
!     char_u	*str;
!     int		len;
  {
      listitem_T *li = listitem_alloc();
  
--- 6386,6392 ----
   * Returns FAIL when out of memory.
   */
      int
! list_append_string(list_T *l, char_u *str, int len)
  {
      listitem_T *li = listitem_alloc();
  
***************
*** 6511,6519 ****
   * Returns FAIL when out of memory.
   */
      static int
! list_append_number(l, n)
!     list_T	*l;
!     varnumber_T	n;
  {
      listitem_T	*li;
  
--- 6408,6414 ----
   * Returns FAIL when out of memory.
   */
      static int
! list_append_number(list_T *l, varnumber_T n)
  {
      listitem_T	*li;
  
***************
*** 6533,6542 ****
   * Return FAIL when out of memory.
   */
      int
! list_insert_tv(l, tv, item)
!     list_T	*l;
!     typval_T	*tv;
!     listitem_T	*item;
  {
      listitem_T	*ni = listitem_alloc();
  
--- 6428,6434 ----
   * Return FAIL when out of memory.
   */
      int
! list_insert_tv(list_T *l, typval_T *tv, listitem_T *item)
  {
      listitem_T	*ni = listitem_alloc();
  
***************
*** 6548,6557 ****
  }
  
      void
! list_insert(l, ni, item)
!     list_T	*l;
!     listitem_T	*ni;
!     listitem_T	*item;
  {
      if (item == NULL)
  	/* Append new item at end of list. */
--- 6440,6446 ----
  }
  
      void
! list_insert(list_T *l, listitem_T *ni, listitem_T *item)
  {
      if (item == NULL)
  	/* Append new item at end of list. */
***************
*** 6582,6591 ****
   * Returns FAIL when out of memory.
   */
      static int
! list_extend(l1, l2, bef)
!     list_T	*l1;
!     list_T	*l2;
!     listitem_T	*bef;
  {
      listitem_T	*item;
      int		todo = l2->lv_len;
--- 6471,6477 ----
   * Returns FAIL when out of memory.
   */
      static int
! list_extend(list_T *l1, list_T *l2, listitem_T *bef)
  {
      listitem_T	*item;
      int		todo = l2->lv_len;
***************
*** 6603,6612 ****
   * Return FAIL when out of memory.
   */
      static int
! list_concat(l1, l2, tv)
!     list_T	*l1;
!     list_T	*l2;
!     typval_T	*tv;
  {
      list_T	*l;
  
--- 6489,6495 ----
   * Return FAIL when out of memory.
   */
      static int
! list_concat(list_T *l1, list_T *l2, typval_T *tv)
  {
      list_T	*l;
  
***************
*** 6631,6640 ****
   * Returns NULL when out of memory.
   */
      static list_T *
! list_copy(orig, deep, copyID)
!     list_T	*orig;
!     int		deep;
!     int		copyID;
  {
      list_T	*copy;
      listitem_T	*item;
--- 6514,6520 ----
   * Returns NULL when out of memory.
   */
      static list_T *
! list_copy(list_T *orig, int deep, int copyID)
  {
      list_T	*copy;
      listitem_T	*item;
***************
*** 6689,6698 ****
   * file.
   */
      void
! vimlist_remove(l, item, item2)
!     list_T	*l;
!     listitem_T	*item;
!     listitem_T	*item2;
  {
      listitem_T	*ip;
  
--- 6569,6575 ----
   * file.
   */
      void
! vimlist_remove(list_T *l, listitem_T *item, listitem_T *item2)
  {
      listitem_T	*ip;
  
***************
*** 6721,6729 ****
   * May return NULL.
   */
      static char_u *
! list2string(tv, copyID)
!     typval_T	*tv;
!     int		copyID;
  {
      garray_T	ga;
  
--- 6598,6604 ----
   * May return NULL.
   */
      static char_u *
! list2string(typval_T *tv, int copyID)
  {
      garray_T	ga;
  
***************
*** 6747,6759 ****
  } join_T;
  
      static int
! list_join_inner(gap, l, sep, echo_style, copyID, join_gap)
!     garray_T	*gap;		/* to store the result in */
!     list_T	*l;
!     char_u	*sep;
!     int		echo_style;
!     int		copyID;
!     garray_T	*join_gap;	/* to keep each list item string */
  {
      int		i;
      join_T	*p;
--- 6622,6634 ----
  } join_T;
  
      static int
! list_join_inner(
!     garray_T	*gap,		/* to store the result in */
!     list_T	*l,
!     char_u	*sep,
!     int		echo_style,
!     int		copyID,
!     garray_T	*join_gap)	/* to keep each list item string */
  {
      int		i;
      join_T	*p;
***************
*** 6825,6836 ****
   * Return FAIL or OK.
   */
      static int
! list_join(gap, l, sep, echo_style, copyID)
!     garray_T	*gap;
!     list_T	*l;
!     char_u	*sep;
!     int		echo_style;
!     int		copyID;
  {
      garray_T	join_ga;
      int		retval;
--- 6700,6711 ----
   * Return FAIL or OK.
   */
      static int
! list_join(
!     garray_T	*gap,
!     list_T	*l,
!     char_u	*sep,
!     int		echo_style,
!     int		copyID)
  {
      garray_T	join_ga;
      int		retval;
***************
*** 6862,6868 ****
   * Used for serializing nested structures.
   */
      int
! get_copyID()
  {
      current_copyID += COPYID_INC;
      return current_copyID;
--- 6737,6743 ----
   * Used for serializing nested structures.
   */
      int
! get_copyID(void)
  {
      current_copyID += COPYID_INC;
      return current_copyID;
***************
*** 6893,6899 ****
   * Return TRUE if some memory was freed.
   */
      int
! garbage_collect()
  {
      int		copyID;
      int		abort = FALSE;
--- 6768,6774 ----
   * Return TRUE if some memory was freed.
   */
      int
! garbage_collect(void)
  {
      int		copyID;
      int		abort = FALSE;
***************
*** 7023,7030 ****
   * Free lists and dictionaries that are no longer referenced.
   */
      static int
! free_unref_items(copyID)
!     int copyID;
  {
      dict_T	*dd, *dd_next;
      list_T	*ll, *ll_next;
--- 6898,6904 ----
   * Free lists and dictionaries that are no longer referenced.
   */
      static int
! free_unref_items(int copyID)
  {
      dict_T	*dd, *dd_next;
      list_T	*ll, *ll_next;
***************
*** 7076,7085 ****
   * Returns TRUE if setting references failed somehow.
   */
      int
! set_ref_in_ht(ht, copyID, list_stack)
!     hashtab_T	    *ht;
!     int		    copyID;
!     list_stack_T    **list_stack;
  {
      int		todo;
      int		abort = FALSE;
--- 6950,6956 ----
   * Returns TRUE if setting references failed somehow.
   */
      int
! set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)
  {
      int		todo;
      int		abort = FALSE;
***************
*** 7126,7135 ****
   * Returns TRUE if setting references failed somehow.
   */
      int
! set_ref_in_list(l, copyID, ht_stack)
!     list_T	*l;
!     int		copyID;
!     ht_stack_T	**ht_stack;
  {
      listitem_T	 *li;
      int		 abort = FALSE;
--- 6997,7003 ----
   * Returns TRUE if setting references failed somehow.
   */
      int
! set_ref_in_list(list_T *l, int copyID, ht_stack_T **ht_stack)
  {
      listitem_T	 *li;
      int		 abort = FALSE;
***************
*** 7168,7178 ****
   * Returns TRUE if setting references failed somehow.
   */
      int
! set_ref_in_item(tv, copyID, ht_stack, list_stack)
!     typval_T	    *tv;
!     int		    copyID;
!     ht_stack_T	    **ht_stack;
!     list_stack_T    **list_stack;
  {
      dict_T	*dd;
      list_T	*ll;
--- 7036,7046 ----
   * Returns TRUE if setting references failed somehow.
   */
      int
! set_ref_in_item(
!     typval_T	    *tv,
!     int		    copyID,
!     ht_stack_T	    **ht_stack,
!     list_stack_T    **list_stack)
  {
      dict_T	*dd;
      list_T	*ll;
***************
*** 7239,7245 ****
   * Allocate an empty header for a dictionary.
   */
      dict_T *
! dict_alloc()
  {
      dict_T *d;
  
--- 7107,7113 ----
   * Allocate an empty header for a dictionary.
   */
      dict_T *
! dict_alloc(void)
  {
      dict_T *d;
  
***************
*** 7267,7274 ****
   * Returns OK or FAIL.
   */
      int
! rettv_dict_alloc(rettv)
!     typval_T	*rettv;
  {
      dict_T	*d = dict_alloc();
  
--- 7135,7141 ----
   * Returns OK or FAIL.
   */
      int
! rettv_dict_alloc(typval_T *rettv)
  {
      dict_T	*d = dict_alloc();
  
***************
*** 7287,7294 ****
   * becomes zero.
   */
      void
! dict_unref(d)
!     dict_T *d;
  {
      if (d != NULL && --d->dv_refcount <= 0)
  	dict_free(d, TRUE);
--- 7154,7160 ----
   * becomes zero.
   */
      void
! dict_unref(dict_T *d)
  {
      if (d != NULL && --d->dv_refcount <= 0)
  	dict_free(d, TRUE);
***************
*** 7299,7307 ****
   * Ignores the reference count.
   */
      void
! dict_free(d, recurse)
!     dict_T  *d;
!     int	    recurse;	/* Free Lists and Dictionaries recursively. */
  {
      int		todo;
      hashitem_T	*hi;
--- 7165,7173 ----
   * Ignores the reference count.
   */
      void
! dict_free(
!     dict_T  *d,
!     int	    recurse)	/* Free Lists and Dictionaries recursively. */
  {
      int		todo;
      hashitem_T	*hi;
***************
*** 7344,7351 ****
   * Returns NULL when out of memory.
   */
      dictitem_T *
! dictitem_alloc(key)
!     char_u	*key;
  {
      dictitem_T *di;
  
--- 7210,7216 ----
   * Returns NULL when out of memory.
   */
      dictitem_T *
! dictitem_alloc(char_u *key)
  {
      dictitem_T *di;
  
***************
*** 7362,7369 ****
   * Make a copy of a Dictionary item.
   */
      static dictitem_T *
! dictitem_copy(org)
!     dictitem_T *org;
  {
      dictitem_T *di;
  
--- 7227,7233 ----
   * Make a copy of a Dictionary item.
   */
      static dictitem_T *
! dictitem_copy(dictitem_T *org)
  {
      dictitem_T *di;
  
***************
*** 7382,7390 ****
   * Remove item "item" from Dictionary "dict" and free it.
   */
      static void
! dictitem_remove(dict, item)
!     dict_T	*dict;
!     dictitem_T	*item;
  {
      hashitem_T	*hi;
  
--- 7246,7252 ----
   * Remove item "item" from Dictionary "dict" and free it.
   */
      static void
! dictitem_remove(dict_T *dict, dictitem_T *item)
  {
      hashitem_T	*hi;
  
***************
*** 7400,7407 ****
   * Free a dict item.  Also clears the value.
   */
      void
! dictitem_free(item)
!     dictitem_T *item;
  {
      clear_tv(&item->di_tv);
      if (item->di_flags & DI_FLAGS_ALLOC)
--- 7262,7268 ----
   * Free a dict item.  Also clears the value.
   */
      void
! dictitem_free(dictitem_T *item)
  {
      clear_tv(&item->di_tv);
      if (item->di_flags & DI_FLAGS_ALLOC)
***************
*** 7415,7424 ****
   * Returns NULL when out of memory.
   */
      static dict_T *
! dict_copy(orig, deep, copyID)
!     dict_T	*orig;
!     int		deep;
!     int		copyID;
  {
      dict_T	*copy;
      dictitem_T	*di;
--- 7276,7282 ----
   * Returns NULL when out of memory.
   */
      static dict_T *
! dict_copy(dict_T *orig, int deep, int copyID)
  {
      dict_T	*copy;
      dictitem_T	*di;
***************
*** 7481,7489 ****
   * Returns FAIL when out of memory and when key already exists.
   */
      int
! dict_add(d, item)
!     dict_T	*d;
!     dictitem_T	*item;
  {
      return hash_add(&d->dv_hashtab, item->di_key);
  }
--- 7339,7345 ----
   * Returns FAIL when out of memory and when key already exists.
   */
      int
! dict_add(dict_T *d, dictitem_T *item)
  {
      return hash_add(&d->dv_hashtab, item->di_key);
  }
***************
*** 7494,7504 ****
   * Returns FAIL when out of memory and when key already exists.
   */
      int
! dict_add_nr_str(d, key, nr, str)
!     dict_T	*d;
!     char	*key;
!     long	nr;
!     char_u	*str;
  {
      dictitem_T	*item;
  
--- 7350,7360 ----
   * Returns FAIL when out of memory and when key already exists.
   */
      int
! dict_add_nr_str(
!     dict_T	*d,
!     char	*key,
!     long	nr,
!     char_u	*str)
  {
      dictitem_T	*item;
  
***************
*** 7529,7538 ****
   * Returns FAIL when out of memory and when key already exists.
   */
      int
! dict_add_list(d, key, list)
!     dict_T	*d;
!     char	*key;
!     list_T	*list;
  {
      dictitem_T	*item;
  
--- 7385,7391 ----
   * Returns FAIL when out of memory and when key already exists.
   */
      int
! dict_add_list(dict_T *d, char *key, list_T *list)
  {
      dictitem_T	*item;
  
***************
*** 7555,7562 ****
   * Get the number of items in a Dictionary.
   */
      static long
! dict_len(d)
!     dict_T	*d;
  {
      if (d == NULL)
  	return 0L;
--- 7408,7414 ----
   * Get the number of items in a Dictionary.
   */
      static long
! dict_len(dict_T *d)
  {
      if (d == NULL)
  	return 0L;
***************
*** 7569,7578 ****
   * Returns NULL when not found.
   */
      dictitem_T *
! dict_find(d, key, len)
!     dict_T	*d;
!     char_u	*key;
!     int		len;
  {
  #define AKEYLEN 200
      char_u	buf[AKEYLEN];
--- 7421,7427 ----
   * Returns NULL when not found.
   */
      dictitem_T *
! dict_find(dict_T *d, char_u *key, int len)
  {
  #define AKEYLEN 200
      char_u	buf[AKEYLEN];
***************
*** 7608,7617 ****
   * Returns NULL if the entry doesn't exist or out of memory.
   */
      char_u *
! get_dict_string(d, key, save)
!     dict_T	*d;
!     char_u	*key;
!     int		save;
  {
      dictitem_T	*di;
      char_u	*s;
--- 7457,7463 ----
   * Returns NULL if the entry doesn't exist or out of memory.
   */
      char_u *
! get_dict_string(dict_T *d, char_u *key, int save)
  {
      dictitem_T	*di;
      char_u	*s;
***************
*** 7630,7638 ****
   * Returns 0 if the entry doesn't exist or out of memory.
   */
      long
! get_dict_number(d, key)
!     dict_T	*d;
!     char_u	*key;
  {
      dictitem_T	*di;
  
--- 7476,7482 ----
   * Returns 0 if the entry doesn't exist or out of memory.
   */
      long
! get_dict_number(dict_T *d, char_u *key)
  {
      dictitem_T	*di;
  
***************
*** 7647,7655 ****
   * May return NULL.
   */
      static char_u *
! dict2string(tv, copyID)
!     typval_T	*tv;
!     int		copyID;
  {
      garray_T	ga;
      int		first = TRUE;
--- 7491,7497 ----
   * May return NULL.
   */
      static char_u *
! dict2string(typval_T *tv, int copyID)
  {
      garray_T	ga;
      int		first = TRUE;
***************
*** 7710,7719 ****
   * Return OK or FAIL.  Returns NOTDONE for {expr}.
   */
      static int
! get_dict_tv(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      dict_T	*d = NULL;
      typval_T	tvkey;
--- 7552,7558 ----
   * Return OK or FAIL.  Returns NOTDONE for {expr}.
   */
      static int
! get_dict_tv(char_u **arg, typval_T *rettv, int evaluate)
  {
      dict_T	*d = NULL;
      typval_T	tvkey;
***************
*** 7852,7862 ****
   * May return NULL.
   */
      static char_u *
! echo_string(tv, tofree, numbuf, copyID)
!     typval_T	*tv;
!     char_u	**tofree;
!     char_u	*numbuf;
!     int		copyID;
  {
      static int	recurse = 0;
      char_u	*r = NULL;
--- 7691,7701 ----
   * May return NULL.
   */
      static char_u *
! echo_string(
!     typval_T	*tv,
!     char_u	**tofree,
!     char_u	*numbuf,
!     int		copyID)
  {
      static int	recurse = 0;
      char_u	*r = NULL;
***************
*** 7958,7968 ****
   * May return NULL.
   */
      static char_u *
! tv2string(tv, tofree, numbuf, copyID)
!     typval_T	*tv;
!     char_u	**tofree;
!     char_u	*numbuf;
!     int		copyID;
  {
      switch (tv->v_type)
      {
--- 7797,7807 ----
   * May return NULL.
   */
      static char_u *
! tv2string(
!     typval_T	*tv,
!     char_u	**tofree,
!     char_u	*numbuf,
!     int		copyID)
  {
      switch (tv->v_type)
      {
***************
*** 7995,8003 ****
   * If "function" is TRUE make it function('string').
   */
      static char_u *
! string_quote(str, function)
!     char_u	*str;
!     int		function;
  {
      unsigned	len;
      char_u	*p, *r, *s;
--- 7834,7840 ----
   * If "function" is TRUE make it function('string').
   */
      static char_u *
! string_quote(char_u *str, int function)
  {
      unsigned	len;
      char_u	*p, *r, *s;
***************
*** 8043,8051 ****
   * Returns the length of the text that was consumed.
   */
      int
! string2float(text, value)
!     char_u	*text;
!     float_T	*value;	    /* result stored here */
  {
      char	*s = (char *)text;
      float_T	f;
--- 7880,7888 ----
   * Returns the length of the text that was consumed.
   */
      int
! string2float(
!     char_u	*text,
!     float_T	*value)	    /* result stored here */
  {
      char	*s = (char *)text;
      float_T	f;
***************
*** 8063,8072 ****
   * Return FAIL if the name is invalid.
   */
      static int
! get_env_tv(arg, rettv, evaluate)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;
  {
      char_u	*string = NULL;
      int		len;
--- 7900,7906 ----
   * Return FAIL if the name is invalid.
   */
      static int
! get_env_tv(char_u **arg, typval_T *rettv, int evaluate)
  {
      char_u	*string = NULL;
      int		len;
***************
*** 8481,8489 ****
   * or user defined function names.
   */
      char_u *
! get_function_name(xp, idx)
!     expand_T	*xp;
!     int		idx;
  {
      static int	intidx = -1;
      char_u	*name;
--- 8315,8321 ----
   * or user defined function names.
   */
      char_u *
! get_function_name(expand_T *xp, int idx)
  {
      static int	intidx = -1;
      char_u	*name;
***************
*** 8513,8521 ****
   * user defined variable or function names.
   */
      char_u *
! get_expr_name(xp, idx)
!     expand_T	*xp;
!     int		idx;
  {
      static int	intidx = -1;
      char_u	*name;
--- 8345,8351 ----
   * user defined variable or function names.
   */
      char_u *
! get_expr_name(expand_T *xp, int idx)
  {
      static int	intidx = -1;
      char_u	*name;
***************
*** 8538,8546 ****
   * Compare struct fst by function name.
   */
      static int
! compare_func_name(s1, s2)
!     const void *s1;
!     const void *s2;
  {
      struct fst *p1 = (struct fst *)s1;
      struct fst *p2 = (struct fst *)s2;
--- 8368,8374 ----
   * Compare struct fst by function name.
   */
      static int
! compare_func_name(const void *s1, const void *s2)
  {
      struct fst *p1 = (struct fst *)s1;
      struct fst *p2 = (struct fst *)s2;
***************
*** 8554,8560 ****
   * On machines using EBCDIC we have to sort it.
   */
      static void
! sortFunctions()
  {
      int		funcCnt = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
  
--- 8382,8388 ----
   * On machines using EBCDIC we have to sort it.
   */
      static void
! sortFunctions(void)
  {
      int		funcCnt = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
  
***************
*** 8568,8575 ****
   * Return index, or -1 if not found
   */
      static int
! find_internal_func(name)
!     char_u	*name;		/* name of the function */
  {
      int		first = 0;
      int		last = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
--- 8396,8403 ----
   * Return index, or -1 if not found
   */
      static int
! find_internal_func(
!     char_u	*name)		/* name of the function */
  {
      int		first = 0;
      int		last = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
***************
*** 8598,8607 ****
   * name it contains, otherwise return "name".
   */
      static char_u *
! deref_func_name(name, lenp, no_autoload)
!     char_u	*name;
!     int		*lenp;
!     int		no_autoload;
  {
      dictitem_T	*v;
      int		cc;
--- 8426,8432 ----
   * name it contains, otherwise return "name".
   */
      static char_u *
! deref_func_name(char_u *name, int *lenp, int no_autoload)
  {
      dictitem_T	*v;
      int		cc;
***************
*** 8629,8645 ****
   * Return OK or FAIL.
   */
      static int
! get_func_tv(name, len, rettv, arg, firstline, lastline, doesrange,
! 							   evaluate, selfdict)
!     char_u	*name;		/* name of the function */
!     int		len;		/* length of "name" */
!     typval_T	*rettv;
!     char_u	**arg;		/* argument, pointing to the '(' */
!     linenr_T	firstline;	/* first line of range */
!     linenr_T	lastline;	/* last line of range */
!     int		*doesrange;	/* return: function handled range */
!     int		evaluate;
!     dict_T	*selfdict;	/* Dictionary for "self" */
  {
      char_u	*argp;
      int		ret = OK;
--- 8454,8469 ----
   * Return OK or FAIL.
   */
      static int
! get_func_tv(
!     char_u	*name,		/* name of the function */
!     int		len,		/* length of "name" */
!     typval_T	*rettv,
!     char_u	**arg,		/* argument, pointing to the '(' */
!     linenr_T	firstline,	/* first line of range */
!     linenr_T	lastline,	/* last line of range */
!     int		*doesrange,	/* return: function handled range */
!     int		evaluate,
!     dict_T	*selfdict)	/* Dictionary for "self" */
  {
      char_u	*argp;
      int		ret = OK;
***************
*** 8694,8712 ****
   * Also returns OK when an error was encountered while executing the function.
   */
      int
! call_func(funcname, len, rettv, argcount, argvars, firstline, lastline,
! 						doesrange, evaluate, selfdict)
!     char_u	*funcname;	/* name of the function */
!     int		len;		/* length of "name" */
!     typval_T	*rettv;		/* return value goes here */
!     int		argcount;	/* number of "argvars" */
!     typval_T	*argvars;	/* vars for arguments, must have "argcount"
  				   PLUS ONE elements! */
!     linenr_T	firstline;	/* first line of range */
!     linenr_T	lastline;	/* last line of range */
!     int		*doesrange;	/* return: function handled range */
!     int		evaluate;
!     dict_T	*selfdict;	/* Dictionary for "self" */
  {
      int		ret = FAIL;
  #define ERROR_UNKNOWN	0
--- 8518,8535 ----
   * Also returns OK when an error was encountered while executing the function.
   */
      int
! call_func(
!     char_u	*funcname,	/* name of the function */
!     int		len,		/* length of "name" */
!     typval_T	*rettv,		/* return value goes here */
!     int		argcount,	/* number of "argvars" */
!     typval_T	*argvars,	/* vars for arguments, must have "argcount"
  				   PLUS ONE elements! */
!     linenr_T	firstline,	/* first line of range */
!     linenr_T	lastline,	/* last line of range */
!     int		*doesrange,	/* return: function handled range */
!     int		evaluate,
!     dict_T	*selfdict)	/* Dictionary for "self" */
  {
      int		ret = FAIL;
  #define ERROR_UNKNOWN	0
***************
*** 8933,8941 ****
   * "ermsg" is to be passed without translation, use N_() instead of _().
   */
      static void
! emsg_funcname(ermsg, name)
!     char	*ermsg;
!     char_u	*name;
  {
      char_u	*p;
  
--- 8756,8762 ----
   * "ermsg" is to be passed without translation, use N_() instead of _().
   */
      static void
! emsg_funcname(char *ermsg, char_u *name)
  {
      char_u	*p;
  
***************
*** 8952,8959 ****
   * Return TRUE for a non-zero Number and a non-empty String.
   */
      static int
! non_zero_arg(argvars)
!     typval_T	*argvars;
  {
      return ((argvars[0].v_type == VAR_NUMBER
  		&& argvars[0].vval.v_number != 0)
--- 8773,8779 ----
   * Return TRUE for a non-zero Number and a non-empty String.
   */
      static int
! non_zero_arg(typval_T *argvars)
  {
      return ((argvars[0].v_type == VAR_NUMBER
  		&& argvars[0].vval.v_number != 0)
***************
*** 8974,8982 ****
   * Returns FAIL when the argument is not a Number or Float.
   */
      static int
! get_float_arg(argvars, f)
!     typval_T	*argvars;
!     float_T	*f;
  {
      if (argvars[0].v_type == VAR_FLOAT)
      {
--- 8794,8800 ----
   * Returns FAIL when the argument is not a Number or Float.
   */
      static int
! get_float_arg(typval_T *argvars, float_T *f)
  {
      if (argvars[0].v_type == VAR_FLOAT)
      {
***************
*** 8996,9004 ****
   * "abs(expr)" function
   */
      static void
! f_abs(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      if (argvars[0].v_type == VAR_FLOAT)
      {
--- 8814,8820 ----
   * "abs(expr)" function
   */
      static void
! f_abs(typval_T *argvars, typval_T *rettv)
  {
      if (argvars[0].v_type == VAR_FLOAT)
      {
***************
*** 9024,9032 ****
   * "acos()" function
   */
      static void
! f_acos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 8840,8846 ----
   * "acos()" function
   */
      static void
! f_acos(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 9042,9050 ****
   * "add(list, item)" function
   */
      static void
! f_add(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      list_T	*l;
  
--- 8856,8862 ----
   * "add(list, item)" function
   */
      static void
! f_add(typval_T *argvars, typval_T *rettv)
  {
      list_T	*l;
  
***************
*** 9065,9073 ****
   * "alloc_fail(id, countdown, repeat)" function
   */
      static void
! f_alloc_fail(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      if (argvars[0].v_type != VAR_NUMBER
  	    || argvars[0].vval.v_number <= 0
--- 8877,8883 ----
   * "alloc_fail(id, countdown, repeat)" function
   */
      static void
! f_alloc_fail(typval_T *argvars, typval_T *rettv UNUSED)
  {
      if (argvars[0].v_type != VAR_NUMBER
  	    || argvars[0].vval.v_number <= 0
***************
*** 9090,9098 ****
   * "and(expr, expr)" function
   */
      static void
! f_and(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
  					& get_tv_number_chk(&argvars[1], NULL);
--- 8900,8906 ----
   * "and(expr, expr)" function
   */
      static void
! f_and(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
  					& get_tv_number_chk(&argvars[1], NULL);
***************
*** 9102,9110 ****
   * "append(lnum, string/list)" function
   */
      static void
! f_append(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      long	lnum;
      char_u	*line;
--- 8910,8916 ----
   * "append(lnum, string/list)" function
   */
      static void
! f_append(typval_T *argvars, typval_T *rettv)
  {
      long	lnum;
      char_u	*line;
***************
*** 9166,9174 ****
   * "argc()" function
   */
      static void
! f_argc(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = ARGCOUNT;
  }
--- 8972,8978 ----
   * "argc()" function
   */
      static void
! f_argc(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = ARGCOUNT;
  }
***************
*** 9177,9185 ****
   * "argidx()" function
   */
      static void
! f_argidx(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = curwin->w_arg_idx;
  }
--- 8981,8987 ----
   * "argidx()" function
   */
      static void
! f_argidx(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = curwin->w_arg_idx;
  }
***************
*** 9188,9196 ****
   * "arglistid()" function
   */
      static void
! f_arglistid(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      win_T	*wp;
  
--- 8990,8996 ----
   * "arglistid()" function
   */
      static void
! f_arglistid(typval_T *argvars UNUSED, typval_T *rettv)
  {
      win_T	*wp;
  
***************
*** 9204,9212 ****
   * "argv(nr)" function
   */
      static void
! f_argv(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		idx;
  
--- 9004,9010 ----
   * "argv(nr)" function
   */
      static void
! f_argv(typval_T *argvars, typval_T *rettv)
  {
      int		idx;
  
***************
*** 9234,9241 ****
   * Prepare "gap" for an assert error and add the sourcing position.
   */
      static void
! prepare_assert_error(gap)
!     garray_T	*gap;
  {
      char buf[NUMBUFLEN];
  
--- 9032,9038 ----
   * Prepare "gap" for an assert error and add the sourcing position.
   */
      static void
! prepare_assert_error(garray_T *gap)
  {
      char buf[NUMBUFLEN];
  
***************
*** 9259,9270 ****
   * Fill "gap" with information about an assert error.
   */
      static void
! fill_assert_error(gap, opt_msg_tv, exp_str, exp_tv, got_tv)
!     garray_T	*gap;
!     typval_T	*opt_msg_tv;
!     char_u      *exp_str;
!     typval_T	*exp_tv;
!     typval_T	*got_tv;
  {
      char_u	numbuf[NUMBUFLEN];
      char_u	*tofree;
--- 9056,9067 ----
   * Fill "gap" with information about an assert error.
   */
      static void
! fill_assert_error(
!     garray_T	*gap,
!     typval_T	*opt_msg_tv,
!     char_u      *exp_str,
!     typval_T	*exp_tv,
!     typval_T	*got_tv)
  {
      char_u	numbuf[NUMBUFLEN];
      char_u	*tofree;
***************
*** 9294,9301 ****
   * Add an assert error to v:errors.
   */
      static void
! assert_error(gap)
!     garray_T	*gap;
  {
      struct vimvar   *vp = &vimvars[VV_ERRORS];
  
--- 9091,9097 ----
   * Add an assert error to v:errors.
   */
      static void
! assert_error(garray_T *gap)
  {
      struct vimvar   *vp = &vimvars[VV_ERRORS];
  
***************
*** 9309,9317 ****
   * "assert_equal(expected, actual[, msg])" function
   */
      static void
! f_assert_equal(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      garray_T	ga;
  
--- 9105,9111 ----
   * "assert_equal(expected, actual[, msg])" function
   */
      static void
! f_assert_equal(typval_T *argvars, typval_T *rettv UNUSED)
  {
      garray_T	ga;
  
***************
*** 9328,9336 ****
   * "assert_exception(string[, msg])" function
   */
      static void
! f_assert_exception(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      garray_T	ga;
      char	*error;
--- 9122,9128 ----
   * "assert_exception(string[, msg])" function
   */
      static void
! f_assert_exception(typval_T *argvars, typval_T *rettv UNUSED)
  {
      garray_T	ga;
      char	*error;
***************
*** 9358,9366 ****
   * "assert_fails(cmd [, error])" function
   */
      static void
! f_assert_fails(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      char_u	*cmd = get_tv_string_chk(&argvars[0]);
      garray_T	ga;
--- 9150,9156 ----
   * "assert_fails(cmd [, error])" function
   */
      static void
! f_assert_fails(typval_T *argvars, typval_T *rettv UNUSED)
  {
      char_u	*cmd = get_tv_string_chk(&argvars[0]);
      garray_T	ga;
***************
*** 9403,9411 ****
   * Common for assert_true() and assert_false().
   */
      static void
! assert_bool(argvars, isTrue)
!     typval_T	*argvars;
!     int		isTrue;
  {
      int		error = FALSE;
      garray_T	ga;
--- 9193,9199 ----
   * Common for assert_true() and assert_false().
   */
      static void
! assert_bool(typval_T *argvars, int isTrue)
  {
      int		error = FALSE;
      garray_T	ga;
***************
*** 9427,9435 ****
   * "assert_false(actual[, msg])" function
   */
      static void
! f_assert_false(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      assert_bool(argvars, FALSE);
  }
--- 9215,9221 ----
   * "assert_false(actual[, msg])" function
   */
      static void
! f_assert_false(typval_T *argvars, typval_T *rettv UNUSED)
  {
      assert_bool(argvars, FALSE);
  }
***************
*** 9438,9446 ****
   * "assert_true(actual[, msg])" function
   */
      static void
! f_assert_true(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      assert_bool(argvars, TRUE);
  }
--- 9224,9230 ----
   * "assert_true(actual[, msg])" function
   */
      static void
! f_assert_true(typval_T *argvars, typval_T *rettv UNUSED)
  {
      assert_bool(argvars, TRUE);
  }
***************
*** 9450,9458 ****
   * "asin()" function
   */
      static void
! f_asin(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 9234,9240 ----
   * "asin()" function
   */
      static void
! f_asin(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 9467,9475 ****
   * "atan()" function
   */
      static void
! f_atan(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 9249,9255 ----
   * "atan()" function
   */
      static void
! f_atan(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 9484,9492 ****
   * "atan2()" function
   */
      static void
! f_atan2(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	fx, fy;
  
--- 9264,9270 ----
   * "atan2()" function
   */
      static void
! f_atan2(typval_T *argvars, typval_T *rettv)
  {
      float_T	fx, fy;
  
***************
*** 9503,9511 ****
   * "browse(save, title, initdir, default)" function
   */
      static void
! f_browse(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
      int		save;
--- 9281,9287 ----
   * "browse(save, title, initdir, default)" function
   */
      static void
! f_browse(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_BROWSE
      int		save;
***************
*** 9537,9545 ****
   * "browsedir(title, initdir)" function
   */
      static void
! f_browsedir(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
      char_u	*title;
--- 9313,9319 ----
   * "browsedir(title, initdir)" function
   */
      static void
! f_browsedir(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_BROWSE
      char_u	*title;
***************
*** 9566,9573 ****
   * Find a buffer by number or exact name.
   */
      static buf_T *
! find_buffer(avar)
!     typval_T	*avar;
  {
      buf_T	*buf = NULL;
  
--- 9340,9346 ----
   * Find a buffer by number or exact name.
   */
      static buf_T *
! find_buffer(typval_T *avar)
  {
      buf_T	*buf = NULL;
  
***************
*** 9598,9606 ****
   * "bufexists(expr)" function
   */
      static void
! f_bufexists(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = (find_buffer(&argvars[0]) != NULL);
  }
--- 9371,9377 ----
   * "bufexists(expr)" function
   */
      static void
! f_bufexists(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = (find_buffer(&argvars[0]) != NULL);
  }
***************
*** 9609,9617 ****
   * "buflisted(expr)" function
   */
      static void
! f_buflisted(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      buf_T	*buf;
  
--- 9380,9386 ----
   * "buflisted(expr)" function
   */
      static void
! f_buflisted(typval_T *argvars, typval_T *rettv)
  {
      buf_T	*buf;
  
***************
*** 9623,9631 ****
   * "bufloaded(expr)" function
   */
      static void
! f_bufloaded(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      buf_T	*buf;
  
--- 9392,9398 ----
   * "bufloaded(expr)" function
   */
      static void
! f_bufloaded(typval_T *argvars, typval_T *rettv)
  {
      buf_T	*buf;
  
***************
*** 9639,9647 ****
   * Get buffer by number or pattern.
   */
      static buf_T *
! get_buf_tv(tv, curtab_only)
!     typval_T	*tv;
!     int		curtab_only;
  {
      char_u	*name = tv->vval.v_string;
      int		save_magic;
--- 9406,9412 ----
   * Get buffer by number or pattern.
   */
      static buf_T *
! get_buf_tv(typval_T *tv, int curtab_only)
  {
      char_u	*name = tv->vval.v_string;
      int		save_magic;
***************
*** 9680,9688 ****
   * "bufname(expr)" function
   */
      static void
! f_bufname(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      buf_T	*buf;
  
--- 9445,9451 ----
   * "bufname(expr)" function
   */
      static void
! f_bufname(typval_T *argvars, typval_T *rettv)
  {
      buf_T	*buf;
  
***************
*** 9701,9709 ****
   * "bufnr(expr)" function
   */
      static void
! f_bufnr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      buf_T	*buf;
      int		error = FALSE;
--- 9464,9470 ----
   * "bufnr(expr)" function
   */
      static void
! f_bufnr(typval_T *argvars, typval_T *rettv)
  {
      buf_T	*buf;
      int		error = FALSE;
***************
*** 9734,9742 ****
   * "bufwinnr(nr)" function
   */
      static void
! f_bufwinnr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
--- 9495,9501 ----
   * "bufwinnr(nr)" function
   */
      static void
! f_bufwinnr(typval_T *argvars, typval_T *rettv)
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
***************
*** 9765,9773 ****
   * "byte2line(byte)" function
   */
      static void
! f_byte2line(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifndef FEAT_BYTEOFF
      rettv->vval.v_number = -1;
--- 9524,9530 ----
   * "byte2line(byte)" function
   */
      static void
! f_byte2line(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifndef FEAT_BYTEOFF
      rettv->vval.v_number = -1;
***************
*** 9784,9793 ****
  }
  
      static void
! byteidx(argvars, rettv, comp)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		comp UNUSED;
  {
  #ifdef FEAT_MBYTE
      char_u	*t;
--- 9541,9547 ----
  }
  
      static void
! byteidx(typval_T *argvars, typval_T *rettv, int comp UNUSED)
  {
  #ifdef FEAT_MBYTE
      char_u	*t;
***************
*** 9823,9831 ****
   * "byteidx()" function
   */
      static void
! f_byteidx(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      byteidx(argvars, rettv, FALSE);
  }
--- 9577,9583 ----
   * "byteidx()" function
   */
      static void
! f_byteidx(typval_T *argvars, typval_T *rettv)
  {
      byteidx(argvars, rettv, FALSE);
  }
***************
*** 9834,9852 ****
   * "byteidxcomp()" function
   */
      static void
! f_byteidxcomp(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      byteidx(argvars, rettv, TRUE);
  }
  
      int
! func_call(name, args, selfdict, rettv)
!     char_u	*name;
!     typval_T	*args;
!     dict_T	*selfdict;
!     typval_T	*rettv;
  {
      listitem_T	*item;
      typval_T	argv[MAX_FUNC_ARGS + 1];
--- 9586,9602 ----
   * "byteidxcomp()" function
   */
      static void
! f_byteidxcomp(typval_T *argvars, typval_T *rettv)
  {
      byteidx(argvars, rettv, TRUE);
  }
  
      int
! func_call(
!     char_u	*name,
!     typval_T	*args,
!     dict_T	*selfdict,
!     typval_T	*rettv)
  {
      listitem_T	*item;
      typval_T	argv[MAX_FUNC_ARGS + 1];
***************
*** 9884,9892 ****
   * "call(func, arglist)" function
   */
      static void
! f_call(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*func;
      dict_T	*selfdict = NULL;
--- 9634,9640 ----
   * "call(func, arglist)" function
   */
      static void
! f_call(typval_T *argvars, typval_T *rettv)
  {
      char_u	*func;
      dict_T	*selfdict = NULL;
***************
*** 9924,9932 ****
   * "ceil({float})" function
   */
      static void
! f_ceil(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 9672,9678 ----
   * "ceil({float})" function
   */
      static void
! f_ceil(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 9942,9950 ****
   * "changenr()" function
   */
      static void
! f_changenr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = curbuf->b_u_seq_cur;
  }
--- 9688,9694 ----
   * "changenr()" function
   */
      static void
! f_changenr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = curbuf->b_u_seq_cur;
  }
***************
*** 9953,9961 ****
   * "char2nr(string)" function
   */
      static void
! f_char2nr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
--- 9697,9703 ----
   * "char2nr(string)" function
   */
      static void
! f_char2nr(typval_T *argvars, typval_T *rettv)
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
***************
*** 9979,9987 ****
   * "cindent(lnum)" function
   */
      static void
! f_cindent(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CINDENT
      pos_T	pos;
--- 9721,9727 ----
   * "cindent(lnum)" function
   */
      static void
! f_cindent(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_CINDENT
      pos_T	pos;
***************
*** 10004,10012 ****
   * "clearmatches()" function
   */
      static void
! f_clearmatches(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      clear_matches(curwin);
--- 9744,9750 ----
   * "clearmatches()" function
   */
      static void
! f_clearmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_SEARCH_EXTRA
      clear_matches(curwin);
***************
*** 10017,10025 ****
   * "col(string)" function
   */
      static void
! f_col(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      colnr_T	col = 0;
      pos_T	*fp;
--- 9755,9761 ----
   * "col(string)" function
   */
      static void
! f_col(typval_T *argvars, typval_T *rettv)
  {
      colnr_T	col = 0;
      pos_T	*fp;
***************
*** 10071,10079 ****
   * "complete()" function
   */
      static void
! f_complete(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      int	    startcol;
  
--- 9807,9813 ----
   * "complete()" function
   */
      static void
! f_complete(typval_T *argvars, typval_T *rettv UNUSED)
  {
      int	    startcol;
  
***************
*** 10105,10113 ****
   * "complete_add()" function
   */
      static void
! f_complete_add(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = ins_compl_add_tv(&argvars[0], 0);
  }
--- 9839,9845 ----
   * "complete_add()" function
   */
      static void
! f_complete_add(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = ins_compl_add_tv(&argvars[0], 0);
  }
***************
*** 10116,10124 ****
   * "complete_check()" function
   */
      static void
! f_complete_check(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		saved = RedrawingDisabled;
  
--- 9848,9854 ----
   * "complete_check()" function
   */
      static void
! f_complete_check(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		saved = RedrawingDisabled;
  
***************
*** 10133,10141 ****
   * "confirm(message, buttons[, default [, type]])" function
   */
      static void
! f_confirm(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
      char_u	*message;
--- 9863,9869 ----
   * "confirm(message, buttons[, default [, type]])" function
   */
      static void
! f_confirm(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
      char_u	*message;
***************
*** 10191,10199 ****
   * "copy()" function
   */
      static void
! f_copy(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      item_copy(&argvars[0], rettv, FALSE, 0);
  }
--- 9919,9925 ----
   * "copy()" function
   */
      static void
! f_copy(typval_T *argvars, typval_T *rettv)
  {
      item_copy(&argvars[0], rettv, FALSE, 0);
  }
***************
*** 10203,10211 ****
   * "cos()" function
   */
      static void
! f_cos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 9929,9935 ----
   * "cos()" function
   */
      static void
! f_cos(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 10220,10228 ****
   * "cosh()" function
   */
      static void
! f_cosh(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 9944,9950 ----
   * "cosh()" function
   */
      static void
! f_cosh(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 10238,10246 ****
   * "count()" function
   */
      static void
! f_count(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      long	n = 0;
      int		ic = FALSE;
--- 9960,9966 ----
   * "count()" function
   */
      static void
! f_count(typval_T *argvars, typval_T *rettv)
  {
      long	n = 0;
      int		ic = FALSE;
***************
*** 10333,10341 ****
   * "connect()" function
   */
      static void
! f_connect(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*address;
      char_u	*mode;
--- 10053,10059 ----
   * "connect()" function
   */
      static void
! f_connect(typval_T *argvars, typval_T *rettv)
  {
      char_u	*address;
      char_u	*mode;
***************
*** 10395,10403 ****
   * Checks the existence of a cscope connection.
   */
      static void
! f_cscope_connection(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_CSCOPE
      int		num = 0;
--- 10113,10119 ----
   * Checks the existence of a cscope connection.
   */
      static void
! f_cscope_connection(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_CSCOPE
      int		num = 0;
***************
*** 10426,10434 ****
   * Returns 0 when the position could be set, -1 otherwise.
   */
      static void
! f_cursor(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      long	line, col;
  #ifdef FEAT_VIRTUALEDIT
--- 10142,10148 ----
   * Returns 0 when the position could be set, -1 otherwise.
   */
      static void
! f_cursor(typval_T *argvars, typval_T *rettv)
  {
      long	line, col;
  #ifdef FEAT_VIRTUALEDIT
***************
*** 10497,10505 ****
   * "deepcopy()" function
   */
      static void
! f_deepcopy(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		noref = 0;
  
--- 10211,10217 ----
   * "deepcopy()" function
   */
      static void
! f_deepcopy(typval_T *argvars, typval_T *rettv)
  {
      int		noref = 0;
  
***************
*** 10518,10526 ****
   * "delete()" function
   */
      static void
! f_delete(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	nbuf[NUMBUFLEN];
      char_u	*name;
--- 10230,10236 ----
   * "delete()" function
   */
      static void
! f_delete(typval_T *argvars, typval_T *rettv)
  {
      char_u	nbuf[NUMBUFLEN];
      char_u	*name;
***************
*** 10559,10567 ****
   * "did_filetype()" function
   */
      static void
! f_did_filetype(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_AUTOCMD
      rettv->vval.v_number = did_filetype;
--- 10269,10275 ----
   * "did_filetype()" function
   */
      static void
! f_did_filetype(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_AUTOCMD
      rettv->vval.v_number = did_filetype;
***************
*** 10572,10580 ****
   * "diff_filler()" function
   */
      static void
! f_diff_filler(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_DIFF
      rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
--- 10280,10286 ----
   * "diff_filler()" function
   */
      static void
! f_diff_filler(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_DIFF
      rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
***************
*** 10585,10593 ****
   * "diff_hlID()" function
   */
      static void
! f_diff_hlID(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_DIFF
      linenr_T		lnum = get_tv_lnum(argvars);
--- 10291,10297 ----
   * "diff_hlID()" function
   */
      static void
! f_diff_hlID(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_DIFF
      linenr_T		lnum = get_tv_lnum(argvars);
***************
*** 10670,10678 ****
   * "disconnect()" function
   */
      static void
! f_disconnect(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      int ch_idx = get_channel_arg(&argvars[0]);
  
--- 10374,10380 ----
   * "disconnect()" function
   */
      static void
! f_disconnect(typval_T *argvars, typval_T *rettv UNUSED)
  {
      int ch_idx = get_channel_arg(&argvars[0]);
  
***************
*** 10685,10693 ****
   * "empty({expr})" function
   */
      static void
! f_empty(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		n;
  
--- 10387,10393 ----
   * "empty({expr})" function
   */
      static void
! f_empty(typval_T *argvars, typval_T *rettv)
  {
      int		n;
  
***************
*** 10730,10738 ****
   * "escape({string}, {chars})" function
   */
      static void
! f_escape(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[NUMBUFLEN];
  
--- 10430,10436 ----
   * "escape({string}, {chars})" function
   */
      static void
! f_escape(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[NUMBUFLEN];
  
***************
*** 10745,10753 ****
   * "eval()" function
   */
      static void
! f_eval(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*s, *p;
  
--- 10443,10449 ----
   * "eval()" function
   */
      static void
! f_eval(typval_T *argvars, typval_T *rettv)
  {
      char_u	*s, *p;
  
***************
*** 10772,10780 ****
   * "eventhandler()" function
   */
      static void
! f_eventhandler(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = vgetc_busy;
  }
--- 10468,10474 ----
   * "eventhandler()" function
   */
      static void
! f_eventhandler(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = vgetc_busy;
  }
***************
*** 10783,10791 ****
   * "executable()" function
   */
      static void
! f_executable(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u *name = get_tv_string(&argvars[0]);
  
--- 10477,10483 ----
   * "executable()" function
   */
      static void
! f_executable(typval_T *argvars, typval_T *rettv)
  {
      char_u *name = get_tv_string(&argvars[0]);
  
***************
*** 10798,10806 ****
   * "exepath()" function
   */
      static void
! f_exepath(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u *p = NULL;
  
--- 10490,10496 ----
   * "exepath()" function
   */
      static void
! f_exepath(typval_T *argvars, typval_T *rettv)
  {
      char_u *p = NULL;
  
***************
*** 10813,10821 ****
   * "exists()" function
   */
      static void
! f_exists(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
      char_u	*name;
--- 10503,10509 ----
   * "exists()" function
   */
      static void
! f_exists(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
      char_u	*name;
***************
*** 10895,10903 ****
   * "exp()" function
   */
      static void
! f_exp(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 10583,10589 ----
   * "exp()" function
   */
      static void
! f_exp(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 10913,10921 ****
   * "expand()" function
   */
      static void
! f_expand(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*s;
      int		len;
--- 10599,10605 ----
   * "expand()" function
   */
      static void
! f_expand(typval_T *argvars, typval_T *rettv)
  {
      char_u	*s;
      int		len;
***************
*** 10989,10998 ****
   * Otherwise duplicate keys are ignored ("action" is "keep").
   */
      void
! dict_extend(d1, d2, action)
!     dict_T	*d1;
!     dict_T	*d2;
!     char_u	*action;
  {
      dictitem_T	*di1;
      hashitem_T	*hi2;
--- 10673,10679 ----
   * Otherwise duplicate keys are ignored ("action" is "keep").
   */
      void
! dict_extend(dict_T *d1, dict_T *d2, char_u *action)
  {
      dictitem_T	*di1;
      hashitem_T	*hi2;
***************
*** 11047,11055 ****
   * "extend(dict, dict [, action])" function
   */
      static void
! f_extend(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u      *arg_errmsg = (char_u *)N_("extend() argument");
  
--- 10728,10734 ----
   * "extend(dict, dict [, action])" function
   */
      static void
! f_extend(typval_T *argvars, typval_T *rettv)
  {
      char_u      *arg_errmsg = (char_u *)N_("extend() argument");
  
***************
*** 11134,11142 ****
   * "feedkeys()" function
   */
      static void
! f_feedkeys(argvars, rettv)
!     typval_T    *argvars;
!     typval_T    *rettv UNUSED;
  {
      int		remap = TRUE;
      int		insert = FALSE;
--- 10813,10819 ----
   * "feedkeys()" function
   */
      static void
! f_feedkeys(typval_T *argvars, typval_T *rettv UNUSED)
  {
      int		remap = TRUE;
      int		insert = FALSE;
***************
*** 11191,11199 ****
   * "filereadable()" function
   */
      static void
! f_filereadable(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		fd;
      char_u	*p;
--- 10868,10874 ----
   * "filereadable()" function
   */
      static void
! f_filereadable(typval_T *argvars, typval_T *rettv)
  {
      int		fd;
      char_u	*p;
***************
*** 11220,11228 ****
   * rights to write into.
   */
      static void
! f_filewritable(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
  }
--- 10895,10901 ----
   * rights to write into.
   */
      static void
! f_filewritable(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
  }
***************
*** 11303,11312 ****
   * Implementation of map() and filter().
   */
      static void
! filter_map(argvars, rettv, map)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		map;
  {
      char_u	buf[NUMBUFLEN];
      char_u	*expr;
--- 10976,10982 ----
   * Implementation of map() and filter().
   */
      static void
! filter_map(typval_T *argvars, typval_T *rettv, int map)
  {
      char_u	buf[NUMBUFLEN];
      char_u	*expr;
***************
*** 11423,11433 ****
  }
  
      static int
! filter_map_one(tv, expr, map, remp)
!     typval_T	*tv;
!     char_u	*expr;
!     int		map;
!     int		*remp;
  {
      typval_T	rettv;
      char_u	*s;
--- 11093,11099 ----
  }
  
      static int
! filter_map_one(typval_T *tv, char_u *expr, int map, int *remp)
  {
      typval_T	rettv;
      char_u	*s;
***************
*** 11472,11480 ****
   * "filter()" function
   */
      static void
! f_filter(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      filter_map(argvars, rettv, FALSE);
  }
--- 11138,11144 ----
   * "filter()" function
   */
      static void
! f_filter(typval_T *argvars, typval_T *rettv)
  {
      filter_map(argvars, rettv, FALSE);
  }
***************
*** 11483,11491 ****
   * "finddir({fname}[, {path}[, {count}]])" function
   */
      static void
! f_finddir(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      findfilendir(argvars, rettv, FINDFILE_DIR);
  }
--- 11147,11153 ----
   * "finddir({fname}[, {path}[, {count}]])" function
   */
      static void
! f_finddir(typval_T *argvars, typval_T *rettv)
  {
      findfilendir(argvars, rettv, FINDFILE_DIR);
  }
***************
*** 11494,11502 ****
   * "findfile({fname}[, {path}[, {count}]])" function
   */
      static void
! f_findfile(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      findfilendir(argvars, rettv, FINDFILE_FILE);
  }
--- 11156,11162 ----
   * "findfile({fname}[, {path}[, {count}]])" function
   */
      static void
! f_findfile(typval_T *argvars, typval_T *rettv)
  {
      findfilendir(argvars, rettv, FINDFILE_FILE);
  }
***************
*** 11506,11514 ****
   * "float2nr({float})" function
   */
      static void
! f_float2nr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 11166,11172 ----
   * "float2nr({float})" function
   */
      static void
! f_float2nr(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 11527,11535 ****
   * "floor({float})" function
   */
      static void
! f_floor(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 11185,11191 ----
   * "floor({float})" function
   */
      static void
! f_floor(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 11544,11552 ****
   * "fmod()" function
   */
      static void
! f_fmod(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	fx, fy;
  
--- 11200,11206 ----
   * "fmod()" function
   */
      static void
! f_fmod(typval_T *argvars, typval_T *rettv)
  {
      float_T	fx, fy;
  
***************
*** 11563,11571 ****
   * "fnameescape({string})" function
   */
      static void
! f_fnameescape(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_string = vim_strsave_fnameescape(
  					   get_tv_string(&argvars[0]), FALSE);
--- 11217,11223 ----
   * "fnameescape({string})" function
   */
      static void
! f_fnameescape(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_string = vim_strsave_fnameescape(
  					   get_tv_string(&argvars[0]), FALSE);
***************
*** 11576,11584 ****
   * "fnamemodify({fname}, {mods})" function
   */
      static void
! f_fnamemodify(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*fname;
      char_u	*mods;
--- 11228,11234 ----
   * "fnamemodify({fname}, {mods})" function
   */
      static void
! f_fnamemodify(typval_T *argvars, typval_T *rettv)
  {
      char_u	*fname;
      char_u	*mods;
***************
*** 11611,11620 ****
   * "foldclosed()" function
   */
      static void
! foldclosed_both(argvars, rettv, end)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
!     int		end UNUSED;
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
--- 11261,11270 ----
   * "foldclosed()" function
   */
      static void
! foldclosed_both(
!     typval_T	*argvars UNUSED,
!     typval_T	*rettv,
!     int		end UNUSED)
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
***************
*** 11640,11648 ****
   * "foldclosed()" function
   */
      static void
! f_foldclosed(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      foldclosed_both(argvars, rettv, FALSE);
  }
--- 11290,11296 ----
   * "foldclosed()" function
   */
      static void
! f_foldclosed(typval_T *argvars, typval_T *rettv)
  {
      foldclosed_both(argvars, rettv, FALSE);
  }
***************
*** 11651,11659 ****
   * "foldclosedend()" function
   */
      static void
! f_foldclosedend(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      foldclosed_both(argvars, rettv, TRUE);
  }
--- 11299,11305 ----
   * "foldclosedend()" function
   */
      static void
! f_foldclosedend(typval_T *argvars, typval_T *rettv)
  {
      foldclosed_both(argvars, rettv, TRUE);
  }
***************
*** 11662,11670 ****
   * "foldlevel()" function
   */
      static void
! f_foldlevel(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
--- 11308,11314 ----
   * "foldlevel()" function
   */
      static void
! f_foldlevel(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
***************
*** 11679,11687 ****
   * "foldtext()" function
   */
      static void
! f_foldtext(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
--- 11323,11329 ----
   * "foldtext()" function
   */
      static void
! f_foldtext(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
***************
*** 11746,11754 ****
   * "foldtextresult(lnum)" function
   */
      static void
! f_foldtextresult(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
--- 11388,11394 ----
   * "foldtextresult(lnum)" function
   */
      static void
! f_foldtextresult(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_FOLDING
      linenr_T	lnum;
***************
*** 11781,11789 ****
   * "foreground()" function
   */
      static void
! f_foreground(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 11421,11427 ----
   * "foreground()" function
   */
      static void
! f_foreground(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 11799,11807 ****
   * "function()" function
   */
      static void
! f_function(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*s;
  
--- 11437,11443 ----
   * "function()" function
   */
      static void
! f_function(typval_T *argvars, typval_T *rettv)
  {
      char_u	*s;
  
***************
*** 11841,11849 ****
   * "garbagecollect()" function
   */
      static void
! f_garbagecollect(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      /* This is postponed until we are back at the toplevel, because we may be
       * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
--- 11477,11483 ----
   * "garbagecollect()" function
   */
      static void
! f_garbagecollect(typval_T *argvars, typval_T *rettv UNUSED)
  {
      /* This is postponed until we are back at the toplevel, because we may be
       * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
***************
*** 11857,11865 ****
   * "get()" function
   */
      static void
! f_get(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      listitem_T	*li;
      list_T	*l;
--- 11491,11497 ----
   * "get()" function
   */
      static void
! f_get(typval_T *argvars, typval_T *rettv)
  {
      listitem_T	*li;
      list_T	*l;
***************
*** 11908,11919 ****
   * If 'retlist' is TRUE, then the lines are returned as a Vim List.
   */
      static void
! get_buffer_lines(buf, start, end, retlist, rettv)
!     buf_T	*buf;
!     linenr_T	start;
!     linenr_T	end;
!     int		retlist;
!     typval_T	*rettv;
  {
      char_u	*p;
  
--- 11540,11551 ----
   * If 'retlist' is TRUE, then the lines are returned as a Vim List.
   */
      static void
! get_buffer_lines(
!     buf_T	*buf,
!     linenr_T	start,
!     linenr_T	end,
!     int		retlist,
!     typval_T	*rettv)
  {
      char_u	*p;
  
***************
*** 11953,11961 ****
   * "getbufline()" function
   */
      static void
! f_getbufline(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum;
      linenr_T	end;
--- 11585,11591 ----
   * "getbufline()" function
   */
      static void
! f_getbufline(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum;
      linenr_T	end;
***************
*** 11979,11987 ****
   * "getbufvar()" function
   */
      static void
! f_getbufvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      buf_T	*buf;
      buf_T	*save_curbuf;
--- 11609,11615 ----
   * "getbufvar()" function
   */
      static void
! f_getbufvar(typval_T *argvars, typval_T *rettv)
  {
      buf_T	*buf;
      buf_T	*save_curbuf;
***************
*** 12042,12050 ****
   * "getchar()" function
   */
      static void
! f_getchar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      varnumber_T		n;
      int			error = FALSE;
--- 11670,11676 ----
   * "getchar()" function
   */
      static void
! f_getchar(typval_T *argvars, typval_T *rettv)
  {
      varnumber_T		n;
      int			error = FALSE;
***************
*** 12144,12152 ****
   * "getcharmod()" function
   */
      static void
! f_getcharmod(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = mod_mask;
  }
--- 11770,11776 ----
   * "getcharmod()" function
   */
      static void
! f_getcharmod(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = mod_mask;
  }
***************
*** 12155,12163 ****
   * "getcharsearch()" function
   */
      static void
! f_getcharsearch(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      if (rettv_dict_alloc(rettv) != FAIL)
      {
--- 11779,11785 ----
   * "getcharsearch()" function
   */
      static void
! f_getcharsearch(typval_T *argvars UNUSED, typval_T *rettv)
  {
      if (rettv_dict_alloc(rettv) != FAIL)
      {
***************
*** 12173,12181 ****
   * "getcmdline()" function
   */
      static void
! f_getcmdline(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = get_cmdline_str();
--- 11795,11801 ----
   * "getcmdline()" function
   */
      static void
! f_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = get_cmdline_str();
***************
*** 12185,12193 ****
   * "getcmdpos()" function
   */
      static void
! f_getcmdpos(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = get_cmdline_pos() + 1;
  }
--- 11805,11811 ----
   * "getcmdpos()" function
   */
      static void
! f_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = get_cmdline_pos() + 1;
  }
***************
*** 12196,12204 ****
   * "getcmdtype()" function
   */
      static void
! f_getcmdtype(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = alloc(2);
--- 11814,11820 ----
   * "getcmdtype()" function
   */
      static void
! f_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = alloc(2);
***************
*** 12213,12221 ****
   * "getcmdwintype()" function
   */
      static void
! f_getcmdwintype(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
--- 11829,11835 ----
   * "getcmdwintype()" function
   */
      static void
! f_getcmdwintype(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
***************
*** 12233,12241 ****
   * "getcwd()" function
   */
      static void
! f_getcwd(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*wp = NULL;
      char_u	*cwd;
--- 11847,11853 ----
   * "getcwd()" function
   */
      static void
! f_getcwd(typval_T *argvars, typval_T *rettv)
  {
      win_T	*wp = NULL;
      char_u	*cwd;
***************
*** 12271,12279 ****
   * "getfontname()" function
   */
      static void
! f_getfontname(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
--- 11883,11889 ----
   * "getfontname()" function
   */
      static void
! f_getfontname(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
***************
*** 12310,12318 ****
   * "getfperm({fname})" function
   */
      static void
! f_getfperm(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*fname;
      struct stat st;
--- 11920,11926 ----
   * "getfperm({fname})" function
   */
      static void
! f_getfperm(typval_T *argvars, typval_T *rettv)
  {
      char_u	*fname;
      struct stat st;
***************
*** 12342,12350 ****
   * "getfsize({fname})" function
   */
      static void
! f_getfsize(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*fname;
      struct stat	st;
--- 11950,11956 ----
   * "getfsize({fname})" function
   */
      static void
! f_getfsize(typval_T *argvars, typval_T *rettv)
  {
      char_u	*fname;
      struct stat	st;
***************
*** 12374,12382 ****
   * "getftime({fname})" function
   */
      static void
! f_getftime(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*fname;
      struct stat	st;
--- 11980,11986 ----
   * "getftime({fname})" function
   */
      static void
! f_getftime(typval_T *argvars, typval_T *rettv)
  {
      char_u	*fname;
      struct stat	st;
***************
*** 12393,12401 ****
   * "getftype({fname})" function
   */
      static void
! f_getftype(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*fname;
      struct stat st;
--- 11997,12003 ----
   * "getftype({fname})" function
   */
      static void
! f_getftype(typval_T *argvars, typval_T *rettv)
  {
      char_u	*fname;
      struct stat st;
***************
*** 12473,12481 ****
   * "getline(lnum, [end])" function
   */
      static void
! f_getline(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum;
      linenr_T	end;
--- 12075,12081 ----
   * "getline(lnum, [end])" function
   */
      static void
! f_getline(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum;
      linenr_T	end;
***************
*** 12500,12508 ****
   * "getmatches()" function
   */
      static void
! f_getmatches(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      dict_T	*dict;
--- 12100,12106 ----
   * "getmatches()" function
   */
      static void
! f_getmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_SEARCH_EXTRA
      dict_T	*dict;
***************
*** 12568,12576 ****
   * "getpid()" function
   */
      static void
! f_getpid(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = mch_get_pid();
  }
--- 12166,12172 ----
   * "getpid()" function
   */
      static void
! f_getpid(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = mch_get_pid();
  }
***************
*** 12581,12589 ****
   * "getcurpos()" function
   */
      static void
! f_getcurpos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      getpos_both(argvars, rettv, TRUE);
  }
--- 12177,12183 ----
   * "getcurpos()" function
   */
      static void
! f_getcurpos(typval_T *argvars, typval_T *rettv)
  {
      getpos_both(argvars, rettv, TRUE);
  }
***************
*** 12592,12609 ****
   * "getpos(string)" function
   */
      static void
! f_getpos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      getpos_both(argvars, rettv, FALSE);
  }
  
      static void
! getpos_both(argvars, rettv, getcurpos)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		getcurpos;
  {
      pos_T	*fp;
      list_T	*l;
--- 12186,12201 ----
   * "getpos(string)" function
   */
      static void
! f_getpos(typval_T *argvars, typval_T *rettv)
  {
      getpos_both(argvars, rettv, FALSE);
  }
  
      static void
! getpos_both(
!     typval_T	*argvars,
!     typval_T	*rettv,
!     int		getcurpos)
  {
      pos_T	*fp;
      list_T	*l;
***************
*** 12642,12650 ****
   * "getqflist()" and "getloclist()" functions
   */
      static void
! f_getqflist(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_QUICKFIX
      win_T	*wp;
--- 12234,12240 ----
   * "getqflist()" and "getloclist()" functions
   */
      static void
! f_getqflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_QUICKFIX
      win_T	*wp;
***************
*** 12670,12678 ****
   * "getreg()" function
   */
      static void
! f_getreg(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*strregname;
      int		regname;
--- 12260,12266 ----
   * "getreg()" function
   */
      static void
! f_getreg(typval_T *argvars, typval_T *rettv)
  {
      char_u	*strregname;
      int		regname;
***************
*** 12721,12729 ****
   * "getregtype()" function
   */
      static void
! f_getregtype(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*strregname;
      int		regname;
--- 12309,12315 ----
   * "getregtype()" function
   */
      static void
! f_getregtype(typval_T *argvars, typval_T *rettv)
  {
      char_u	*strregname;
      int		regname;
***************
*** 12767,12775 ****
   * "gettabvar()" function
   */
      static void
! f_gettabvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*oldcurwin;
      tabpage_T	*tp, *oldtabpage;
--- 12353,12359 ----
   * "gettabvar()" function
   */
      static void
! f_gettabvar(typval_T *argvars, typval_T *rettv)
  {
      win_T	*oldcurwin;
      tabpage_T	*tp, *oldtabpage;
***************
*** 12812,12820 ****
   * "gettabwinvar()" function
   */
      static void
! f_gettabwinvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      getwinvar(argvars, rettv, 1);
  }
--- 12396,12402 ----
   * "gettabwinvar()" function
   */
      static void
! f_gettabwinvar(typval_T *argvars, typval_T *rettv)
  {
      getwinvar(argvars, rettv, 1);
  }
***************
*** 12823,12831 ****
   * "getwinposx()" function
   */
      static void
! f_getwinposx(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = -1;
  #ifdef FEAT_GUI
--- 12405,12411 ----
   * "getwinposx()" function
   */
      static void
! f_getwinposx(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = -1;
  #ifdef FEAT_GUI
***************
*** 12843,12851 ****
   * "getwinposy()" function
   */
      static void
! f_getwinposy(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = -1;
  #ifdef FEAT_GUI
--- 12423,12429 ----
   * "getwinposy()" function
   */
      static void
! f_getwinposy(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = -1;
  #ifdef FEAT_GUI
***************
*** 12863,12871 ****
   * Find window specified by "vp" in tabpage "tp".
   */
      static win_T *
! find_win_by_nr(vp, tp)
!     typval_T	*vp;
!     tabpage_T	*tp UNUSED;	/* NULL for current tab page */
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
--- 12441,12449 ----
   * Find window specified by "vp" in tabpage "tp".
   */
      static win_T *
! find_win_by_nr(
!     typval_T	*vp,
!     tabpage_T	*tp UNUSED)	/* NULL for current tab page */
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
***************
*** 12896,12904 ****
   * Find window specified by "wvp" in tabpage "tvp".
   */
      static win_T *
! find_tabwin(wvp, tvp)
!     typval_T	*wvp;	/* VAR_UNKNOWN for current window */
!     typval_T	*tvp;	/* VAR_UNKNOWN for current tab page */
  {
      win_T	*wp = NULL;
      tabpage_T	*tp = NULL;
--- 12474,12482 ----
   * Find window specified by "wvp" in tabpage "tvp".
   */
      static win_T *
! find_tabwin(
!     typval_T	*wvp,	/* VAR_UNKNOWN for current window */
!     typval_T	*tvp)	/* VAR_UNKNOWN for current tab page */
  {
      win_T	*wp = NULL;
      tabpage_T	*tp = NULL;
***************
*** 12928,12936 ****
   * "getwinvar()" function
   */
      static void
! f_getwinvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      getwinvar(argvars, rettv, 0);
  }
--- 12506,12512 ----
   * "getwinvar()" function
   */
      static void
! f_getwinvar(typval_T *argvars, typval_T *rettv)
  {
      getwinvar(argvars, rettv, 0);
  }
***************
*** 12939,12948 ****
   * getwinvar() and gettabwinvar()
   */
      static void
! getwinvar(argvars, rettv, off)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		off;	    /* 1 for gettabwinvar() */
  {
      win_T	*win;
      char_u	*varname;
--- 12515,12524 ----
   * getwinvar() and gettabwinvar()
   */
      static void
! getwinvar(
!     typval_T	*argvars,
!     typval_T	*rettv,
!     int		off)	    /* 1 for gettabwinvar() */
  {
      win_T	*win;
      char_u	*varname;
***************
*** 13016,13024 ****
   * "glob()" function
   */
      static void
! f_glob(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		options = WILD_SILENT|WILD_USE_NL;
      expand_T	xpc;
--- 12592,12598 ----
   * "glob()" function
   */
      static void
! f_glob(typval_T *argvars, typval_T *rettv)
  {
      int		options = WILD_SILENT|WILD_USE_NL;
      expand_T	xpc;
***************
*** 13072,13080 ****
   * "globpath()" function
   */
      static void
! f_globpath(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		flags = 0;
      char_u	buf1[NUMBUFLEN];
--- 12646,12652 ----
   * "globpath()" function
   */
      static void
! f_globpath(typval_T *argvars, typval_T *rettv)
  {
      int		flags = 0;
      char_u	buf1[NUMBUFLEN];
***************
*** 13122,13130 ****
   * "glob2regpat()" function
   */
      static void
! f_glob2regpat(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*pat = get_tv_string_chk(&argvars[0]);
  
--- 12694,12700 ----
   * "glob2regpat()" function
   */
      static void
! f_glob2regpat(typval_T *argvars, typval_T *rettv)
  {
      char_u	*pat = get_tv_string_chk(&argvars[0]);
  
***************
*** 13137,13145 ****
   * "has()" function
   */
      static void
! f_has(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		i;
      char_u	*name;
--- 12707,12713 ----
   * "has()" function
   */
      static void
! f_has(typval_T *argvars, typval_T *rettv)
  {
      int		i;
      char_u	*name;
***************
*** 13742,13750 ****
   * "has_key()" function
   */
      static void
! f_has_key(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      if (argvars[0].v_type != VAR_DICT)
      {
--- 13310,13316 ----
   * "has_key()" function
   */
      static void
! f_has_key(typval_T *argvars, typval_T *rettv)
  {
      if (argvars[0].v_type != VAR_DICT)
      {
***************
*** 13762,13770 ****
   * "haslocaldir()" function
   */
      static void
! f_haslocaldir(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*wp = NULL;
  
--- 13328,13334 ----
   * "haslocaldir()" function
   */
      static void
! f_haslocaldir(typval_T *argvars, typval_T *rettv)
  {
      win_T	*wp = NULL;
  
***************
*** 13776,13784 ****
   * "hasmapto()" function
   */
      static void
! f_hasmapto(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*name;
      char_u	*mode;
--- 13340,13346 ----
   * "hasmapto()" function
   */
      static void
! f_hasmapto(typval_T *argvars, typval_T *rettv)
  {
      char_u	*name;
      char_u	*mode;
***************
*** 13805,13813 ****
   * "histadd()" function
   */
      static void
! f_histadd(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
      int		histype;
--- 13367,13373 ----
   * "histadd()" function
   */
      static void
! f_histadd(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_CMDHIST
      int		histype;
***************
*** 13839,13847 ****
   * "histdel()" function
   */
      static void
! f_histdel(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_CMDHIST
      int		n;
--- 13399,13405 ----
   * "histdel()" function
   */
      static void
! f_histdel(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_CMDHIST
      int		n;
***************
*** 13870,13878 ****
   * "histget()" function
   */
      static void
! f_histget(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CMDHIST
      int		type;
--- 13428,13434 ----
   * "histget()" function
   */
      static void
! f_histget(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_CMDHIST
      int		type;
***************
*** 13902,13910 ****
   * "histnr()" function
   */
      static void
! f_histnr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		i;
  
--- 13458,13464 ----
   * "histnr()" function
   */
      static void
! f_histnr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		i;
  
***************
*** 13924,13932 ****
   * "highlightID(name)" function
   */
      static void
! f_hlID(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = syn_name2id(get_tv_string(&argvars[0]));
  }
--- 13478,13484 ----
   * "highlightID(name)" function
   */
      static void
! f_hlID(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = syn_name2id(get_tv_string(&argvars[0]));
  }
***************
*** 13935,13943 ****
   * "highlight_exists()" function
   */
      static void
! f_hlexists(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = highlight_exists(get_tv_string(&argvars[0]));
  }
--- 13487,13493 ----
   * "highlight_exists()" function
   */
      static void
! f_hlexists(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = highlight_exists(get_tv_string(&argvars[0]));
  }
***************
*** 13946,13954 ****
   * "hostname()" function
   */
      static void
! f_hostname(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      char_u hostname[256];
  
--- 13496,13502 ----
   * "hostname()" function
   */
      static void
! f_hostname(typval_T *argvars UNUSED, typval_T *rettv)
  {
      char_u hostname[256];
  
***************
*** 13961,13969 ****
   * iconv() function
   */
      static void
! f_iconv(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_MBYTE
      char_u	buf1[NUMBUFLEN];
--- 13509,13515 ----
   * iconv() function
   */
      static void
! f_iconv(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_MBYTE
      char_u	buf1[NUMBUFLEN];
***************
*** 13998,14006 ****
   * "indent()" function
   */
      static void
! f_indent(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum;
  
--- 13544,13550 ----
   * "indent()" function
   */
      static void
! f_indent(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum;
  
***************
*** 14015,14023 ****
   * "index()" function
   */
      static void
! f_index(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      list_T	*l;
      listitem_T	*item;
--- 13559,13565 ----
   * "index()" function
   */
      static void
! f_index(typval_T *argvars, typval_T *rettv)
  {
      list_T	*l;
      listitem_T	*item;
***************
*** 14068,14077 ****
   * when the user cancels the prompt.
   */
      static void
! get_user_input(argvars, rettv, inputdialog)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		inputdialog;
  {
      char_u	*prompt = get_tv_string_chk(&argvars[0]);
      char_u	*p = NULL;
--- 13610,13619 ----
   * when the user cancels the prompt.
   */
      static void
! get_user_input(
!     typval_T	*argvars,
!     typval_T	*rettv,
!     int		inputdialog)
  {
      char_u	*prompt = get_tv_string_chk(&argvars[0]);
      char_u	*p = NULL;
***************
*** 14173,14181 ****
   *     Also handles inputsecret() when inputsecret is set.
   */
      static void
! f_input(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      get_user_input(argvars, rettv, FALSE);
  }
--- 13715,13721 ----
   *     Also handles inputsecret() when inputsecret is set.
   */
      static void
! f_input(typval_T *argvars, typval_T *rettv)
  {
      get_user_input(argvars, rettv, FALSE);
  }
***************
*** 14184,14192 ****
   * "inputdialog()" function
   */
      static void
! f_inputdialog(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #if defined(FEAT_GUI_TEXTDIALOG)
      /* Use a GUI dialog if the GUI is running and 'c' is not in 'guioptions' */
--- 13724,13730 ----
   * "inputdialog()" function
   */
      static void
! f_inputdialog(typval_T *argvars, typval_T *rettv)
  {
  #if defined(FEAT_GUI_TEXTDIALOG)
      /* Use a GUI dialog if the GUI is running and 'c' is not in 'guioptions' */
***************
*** 14227,14235 ****
   * "inputlist()" function
   */
      static void
! f_inputlist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      listitem_T	*li;
      int		selected;
--- 13765,13771 ----
   * "inputlist()" function
   */
      static void
! f_inputlist(typval_T *argvars, typval_T *rettv)
  {
      listitem_T	*li;
      int		selected;
***************
*** 14273,14281 ****
   * "inputrestore()" function
   */
      static void
! f_inputrestore(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      if (ga_userinput.ga_len > 0)
      {
--- 13809,13815 ----
   * "inputrestore()" function
   */
      static void
! f_inputrestore(typval_T *argvars UNUSED, typval_T *rettv)
  {
      if (ga_userinput.ga_len > 0)
      {
***************
*** 14295,14303 ****
   * "inputsave()" function
   */
      static void
! f_inputsave(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      /* Add an entry to the stack of typeahead storage. */
      if (ga_grow(&ga_userinput, 1) == OK)
--- 13829,13835 ----
   * "inputsave()" function
   */
      static void
! f_inputsave(typval_T *argvars UNUSED, typval_T *rettv)
  {
      /* Add an entry to the stack of typeahead storage. */
      if (ga_grow(&ga_userinput, 1) == OK)
***************
*** 14315,14323 ****
   * "inputsecret()" function
   */
      static void
! f_inputsecret(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      ++cmdline_star;
      ++inputsecret_flag;
--- 13847,13853 ----
   * "inputsecret()" function
   */
      static void
! f_inputsecret(typval_T *argvars, typval_T *rettv)
  {
      ++cmdline_star;
      ++inputsecret_flag;
***************
*** 14330,14338 ****
   * "insert()" function
   */
      static void
! f_insert(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      long	before = 0;
      listitem_T	*item;
--- 13860,13866 ----
   * "insert()" function
   */
      static void
! f_insert(typval_T *argvars, typval_T *rettv)
  {
      long	before = 0;
      listitem_T	*item;
***************
*** 14372,14380 ****
   * "invert(expr)" function
   */
      static void
! f_invert(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = ~get_tv_number_chk(&argvars[0], NULL);
  }
--- 13900,13906 ----
   * "invert(expr)" function
   */
      static void
! f_invert(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = ~get_tv_number_chk(&argvars[0], NULL);
  }
***************
*** 14383,14391 ****
   * "isdirectory()" function
   */
      static void
! f_isdirectory(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = mch_isdir(get_tv_string(&argvars[0]));
  }
--- 13909,13915 ----
   * "isdirectory()" function
   */
      static void
! f_isdirectory(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = mch_isdir(get_tv_string(&argvars[0]));
  }
***************
*** 14394,14402 ****
   * "islocked()" function
   */
      static void
! f_islocked(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      lval_T	lv;
      char_u	*end;
--- 13918,13924 ----
   * "islocked()" function
   */
      static void
! f_islocked(typval_T *argvars, typval_T *rettv)
  {
      lval_T	lv;
      char_u	*end;
***************
*** 14455,14464 ****
   * "what" == 2: list of items
   */
      static void
! dict_list(argvars, rettv, what)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		what;
  {
      list_T	*l2;
      dictitem_T	*di;
--- 13977,13983 ----
   * "what" == 2: list of items
   */
      static void
! dict_list(typval_T *argvars, typval_T *rettv, int what)
  {
      list_T	*l2;
      dictitem_T	*di;
***************
*** 14537,14545 ****
   * "items(dict)" function
   */
      static void
! f_items(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      dict_list(argvars, rettv, 2);
  }
--- 14056,14062 ----
   * "items(dict)" function
   */
      static void
! f_items(typval_T *argvars, typval_T *rettv)
  {
      dict_list(argvars, rettv, 2);
  }
***************
*** 14548,14556 ****
   * "join()" function
   */
      static void
! f_join(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      garray_T	ga;
      char_u	*sep;
--- 14065,14071 ----
   * "join()" function
   */
      static void
! f_join(typval_T *argvars, typval_T *rettv)
  {
      garray_T	ga;
      char_u	*sep;
***************
*** 14584,14592 ****
   * "jsondecode()" function
   */
      static void
! f_jsondecode(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      js_read_T	reader;
  
--- 14099,14105 ----
   * "jsondecode()" function
   */
      static void
! f_jsondecode(typval_T *argvars, typval_T *rettv)
  {
      js_read_T	reader;
  
***************
*** 14600,14608 ****
   * "jsonencode()" function
   */
      static void
! f_jsonencode(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = json_encode(&argvars[0]);
--- 14113,14119 ----
   * "jsonencode()" function
   */
      static void
! f_jsonencode(typval_T *argvars, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = json_encode(&argvars[0]);
***************
*** 14612,14620 ****
   * "keys()" function
   */
      static void
! f_keys(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      dict_list(argvars, rettv, 0);
  }
--- 14123,14129 ----
   * "keys()" function
   */
      static void
! f_keys(typval_T *argvars, typval_T *rettv)
  {
      dict_list(argvars, rettv, 0);
  }
***************
*** 14623,14631 ****
   * "last_buffer_nr()" function.
   */
      static void
! f_last_buffer_nr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		n = 0;
      buf_T	*buf;
--- 14132,14138 ----
   * "last_buffer_nr()" function.
   */
      static void
! f_last_buffer_nr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		n = 0;
      buf_T	*buf;
***************
*** 14641,14649 ****
   * "len()" function
   */
      static void
! f_len(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      switch (argvars[0].v_type)
      {
--- 14148,14154 ----
   * "len()" function
   */
      static void
! f_len(typval_T *argvars, typval_T *rettv)
  {
      switch (argvars[0].v_type)
      {
***************
*** 14667,14676 ****
  static void libcall_common(typval_T *argvars, typval_T *rettv, int type);
  
      static void
! libcall_common(argvars, rettv, type)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		type;
  {
  #ifdef FEAT_LIBCALL
      char_u		*string_in;
--- 14172,14178 ----
  static void libcall_common(typval_T *argvars, typval_T *rettv, int type);
  
      static void
! libcall_common(typval_T *argvars, typval_T *rettv, int type)
  {
  #ifdef FEAT_LIBCALL
      char_u		*string_in;
***************
*** 14712,14720 ****
   * "libcall()" function
   */
      static void
! f_libcall(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      libcall_common(argvars, rettv, VAR_STRING);
  }
--- 14214,14220 ----
   * "libcall()" function
   */
      static void
! f_libcall(typval_T *argvars, typval_T *rettv)
  {
      libcall_common(argvars, rettv, VAR_STRING);
  }
***************
*** 14723,14731 ****
   * "libcallnr()" function
   */
      static void
! f_libcallnr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      libcall_common(argvars, rettv, VAR_NUMBER);
  }
--- 14223,14229 ----
   * "libcallnr()" function
   */
      static void
! f_libcallnr(typval_T *argvars, typval_T *rettv)
  {
      libcall_common(argvars, rettv, VAR_NUMBER);
  }
***************
*** 14734,14742 ****
   * "line(string)" function
   */
      static void
! f_line(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum = 0;
      pos_T	*fp;
--- 14232,14238 ----
   * "line(string)" function
   */
      static void
! f_line(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum = 0;
      pos_T	*fp;
***************
*** 14752,14760 ****
   * "line2byte(lnum)" function
   */
      static void
! f_line2byte(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifndef FEAT_BYTEOFF
      rettv->vval.v_number = -1;
--- 14248,14254 ----
   * "line2byte(lnum)" function
   */
      static void
! f_line2byte(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifndef FEAT_BYTEOFF
      rettv->vval.v_number = -1;
***************
*** 14775,14783 ****
   * "lispindent(lnum)" function
   */
      static void
! f_lispindent(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_LISP
      pos_T	pos;
--- 14269,14275 ----
   * "lispindent(lnum)" function
   */
      static void
! f_lispindent(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_LISP
      pos_T	pos;
***************
*** 14800,14808 ****
   * "localtime()" function
   */
      static void
! f_localtime(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = (varnumber_T)time(NULL);
  }
--- 14292,14298 ----
   * "localtime()" function
   */
      static void
! f_localtime(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = (varnumber_T)time(NULL);
  }
***************
*** 14810,14819 ****
  static void get_maparg(typval_T *argvars, typval_T *rettv, int exact);
  
      static void
! get_maparg(argvars, rettv, exact)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		exact;
  {
      char_u	*keys;
      char_u	*which;
--- 14300,14306 ----
  static void get_maparg(typval_T *argvars, typval_T *rettv, int exact);
  
      static void
! get_maparg(typval_T *argvars, typval_T *rettv, int exact)
  {
      char_u	*keys;
      char_u	*which;
***************
*** 14889,14897 ****
   * "log()" function
   */
      static void
! f_log(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 14376,14382 ----
   * "log()" function
   */
      static void
! f_log(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 14906,14914 ****
   * "log10()" function
   */
      static void
! f_log10(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 14391,14397 ----
   * "log10()" function
   */
      static void
! f_log10(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 14925,14933 ****
   * "luaeval()" function
   */
      static void
! f_luaeval(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
--- 14408,14414 ----
   * "luaeval()" function
   */
      static void
! f_luaeval(typval_T *argvars, typval_T *rettv)
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
***************
*** 14941,14949 ****
   * "map()" function
   */
      static void
! f_map(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      filter_map(argvars, rettv, TRUE);
  }
--- 14422,14428 ----
   * "map()" function
   */
      static void
! f_map(typval_T *argvars, typval_T *rettv)
  {
      filter_map(argvars, rettv, TRUE);
  }
***************
*** 14952,14960 ****
   * "maparg()" function
   */
      static void
! f_maparg(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      get_maparg(argvars, rettv, TRUE);
  }
--- 14431,14437 ----
   * "maparg()" function
   */
      static void
! f_maparg(typval_T *argvars, typval_T *rettv)
  {
      get_maparg(argvars, rettv, TRUE);
  }
***************
*** 14963,14971 ****
   * "mapcheck()" function
   */
      static void
! f_mapcheck(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      get_maparg(argvars, rettv, FALSE);
  }
--- 14440,14446 ----
   * "mapcheck()" function
   */
      static void
! f_mapcheck(typval_T *argvars, typval_T *rettv)
  {
      get_maparg(argvars, rettv, FALSE);
  }
***************
*** 14973,14982 ****
  static void find_some_match(typval_T *argvars, typval_T *rettv, int start);
  
      static void
! find_some_match(argvars, rettv, type)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		type;
  {
      char_u	*str = NULL;
      long	len = 0;
--- 14448,14454 ----
  static void find_some_match(typval_T *argvars, typval_T *rettv, int start);
  
      static void
! find_some_match(typval_T *argvars, typval_T *rettv, int type)
  {
      char_u	*str = NULL;
      long	len = 0;
***************
*** 15172,15180 ****
   * "match()" function
   */
      static void
! f_match(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      find_some_match(argvars, rettv, 1);
  }
--- 14644,14650 ----
   * "match()" function
   */
      static void
! f_match(typval_T *argvars, typval_T *rettv)
  {
      find_some_match(argvars, rettv, 1);
  }
***************
*** 15183,15191 ****
   * "matchadd()" function
   */
      static void
! f_matchadd(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      char_u	buf[NUMBUFLEN];
--- 14653,14659 ----
   * "matchadd()" function
   */
      static void
! f_matchadd(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_SEARCH_EXTRA
      char_u	buf[NUMBUFLEN];
***************
*** 15237,15245 ****
   * "matchaddpos()" function
   */
      static void
! f_matchaddpos(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      char_u	buf[NUMBUFLEN];
--- 14705,14711 ----
   * "matchaddpos()" function
   */
      static void
! f_matchaddpos(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_SEARCH_EXTRA
      char_u	buf[NUMBUFLEN];
***************
*** 15304,15312 ****
   * "matcharg()" function
   */
      static void
! f_matcharg(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      if (rettv_list_alloc(rettv) == OK)
      {
--- 14770,14776 ----
   * "matcharg()" function
   */
      static void
! f_matcharg(typval_T *argvars UNUSED, typval_T *rettv)
  {
      if (rettv_list_alloc(rettv) == OK)
      {
***************
*** 15336,15344 ****
   * "matchdelete()" function
   */
      static void
! f_matchdelete(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      rettv->vval.v_number = match_delete(curwin,
--- 14800,14806 ----
   * "matchdelete()" function
   */
      static void
! f_matchdelete(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_SEARCH_EXTRA
      rettv->vval.v_number = match_delete(curwin,
***************
*** 15350,15358 ****
   * "matchend()" function
   */
      static void
! f_matchend(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      find_some_match(argvars, rettv, 0);
  }
--- 14812,14818 ----
   * "matchend()" function
   */
      static void
! f_matchend(typval_T *argvars, typval_T *rettv)
  {
      find_some_match(argvars, rettv, 0);
  }
***************
*** 15361,15369 ****
   * "matchlist()" function
   */
      static void
! f_matchlist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      find_some_match(argvars, rettv, 3);
  }
--- 14821,14827 ----
   * "matchlist()" function
   */
      static void
! f_matchlist(typval_T *argvars, typval_T *rettv)
  {
      find_some_match(argvars, rettv, 3);
  }
***************
*** 15372,15380 ****
   * "matchstr()" function
   */
      static void
! f_matchstr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      find_some_match(argvars, rettv, 2);
  }
--- 14830,14836 ----
   * "matchstr()" function
   */
      static void
! f_matchstr(typval_T *argvars, typval_T *rettv)
  {
      find_some_match(argvars, rettv, 2);
  }
***************
*** 15382,15391 ****
  static void max_min(typval_T *argvars, typval_T *rettv, int domax);
  
      static void
! max_min(argvars, rettv, domax)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		domax;
  {
      long	n = 0;
      long	i;
--- 14838,14844 ----
  static void max_min(typval_T *argvars, typval_T *rettv, int domax);
  
      static void
! max_min(typval_T *argvars, typval_T *rettv, int domax)
  {
      long	n = 0;
      long	i;
***************
*** 15452,15460 ****
   * "max()" function
   */
      static void
! f_max(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      max_min(argvars, rettv, TRUE);
  }
--- 14905,14911 ----
   * "max()" function
   */
      static void
! f_max(typval_T *argvars, typval_T *rettv)
  {
      max_min(argvars, rettv, TRUE);
  }
***************
*** 15463,15471 ****
   * "min()" function
   */
      static void
! f_min(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      max_min(argvars, rettv, FALSE);
  }
--- 14914,14920 ----
   * "min()" function
   */
      static void
! f_min(typval_T *argvars, typval_T *rettv)
  {
      max_min(argvars, rettv, FALSE);
  }
***************
*** 15477,15485 ****
   * needed.
   */
      static int
! mkdir_recurse(dir, prot)
!     char_u	*dir;
!     int		prot;
  {
      char_u	*p;
      char_u	*updir;
--- 14926,14932 ----
   * needed.
   */
      static int
! mkdir_recurse(char_u *dir, int prot)
  {
      char_u	*p;
      char_u	*updir;
***************
*** 15508,15516 ****
   * "mkdir()" function
   */
      static void
! f_mkdir(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*dir;
      char_u	buf[NUMBUFLEN];
--- 14955,14961 ----
   * "mkdir()" function
   */
      static void
! f_mkdir(typval_T *argvars, typval_T *rettv)
  {
      char_u	*dir;
      char_u	buf[NUMBUFLEN];
***************
*** 15545,15553 ****
   * "mode()" function
   */
      static void
! f_mode(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[3];
  
--- 14990,14996 ----
   * "mode()" function
   */
      static void
! f_mode(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[3];
  
***************
*** 15619,15627 ****
   * "mzeval()" function
   */
      static void
! f_mzeval(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
--- 15062,15068 ----
   * "mzeval()" function
   */
      static void
! f_mzeval(typval_T *argvars, typval_T *rettv)
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
***************
*** 15631,15640 ****
  }
  
      void
! mzscheme_call_vim(name, args, rettv)
!     char_u	*name;
!     typval_T	*args;
!     typval_T	*rettv;
  {
      typval_T argvars[3];
  
--- 15072,15078 ----
  }
  
      void
! mzscheme_call_vim(char_u *name, typval_T *args, typval_T *rettv)
  {
      typval_T argvars[3];
  
***************
*** 15651,15659 ****
   * "nextnonblank()" function
   */
      static void
! f_nextnonblank(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum;
  
--- 15089,15095 ----
   * "nextnonblank()" function
   */
      static void
! f_nextnonblank(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum;
  
***************
*** 15674,15682 ****
   * "nr2char()" function
   */
      static void
! f_nr2char(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[NUMBUFLEN];
  
--- 15110,15116 ----
   * "nr2char()" function
   */
      static void
! f_nr2char(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[NUMBUFLEN];
  
***************
*** 15706,15714 ****
   * "or(expr, expr)" function
   */
      static void
! f_or(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
  					| get_tv_number_chk(&argvars[1], NULL);
--- 15140,15146 ----
   * "or(expr, expr)" function
   */
      static void
! f_or(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
  					| get_tv_number_chk(&argvars[1], NULL);
***************
*** 15718,15726 ****
   * "pathshorten()" function
   */
      static void
! f_pathshorten(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
  
--- 15150,15156 ----
   * "pathshorten()" function
   */
      static void
! f_pathshorten(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
  
***************
*** 15742,15750 ****
   * "perleval()" function
   */
      static void
! f_perleval(argvars, rettv)
!     typval_T *argvars;
!     typval_T *rettv;
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
--- 15172,15178 ----
   * "perleval()" function
   */
      static void
! f_perleval(typval_T *argvars, typval_T *rettv)
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
***************
*** 15759,15767 ****
   * "pow()" function
   */
      static void
! f_pow(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	fx, fy;
  
--- 15187,15193 ----
   * "pow()" function
   */
      static void
! f_pow(typval_T *argvars, typval_T *rettv)
  {
      float_T	fx, fy;
  
***************
*** 15778,15786 ****
   * "prevnonblank()" function
   */
      static void
! f_prevnonblank(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum;
  
--- 15204,15210 ----
   * "prevnonblank()" function
   */
      static void
! f_prevnonblank(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum;
  
***************
*** 15805,15813 ****
   * "printf()" function
   */
      static void
! f_printf(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
--- 15229,15235 ----
   * "printf()" function
   */
      static void
! f_printf(typval_T *argvars, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
***************
*** 15841,15849 ****
   * "pumvisible()" function
   */
      static void
! f_pumvisible(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
--- 15263,15269 ----
   * "pumvisible()" function
   */
      static void
! f_pumvisible(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
***************
*** 15856,15864 ****
   * "py3eval()" function
   */
      static void
! f_py3eval(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
--- 15276,15282 ----
   * "py3eval()" function
   */
      static void
! f_py3eval(typval_T *argvars, typval_T *rettv)
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
***************
*** 15873,15881 ****
   * "pyeval()" function
   */
      static void
! f_pyeval(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
--- 15291,15297 ----
   * "pyeval()" function
   */
      static void
! f_pyeval(typval_T *argvars, typval_T *rettv)
  {
      char_u	*str;
      char_u	buf[NUMBUFLEN];
***************
*** 15889,15897 ****
   * "range()" function
   */
      static void
! f_range(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      long	start;
      long	end;
--- 15305,15311 ----
   * "range()" function
   */
      static void
! f_range(typval_T *argvars, typval_T *rettv)
  {
      long	start;
      long	end;
***************
*** 15932,15940 ****
   * "readfile()" function
   */
      static void
! f_readfile(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		binary = FALSE;
      int		failed = FALSE;
--- 15346,15352 ----
   * "readfile()" function
   */
      static void
! f_readfile(typval_T *argvars, typval_T *rettv)
  {
      int		binary = FALSE;
      int		failed = FALSE;
***************
*** 16150,16158 ****
   * Return FAIL when there is something wrong.
   */
      static int
! list2proftime(arg, tm)
!     typval_T	*arg;
!     proftime_T  *tm;
  {
      long	n1, n2;
      int	error = FALSE;
--- 15562,15568 ----
   * Return FAIL when there is something wrong.
   */
      static int
! list2proftime(typval_T *arg, proftime_T *tm)
  {
      long	n1, n2;
      int	error = FALSE;
***************
*** 16177,16185 ****
   * "reltime()" function
   */
      static void
! f_reltime(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_RELTIME
      proftime_T	res;
--- 15587,15593 ----
   * "reltime()" function
   */
      static void
! f_reltime(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_RELTIME
      proftime_T	res;
***************
*** 16226,16234 ****
   * "reltimestr()" function
   */
      static void
! f_reltimestr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_RELTIME
      proftime_T	tm;
--- 15634,15640 ----
   * "reltimestr()" function
   */
      static void
! f_reltimestr(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_RELTIME
      proftime_T	tm;
***************
*** 16247,16253 ****
  static int check_connection(void);
  
      static void
! make_connection()
  {
      if (X_DISPLAY == NULL
  # ifdef FEAT_GUI
--- 15653,15659 ----
  static int check_connection(void);
  
      static void
! make_connection(void)
  {
      if (X_DISPLAY == NULL
  # ifdef FEAT_GUI
***************
*** 16262,16268 ****
  }
  
      static int
! check_connection()
  {
      make_connection();
      if (X_DISPLAY == NULL)
--- 15668,15674 ----
  }
  
      static int
! check_connection(void)
  {
      make_connection();
      if (X_DISPLAY == NULL)
***************
*** 16278,16287 ****
  static void remote_common(typval_T *argvars, typval_T *rettv, int expr);
  
      static void
! remote_common(argvars, rettv, expr)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		expr;
  {
      char_u	*server_name;
      char_u	*keys;
--- 15684,15690 ----
  static void remote_common(typval_T *argvars, typval_T *rettv, int expr);
  
      static void
! remote_common(typval_T *argvars, typval_T *rettv, int expr)
  {
      char_u	*server_name;
      char_u	*keys;
***************
*** 16342,16350 ****
   * "remote_expr()" function
   */
      static void
! f_remote_expr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
--- 15745,15751 ----
   * "remote_expr()" function
   */
      static void
! f_remote_expr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
***************
*** 16357,16365 ****
   * "remote_foreground()" function
   */
      static void
! f_remote_foreground(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_CLIENTSERVER
  # ifdef WIN32
--- 15758,15764 ----
   * "remote_foreground()" function
   */
      static void
! f_remote_foreground(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_CLIENTSERVER
  # ifdef WIN32
***************
*** 16382,16390 ****
  }
  
      static void
! f_remote_peek(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
      dictitem_T	v;
--- 15781,15787 ----
  }
  
      static void
! f_remote_peek(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_CLIENTSERVER
      dictitem_T	v;
***************
*** 16439,16447 ****
  }
  
      static void
! f_remote_read(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      char_u	*r = NULL;
  
--- 15836,15842 ----
  }
  
      static void
! f_remote_read(typval_T *argvars UNUSED, typval_T *rettv)
  {
      char_u	*r = NULL;
  
***************
*** 16473,16481 ****
   * "remote_send()" function
   */
      static void
! f_remote_send(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
--- 15868,15874 ----
   * "remote_send()" function
   */
      static void
! f_remote_send(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
***************
*** 16488,16496 ****
   * "remove()" function
   */
      static void
! f_remove(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      list_T	*l;
      listitem_T	*item, *item2;
--- 15881,15887 ----
   * "remove()" function
   */
      static void
! f_remove(typval_T *argvars, typval_T *rettv)
  {
      list_T	*l;
      listitem_T	*item, *item2;
***************
*** 16589,16597 ****
   * "rename({from}, {to})" function
   */
      static void
! f_rename(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[NUMBUFLEN];
  
--- 15980,15986 ----
   * "rename({from}, {to})" function
   */
      static void
! f_rename(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[NUMBUFLEN];
  
***************
*** 16606,16614 ****
   * "repeat()" function
   */
      static void
! f_repeat(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
      int		n;
--- 15995,16001 ----
   * "repeat()" function
   */
      static void
! f_repeat(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
      int		n;
***************
*** 16653,16661 ****
   * "resolve()" function
   */
      static void
! f_resolve(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
  #ifdef HAVE_READLINK
--- 16040,16046 ----
   * "resolve()" function
   */
      static void
! f_resolve(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
  #ifdef HAVE_READLINK
***************
*** 16862,16870 ****
   * "reverse({list})" function
   */
      static void
! f_reverse(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      list_T	*l;
      listitem_T	*li, *ni;
--- 16247,16253 ----
   * "reverse({list})" function
   */
      static void
! f_reverse(typval_T *argvars, typval_T *rettv)
  {
      list_T	*l;
      listitem_T	*li, *ni;
***************
*** 16908,16916 ****
   * Returns BACKWARD, FORWARD or zero (for an error).
   */
      static int
! get_search_arg(varp, flagsp)
!     typval_T	*varp;
!     int		*flagsp;
  {
      int		dir = FORWARD;
      char_u	*flags;
--- 16291,16297 ----
   * Returns BACKWARD, FORWARD or zero (for an error).
   */
      static int
! get_search_arg(typval_T *varp, int *flagsp)
  {
      int		dir = FORWARD;
      char_u	*flags;
***************
*** 16962,16971 ****
   * Shared by search() and searchpos() functions.
   */
      static int
! search_cmn(argvars, match_pos, flagsp)
!     typval_T	*argvars;
!     pos_T	*match_pos;
!     int		*flagsp;
  {
      int		flags;
      char_u	*pat;
--- 16343,16349 ----
   * Shared by search() and searchpos() functions.
   */
      static int
! search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)
  {
      int		flags;
      char_u	*pat;
***************
*** 17068,17075 ****
   * round() is not in C90, use ceil() or floor() instead.
   */
      float_T
! vim_round(f)
!     float_T f;
  {
      return f > 0 ? floor(f + 0.5) : ceil(f - 0.5);
  }
--- 16446,16452 ----
   * round() is not in C90, use ceil() or floor() instead.
   */
      float_T
! vim_round(float_T f)
  {
      return f > 0 ? floor(f + 0.5) : ceil(f - 0.5);
  }
***************
*** 17078,17086 ****
   * "round({float})" function
   */
      static void
! f_round(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 16455,16461 ----
   * "round({float})" function
   */
      static void
! f_round(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 17096,17104 ****
   * "screenattr()" function
   */
      static void
! f_screenattr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		row;
      int		col;
--- 16471,16477 ----
   * "screenattr()" function
   */
      static void
! f_screenattr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		row;
      int		col;
***************
*** 17117,17126 ****
  /*
   * "screenchar()" function
   */
!     static void
! f_screenchar(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		row;
      int		col;
--- 16490,16497 ----
  /*
   * "screenchar()" function
   */
!     static void
! f_screenchar(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		row;
      int		col;
***************
*** 17151,17159 ****
   * First column is 1 to be consistent with virtcol().
   */
      static void
! f_screencol(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = screen_screencol() + 1;
  }
--- 16522,16528 ----
   * First column is 1 to be consistent with virtcol().
   */
      static void
! f_screencol(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = screen_screencol() + 1;
  }
***************
*** 17162,17170 ****
   * "screenrow()" function
   */
      static void
! f_screenrow(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = screen_screenrow() + 1;
  }
--- 16531,16537 ----
   * "screenrow()" function
   */
      static void
! f_screenrow(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = screen_screenrow() + 1;
  }
***************
*** 17173,17181 ****
   * "search()" function
   */
      static void
! f_search(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		flags = 0;
  
--- 16540,16546 ----
   * "search()" function
   */
      static void
! f_search(typval_T *argvars, typval_T *rettv)
  {
      int		flags = 0;
  
***************
*** 17186,17194 ****
   * "searchdecl()" function
   */
      static void
! f_searchdecl(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		locally = 1;
      int		thisblock = 0;
--- 16551,16557 ----
   * "searchdecl()" function
   */
      static void
! f_searchdecl(typval_T *argvars, typval_T *rettv)
  {
      int		locally = 1;
      int		thisblock = 0;
***************
*** 17213,17221 ****
   * Used by searchpair() and searchpairpos()
   */
      static int
! searchpair_cmn(argvars, match_pos)
!     typval_T	*argvars;
!     pos_T	*match_pos;
  {
      char_u	*spat, *mpat, *epat;
      char_u	*skip;
--- 16576,16582 ----
   * Used by searchpair() and searchpairpos()
   */
      static int
! searchpair_cmn(typval_T *argvars, pos_T *match_pos)
  {
      char_u	*spat, *mpat, *epat;
      char_u	*skip;
***************
*** 17293,17301 ****
   * "searchpair()" function
   */
      static void
! f_searchpair(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = searchpair_cmn(argvars, NULL);
  }
--- 16654,16660 ----
   * "searchpair()" function
   */
      static void
! f_searchpair(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = searchpair_cmn(argvars, NULL);
  }
***************
*** 17304,17312 ****
   * "searchpairpos()" function
   */
      static void
! f_searchpairpos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      pos_T	match_pos;
      int		lnum = 0;
--- 16663,16669 ----
   * "searchpairpos()" function
   */
      static void
! f_searchpairpos(typval_T *argvars, typval_T *rettv)
  {
      pos_T	match_pos;
      int		lnum = 0;
***************
*** 17331,17347 ****
   * Returns 0 or -1 for no match,
   */
      long
! do_searchpair(spat, mpat, epat, dir, skip, flags, match_pos,
! 							lnum_stop, time_limit)
!     char_u	*spat;	    /* start pattern */
!     char_u	*mpat;	    /* middle pattern */
!     char_u	*epat;	    /* end pattern */
!     int		dir;	    /* BACKWARD or FORWARD */
!     char_u	*skip;	    /* skip expression */
!     int		flags;	    /* SP_SETPCMARK and other SP_ values */
!     pos_T	*match_pos;
!     linenr_T	lnum_stop;  /* stop at this line if not zero */
!     long	time_limit UNUSED; /* stop after this many msec */
  {
      char_u	*save_cpo;
      char_u	*pat, *pat2 = NULL, *pat3 = NULL;
--- 16688,16703 ----
   * Returns 0 or -1 for no match,
   */
      long
! do_searchpair(
!     char_u	*spat,	    /* start pattern */
!     char_u	*mpat,	    /* middle pattern */
!     char_u	*epat,	    /* end pattern */
!     int		dir,	    /* BACKWARD or FORWARD */
!     char_u	*skip,	    /* skip expression */
!     int		flags,	    /* SP_SETPCMARK and other SP_ values */
!     pos_T	*match_pos,
!     linenr_T	lnum_stop,  /* stop at this line if not zero */
!     long	time_limit UNUSED) /* stop after this many msec */
  {
      char_u	*save_cpo;
      char_u	*pat, *pat2 = NULL, *pat3 = NULL;
***************
*** 17488,17496 ****
   * "searchpos()" function
   */
      static void
! f_searchpos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      pos_T	match_pos;
      int		lnum = 0;
--- 16844,16850 ----
   * "searchpos()" function
   */
      static void
! f_searchpos(typval_T *argvars, typval_T *rettv)
  {
      pos_T	match_pos;
      int		lnum = 0;
***************
*** 17552,17560 ****
   * "sendexpr()" function
   */
      static void
! f_sendexpr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*text;
      char_u	*resp;
--- 16906,16912 ----
   * "sendexpr()" function
   */
      static void
! f_sendexpr(typval_T *argvars, typval_T *rettv)
  {
      char_u	*text;
      char_u	*resp;
***************
*** 17598,17606 ****
   * "sendraw()" function
   */
      static void
! f_sendraw(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[NUMBUFLEN];
      char_u	*text;
--- 16950,16956 ----
   * "sendraw()" function
   */
      static void
! f_sendraw(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[NUMBUFLEN];
      char_u	*text;
***************
*** 17619,17627 ****
  
  
      static void
! f_server2client(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_CLIENTSERVER
      char_u	buf[NUMBUFLEN];
--- 16969,16975 ----
  
  
      static void
! f_server2client(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_CLIENTSERVER
      char_u	buf[NUMBUFLEN];
***************
*** 17650,17658 ****
  }
  
      static void
! f_serverlist(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      char_u	*r = NULL;
  
--- 16998,17004 ----
  }
  
      static void
! f_serverlist(typval_T *argvars UNUSED, typval_T *rettv)
  {
      char_u	*r = NULL;
  
***************
*** 17673,17681 ****
   * "setbufvar()" function
   */
      static void
! f_setbufvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      buf_T	*buf;
      aco_save_T	aco;
--- 17019,17025 ----
   * "setbufvar()" function
   */
      static void
! f_setbufvar(typval_T *argvars, typval_T *rettv UNUSED)
  {
      buf_T	*buf;
      aco_save_T	aco;
***************
*** 17725,17733 ****
  }
  
      static void
! f_setcharsearch(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      dict_T	*d;
      dictitem_T	*di;
--- 17069,17075 ----
  }
  
      static void
! f_setcharsearch(typval_T *argvars, typval_T *rettv UNUSED)
  {
      dict_T	*d;
      dictitem_T	*di;
***************
*** 17773,17781 ****
   * "setcmdpos()" function
   */
      static void
! f_setcmdpos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		pos = (int)get_tv_number(&argvars[0]) - 1;
  
--- 17115,17121 ----
   * "setcmdpos()" function
   */
      static void
! f_setcmdpos(typval_T *argvars, typval_T *rettv)
  {
      int		pos = (int)get_tv_number(&argvars[0]) - 1;
  
***************
*** 17787,17795 ****
   * "setline()" function
   */
      static void
! f_setline(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      linenr_T	lnum;
      char_u	*line = NULL;
--- 17127,17133 ----
   * "setline()" function
   */
      static void
! f_setline(typval_T *argvars, typval_T *rettv)
  {
      linenr_T	lnum;
      char_u	*line = NULL;
***************
*** 17865,17875 ****
   * Used by "setqflist()" and "setloclist()" functions
   */
      static void
! set_qf_ll_list(wp, list_arg, action_arg, rettv)
!     win_T	*wp UNUSED;
!     typval_T	*list_arg UNUSED;
!     typval_T	*action_arg UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_QUICKFIX
      char_u	*act;
--- 17203,17213 ----
   * Used by "setqflist()" and "setloclist()" functions
   */
      static void
! set_qf_ll_list(
!     win_T	*wp UNUSED,
!     typval_T	*list_arg UNUSED,
!     typval_T	*action_arg UNUSED,
!     typval_T	*rettv)
  {
  #ifdef FEAT_QUICKFIX
      char_u	*act;
***************
*** 17905,17913 ****
   * "setloclist()" function
   */
      static void
! f_setloclist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*win;
  
--- 17243,17249 ----
   * "setloclist()" function
   */
      static void
! f_setloclist(typval_T *argvars, typval_T *rettv)
  {
      win_T	*win;
  
***************
*** 17922,17930 ****
   * "setmatches()" function
   */
      static void
! f_setmatches(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_SEARCH_EXTRA
      list_T	*l;
--- 17258,17264 ----
   * "setmatches()" function
   */
      static void
! f_setmatches(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_SEARCH_EXTRA
      list_T	*l;
***************
*** 18033,18041 ****
   * "setpos()" function
   */
      static void
! f_setpos(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      pos_T	pos;
      int		fnum;
--- 17367,17373 ----
   * "setpos()" function
   */
      static void
! f_setpos(typval_T *argvars, typval_T *rettv)
  {
      pos_T	pos;
      int		fnum;
***************
*** 18083,18091 ****
   * "setqflist()" function
   */
      static void
! f_setqflist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      set_qf_ll_list(NULL, &argvars[0], &argvars[1], rettv);
  }
--- 17415,17421 ----
   * "setqflist()" function
   */
      static void
! f_setqflist(typval_T *argvars, typval_T *rettv)
  {
      set_qf_ll_list(NULL, &argvars[0], &argvars[1], rettv);
  }
***************
*** 18094,18102 ****
   * "setreg()" function
   */
      static void
! f_setreg(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		regname;
      char_u	*strregname;
--- 17424,17430 ----
   * "setreg()" function
   */
      static void
! f_setreg(typval_T *argvars, typval_T *rettv)
  {
      int		regname;
      char_u	*strregname;
***************
*** 18208,18216 ****
   * "settabvar()" function
   */
      static void
! f_settabvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
  #ifdef FEAT_WINDOWS
      tabpage_T	*save_curtab;
--- 17536,17542 ----
   * "settabvar()" function
   */
      static void
! f_settabvar(typval_T *argvars, typval_T *rettv)
  {
  #ifdef FEAT_WINDOWS
      tabpage_T	*save_curtab;
***************
*** 18262,18270 ****
   * "settabwinvar()" function
   */
      static void
! f_settabwinvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      setwinvar(argvars, rettv, 1);
  }
--- 17588,17594 ----
   * "settabwinvar()" function
   */
      static void
! f_settabwinvar(typval_T *argvars, typval_T *rettv)
  {
      setwinvar(argvars, rettv, 1);
  }
***************
*** 18273,18281 ****
   * "setwinvar()" function
   */
      static void
! f_setwinvar(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      setwinvar(argvars, rettv, 0);
  }
--- 17597,17603 ----
   * "setwinvar()" function
   */
      static void
! f_setwinvar(typval_T *argvars, typval_T *rettv)
  {
      setwinvar(argvars, rettv, 0);
  }
***************
*** 18285,18294 ****
   */
  
      static void
! setwinvar(argvars, rettv, off)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
!     int		off;
  {
      win_T	*win;
  #ifdef FEAT_WINDOWS
--- 17607,17613 ----
   */
  
      static void
! setwinvar(typval_T *argvars, typval_T *rettv UNUSED, int off)
  {
      win_T	*win;
  #ifdef FEAT_WINDOWS
***************
*** 18358,18366 ****
   * "sha256({string})" function
   */
      static void
! f_sha256(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
  
--- 17677,17683 ----
   * "sha256({string})" function
   */
      static void
! f_sha256(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
  
***************
*** 18375,18383 ****
   * "shellescape({string})" function
   */
      static void
! f_shellescape(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_string = vim_strsave_shellescape(
  		get_tv_string(&argvars[0]), non_zero_arg(&argvars[1]), TRUE);
--- 17692,17698 ----
   * "shellescape({string})" function
   */
      static void
! f_shellescape(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_string = vim_strsave_shellescape(
  		get_tv_string(&argvars[0]), non_zero_arg(&argvars[1]), TRUE);
***************
*** 18388,18396 ****
   * shiftwidth() function
   */
      static void
! f_shiftwidth(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = get_sw_value(curbuf);
  }
--- 17703,17709 ----
   * shiftwidth() function
   */
      static void
! f_shiftwidth(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->vval.v_number = get_sw_value(curbuf);
  }
***************
*** 18399,18407 ****
   * "simplify()" function
   */
      static void
! f_simplify(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
  
--- 17712,17718 ----
   * "simplify()" function
   */
      static void
! f_simplify(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
  
***************
*** 18416,18424 ****
   * "sin()" function
   */
      static void
! f_sin(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 17727,17733 ----
   * "sin()" function
   */
      static void
! f_sin(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 18433,18441 ****
   * "sinh()" function
   */
      static void
! f_sinh(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 17742,17748 ----
   * "sinh()" function
   */
      static void
! f_sinh(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 18485,18493 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! item_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      sortItem_T  *si1, *si2;
      typval_T	*tv1, *tv2;
--- 17792,17798 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! item_compare(const void *s1, const void *s2)
  {
      sortItem_T  *si1, *si2;
      typval_T	*tv1, *tv2;
***************
*** 18574,18582 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! item_compare2(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      sortItem_T  *si1, *si2;
      int		res;
--- 17879,17885 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! item_compare2(const void *s1, const void *s2)
  {
      sortItem_T  *si1, *si2;
      int		res;
***************
*** 18623,18632 ****
   * "sort({list})" function
   */
      static void
! do_sort_uniq(argvars, rettv, sort)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		sort;
  {
      list_T	*l;
      listitem_T	*li;
--- 17926,17932 ----
   * "sort({list})" function
   */
      static void
! do_sort_uniq(typval_T *argvars, typval_T *rettv, int sort)
  {
      list_T	*l;
      listitem_T	*li;
***************
*** 18801,18809 ****
   * "sort({list})" function
   */
      static void
! f_sort(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      do_sort_uniq(argvars, rettv, TRUE);
  }
--- 18101,18107 ----
   * "sort({list})" function
   */
      static void
! f_sort(typval_T *argvars, typval_T *rettv)
  {
      do_sort_uniq(argvars, rettv, TRUE);
  }
***************
*** 18812,18820 ****
   * "uniq({list})" function
   */
      static void
! f_uniq(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      do_sort_uniq(argvars, rettv, FALSE);
  }
--- 18110,18116 ----
   * "uniq({list})" function
   */
      static void
! f_uniq(typval_T *argvars, typval_T *rettv)
  {
      do_sort_uniq(argvars, rettv, FALSE);
  }
***************
*** 18823,18831 ****
   * "soundfold({word})" function
   */
      static void
! f_soundfold(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*s;
  
--- 18119,18125 ----
   * "soundfold({word})" function
   */
      static void
! f_soundfold(typval_T *argvars, typval_T *rettv)
  {
      char_u	*s;
  
***************
*** 18842,18850 ****
   * "spellbadword()" function
   */
      static void
! f_spellbadword(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      char_u	*word = (char_u *)"";
      hlf_T	attr = HLF_COUNT;
--- 18136,18142 ----
   * "spellbadword()" function
   */
      static void
! f_spellbadword(typval_T *argvars UNUSED, typval_T *rettv)
  {
      char_u	*word = (char_u *)"";
      hlf_T	attr = HLF_COUNT;
***************
*** 18896,18904 ****
   * "spellsuggest()" function
   */
      static void
! f_spellsuggest(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_SPELL
      char_u	*str;
--- 18188,18194 ----
   * "spellsuggest()" function
   */
      static void
! f_spellsuggest(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_SPELL
      char_u	*str;
***************
*** 18955,18963 ****
  }
  
      static void
! f_split(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*str;
      char_u	*end;
--- 18245,18251 ----
  }
  
      static void
! f_split(typval_T *argvars, typval_T *rettv)
  {
      char_u	*str;
      char_u	*end;
***************
*** 19040,19048 ****
   * "sqrt()" function
   */
      static void
! f_sqrt(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 18328,18334 ----
   * "sqrt()" function
   */
      static void
! f_sqrt(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 19057,19065 ****
   * "str2float()" function
   */
      static void
! f_str2float(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u *p = skipwhite(get_tv_string(&argvars[0]));
  
--- 18343,18349 ----
   * "str2float()" function
   */
      static void
! f_str2float(typval_T *argvars, typval_T *rettv)
  {
      char_u *p = skipwhite(get_tv_string(&argvars[0]));
  
***************
*** 19074,19082 ****
   * "str2nr()" function
   */
      static void
! f_str2nr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		base = 10;
      char_u	*p;
--- 18358,18364 ----
   * "str2nr()" function
   */
      static void
! f_str2nr(typval_T *argvars, typval_T *rettv)
  {
      int		base = 10;
      char_u	*p;
***************
*** 19112,19120 ****
   * "strftime({format}[, {time}])" function
   */
      static void
! f_strftime(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	result_buf[256];
      struct tm	*curtime;
--- 18394,18400 ----
   * "strftime({format}[, {time}])" function
   */
      static void
! f_strftime(typval_T *argvars, typval_T *rettv)
  {
      char_u	result_buf[256];
      struct tm	*curtime;
***************
*** 19173,19181 ****
   * "stridx()" function
   */
      static void
! f_stridx(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[NUMBUFLEN];
      char_u	*needle;
--- 18453,18459 ----
   * "stridx()" function
   */
      static void
! f_stridx(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[NUMBUFLEN];
      char_u	*needle;
***************
*** 19210,19218 ****
   * "string()" function
   */
      static void
! f_string(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*tofree;
      char_u	numbuf[NUMBUFLEN];
--- 18488,18494 ----
   * "string()" function
   */
      static void
! f_string(typval_T *argvars, typval_T *rettv)
  {
      char_u	*tofree;
      char_u	numbuf[NUMBUFLEN];
***************
*** 19228,19236 ****
   * "strlen()" function
   */
      static void
! f_strlen(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = (varnumber_T)(STRLEN(
  					      get_tv_string(&argvars[0])));
--- 18504,18510 ----
   * "strlen()" function
   */
      static void
! f_strlen(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = (varnumber_T)(STRLEN(
  					      get_tv_string(&argvars[0])));
***************
*** 19240,19248 ****
   * "strchars()" function
   */
      static void
! f_strchars(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u		*s = get_tv_string(&argvars[0]);
      int			skipcc = 0;
--- 18514,18520 ----
   * "strchars()" function
   */
      static void
! f_strchars(typval_T *argvars, typval_T *rettv)
  {
      char_u		*s = get_tv_string(&argvars[0]);
      int			skipcc = 0;
***************
*** 19275,19283 ****
   * "strdisplaywidth()" function
   */
      static void
! f_strdisplaywidth(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*s = get_tv_string(&argvars[0]);
      int		col = 0;
--- 18547,18553 ----
   * "strdisplaywidth()" function
   */
      static void
! f_strdisplaywidth(typval_T *argvars, typval_T *rettv)
  {
      char_u	*s = get_tv_string(&argvars[0]);
      int		col = 0;
***************
*** 19292,19300 ****
   * "strwidth()" function
   */
      static void
! f_strwidth(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*s = get_tv_string(&argvars[0]);
  
--- 18562,18568 ----
   * "strwidth()" function
   */
      static void
! f_strwidth(typval_T *argvars, typval_T *rettv)
  {
      char_u	*s = get_tv_string(&argvars[0]);
  
***************
*** 19311,19319 ****
   * "strpart()" function
   */
      static void
! f_strpart(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
      int		n;
--- 18579,18585 ----
   * "strpart()" function
   */
      static void
! f_strpart(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
      int		n;
***************
*** 19356,19364 ****
   * "strridx()" function
   */
      static void
! f_strridx(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	buf[NUMBUFLEN];
      char_u	*needle;
--- 18622,18628 ----
   * "strridx()" function
   */
      static void
! f_strridx(typval_T *argvars, typval_T *rettv)
  {
      char_u	buf[NUMBUFLEN];
      char_u	*needle;
***************
*** 19411,19419 ****
   * "strtrans()" function
   */
      static void
! f_strtrans(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = transstr(get_tv_string(&argvars[0]));
--- 18675,18681 ----
   * "strtrans()" function
   */
      static void
! f_strtrans(typval_T *argvars, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = transstr(get_tv_string(&argvars[0]));
***************
*** 19423,19431 ****
   * "submatch()" function
   */
      static void
! f_submatch(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		error = FALSE;
      int		no;
--- 18685,18691 ----
   * "submatch()" function
   */
      static void
! f_submatch(typval_T *argvars, typval_T *rettv)
  {
      int		error = FALSE;
      int		no;
***************
*** 19456,19464 ****
   * "substitute()" function
   */
      static void
! f_substitute(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	patbuf[NUMBUFLEN];
      char_u	subbuf[NUMBUFLEN];
--- 18716,18722 ----
   * "substitute()" function
   */
      static void
! f_substitute(typval_T *argvars, typval_T *rettv)
  {
      char_u	patbuf[NUMBUFLEN];
      char_u	subbuf[NUMBUFLEN];
***************
*** 19480,19488 ****
   * "synID(lnum, col, trans)" function
   */
      static void
! f_synID(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		id = 0;
  #ifdef FEAT_SYN_HL
--- 18738,18744 ----
   * "synID(lnum, col, trans)" function
   */
      static void
! f_synID(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		id = 0;
  #ifdef FEAT_SYN_HL
***************
*** 19507,19515 ****
   * "synIDattr(id, what [, mode])" function
   */
      static void
! f_synIDattr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      char_u	*p = NULL;
  #ifdef FEAT_SYN_HL
--- 18763,18769 ----
   * "synIDattr(id, what [, mode])" function
   */
      static void
! f_synIDattr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      char_u	*p = NULL;
  #ifdef FEAT_SYN_HL
***************
*** 19598,19606 ****
   * "synIDtrans(id)" function
   */
      static void
! f_synIDtrans(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		id;
  
--- 18852,18858 ----
   * "synIDtrans(id)" function
   */
      static void
! f_synIDtrans(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		id;
  
***************
*** 19620,19628 ****
   * "synconcealed(lnum, col)" function
   */
      static void
! f_synconcealed(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #if defined(FEAT_SYN_HL) && defined(FEAT_CONCEAL)
      long	lnum;
--- 18872,18878 ----
   * "synconcealed(lnum, col)" function
   */
      static void
! f_synconcealed(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #if defined(FEAT_SYN_HL) && defined(FEAT_CONCEAL)
      long	lnum;
***************
*** 19682,19690 ****
   * "synstack(lnum, col)" function
   */
      static void
! f_synstack(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_SYN_HL
      long	lnum;
--- 18932,18938 ----
   * "synstack(lnum, col)" function
   */
      static void
! f_synstack(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_SYN_HL
      long	lnum;
***************
*** 19718,19727 ****
  }
  
      static void
! get_cmd_output_as_rettv(argvars, rettv, retlist)
!     typval_T	*argvars;
!     typval_T	*rettv;
!     int		retlist;
  {
      char_u	*res = NULL;
      char_u	*p;
--- 18966,18975 ----
  }
  
      static void
! get_cmd_output_as_rettv(
!     typval_T	*argvars,
!     typval_T	*rettv,
!     int		retlist)
  {
      char_u	*res = NULL;
      char_u	*p;
***************
*** 19890,19898 ****
   * "system()" function
   */
      static void
! f_system(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      get_cmd_output_as_rettv(argvars, rettv, FALSE);
  }
--- 19138,19144 ----
   * "system()" function
   */
      static void
! f_system(typval_T *argvars, typval_T *rettv)
  {
      get_cmd_output_as_rettv(argvars, rettv, FALSE);
  }
***************
*** 19901,19909 ****
   * "systemlist()" function
   */
      static void
! f_systemlist(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      get_cmd_output_as_rettv(argvars, rettv, TRUE);
  }
--- 19147,19153 ----
   * "systemlist()" function
   */
      static void
! f_systemlist(typval_T *argvars, typval_T *rettv)
  {
      get_cmd_output_as_rettv(argvars, rettv, TRUE);
  }
***************
*** 19912,19920 ****
   * "tabpagebuflist()" function
   */
      static void
! f_tabpagebuflist(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
--- 19156,19162 ----
   * "tabpagebuflist()" function
   */
      static void
! f_tabpagebuflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
***************
*** 19943,19951 ****
   * "tabpagenr()" function
   */
      static void
! f_tabpagenr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		nr = 1;
  #ifdef FEAT_WINDOWS
--- 19185,19191 ----
   * "tabpagenr()" function
   */
      static void
! f_tabpagenr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		nr = 1;
  #ifdef FEAT_WINDOWS
***************
*** 19977,19985 ****
   * Common code for tabpagewinnr() and winnr().
   */
      static int
! get_winnr(tp, argvar)
!     tabpage_T	*tp;
!     typval_T	*argvar;
  {
      win_T	*twin;
      int		nr = 1;
--- 19217,19223 ----
   * Common code for tabpagewinnr() and winnr().
   */
      static int
! get_winnr(tabpage_T *tp, typval_T *argvar)
  {
      win_T	*twin;
      int		nr = 1;
***************
*** 20027,20035 ****
   * "tabpagewinnr()" function
   */
      static void
! f_tabpagewinnr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		nr = 1;
  #ifdef FEAT_WINDOWS
--- 19265,19271 ----
   * "tabpagewinnr()" function
   */
      static void
! f_tabpagewinnr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		nr = 1;
  #ifdef FEAT_WINDOWS
***************
*** 20049,20057 ****
   * "tagfiles()" function
   */
      static void
! f_tagfiles(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      char_u	*fname;
      tagname_T	tn;
--- 19285,19291 ----
   * "tagfiles()" function
   */
      static void
! f_tagfiles(typval_T *argvars UNUSED, typval_T *rettv)
  {
      char_u	*fname;
      tagname_T	tn;
***************
*** 20075,20083 ****
   * "taglist()" function
   */
      static void
! f_taglist(argvars, rettv)
!     typval_T  *argvars;
!     typval_T  *rettv;
  {
      char_u  *tag_pattern;
  
--- 19309,19315 ----
   * "taglist()" function
   */
      static void
! f_taglist(typval_T *argvars, typval_T *rettv)
  {
      char_u  *tag_pattern;
  
***************
*** 20095,20103 ****
   * "tempname()" function
   */
      static void
! f_tempname(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      static int	x = 'A';
  
--- 19327,19333 ----
   * "tempname()" function
   */
      static void
! f_tempname(typval_T *argvars UNUSED, typval_T *rettv)
  {
      static int	x = 'A';
  
***************
*** 20130,20138 ****
   * "test(list)" function: Just checking the walls...
   */
      static void
! f_test(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
      /* Used for unit testing.  Change the code below to your liking. */
  #if 0
--- 19360,19366 ----
   * "test(list)" function: Just checking the walls...
   */
      static void
! f_test(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
      /* Used for unit testing.  Change the code below to your liking. */
  #if 0
***************
*** 20162,20170 ****
   * "tan()" function
   */
      static void
! f_tan(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 19390,19396 ----
   * "tan()" function
   */
      static void
! f_tan(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 20179,20187 ****
   * "tanh()" function
   */
      static void
! f_tanh(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 19405,19411 ----
   * "tanh()" function
   */
      static void
! f_tanh(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 20197,20205 ****
   * "tolower(string)" function
   */
      static void
! f_tolower(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*p;
  
--- 19421,19427 ----
   * "tolower(string)" function
   */
      static void
! f_tolower(typval_T *argvars, typval_T *rettv)
  {
      char_u	*p;
  
***************
*** 20240,20248 ****
   * "toupper(string)" function
   */
      static void
! f_toupper(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = strup_save(get_tv_string(&argvars[0]));
--- 19462,19468 ----
   * "toupper(string)" function
   */
      static void
! f_toupper(typval_T *argvars, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = strup_save(get_tv_string(&argvars[0]));
***************
*** 20252,20260 ****
   * "tr(string, fromstr, tostr)" function
   */
      static void
! f_tr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      char_u	*in_str;
      char_u	*fromstr;
--- 19472,19478 ----
   * "tr(string, fromstr, tostr)" function
   */
      static void
! f_tr(typval_T *argvars, typval_T *rettv)
  {
      char_u	*in_str;
      char_u	*fromstr;
***************
*** 20376,20384 ****
   * "trunc({float})" function
   */
      static void
! f_trunc(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      float_T	f;
  
--- 19594,19600 ----
   * "trunc({float})" function
   */
      static void
! f_trunc(typval_T *argvars, typval_T *rettv)
  {
      float_T	f;
  
***************
*** 20395,20403 ****
   * "type(expr)" function
   */
      static void
! f_type(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int n;
  
--- 19611,19617 ----
   * "type(expr)" function
   */
      static void
! f_type(typval_T *argvars, typval_T *rettv)
  {
      int n;
  
***************
*** 20427,20435 ****
   * "undofile(name)" function
   */
      static void
! f_undofile(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      rettv->v_type = VAR_STRING;
  #ifdef FEAT_PERSISTENT_UNDO
--- 19641,19647 ----
   * "undofile(name)" function
   */
      static void
! f_undofile(typval_T *argvars UNUSED, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
  #ifdef FEAT_PERSISTENT_UNDO
***************
*** 20459,20467 ****
   * "undotree()" function
   */
      static void
! f_undotree(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      if (rettv_dict_alloc(rettv) == OK)
      {
--- 19671,19677 ----
   * "undotree()" function
   */
      static void
! f_undotree(typval_T *argvars UNUSED, typval_T *rettv)
  {
      if (rettv_dict_alloc(rettv) == OK)
      {
***************
*** 20489,20497 ****
   * "values(dict)" function
   */
      static void
! f_values(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      dict_list(argvars, rettv, 1);
  }
--- 19699,19705 ----
   * "values(dict)" function
   */
      static void
! f_values(typval_T *argvars, typval_T *rettv)
  {
      dict_list(argvars, rettv, 1);
  }
***************
*** 20500,20508 ****
   * "virtcol(string)" function
   */
      static void
! f_virtcol(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      colnr_T	vcol = 0;
      pos_T	*fp;
--- 19708,19714 ----
   * "virtcol(string)" function
   */
      static void
! f_virtcol(typval_T *argvars, typval_T *rettv)
  {
      colnr_T	vcol = 0;
      pos_T	*fp;
***************
*** 20523,20531 ****
   * "visualmode()" function
   */
      static void
! f_visualmode(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
      char_u	str[2];
  
--- 19729,19735 ----
   * "visualmode()" function
   */
      static void
! f_visualmode(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
      char_u	str[2];
  
***************
*** 20543,20551 ****
   * "wildmenumode()" function
   */
      static void
! f_wildmenumode(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv UNUSED;
  {
  #ifdef FEAT_WILDMENU
      if (wild_menu_showing)
--- 19747,19753 ----
   * "wildmenumode()" function
   */
      static void
! f_wildmenumode(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
  #ifdef FEAT_WILDMENU
      if (wild_menu_showing)
***************
*** 20557,20565 ****
   * "winbufnr(nr)" function
   */
      static void
! f_winbufnr(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*wp;
  
--- 19759,19765 ----
   * "winbufnr(nr)" function
   */
      static void
! f_winbufnr(typval_T *argvars, typval_T *rettv)
  {
      win_T	*wp;
  
***************
*** 20574,20582 ****
   * "wincol()" function
   */
      static void
! f_wincol(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      validate_cursor();
      rettv->vval.v_number = curwin->w_wcol + 1;
--- 19774,19780 ----
   * "wincol()" function
   */
      static void
! f_wincol(typval_T *argvars UNUSED, typval_T *rettv)
  {
      validate_cursor();
      rettv->vval.v_number = curwin->w_wcol + 1;
***************
*** 20586,20594 ****
   * "winheight(nr)" function
   */
      static void
! f_winheight(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*wp;
  
--- 19784,19790 ----
   * "winheight(nr)" function
   */
      static void
! f_winheight(typval_T *argvars, typval_T *rettv)
  {
      win_T	*wp;
  
***************
*** 20603,20611 ****
   * "winline()" function
   */
      static void
! f_winline(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      validate_cursor();
      rettv->vval.v_number = curwin->w_wrow + 1;
--- 19799,19805 ----
   * "winline()" function
   */
      static void
! f_winline(typval_T *argvars UNUSED, typval_T *rettv)
  {
      validate_cursor();
      rettv->vval.v_number = curwin->w_wrow + 1;
***************
*** 20615,20623 ****
   * "winnr()" function
   */
      static void
! f_winnr(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      int		nr = 1;
  
--- 19809,19815 ----
   * "winnr()" function
   */
      static void
! f_winnr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		nr = 1;
  
***************
*** 20631,20639 ****
   * "winrestcmd()" function
   */
      static void
! f_winrestcmd(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
--- 19823,19829 ----
   * "winrestcmd()" function
   */
      static void
! f_winrestcmd(typval_T *argvars UNUSED, typval_T *rettv)
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
***************
*** 20665,20673 ****
   * "winrestview()" function
   */
      static void
! f_winrestview(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv UNUSED;
  {
      dict_T	*dict;
  
--- 19855,19861 ----
   * "winrestview()" function
   */
      static void
! f_winrestview(typval_T *argvars, typval_T *rettv UNUSED)
  {
      dict_T	*dict;
  
***************
*** 20722,20730 ****
   * "winsaveview()" function
   */
      static void
! f_winsaveview(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      dict_T	*dict;
  
--- 19910,19916 ----
   * "winsaveview()" function
   */
      static void
! f_winsaveview(typval_T *argvars UNUSED, typval_T *rettv)
  {
      dict_T	*dict;
  
***************
*** 20752,20760 ****
   * "winwidth(nr)" function
   */
      static void
! f_winwidth(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      win_T	*wp;
  
--- 19938,19944 ----
   * "winwidth(nr)" function
   */
      static void
! f_winwidth(typval_T *argvars, typval_T *rettv)
  {
      win_T	*wp;
  
***************
*** 20773,20781 ****
   * "wordcount()" function
   */
      static void
! f_wordcount(argvars, rettv)
!     typval_T	*argvars UNUSED;
!     typval_T	*rettv;
  {
      if (rettv_dict_alloc(rettv) == FAIL)
  	return;
--- 19957,19963 ----
   * "wordcount()" function
   */
      static void
! f_wordcount(typval_T *argvars UNUSED, typval_T *rettv)
  {
      if (rettv_dict_alloc(rettv) == FAIL)
  	return;
***************
*** 20786,20795 ****
   * Write list of strings to file
   */
      static int
! write_list(fd, list, binary)
!     FILE	*fd;
!     list_T	*list;
!     int		binary;
  {
      listitem_T	*li;
      int		c;
--- 19968,19974 ----
   * Write list of strings to file
   */
      static int
! write_list(FILE *fd, list_T *list, int binary)
  {
      listitem_T	*li;
      int		c;
***************
*** 20829,20837 ****
   * "writefile()" function
   */
      static void
! f_writefile(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      int		binary = FALSE;
      int		append = FALSE;
--- 20008,20014 ----
   * "writefile()" function
   */
      static void
! f_writefile(typval_T *argvars, typval_T *rettv)
  {
      int		binary = FALSE;
      int		append = FALSE;
***************
*** 20881,20889 ****
   * "xor(expr, expr)" function
   */
      static void
! f_xor(argvars, rettv)
!     typval_T	*argvars;
!     typval_T	*rettv;
  {
      rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
  					^ get_tv_number_chk(&argvars[1], NULL);
--- 20058,20064 ----
   * "xor(expr, expr)" function
   */
      static void
! f_xor(typval_T *argvars, typval_T *rettv)
  {
      rettv->vval.v_number = get_tv_number_chk(&argvars[0], NULL)
  					^ get_tv_number_chk(&argvars[1], NULL);
***************
*** 20895,20904 ****
   * Returns NULL when there is an error.
   */
      static pos_T *
! var2fpos(varp, dollar_lnum, fnum)
!     typval_T	*varp;
!     int		dollar_lnum;	/* TRUE when $ is last line */
!     int		*fnum;		/* set to fnum for '0, 'A, etc. */
  {
      char_u		*name;
      static pos_T	pos;
--- 20070,20079 ----
   * Returns NULL when there is an error.
   */
      static pos_T *
! var2fpos(
!     typval_T	*varp,
!     int		dollar_lnum,	/* TRUE when $ is last line */
!     int		*fnum)		/* set to fnum for '0, 'A, etc. */
  {
      char_u		*name;
      static pos_T	pos;
***************
*** 21014,21024 ****
   * validity.
   */
      static int
! list2fpos(arg, posp, fnump, curswantp)
!     typval_T	*arg;
!     pos_T	*posp;
!     int		*fnump;
!     colnr_T	*curswantp;
  {
      list_T	*l = arg->vval.v_list;
      long	i = 0;
--- 20189,20199 ----
   * validity.
   */
      static int
! list2fpos(
!     typval_T	*arg,
!     pos_T	*posp,
!     int		*fnump,
!     colnr_T	*curswantp)
  {
      list_T	*l = arg->vval.v_list;
      long	i = 0;
***************
*** 21072,21079 ****
   * Return 0 for error.
   */
      static int
! get_env_len(arg)
!     char_u	**arg;
  {
      char_u	*p;
      int		len;
--- 20247,20253 ----
   * Return 0 for error.
   */
      static int
! get_env_len(char_u **arg)
  {
      char_u	*p;
      int		len;
***************
*** 21094,21101 ****
   * Return 0 if something is wrong.
   */
      static int
! get_id_len(arg)
!     char_u	**arg;
  {
      char_u	*p;
      int		len;
--- 20268,20274 ----
   * Return 0 if something is wrong.
   */
      static int
! get_id_len(char_u **arg)
  {
      char_u	*p;
      int		len;
***************
*** 21132,21142 ****
   * expanded name in an allocated string via 'alias' - caller must free.
   */
      static int
! get_name_len(arg, alias, evaluate, verbose)
!     char_u	**arg;
!     char_u	**alias;
!     int		evaluate;
!     int		verbose;
  {
      int		len;
      char_u	*p;
--- 20305,20315 ----
   * expanded name in an allocated string via 'alias' - caller must free.
   */
      static int
! get_name_len(
!     char_u	**arg,
!     char_u	**alias,
!     int		evaluate,
!     int		verbose)
  {
      int		len;
      char_u	*p;
***************
*** 21203,21213 ****
   * valid name.
   */
      static char_u *
! find_name_end(arg, expr_start, expr_end, flags)
!     char_u	*arg;
!     char_u	**expr_start;
!     char_u	**expr_end;
!     int		flags;
  {
      int		mb_nest = 0;
      int		br_nest = 0;
--- 20376,20386 ----
   * valid name.
   */
      static char_u *
! find_name_end(
!     char_u	*arg,
!     char_u	**expr_start,
!     char_u	**expr_end,
!     int		flags)
  {
      int		mb_nest = 0;
      int		br_nest = 0;
***************
*** 21300,21310 ****
   * Returns NULL for failure.
   */
      static char_u *
! make_expanded_name(in_start, expr_start, expr_end, in_end)
!     char_u	*in_start;
!     char_u	*expr_start;
!     char_u	*expr_end;
!     char_u	*in_end;
  {
      char_u	c1;
      char_u	*retval = NULL;
--- 20473,20483 ----
   * Returns NULL for failure.
   */
      static char_u *
! make_expanded_name(
!     char_u	*in_start,
!     char_u	*expr_start,
!     char_u	*expr_end,
!     char_u	*in_end)
  {
      char_u	c1;
      char_u	*retval = NULL;
***************
*** 21357,21364 ****
   * Does not include '{' or '}' for magic braces.
   */
      static int
! eval_isnamec(c)
!     int	    c;
  {
      return (ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR);
  }
--- 20530,20536 ----
   * Does not include '{' or '}' for magic braces.
   */
      static int
! eval_isnamec(int c)
  {
      return (ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR);
  }
***************
*** 21368,21375 ****
   * variable or function name (excluding '{' and '}').
   */
      static int
! eval_isnamec1(c)
!     int	    c;
  {
      return (ASCII_ISALPHA(c) || c == '_');
  }
--- 20540,20546 ----
   * variable or function name (excluding '{' and '}').
   */
      static int
! eval_isnamec1(int c)
  {
      return (ASCII_ISALPHA(c) || c == '_');
  }
***************
*** 21378,21386 ****
   * Set number v: variable to "val".
   */
      void
! set_vim_var_nr(idx, val)
!     int		idx;
!     long	val;
  {
      vimvars[idx].vv_nr = val;
  }
--- 20549,20555 ----
   * Set number v: variable to "val".
   */
      void
! set_vim_var_nr(int idx, long val)
  {
      vimvars[idx].vv_nr = val;
  }
***************
*** 21389,21396 ****
   * Get number v: variable value.
   */
      long
! get_vim_var_nr(idx)
!     int		idx;
  {
      return vimvars[idx].vv_nr;
  }
--- 20558,20564 ----
   * Get number v: variable value.
   */
      long
! get_vim_var_nr(int idx)
  {
      return vimvars[idx].vv_nr;
  }
***************
*** 21399,21406 ****
   * Get string v: variable value.  Uses a static buffer, can only be used once.
   */
      char_u *
! get_vim_var_str(idx)
!     int		idx;
  {
      return get_tv_string(&vimvars[idx].vv_tv);
  }
--- 20567,20573 ----
   * Get string v: variable value.  Uses a static buffer, can only be used once.
   */
      char_u *
! get_vim_var_str(int idx)
  {
      return get_tv_string(&vimvars[idx].vv_tv);
  }
***************
*** 21410,21417 ****
   * needed.
   */
      list_T *
! get_vim_var_list(idx)
!     int		idx;
  {
      return vimvars[idx].vv_list;
  }
--- 20577,20583 ----
   * needed.
   */
      list_T *
! get_vim_var_list(int idx)
  {
      return vimvars[idx].vv_list;
  }
***************
*** 21420,21427 ****
   * Set v:char to character "c".
   */
      void
! set_vim_var_char(c)
!     int c;
  {
      char_u	buf[MB_MAXBYTES + 1];
  
--- 20586,20592 ----
   * Set v:char to character "c".
   */
      void
! set_vim_var_char(int c)
  {
      char_u	buf[MB_MAXBYTES + 1];
  
***************
*** 21442,21451 ****
   * When "set_prevcount" is TRUE first set v:prevcount from v:count.
   */
      void
! set_vcount(count, count1, set_prevcount)
!     long	count;
!     long	count1;
!     int		set_prevcount;
  {
      if (set_prevcount)
  	vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
--- 20607,20616 ----
   * When "set_prevcount" is TRUE first set v:prevcount from v:count.
   */
      void
! set_vcount(
!     long	count,
!     long	count1,
!     int		set_prevcount)
  {
      if (set_prevcount)
  	vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
***************
*** 21457,21466 ****
   * Set string v: variable to a copy of "val".
   */
      void
! set_vim_var_string(idx, val, len)
!     int		idx;
!     char_u	*val;
!     int		len;	    /* length of "val" to use or -1 (whole string) */
  {
      /* Need to do this (at least) once, since we can't initialize a union.
       * Will always be invoked when "v:progname" is set. */
--- 20622,20631 ----
   * Set string v: variable to a copy of "val".
   */
      void
! set_vim_var_string(
!     int		idx,
!     char_u	*val,
!     int		len)	    /* length of "val" to use or -1 (whole string) */
  {
      /* Need to do this (at least) once, since we can't initialize a union.
       * Will always be invoked when "v:progname" is set. */
***************
*** 21479,21487 ****
   * Set List v: variable to "val".
   */
      void
! set_vim_var_list(idx, val)
!     int		idx;
!     list_T	*val;
  {
      list_unref(vimvars[idx].vv_list);
      vimvars[idx].vv_list = val;
--- 20644,20650 ----
   * Set List v: variable to "val".
   */
      void
! set_vim_var_list(int idx, list_T *val)
  {
      list_unref(vimvars[idx].vv_list);
      vimvars[idx].vv_list = val;
***************
*** 21493,21501 ****
   * Set Dictionary v: variable to "val".
   */
      void
! set_vim_var_dict(idx, val)
!     int		idx;
!     dict_T	*val;
  {
      int		todo;
      hashitem_T	*hi;
--- 20656,20662 ----
   * Set Dictionary v: variable to "val".
   */
      void
! set_vim_var_dict(int idx, dict_T *val)
  {
      int		todo;
      hashitem_T	*hi;
***************
*** 21522,21529 ****
   * Set v:register if needed.
   */
      void
! set_reg_var(c)
!     int		c;
  {
      char_u	regname;
  
--- 20683,20689 ----
   * Set v:register if needed.
   */
      void
! set_reg_var(int c)
  {
      char_u	regname;
  
***************
*** 21543,21550 ****
   * take care of memory allocations.
   */
      char_u *
! v_exception(oldval)
!     char_u	*oldval;
  {
      if (oldval == NULL)
  	return vimvars[VV_EXCEPTION].vv_str;
--- 20703,20709 ----
   * take care of memory allocations.
   */
      char_u *
! v_exception(char_u *oldval)
  {
      if (oldval == NULL)
  	return vimvars[VV_EXCEPTION].vv_str;
***************
*** 21560,21567 ****
   * take care of memory allocations.
   */
      char_u *
! v_throwpoint(oldval)
!     char_u	*oldval;
  {
      if (oldval == NULL)
  	return vimvars[VV_THROWPOINT].vv_str;
--- 20719,20725 ----
   * take care of memory allocations.
   */
      char_u *
! v_throwpoint(char_u *oldval)
  {
      if (oldval == NULL)
  	return vimvars[VV_THROWPOINT].vv_str;
***************
*** 21578,21586 ****
   * Must always be called in pairs!
   */
      char_u *
! set_cmdarg(eap, oldarg)
!     exarg_T	*eap;
!     char_u	*oldarg;
  {
      char_u	*oldval;
      char_u	*newval;
--- 20736,20742 ----
   * Must always be called in pairs!
   */
      char_u *
! set_cmdarg(exarg_T *eap, char_u *oldarg)
  {
      char_u	*oldval;
      char_u	*newval;
***************
*** 21651,21663 ****
   * Return OK or FAIL.
   */
      static int
! get_var_tv(name, len, rettv, dip, verbose, no_autoload)
!     char_u	*name;
!     int		len;		/* length of "name" */
!     typval_T	*rettv;		/* NULL when only checking existence */
!     dictitem_T	**dip;		/* non-NULL when typval's dict item is needed */
!     int		verbose;	/* may give error message */
!     int		no_autoload;	/* do not use script autoloading */
  {
      int		ret = OK;
      typval_T	*tv = NULL;
--- 20807,20819 ----
   * Return OK or FAIL.
   */
      static int
! get_var_tv(
!     char_u	*name,
!     int		len,		/* length of "name" */
!     typval_T	*rettv,		/* NULL when only checking existence */
!     dictitem_T	**dip,		/* non-NULL when typval's dict item is needed */
!     int		verbose,	/* may give error message */
!     int		no_autoload)	/* do not use script autoloading */
  {
      int		ret = OK;
      typval_T	*tv = NULL;
***************
*** 21713,21723 ****
   * Can all be combined: dict.func(expr)[idx]['func'](expr)
   */
      static int
! handle_subscript(arg, rettv, evaluate, verbose)
!     char_u	**arg;
!     typval_T	*rettv;
!     int		evaluate;	/* do more than finding the end */
!     int		verbose;	/* give error messages */
  {
      int		ret = OK;
      dict_T	*selfdict = NULL;
--- 20869,20879 ----
   * Can all be combined: dict.func(expr)[idx]['func'](expr)
   */
      static int
! handle_subscript(
!     char_u	**arg,
!     typval_T	*rettv,
!     int		evaluate,	/* do more than finding the end */
!     int		verbose)	/* give error messages */
  {
      int		ret = OK;
      dict_T	*selfdict = NULL;
***************
*** 21792,21798 ****
   * value).
   */
      static typval_T *
! alloc_tv()
  {
      return (typval_T *)alloc_clear((unsigned)sizeof(typval_T));
  }
--- 20948,20954 ----
   * value).
   */
      static typval_T *
! alloc_tv(void)
  {
      return (typval_T *)alloc_clear((unsigned)sizeof(typval_T));
  }
***************
*** 21803,21810 ****
   * Return NULL for out of memory, the variable otherwise.
   */
      static typval_T *
! alloc_string_tv(s)
!     char_u	*s;
  {
      typval_T	*rettv;
  
--- 20959,20965 ----
   * Return NULL for out of memory, the variable otherwise.
   */
      static typval_T *
! alloc_string_tv(char_u *s)
  {
      typval_T	*rettv;
  
***************
*** 21823,21830 ****
   * Free the memory for a variable type-value.
   */
      void
! free_tv(varp)
!     typval_T *varp;
  {
      if (varp != NULL)
      {
--- 20978,20984 ----
   * Free the memory for a variable type-value.
   */
      void
! free_tv(typval_T *varp)
  {
      if (varp != NULL)
      {
***************
*** 21861,21868 ****
   * Free the memory for a variable value and set the value to NULL or 0.
   */
      void
! clear_tv(varp)
!     typval_T *varp;
  {
      if (varp != NULL)
      {
--- 21015,21021 ----
   * Free the memory for a variable value and set the value to NULL or 0.
   */
      void
! clear_tv(typval_T *varp)
  {
      if (varp != NULL)
      {
***************
*** 21905,21912 ****
   * Set the value of a variable to NULL without freeing items.
   */
      static void
! init_tv(varp)
!     typval_T *varp;
  {
      if (varp != NULL)
  	vim_memset(varp, 0, sizeof(typval_T));
--- 21058,21064 ----
   * Set the value of a variable to NULL without freeing items.
   */
      static void
! init_tv(typval_T *varp)
  {
      if (varp != NULL)
  	vim_memset(varp, 0, sizeof(typval_T));
***************
*** 21921,21928 ****
   * is not NULL or returns -1 otherwise.
   */
      static long
! get_tv_number(varp)
!     typval_T	*varp;
  {
      int		error = FALSE;
  
--- 21073,21079 ----
   * is not NULL or returns -1 otherwise.
   */
      static long
! get_tv_number(typval_T *varp)
  {
      int		error = FALSE;
  
***************
*** 21930,21938 ****
  }
  
      long
! get_tv_number_chk(varp, denote)
!     typval_T	*varp;
!     int		*denote;
  {
      long	n = 0L;
  
--- 21081,21087 ----
  }
  
      long
! get_tv_number_chk(typval_T *varp, int *denote)
  {
      long	n = 0L;
  
***************
*** 21975,21982 ****
  
  #ifdef FEAT_FLOAT
      static float_T
! get_tv_float(varp)
!     typval_T	*varp;
  {
      switch (varp->v_type)
      {
--- 21124,21130 ----
  
  #ifdef FEAT_FLOAT
      static float_T
! get_tv_float(typval_T *varp)
  {
      switch (varp->v_type)
      {
***************
*** 22013,22020 ****
   * Returns -1 on error.
   */
      static linenr_T
! get_tv_lnum(argvars)
!     typval_T	*argvars;
  {
      typval_T	rettv;
      linenr_T	lnum;
--- 21161,21167 ----
   * Returns -1 on error.
   */
      static linenr_T
! get_tv_lnum(typval_T *argvars)
  {
      typval_T	rettv;
      linenr_T	lnum;
***************
*** 22036,22044 ****
   * Returns 0 on error.
   */
      static linenr_T
! get_tv_lnum_buf(argvars, buf)
!     typval_T	*argvars;
!     buf_T	*buf;
  {
      if (argvars[0].v_type == VAR_STRING
  	    && argvars[0].vval.v_string != NULL
--- 21183,21189 ----
   * Returns 0 on error.
   */
      static linenr_T
! get_tv_lnum_buf(typval_T *argvars, buf_T *buf)
  {
      if (argvars[0].v_type == VAR_STRING
  	    && argvars[0].vval.v_string != NULL
***************
*** 22059,22066 ****
   * NULL on error.
   */
      static char_u *
! get_tv_string(varp)
!     typval_T	*varp;
  {
      static char_u   mybuf[NUMBUFLEN];
  
--- 21204,21210 ----
   * NULL on error.
   */
      static char_u *
! get_tv_string(typval_T *varp)
  {
      static char_u   mybuf[NUMBUFLEN];
  
***************
*** 22068,22076 ****
  }
  
      static char_u *
! get_tv_string_buf(varp, buf)
!     typval_T	*varp;
!     char_u	*buf;
  {
      char_u	*res =  get_tv_string_buf_chk(varp, buf);
  
--- 21212,21218 ----
  }
  
      static char_u *
! get_tv_string_buf(typval_T *varp, char_u *buf)
  {
      char_u	*res =  get_tv_string_buf_chk(varp, buf);
  
***************
*** 22081,22088 ****
   * Careful: This uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!
   */
      char_u *
! get_tv_string_chk(varp)
!     typval_T	*varp;
  {
      static char_u   mybuf[NUMBUFLEN];
  
--- 21223,21229 ----
   * Careful: This uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!
   */
      char_u *
! get_tv_string_chk(typval_T *varp)
  {
      static char_u   mybuf[NUMBUFLEN];
  
***************
*** 22090,22098 ****
  }
  
      char_u *
! get_tv_string_buf_chk(varp, buf)
!     typval_T	*varp;
!     char_u	*buf;
  {
      switch (varp->v_type)
      {
--- 21231,21237 ----
  }
  
      char_u *
! get_tv_string_buf_chk(typval_T *varp, char_u *buf)
  {
      switch (varp->v_type)
      {
***************
*** 22136,22145 ****
   * hashtab_T used.
   */
      static dictitem_T *
! find_var(name, htp, no_autoload)
!     char_u	*name;
!     hashtab_T	**htp;
!     int		no_autoload;
  {
      char_u	*varname;
      hashtab_T	*ht;
--- 21275,21281 ----
   * hashtab_T used.
   */
      static dictitem_T *
! find_var(char_u *name, hashtab_T **htp, int no_autoload)
  {
      char_u	*varname;
      hashtab_T	*ht;
***************
*** 22157,22167 ****
   * Returns NULL if not found.
   */
      static dictitem_T *
! find_var_in_ht(ht, htname, varname, no_autoload)
!     hashtab_T	*ht;
!     int		htname;
!     char_u	*varname;
!     int		no_autoload;
  {
      hashitem_T	*hi;
  
--- 21293,21303 ----
   * Returns NULL if not found.
   */
      static dictitem_T *
! find_var_in_ht(
!     hashtab_T	*ht,
!     int		htname,
!     char_u	*varname,
!     int		no_autoload)
  {
      hashitem_T	*hi;
  
***************
*** 22213,22221 ****
   * Set "varname" to the start of name without ':'.
   */
      static hashtab_T *
! find_var_ht(name, varname)
!     char_u  *name;
!     char_u  **varname;
  {
      hashitem_T	*hi;
  
--- 21349,21355 ----
   * Set "varname" to the start of name without ':'.
   */
      static hashtab_T *
! find_var_ht(char_u *name, char_u **varname)
  {
      hashitem_T	*hi;
  
***************
*** 22269,22275 ****
   * Get function call environment based on bactrace debug level
   */
      static funccall_T *
! get_funccal()
  {
      int		i;
      funccall_T	*funccal;
--- 21403,21409 ----
   * Get function call environment based on bactrace debug level
   */
      static funccall_T *
! get_funccal(void)
  {
      int		i;
      funccall_T	*funccal;
***************
*** 22297,22304 ****
   * Returns NULL when it doesn't exist.
   */
      char_u *
! get_var_value(name)
!     char_u	*name;
  {
      dictitem_T	*v;
  
--- 21431,21437 ----
   * Returns NULL when it doesn't exist.
   */
      char_u *
! get_var_value(char_u *name)
  {
      dictitem_T	*v;
  
***************
*** 22313,22320 ****
   * sourcing this script and when executing functions defined in the script.
   */
      void
! new_script_vars(id)
!     scid_T id;
  {
      int		i;
      hashtab_T	*ht;
--- 21446,21452 ----
   * sourcing this script and when executing functions defined in the script.
   */
      void
! new_script_vars(scid_T id)
  {
      int		i;
      hashtab_T	*ht;
***************
*** 22349,22358 ****
   * point to it.
   */
      void
! init_var_dict(dict, dict_var, scope)
!     dict_T	*dict;
!     dictitem_T	*dict_var;
!     int		scope;
  {
      hash_init(&dict->dv_hashtab);
      dict->dv_lock = 0;
--- 21481,21487 ----
   * point to it.
   */
      void
! init_var_dict(dict_T *dict, dictitem_T *dict_var, int scope)
  {
      hash_init(&dict->dv_hashtab);
      dict->dv_lock = 0;
***************
*** 22370,22377 ****
   * Unreference a dictionary initialized by init_var_dict().
   */
      void
! unref_var_dict(dict)
!     dict_T	*dict;
  {
      /* Now the dict needs to be freed if no one else is using it, go back to
       * normal reference counting. */
--- 21499,21505 ----
   * Unreference a dictionary initialized by init_var_dict().
   */
      void
! unref_var_dict(dict_T *dict)
  {
      /* Now the dict needs to be freed if no one else is using it, go back to
       * normal reference counting. */
***************
*** 22385,22392 ****
   * Clears hashtab "ht", does not free it.
   */
      void
! vars_clear(ht)
!     hashtab_T *ht;
  {
      vars_clear_ext(ht, TRUE);
  }
--- 21513,21519 ----
   * Clears hashtab "ht", does not free it.
   */
      void
! vars_clear(hashtab_T *ht)
  {
      vars_clear_ext(ht, TRUE);
  }
***************
*** 22395,22403 ****
   * Like vars_clear(), but only free the value if "free_val" is TRUE.
   */
      static void
! vars_clear_ext(ht, free_val)
!     hashtab_T	*ht;
!     int		free_val;
  {
      int		todo;
      hashitem_T	*hi;
--- 21522,21528 ----
   * Like vars_clear(), but only free the value if "free_val" is TRUE.
   */
      static void
! vars_clear_ext(hashtab_T *ht, int free_val)
  {
      int		todo;
      hashitem_T	*hi;
***************
*** 22430,22438 ****
   * Clear the variable value and free the dictitem.
   */
      static void
! delete_var(ht, hi)
!     hashtab_T	*ht;
!     hashitem_T	*hi;
  {
      dictitem_T	*di = HI2DI(hi);
  
--- 21555,21561 ----
   * Clear the variable value and free the dictitem.
   */
      static void
! delete_var(hashtab_T *ht, hashitem_T *hi)
  {
      dictitem_T	*di = HI2DI(hi);
  
***************
*** 22445,22454 ****
   * List the value of one internal variable.
   */
      static void
! list_one_var(v, prefix, first)
!     dictitem_T	*v;
!     char_u	*prefix;
!     int		*first;
  {
      char_u	*tofree;
      char_u	*s;
--- 21568,21574 ----
   * List the value of one internal variable.
   */
      static void
! list_one_var(dictitem_T *v, char_u *prefix, int *first)
  {
      char_u	*tofree;
      char_u	*s;
***************
*** 22461,22472 ****
  }
  
      static void
! list_one_var_a(prefix, name, type, string, first)
!     char_u	*prefix;
!     char_u	*name;
!     int		type;
!     char_u	*string;
!     int		*first;  /* when TRUE clear rest of screen and set to FALSE */
  {
      /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
      msg_start();
--- 21581,21592 ----
  }
  
      static void
! list_one_var_a(
!     char_u	*prefix,
!     char_u	*name,
!     int		type,
!     char_u	*string,
!     int		*first)  /* when TRUE clear rest of screen and set to FALSE */
  {
      /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
      msg_start();
***************
*** 22511,22520 ****
   * Otherwise the variable is created.
   */
      static void
! set_var(name, tv, copy)
!     char_u	*name;
!     typval_T	*tv;
!     int		copy;	    /* make copy of value in "tv" */
  {
      dictitem_T	*v;
      char_u	*varname;
--- 21631,21640 ----
   * Otherwise the variable is created.
   */
      static void
! set_var(
!     char_u	*name,
!     typval_T	*tv,
!     int		copy)	    /* make copy of value in "tv" */
  {
      dictitem_T	*v;
      char_u	*varname;
***************
*** 22634,22643 ****
   * Also give an error message.
   */
      static int
! var_check_ro(flags, name, use_gettext)
!     int		flags;
!     char_u	*name;
!     int		use_gettext;
  {
      if (flags & DI_FLAGS_RO)
      {
--- 21754,21760 ----
   * Also give an error message.
   */
      static int
! var_check_ro(int flags, char_u *name, int use_gettext)
  {
      if (flags & DI_FLAGS_RO)
      {
***************
*** 22657,22666 ****
   * Also give an error message.
   */
      static int
! var_check_fixed(flags, name, use_gettext)
!     int		flags;
!     char_u	*name;
!     int		use_gettext;
  {
      if (flags & DI_FLAGS_FIX)
      {
--- 21774,21780 ----
   * Also give an error message.
   */
      static int
! var_check_fixed(int flags, char_u *name, int use_gettext)
  {
      if (flags & DI_FLAGS_FIX)
      {
***************
*** 22676,22684 ****
   * Return TRUE and give an error if not.
   */
      static int
! var_check_func_name(name, new_var)
!     char_u *name;    /* points to start of variable name */
!     int    new_var;  /* TRUE when creating the variable */
  {
      /* Allow for w: b: s: and t:. */
      if (!(vim_strchr((char_u *)"wbst", name[0]) != NULL && name[1] == ':')
--- 21790,21798 ----
   * Return TRUE and give an error if not.
   */
      static int
! var_check_func_name(
!     char_u *name,    /* points to start of variable name */
!     int    new_var)  /* TRUE when creating the variable */
  {
      /* Allow for w: b: s: and t:. */
      if (!(vim_strchr((char_u *)"wbst", name[0]) != NULL && name[1] == ':')
***************
*** 22706,22713 ****
   * Return FALSE and give an error if not.
   */
      static int
! valid_varname(varname)
!     char_u *varname;
  {
      char_u *p;
  
--- 21820,21826 ----
   * Return FALSE and give an error if not.
   */
      static int
! valid_varname(char_u *varname)
  {
      char_u *p;
  
***************
*** 22727,22736 ****
   * TRUE.
   */
      static int
! tv_check_lock(lock, name, use_gettext)
!     int		lock;
!     char_u	*name;
!     int		use_gettext;
  {
      if (lock & VAR_LOCKED)
      {
--- 21840,21846 ----
   * TRUE.
   */
      static int
! tv_check_lock(int lock, char_u *name, int use_gettext)
  {
      if (lock & VAR_LOCKED)
      {
***************
*** 22759,22767 ****
   * make a copy later.
   */
      void
! copy_tv(from, to)
!     typval_T *from;
!     typval_T *to;
  {
      to->v_type = from->v_type;
      to->v_lock = 0;
--- 21869,21875 ----
   * make a copy later.
   */
      void
! copy_tv(typval_T *from, typval_T *to)
  {
      to->v_type = from->v_type;
      to->v_lock = 0;
***************
*** 22819,22829 ****
   * Returns FAIL or OK.
   */
      static int
! item_copy(from, to, deep, copyID)
!     typval_T	*from;
!     typval_T	*to;
!     int		deep;
!     int		copyID;
  {
      static int	recurse = 0;
      int		ret = OK;
--- 21927,21937 ----
   * Returns FAIL or OK.
   */
      static int
! item_copy(
!     typval_T	*from,
!     typval_T	*to,
!     int		deep,
!     int		copyID)
  {
      static int	recurse = 0;
      int		ret = OK;
***************
*** 22891,22898 ****
   * ":echon expr1 ..."	print each argument plain.
   */
      void
! ex_echo(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      typval_T	rettv;
--- 21999,22005 ----
   * ":echon expr1 ..."	print each argument plain.
   */
      void
! ex_echo(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      typval_T	rettv;
***************
*** 22995,23002 ****
   * ":echohl {name}".
   */
      void
! ex_echohl(eap)
!     exarg_T	*eap;
  {
      int		id;
  
--- 22102,22108 ----
   * ":echohl {name}".
   */
      void
! ex_echohl(exarg_T *eap)
  {
      int		id;
  
***************
*** 23015,23022 ****
   * echo commands
   */
      void
! ex_execute(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      typval_T	rettv;
--- 22121,22127 ----
   * echo commands
   */
      void
! ex_execute(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      typval_T	rettv;
***************
*** 23101,23109 ****
   * after the option name.
   */
      static char_u *
! find_option_end(arg, opt_flags)
!     char_u	**arg;
!     int		*opt_flags;
  {
      char_u	*p = *arg;
  
--- 22206,22212 ----
   * after the option name.
   */
      static char_u *
! find_option_end(char_u **arg, int *opt_flags)
  {
      char_u	*p = *arg;
  
***************
*** 23137,23144 ****
   * ":function"
   */
      void
! ex_function(eap)
!     exarg_T	*eap;
  {
      char_u	*theline;
      int		i;
--- 22240,22246 ----
   * ":function"
   */
      void
! ex_function(exarg_T *eap)
  {
      char_u	*theline;
      int		i;
***************
*** 23811,23821 ****
   * Advances "pp" to just after the function name (if no error).
   */
      static char_u *
! trans_function_name(pp, skip, flags, fdp)
!     char_u	**pp;
!     int		skip;		/* only find the end, don't evaluate */
!     int		flags;
!     funcdict_T	*fdp;		/* return: info about dictionary used */
  {
      char_u	*name = NULL;
      char_u	*start;
--- 22913,22923 ----
   * Advances "pp" to just after the function name (if no error).
   */
      static char_u *
! trans_function_name(
!     char_u	**pp,
!     int		skip,		/* only find the end, don't evaluate */
!     int		flags,
!     funcdict_T	*fdp)		/* return: info about dictionary used */
  {
      char_u	*name = NULL;
      char_u	*start;
***************
*** 24022,24029 ****
   * Return 0 otherwise.
   */
      static int
! eval_fname_script(p)
!     char_u	*p;
  {
      /* Use MB_STRICMP() because in Turkish comparing the "I" may not work with
       * the standard library function. */
--- 23124,23130 ----
   * Return 0 otherwise.
   */
      static int
! eval_fname_script(char_u *p)
  {
      /* Use MB_STRICMP() because in Turkish comparing the "I" may not work with
       * the standard library function. */
***************
*** 24040,24047 ****
   * Only works if eval_fname_script() returned non-zero for "p"!
   */
      static int
! eval_fname_sid(p)
!     char_u	*p;
  {
      return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');
  }
--- 23141,23147 ----
   * Only works if eval_fname_script() returned non-zero for "p"!
   */
      static int
! eval_fname_sid(char_u *p)
  {
      return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');
  }
***************
*** 24050,24058 ****
   * List the head of the function: "name(arg1, arg2)".
   */
      static void
! list_func_head(fp, indent)
!     ufunc_T	*fp;
!     int		indent;
  {
      int		j;
  
--- 23150,23156 ----
   * List the head of the function: "name(arg1, arg2)".
   */
      static void
! list_func_head(ufunc_T *fp, int indent)
  {
      int		j;
  
***************
*** 24097,24104 ****
   * Return NULL for unknown function.
   */
      static ufunc_T *
! find_func(name)
!     char_u	*name;
  {
      hashitem_T	*hi;
  
--- 23195,23201 ----
   * Return NULL for unknown function.
   */
      static ufunc_T *
! find_func(char_u *name)
  {
      hashitem_T	*hi;
  
***************
*** 24110,24116 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_all_functions()
  {
      hashitem_T	*hi;
  
--- 23207,23213 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_all_functions(void)
  {
      hashitem_T	*hi;
  
***************
*** 24127,24134 ****
  #endif
  
      int
! translated_function_exists(name)
!     char_u	*name;
  {
      if (builtin_function(name, -1))
  	return find_internal_func(name) >= 0;
--- 23224,23230 ----
  #endif
  
      int
! translated_function_exists(char_u *name)
  {
      if (builtin_function(name, -1))
  	return find_internal_func(name) >= 0;
***************
*** 24139,24146 ****
   * Return TRUE if a function "name" exists.
   */
      static int
! function_exists(name)
!     char_u *name;
  {
      char_u  *nm = name;
      char_u  *p;
--- 23235,23241 ----
   * Return TRUE if a function "name" exists.
   */
      static int
! function_exists(char_u *name)
  {
      char_u  *nm = name;
      char_u  *p;
***************
*** 24159,24167 ****
  }
  
      char_u *
! get_expanded_name(name, check)
!     char_u	*name;
!     int		check;
  {
      char_u	*nm = name;
      char_u	*p;
--- 23254,23260 ----
  }
  
      char_u *
! get_expanded_name(char_u *name, int check)
  {
      char_u	*nm = name;
      char_u	*p;
***************
*** 24182,24190 ****
   * "len" is the length of "name", or -1 for NUL terminated.
   */
      static int
! builtin_function(name, len)
!     char_u *name;
!     int len;
  {
      char_u *p;
  
--- 23275,23281 ----
   * "len" is the length of "name", or -1 for NUL terminated.
   */
      static int
! builtin_function(char_u *name, int len)
  {
      char_u *p;
  
***************
*** 24199,24206 ****
   * Start profiling function "fp".
   */
      static void
! func_do_profile(fp)
!     ufunc_T	*fp;
  {
      int		len = fp->uf_lines.ga_len;
  
--- 23290,23296 ----
   * Start profiling function "fp".
   */
      static void
! func_do_profile(ufunc_T *fp)
  {
      int		len = fp->uf_lines.ga_len;
  
***************
*** 24229,24236 ****
   * Dump the profiling results for all functions in file "fd".
   */
      void
! func_dump_profile(fd)
!     FILE    *fd;
  {
      hashitem_T	*hi;
      int		todo;
--- 23319,23325 ----
   * Dump the profiling results for all functions in file "fd".
   */
      void
! func_dump_profile(FILE *fd)
  {
      hashitem_T	*hi;
      int		todo;
***************
*** 24296,24307 ****
  }
  
      static void
! prof_sort_list(fd, sorttab, st_len, title, prefer_self)
!     FILE	*fd;
!     ufunc_T	**sorttab;
!     int		st_len;
!     char	*title;
!     int		prefer_self;	/* when equal print only self time */
  {
      int		i;
      ufunc_T	*fp;
--- 23385,23396 ----
  }
  
      static void
! prof_sort_list(
!     FILE	*fd,
!     ufunc_T	**sorttab,
!     int		st_len,
!     char	*title,
!     int		prefer_self)	/* when equal print only self time */
  {
      int		i;
      ufunc_T	*fp;
***************
*** 24325,24336 ****
   * Print the count and times for one function or function line.
   */
      static void
! prof_func_line(fd, count, total, self, prefer_self)
!     FILE	*fd;
!     int		count;
!     proftime_T	*total;
!     proftime_T	*self;
!     int		prefer_self;	/* when equal print only self time */
  {
      if (count > 0)
      {
--- 23414,23425 ----
   * Print the count and times for one function or function line.
   */
      static void
! prof_func_line(
!     FILE	*fd,
!     int		count,
!     proftime_T	*total,
!     proftime_T	*self,
!     int		prefer_self)	/* when equal print only self time */
  {
      if (count > 0)
      {
***************
*** 24355,24363 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! prof_total_cmp(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      ufunc_T	*p1, *p2;
  
--- 23444,23450 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! prof_total_cmp(const void *s1, const void *s2)
  {
      ufunc_T	*p1, *p2;
  
***************
*** 24373,24381 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! prof_self_cmp(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      ufunc_T	*p1, *p2;
  
--- 23460,23466 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! prof_self_cmp(const void *s1, const void *s2)
  {
      ufunc_T	*p1, *p2;
  
***************
*** 24391,24399 ****
   * Return TRUE if a package was loaded.
   */
      static int
! script_autoload(name, reload)
!     char_u	*name;
!     int		reload;	    /* load script again when already loaded */
  {
      char_u	*p;
      char_u	*scriptname, *tofree;
--- 23476,23484 ----
   * Return TRUE if a package was loaded.
   */
      static int
! script_autoload(
!     char_u	*name,
!     int		reload)	    /* load script again when already loaded */
  {
      char_u	*p;
      char_u	*scriptname, *tofree;
***************
*** 24437,24444 ****
   * Returns NULL when out of memory.
   */
      static char_u *
! autoload_name(name)
!     char_u	*name;
  {
      char_u	*p;
      char_u	*scriptname;
--- 23522,23528 ----
   * Returns NULL when out of memory.
   */
      static char_u *
! autoload_name(char_u *name)
  {
      char_u	*p;
      char_u	*scriptname;
***************
*** 24463,24471 ****
   * function names.
   */
      char_u *
! get_user_func_name(xp, idx)
!     expand_T	*xp;
!     int		idx;
  {
      static long_u	done;
      static hashitem_T	*hi;
--- 23547,23553 ----
   * function names.
   */
      char_u *
! get_user_func_name(expand_T *xp, int idx)
  {
      static long_u	done;
      static hashitem_T	*hi;
***************
*** 24510,24518 ****
   * Takes care of script-local function names.
   */
      static void
! cat_func_name(buf, fp)
!     char_u	*buf;
!     ufunc_T	*fp;
  {
      if (fp->uf_name[0] == K_SPECIAL)
      {
--- 23592,23598 ----
   * Takes care of script-local function names.
   */
      static void
! cat_func_name(char_u *buf, ufunc_T *fp)
  {
      if (fp->uf_name[0] == K_SPECIAL)
      {
***************
*** 24527,24534 ****
   * ":delfunction {name}"
   */
      void
! ex_delfunction(eap)
!     exarg_T	*eap;
  {
      ufunc_T	*fp = NULL;
      char_u	*p;
--- 23607,23613 ----
   * ":delfunction {name}"
   */
      void
! ex_delfunction(exarg_T *eap)
  {
      ufunc_T	*fp = NULL;
      char_u	*p;
***************
*** 24586,24593 ****
   * Free a function and remove it from the list of functions.
   */
      static void
! func_free(fp)
!     ufunc_T *fp;
  {
      hashitem_T	*hi;
  
--- 23665,23671 ----
   * Free a function and remove it from the list of functions.
   */
      static void
! func_free(ufunc_T *fp)
  {
      hashitem_T	*hi;
  
***************
*** 24615,24622 ****
   * becomes zero.  Only for numbered functions.
   */
      void
! func_unref(name)
!     char_u	*name;
  {
      ufunc_T *fp;
  
--- 23693,23699 ----
   * becomes zero.  Only for numbered functions.
   */
      void
! func_unref(char_u *name)
  {
      ufunc_T *fp;
  
***************
*** 24639,24646 ****
   * Count a reference to a Function.
   */
      void
! func_ref(name)
!     char_u	*name;
  {
      ufunc_T *fp;
  
--- 23716,23722 ----
   * Count a reference to a Function.
   */
      void
! func_ref(char_u *name)
  {
      ufunc_T *fp;
  
***************
*** 24658,24671 ****
   * Call a user function.
   */
      static void
! call_user_func(fp, argcount, argvars, rettv, firstline, lastline, selfdict)
!     ufunc_T	*fp;		/* pointer to function */
!     int		argcount;	/* nr of args */
!     typval_T	*argvars;	/* arguments */
!     typval_T	*rettv;		/* return value */
!     linenr_T	firstline;	/* first line of range */
!     linenr_T	lastline;	/* last line of range */
!     dict_T	*selfdict;	/* Dictionary for "self" */
  {
      char_u	*save_sourcing_name;
      linenr_T	save_sourcing_lnum;
--- 23734,23747 ----
   * Call a user function.
   */
      static void
! call_user_func(
!     ufunc_T	*fp,		/* pointer to function */
!     int		argcount,	/* nr of args */
!     typval_T	*argvars,	/* arguments */
!     typval_T	*rettv,		/* return value */
!     linenr_T	firstline,	/* first line of range */
!     linenr_T	lastline,	/* last line of range */
!     dict_T	*selfdict)	/* Dictionary for "self" */
  {
      char_u	*save_sourcing_name;
      linenr_T	save_sourcing_lnum;
***************
*** 25031,25039 ****
   * referenced from anywhere that is in use.
   */
      static int
! can_free_funccal(fc, copyID)
!     funccall_T	*fc;
!     int		copyID;
  {
      return (fc->l_varlist.lv_copyID != copyID
  	    && fc->l_vars.dv_copyID != copyID
--- 24107,24113 ----
   * referenced from anywhere that is in use.
   */
      static int
! can_free_funccal(funccall_T *fc, int copyID)
  {
      return (fc->l_varlist.lv_copyID != copyID
  	    && fc->l_vars.dv_copyID != copyID
***************
*** 25044,25052 ****
   * Free "fc" and what it contains.
   */
     static void
! free_funccal(fc, free_val)
!     funccall_T	*fc;
!     int		free_val;  /* a: vars were allocated */
  {
      listitem_T	*li;
  
--- 24118,24126 ----
   * Free "fc" and what it contains.
   */
     static void
! free_funccal(
!     funccall_T	*fc,
!     int		free_val)  /* a: vars were allocated */
  {
      listitem_T	*li;
  
***************
*** 25069,25079 ****
   * Add a number variable "name" to dict "dp" with value "nr".
   */
      static void
! add_nr_var(dp, v, name, nr)
!     dict_T	*dp;
!     dictitem_T	*v;
!     char	*name;
!     varnumber_T nr;
  {
      STRCPY(v->di_key, name);
      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
--- 24143,24153 ----
   * Add a number variable "name" to dict "dp" with value "nr".
   */
      static void
! add_nr_var(
!     dict_T	*dp,
!     dictitem_T	*v,
!     char	*name,
!     varnumber_T nr)
  {
      STRCPY(v->di_key, name);
      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
***************
*** 25087,25094 ****
   * ":return [expr]"
   */
      void
! ex_return(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      typval_T	rettv;
--- 24161,24167 ----
   * ":return [expr]"
   */
      void
! ex_return(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      typval_T	rettv;
***************
*** 25144,25154 ****
   * FALSE when the return gets pending.
   */
      int
! do_return(eap, reanimate, is_cmd, rettv)
!     exarg_T	*eap;
!     int		reanimate;
!     int		is_cmd;
!     void	*rettv;
  {
      int		idx;
      struct condstack *cstack = eap->cstack;
--- 24217,24227 ----
   * FALSE when the return gets pending.
   */
      int
! do_return(
!     exarg_T	*eap,
!     int		reanimate,
!     int		is_cmd,
!     void	*rettv)
  {
      int		idx;
      struct condstack *cstack = eap->cstack;
***************
*** 25225,25232 ****
   * Free the variable with a pending return value.
   */
      void
! discard_pending_return(rettv)
!     void	*rettv;
  {
      free_tv((typval_T *)rettv);
  }
--- 24298,24304 ----
   * Free the variable with a pending return value.
   */
      void
! discard_pending_return(void *rettv)
  {
      free_tv((typval_T *)rettv);
  }
***************
*** 25236,25243 ****
   * is an allocated string.  Used by report_pending() for verbose messages.
   */
      char_u *
! get_return_cmd(rettv)
!     void	*rettv;
  {
      char_u	*s = NULL;
      char_u	*tofree = NULL;
--- 24308,24314 ----
   * is an allocated string.  Used by report_pending() for verbose messages.
   */
      char_u *
! get_return_cmd(void *rettv)
  {
      char_u	*s = NULL;
      char_u	*tofree = NULL;
***************
*** 25262,25271 ****
   * Returns allocated string, or NULL for end of function.
   */
      char_u *
! get_func_line(c, cookie, indent)
!     int	    c UNUSED;
!     void    *cookie;
!     int	    indent UNUSED;
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
--- 24333,24342 ----
   * Returns allocated string, or NULL for end of function.
   */
      char_u *
! get_func_line(
!     int	    c UNUSED,
!     void    *cookie,
!     int	    indent UNUSED)
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
***************
*** 25328,25335 ****
   * until later and we need to store the time now.
   */
      void
! func_line_start(cookie)
!     void    *cookie;
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
--- 24399,24405 ----
   * until later and we need to store the time now.
   */
      void
! func_line_start(void *cookie)
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
***************
*** 25352,25359 ****
   * Called when actually executing a function line.
   */
      void
! func_line_exec(cookie)
!     void    *cookie;
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
--- 24422,24428 ----
   * Called when actually executing a function line.
   */
      void
! func_line_exec(void *cookie)
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
***************
*** 25366,25373 ****
   * Called when done with a function line.
   */
      void
! func_line_end(cookie)
!     void    *cookie;
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
--- 24435,24441 ----
   * Called when done with a function line.
   */
      void
! func_line_end(void *cookie)
  {
      funccall_T	*fcp = (funccall_T *)cookie;
      ufunc_T	*fp = fcp->func;
***************
*** 25393,25400 ****
   * return was encountered or an error occurred.  Used inside a ":while".
   */
      int
! func_has_ended(cookie)
!     void    *cookie;
  {
      funccall_T  *fcp = (funccall_T *)cookie;
  
--- 24461,24467 ----
   * return was encountered or an error occurred.  Used inside a ":while".
   */
      int
! func_has_ended(void *cookie)
  {
      funccall_T  *fcp = (funccall_T *)cookie;
  
***************
*** 25408,25415 ****
   * return TRUE if cookie indicates a function which "abort"s on errors.
   */
      int
! func_has_abort(cookie)
!     void    *cookie;
  {
      return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;
  }
--- 24475,24482 ----
   * return TRUE if cookie indicates a function which "abort"s on errors.
   */
      int
! func_has_abort(
!     void    *cookie)
  {
      return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;
  }
***************
*** 25425,25432 ****
  static var_flavour_T var_flavour(char_u *varname);
  
      static var_flavour_T
! var_flavour(varname)
!     char_u *varname;
  {
      char_u *p = varname;
  
--- 24492,24498 ----
  static var_flavour_T var_flavour(char_u *varname);
  
      static var_flavour_T
! var_flavour(char_u *varname)
  {
      char_u *p = varname;
  
***************
*** 25447,25455 ****
   * Restore global vars that start with a capital from the viminfo file
   */
      int
! read_viminfo_varlist(virp, writing)
!     vir_T	*virp;
!     int		writing;
  {
      char_u	*tab;
      int		type = VAR_NUMBER;
--- 24513,24519 ----
   * Restore global vars that start with a capital from the viminfo file
   */
      int
! read_viminfo_varlist(vir_T *virp, int writing)
  {
      char_u	*tab;
      int		type = VAR_NUMBER;
***************
*** 25522,25529 ****
   * Write global vars that start with a capital to the viminfo file
   */
      void
! write_viminfo_varlist(fp)
!     FILE    *fp;
  {
      hashitem_T	*hi;
      dictitem_T	*this_var;
--- 24586,24592 ----
   * Write global vars that start with a capital to the viminfo file
   */
      void
! write_viminfo_varlist(FILE *fp)
  {
      hashitem_T	*hi;
      dictitem_T	*this_var;
***************
*** 25571,25578 ****
  
  #if defined(FEAT_SESSION) || defined(PROTO)
      int
! store_session_globals(fd)
!     FILE	*fd;
  {
      hashitem_T	*hi;
      dictitem_T	*this_var;
--- 24634,24640 ----
  
  #if defined(FEAT_SESSION) || defined(PROTO)
      int
! store_session_globals(FILE *fd)
  {
      hashitem_T	*hi;
      dictitem_T	*this_var;
***************
*** 25644,25651 ****
   * Should only be invoked when 'verbose' is non-zero.
   */
      void
! last_set_msg(scriptID)
!     scid_T scriptID;
  {
      char_u *p;
  
--- 24706,24712 ----
   * Should only be invoked when 'verbose' is non-zero.
   */
      void
! last_set_msg(scid_T scriptID)
  {
      char_u *p;
  
***************
*** 25667,25674 ****
   * List v:oldfiles in a nice way.
   */
      void
! ex_oldfiles(eap)
!     exarg_T	*eap UNUSED;
  {
      list_T	*l = vimvars[VV_OLDFILES].vv_list;
      listitem_T	*li;
--- 24728,24734 ----
   * List v:oldfiles in a nice way.
   */
      void
! ex_oldfiles(exarg_T *eap UNUSED)
  {
      list_T	*l = vimvars[VV_OLDFILES].vv_list;
      listitem_T	*li;
***************
*** 25720,25726 ****
  
  /* reset v:option_new, v:option_old and v:option_type */
      void
! reset_v_option_vars()
  {
      set_vim_var_string(VV_OPTION_NEW,  NULL, -1);
      set_vim_var_string(VV_OPTION_OLD,  NULL, -1);
--- 24780,24786 ----
  
  /* reset v:option_new, v:option_old and v:option_type */
      void
! reset_v_option_vars(void)
  {
      set_vim_var_string(VV_OPTION_NEW,  NULL, -1);
      set_vim_var_string(VV_OPTION_OLD,  NULL, -1);
***************
*** 25750,25759 ****
   * Returns OK on success, FAIL on failure.
   */
      static int
! get_short_pathname(fnamep, bufp, fnamelen)
!     char_u	**fnamep;
!     char_u	**bufp;
!     int		*fnamelen;
  {
      int		l, len;
      char_u	*newbuf;
--- 24810,24816 ----
   * Returns OK on success, FAIL on failure.
   */
      static int
! get_short_pathname(char_u **fnamep, char_u **bufp, int *fnamelen)
  {
      int		l, len;
      char_u	*newbuf;
***************
*** 25795,25804 ****
   * Returns OK on success (or nothing done) and FAIL on failure (out of memory).
   */
      static int
! shortpath_for_invalid_fname(fname, bufp, fnamelen)
!     char_u	**fname;
!     char_u	**bufp;
!     int		*fnamelen;
  {
      char_u	*short_fname, *save_fname, *pbuf_unused;
      char_u	*endp, *save_endp;
--- 24852,24861 ----
   * Returns OK on success (or nothing done) and FAIL on failure (out of memory).
   */
      static int
! shortpath_for_invalid_fname(
!     char_u	**fname,
!     char_u	**bufp,
!     int		*fnamelen)
  {
      char_u	*short_fname, *save_fname, *pbuf_unused;
      char_u	*endp, *save_endp;
***************
*** 25902,25911 ****
   * Returns OK for success, FAIL for failure.
   */
      static int
! shortpath_for_partial(fnamep, bufp, fnamelen)
!     char_u	**fnamep;
!     char_u	**bufp;
!     int		*fnamelen;
  {
      int		sepcount, len, tflen;
      char_u	*p;
--- 24959,24968 ----
   * Returns OK for success, FAIL for failure.
   */
      static int
! shortpath_for_partial(
!     char_u	**fnamep,
!     char_u	**bufp,
!     int		*fnamelen)
  {
      int		sepcount, len, tflen;
      char_u	*p;
***************
*** 25986,25997 ****
   * When there is an error, *fnamep is set to NULL.
   */
      int
! modify_fname(src, usedlen, fnamep, bufp, fnamelen)
!     char_u	*src;		/* string with modifiers */
!     int		*usedlen;	/* characters after src that are used */
!     char_u	**fnamep;	/* file name so far */
!     char_u	**bufp;		/* buffer for allocated file name or NULL */
!     int		*fnamelen;	/* length of fnamep */
  {
      int		valid = 0;
      char_u	*tail;
--- 25043,25054 ----
   * When there is an error, *fnamep is set to NULL.
   */
      int
! modify_fname(
!     char_u	*src,		/* string with modifiers */
!     int		*usedlen,	/* characters after src that are used */
!     char_u	**fnamep,	/* file name so far */
!     char_u	**bufp,		/* buffer for allocated file name or NULL */
!     int		*fnamelen)	/* length of fnamep */
  {
      int		valid = 0;
      char_u	*tail;
***************
*** 26375,26385 ****
   * Returns an allocated string, NULL for error.
   */
      char_u *
! do_string_sub(str, pat, sub, flags)
!     char_u	*str;
!     char_u	*pat;
!     char_u	*sub;
!     char_u	*flags;
  {
      int		sublen;
      regmatch_T	regmatch;
--- 25432,25442 ----
   * Returns an allocated string, NULL for error.
   */
      char_u *
! do_string_sub(
!     char_u	*str,
!     char_u	*pat,
!     char_u	*sub,
!     char_u	*flags)
  {
      int		sublen;
      regmatch_T	regmatch;
*** ../vim-7.4.1204/src/version.c	2016-01-30 13:53:30.189407662 +0100
--- src/version.c	2016-01-30 13:59:50.941472310 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1205,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
90. Instead of calling you to dinner, your spouse sends e-mail.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
