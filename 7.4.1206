To: vim_dev@googlegroups.com
Subject: Patch 7.4.1206
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1206
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/ex_cmds.c, src/ex_cmds2.c, src/ex_docmd.c, src/ex_eval.c,
            src/ex_getln.c, src/farsi.c, src/fileio.c


*** ../vim-7.4.1205/src/ex_cmds.c	2016-01-29 22:03:43.481945824 +0100
--- src/ex_cmds.c	2016-01-30 15:20:00.467753235 +0100
***************
*** 44,51 ****
   * ":ascii" and "ga".
   */
      void
! do_ascii(eap)
!     exarg_T	*eap UNUSED;
  {
      int		c;
      int		cval;
--- 44,50 ----
   * ":ascii" and "ga".
   */
      void
! do_ascii(exarg_T *eap UNUSED)
  {
      int		c;
      int		cval;
***************
*** 144,151 ****
   * ":left", ":center" and ":right": align text.
   */
      void
! ex_align(eap)
!     exarg_T	*eap;
  {
      pos_T	save_curpos;
      int		len;
--- 143,149 ----
   * ":left", ":center" and ":right": align text.
   */
      void
! ex_align(exarg_T *eap)
  {
      pos_T	save_curpos;
      int		len;
***************
*** 247,254 ****
   * Get the length of the current line, excluding trailing white space.
   */
      static int
! linelen(has_tab)
!     int	    *has_tab;
  {
      char_u  *line;
      char_u  *first;
--- 245,251 ----
   * Get the length of the current line, excluding trailing white space.
   */
      static int
! linelen(int *has_tab)
  {
      char_u  *line;
      char_u  *first;
***************
*** 315,323 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      sorti_T	l1 = *(sorti_T *)s1;
      sorti_T	l2 = *(sorti_T *)s2;
--- 312,318 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_compare(const void *s1, const void *s2)
  {
      sorti_T	l1 = *(sorti_T *)s1;
      sorti_T	l2 = *(sorti_T *)s2;
***************
*** 368,375 ****
   * ":sort".
   */
      void
! ex_sort(eap)
!     exarg_T	*eap;
  {
      regmatch_T	regmatch;
      int		len;
--- 363,369 ----
   * ":sort".
   */
      void
! ex_sort(exarg_T *eap)
  {
      regmatch_T	regmatch;
      int		len;
***************
*** 648,655 ****
   * ":retab".
   */
      void
! ex_retab(eap)
!     exarg_T	*eap;
  {
      linenr_T	lnum;
      int		got_tab = FALSE;
--- 642,648 ----
   * ":retab".
   */
      void
! ex_retab(exarg_T *eap)
  {
      linenr_T	lnum;
      int		got_tab = FALSE;
***************
*** 798,807 ****
   * return FAIL for failure, OK otherwise
   */
      int
! do_move(line1, line2, dest)
!     linenr_T	line1;
!     linenr_T	line2;
!     linenr_T	dest;
  {
      char_u	*str;
      linenr_T	l;
--- 791,797 ----
   * return FAIL for failure, OK otherwise
   */
      int
! do_move(linenr_T line1, linenr_T line2, linenr_T dest)
  {
      char_u	*str;
      linenr_T	l;
***************
*** 929,938 ****
   * ":copy"
   */
      void
! ex_copy(line1, line2, n)
!     linenr_T	line1;
!     linenr_T	line2;
!     linenr_T	n;
  {
      linenr_T	count;
      char_u	*p;
--- 919,925 ----
   * ":copy"
   */
      void
! ex_copy(linenr_T line1, linenr_T line2, linenr_T n)
  {
      linenr_T	count;
      char_u	*p;
***************
*** 987,993 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_prev_shellcmd()
  {
      vim_free(prevcmd);
  }
--- 974,980 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_prev_shellcmd(void)
  {
      vim_free(prevcmd);
  }
***************
*** 999,1009 ****
   * Remember the argument.
   */
      void
! do_bang(addr_count, eap, forceit, do_in, do_out)
!     int		addr_count;
!     exarg_T	*eap;
!     int		forceit;
!     int		do_in, do_out;
  {
      char_u		*arg = eap->arg;	/* command */
      linenr_T		line1 = eap->line1;	/* start of range */
--- 986,997 ----
   * Remember the argument.
   */
      void
! do_bang(
!     int		addr_count,
!     exarg_T	*eap,
!     int		forceit,
!     int		do_in,
!     int		do_out)
  {
      char_u		*arg = eap->arg;	/* command */
      linenr_T		line1 = eap->line1;	/* start of range */
***************
*** 1165,1175 ****
   * We use output redirection if do_out is TRUE.
   */
      static void
! do_filter(line1, line2, eap, cmd, do_in, do_out)
!     linenr_T	line1, line2;
!     exarg_T	*eap;		/* for forced 'ff' and 'fenc' */
!     char_u	*cmd;
!     int		do_in, do_out;
  {
      char_u	*itmp = NULL;
      char_u	*otmp = NULL;
--- 1153,1165 ----
   * We use output redirection if do_out is TRUE.
   */
      static void
! do_filter(
!     linenr_T	line1,
!     linenr_T	line2,
!     exarg_T	*eap,		/* for forced 'ff' and 'fenc' */
!     char_u	*cmd,
!     int		do_in,
!     int		do_out)
  {
      char_u	*itmp = NULL;
      char_u	*otmp = NULL;
***************
*** 1445,1453 ****
   * When "cmd" is NULL start an interactive shell.
   */
      void
! do_shell(cmd, flags)
!     char_u	*cmd;
!     int		flags;	/* may be SHELL_DOOUT when output is redirected */
  {
      buf_T	*buf;
  #ifndef FEAT_GUI_MSWIN
--- 1435,1443 ----
   * When "cmd" is NULL start an interactive shell.
   */
      void
! do_shell(
!     char_u	*cmd,
!     int		flags)	/* may be SHELL_DOOUT when output is redirected */
  {
      buf_T	*buf;
  #ifndef FEAT_GUI_MSWIN
***************
*** 1628,1637 ****
   * Returns an allocated string with the shell command, or NULL for failure.
   */
      char_u *
! make_filter_cmd(cmd, itmp, otmp)
!     char_u	*cmd;		/* command */
!     char_u	*itmp;		/* NULL or name of input file */
!     char_u	*otmp;		/* NULL or name of output file */
  {
      char_u	*buf;
      long_u	len;
--- 1618,1627 ----
   * Returns an allocated string with the shell command, or NULL for failure.
   */
      char_u *
! make_filter_cmd(
!     char_u	*cmd,		/* command */
!     char_u	*itmp,		/* NULL or name of input file */
!     char_u	*otmp)		/* NULL or name of output file */
  {
      char_u	*buf;
      long_u	len;
***************
*** 1723,1733 ****
   *	STRLEN(opt) + STRLEN(fname) + 3
   */
      void
! append_redir(buf, buflen, opt, fname)
!     char_u	*buf;
!     int		buflen;
!     char_u	*opt;
!     char_u	*fname;
  {
      char_u	*p;
      char_u	*end;
--- 1713,1723 ----
   *	STRLEN(opt) + STRLEN(fname) + 3
   */
      void
! append_redir(
!     char_u	*buf,
!     int		buflen,
!     char_u	*opt,
!     char_u	*fname)
  {
      char_u	*p;
      char_u	*end;
***************
*** 1764,1770 ****
  static int  viminfo_errcnt;
  
      static int
! no_viminfo()
  {
      /* "vim -i NONE" does not read or write a viminfo file */
      return (use_viminfo != NULL && STRCMP(use_viminfo, "NONE") == 0);
--- 1754,1760 ----
  static int  viminfo_errcnt;
  
      static int
! no_viminfo(void)
  {
      /* "vim -i NONE" does not read or write a viminfo file */
      return (use_viminfo != NULL && STRCMP(use_viminfo, "NONE") == 0);
***************
*** 1775,1784 ****
   * Count the number of errors.	When there are more than 10, return TRUE.
   */
      int
! viminfo_error(errnum, message, line)
!     char    *errnum;
!     char    *message;
!     char_u  *line;
  {
      vim_snprintf((char *)IObuff, IOSIZE, _("%sviminfo: %s in line: "),
  							     errnum, message);
--- 1765,1771 ----
   * Count the number of errors.	When there are more than 10, return TRUE.
   */
      int
! viminfo_error(char *errnum, char *message, char_u *line)
  {
      vim_snprintf((char *)IObuff, IOSIZE, _("%sviminfo: %s in line: "),
  							     errnum, message);
***************
*** 1799,1807 ****
   * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
   */
      int
! read_viminfo(file, flags)
!     char_u	*file;	    /* file name or NULL to use default name */
!     int		flags;	    /* VIF_WANT_INFO et al. */
  {
      FILE	*fp;
      char_u	*fname;
--- 1786,1794 ----
   * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
   */
      int
! read_viminfo(
!     char_u	*file,	    /* file name or NULL to use default name */
!     int		flags)	    /* VIF_WANT_INFO et al. */
  {
      FILE	*fp;
      char_u	*fname;
***************
*** 1845,1853 ****
   * info is written to the file.
   */
      void
! write_viminfo(file, forceit)
!     char_u	*file;
!     int		forceit;
  {
      char_u	*fname;
      FILE	*fp_in = NULL;	/* input viminfo file, if any */
--- 1832,1838 ----
   * info is written to the file.
   */
      void
! write_viminfo(char_u *file, int forceit)
  {
      char_u	*fname;
      FILE	*fp_in = NULL;	/* input viminfo file, if any */
***************
*** 2120,2127 ****
   * Returns an allocated string.  NULL when out of memory.
   */
      static char_u *
! viminfo_filename(file)
!     char_u	*file;
  {
      if (file == NULL || *file == NUL)
      {
--- 2105,2111 ----
   * Returns an allocated string.  NULL when out of memory.
   */
      static char_u *
! viminfo_filename(char_u *file)
  {
      if (file == NULL || *file == NUL)
      {
***************
*** 2158,2167 ****
   * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
   */
      static void
! do_viminfo(fp_in, fp_out, flags)
!     FILE	*fp_in;
!     FILE	*fp_out;
!     int		flags;
  {
      int		count = 0;
      int		eof = FALSE;
--- 2142,2148 ----
   * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
   */
      static void
! do_viminfo(FILE *fp_in, FILE *fp_out, int flags)
  {
      int		count = 0;
      int		eof = FALSE;
***************
*** 2232,2241 ****
   * are local to a file.  Returns TRUE when end-of-file is reached. -- webb
   */
      static int
! read_viminfo_up_to_marks(virp, forceit, writing)
!     vir_T	*virp;
!     int		forceit;
!     int		writing;
  {
      int		eof;
      buf_T	*buf;
--- 2213,2222 ----
   * are local to a file.  Returns TRUE when end-of-file is reached. -- webb
   */
      static int
! read_viminfo_up_to_marks(
!     vir_T	*virp,
!     int		forceit,
!     int		writing)
  {
      int		eof;
      buf_T	*buf;
***************
*** 2331,2338 ****
   * conversion of text with iconv() in viminfo_readstring().
   */
      static int
! viminfo_encoding(virp)
!     vir_T	*virp;
  {
  #ifdef FEAT_MBYTE
      char_u	*p;
--- 2312,2318 ----
   * conversion of text with iconv() in viminfo_readstring().
   */
      static int
! viminfo_encoding(vir_T *virp)
  {
  #ifdef FEAT_MBYTE
      char_u	*p;
***************
*** 2361,2368 ****
   * Returns TRUE for end-of-file;
   */
      int
! viminfo_readline(virp)
!     vir_T	*virp;
  {
      return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);
  }
--- 2341,2347 ----
   * Returns TRUE for end-of-file;
   */
      int
! viminfo_readline(vir_T *virp)
  {
      return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);
  }
***************
*** 2378,2387 ****
   * Return the string in allocated memory (NULL when out of memory).
   */
      char_u *
! viminfo_readstring(virp, off, convert)
!     vir_T	*virp;
!     int		off;		    /* offset for virp->vir_line */
!     int		convert UNUSED;	    /* convert the string */
  {
      char_u	*retval;
      char_u	*s, *d;
--- 2357,2366 ----
   * Return the string in allocated memory (NULL when out of memory).
   */
      char_u *
! viminfo_readstring(
!     vir_T	*virp,
!     int		off,		    /* offset for virp->vir_line */
!     int		convert UNUSED)	    /* convert the string */
  {
      char_u	*retval;
      char_u	*s, *d;
***************
*** 2451,2459 ****
   * - write " < <string> \n "	  in second line
   */
      void
! viminfo_writestring(fd, p)
!     FILE	*fd;
!     char_u	*p;
  {
      int		c;
      char_u	*s;
--- 2430,2436 ----
   * - write " < <string> \n "	  in second line
   */
      void
! viminfo_writestring(FILE *fd, char_u *p)
  {
      int		c;
      char_u	*s;
***************
*** 2509,2516 ****
   * not ^?	^?
   */
      void
! do_fixdel(eap)
!     exarg_T	*eap UNUSED;
  {
      char_u  *p;
  
--- 2486,2492 ----
   * not ^?	^?
   */
      void
! do_fixdel(exarg_T *eap UNUSED)
  {
      char_u  *p;
  
***************
*** 2520,2529 ****
  }
  
      void
! print_line_no_prefix(lnum, use_number, list)
!     linenr_T	lnum;
!     int		use_number;
!     int		list;
  {
      char_u	numbuf[30];
  
--- 2496,2505 ----
  }
  
      void
! print_line_no_prefix(
!     linenr_T	lnum,
!     int		use_number,
!     int		list)
  {
      char_u	numbuf[30];
  
***************
*** 2540,2549 ****
   * Print a text line.  Also in silent mode ("ex -s").
   */
      void
! print_line(lnum, use_number, list)
!     linenr_T	lnum;
!     int		use_number;
!     int		list;
  {
      int		save_silent = silent_mode;
  
--- 2516,2522 ----
   * Print a text line.  Also in silent mode ("ex -s").
   */
      void
! print_line(linenr_T lnum, int use_number, int list)
  {
      int		save_silent = silent_mode;
  
***************
*** 2562,2569 ****
  }
  
      int
! rename_buffer(new_fname)
!     char_u	*new_fname;
  {
      char_u	*fname, *sfname, *xfname;
      buf_T	*buf;
--- 2535,2541 ----
  }
  
      int
! rename_buffer(char_u *new_fname)
  {
      char_u	*fname, *sfname, *xfname;
      buf_T	*buf;
***************
*** 2618,2625 ****
   * ":file[!] [fname]".
   */
      void
! ex_file(eap)
!     exarg_T	*eap;
  {
      /* ":0file" removes the file name.  Check for illegal uses ":3file",
       * "0file name", etc. */
--- 2590,2596 ----
   * ":file[!] [fname]".
   */
      void
! ex_file(exarg_T *eap)
  {
      /* ":0file" removes the file name.  Check for illegal uses ":3file",
       * "0file name", etc. */
***************
*** 2645,2652 ****
   * ":update".
   */
      void
! ex_update(eap)
!     exarg_T	*eap;
  {
      if (curbufIsChanged())
  	(void)do_write(eap);
--- 2616,2622 ----
   * ":update".
   */
      void
! ex_update(exarg_T *eap)
  {
      if (curbufIsChanged())
  	(void)do_write(eap);
***************
*** 2656,2663 ****
   * ":write" and ":saveas".
   */
      void
! ex_write(eap)
!     exarg_T	*eap;
  {
      if (eap->usefilter)		/* input lines to shell command */
  	do_bang(1, eap, FALSE, TRUE, FALSE);
--- 2626,2632 ----
   * ":write" and ":saveas".
   */
      void
! ex_write(exarg_T *eap)
  {
      if (eap->usefilter)		/* input lines to shell command */
  	do_bang(1, eap, FALSE, TRUE, FALSE);
***************
*** 2674,2681 ****
   * return FAIL for failure, OK otherwise
   */
      int
! do_write(eap)
!     exarg_T	*eap;
  {
      int		other;
      char_u	*fname = NULL;		/* init to shut up gcc */
--- 2643,2649 ----
   * return FAIL for failure, OK otherwise
   */
      int
! do_write(exarg_T *eap)
  {
      int		other;
      char_u	*fname = NULL;		/* init to shut up gcc */
***************
*** 2886,2898 ****
   * Return OK if it's OK, FAIL if it is not.
   */
      int
! check_overwrite(eap, buf, fname, ffname, other)
!     exarg_T	*eap;
!     buf_T	*buf;
!     char_u	*fname;	    /* file name to be used (can differ from
  			       buf->ffname) */
!     char_u	*ffname;    /* full path version of fname */
!     int		other;	    /* writing under other name */
  {
      /*
       * write to other file or b_flags set or not writing the whole file:
--- 2854,2866 ----
   * Return OK if it's OK, FAIL if it is not.
   */
      int
! check_overwrite(
!     exarg_T	*eap,
!     buf_T	*buf,
!     char_u	*fname,	    /* file name to be used (can differ from
  			       buf->ffname) */
!     char_u	*ffname,    /* full path version of fname */
!     int		other)	    /* writing under other name */
  {
      /*
       * write to other file or b_flags set or not writing the whole file:
***************
*** 3005,3012 ****
   * Handle ":wnext", ":wNext" and ":wprevious" commands.
   */
      void
! ex_wnext(eap)
!     exarg_T	*eap;
  {
      int		i;
  
--- 2973,2979 ----
   * Handle ":wnext", ":wNext" and ":wprevious" commands.
   */
      void
! ex_wnext(exarg_T *eap)
  {
      int		i;
  
***************
*** 3024,3031 ****
   * ":wall", ":wqall" and ":xall": Write all changed files (and exit).
   */
      void
! do_wqall(eap)
!     exarg_T	*eap;
  {
      buf_T	*buf;
      int		error = 0;
--- 2991,2997 ----
   * ":wall", ":wqall" and ":xall": Write all changed files (and exit).
   */
      void
! do_wqall(exarg_T *eap)
  {
      buf_T	*buf;
      int		error = 0;
***************
*** 3092,3098 ****
   * Return TRUE and give a message when it's not st.
   */
      int
! not_writing()
  {
      if (p_write)
  	return FALSE;
--- 3058,3064 ----
   * Return TRUE and give a message when it's not st.
   */
      int
! not_writing(void)
  {
      if (p_write)
  	return FALSE;
***************
*** 3106,3114 ****
   * message when the buffer is readonly.
   */
      static int
! check_readonly(forceit, buf)
!     int		*forceit;
!     buf_T	*buf;
  {
      struct stat	st;
  
--- 3072,3078 ----
   * message when the buffer is readonly.
   */
      static int
! check_readonly(int *forceit, buf_T *buf)
  {
      struct stat	st;
  
***************
*** 3163,3175 ****
   * 'lnum' is the line number for the cursor in the new file (if non-zero).
   */
      int
! getfile(fnum, ffname, sfname, setpm, lnum, forceit)
!     int		fnum;
!     char_u	*ffname;
!     char_u	*sfname;
!     int		setpm;
!     linenr_T	lnum;
!     int		forceit;
  {
      int		other;
      int		retval;
--- 3127,3139 ----
   * 'lnum' is the line number for the cursor in the new file (if non-zero).
   */
      int
! getfile(
!     int		fnum,
!     char_u	*ffname,
!     char_u	*sfname,
!     int		setpm,
!     linenr_T	lnum,
!     int		forceit)
  {
      int		other;
      int		retval;
***************
*** 3264,3277 ****
   * return FAIL for failure, OK otherwise
   */
      int
! do_ecmd(fnum, ffname, sfname, eap, newlnum, flags, oldwin)
!     int		fnum;
!     char_u	*ffname;
!     char_u	*sfname;
!     exarg_T	*eap;			/* can be NULL! */
!     linenr_T	newlnum;
!     int		flags;
!     win_T	*oldwin;
  {
      int		other_file;		/* TRUE if editing another file */
      int		oldbuf;			/* TRUE if using existing buffer */
--- 3228,3241 ----
   * return FAIL for failure, OK otherwise
   */
      int
! do_ecmd(
!     int		fnum,
!     char_u	*ffname,
!     char_u	*sfname,
!     exarg_T	*eap,			/* can be NULL! */
!     linenr_T	newlnum,
!     int		flags,
!     win_T	*oldwin)
  {
      int		other_file;		/* TRUE if editing another file */
      int		oldbuf;			/* TRUE if using existing buffer */
***************
*** 3982,3989 ****
  
  #ifdef FEAT_AUTOCMD
      static void
! delbuf_msg(name)
!     char_u	*name;
  {
      EMSG2(_("E143: Autocommands unexpectedly deleted new buffer %s"),
  	    name == NULL ? (char_u *)"" : name);
--- 3946,3952 ----
  
  #ifdef FEAT_AUTOCMD
      static void
! delbuf_msg(char_u *name)
  {
      EMSG2(_("E143: Autocommands unexpectedly deleted new buffer %s"),
  	    name == NULL ? (char_u *)"" : name);
***************
*** 3998,4005 ****
   * ":insert" and ":append", also used by ":change"
   */
      void
! ex_append(eap)
!     exarg_T	*eap;
  {
      char_u	*theline;
      int		did_undo = FALSE;
--- 3961,3967 ----
   * ":insert" and ":append", also used by ":change"
   */
      void
! ex_append(exarg_T *eap)
  {
      char_u	*theline;
      int		did_undo = FALSE;
***************
*** 4143,4150 ****
   * ":change"
   */
      void
! ex_change(eap)
!     exarg_T	*eap;
  {
      linenr_T	lnum;
  
--- 4105,4111 ----
   * ":change"
   */
      void
! ex_change(exarg_T *eap)
  {
      linenr_T	lnum;
  
***************
*** 4173,4180 ****
  }
  
      void
! ex_z(eap)
!     exarg_T	*eap;
  {
      char_u	*x;
      int		bigness;
--- 4134,4140 ----
  }
  
      void
! ex_z(exarg_T *eap)
  {
      char_u	*x;
      int		bigness;
***************
*** 4304,4310 ****
   * Otherwise, return FALSE.
   */
      int
! check_restricted()
  {
      if (restricted)
      {
--- 4264,4270 ----
   * Otherwise, return FALSE.
   */
      int
! check_restricted(void)
  {
      if (restricted)
      {
***************
*** 4320,4326 ****
   * Otherwise, return FALSE.
   */
      int
! check_secure()
  {
      if (secure)
      {
--- 4280,4286 ----
   * Otherwise, return FALSE.
   */
      int
! check_secure(void)
  {
      if (secure)
      {
***************
*** 4355,4362 ****
   * The usual escapes are supported as described in the regexp docs.
   */
      void
! do_sub(eap)
!     exarg_T	*eap;
  {
      linenr_T	lnum;
      long	i = 0;
--- 4315,4321 ----
   * The usual escapes are supported as described in the regexp docs.
   */
      void
! do_sub(exarg_T *eap)
  {
      linenr_T	lnum;
      long	i = 0;
***************
*** 5434,5441 ****
   * Return TRUE if a message was given.
   */
      int
! do_sub_msg(count_only)
!     int	    count_only;		/* used 'n' flag for ":s" */
  {
      /*
       * Only report substitutions when:
--- 5393,5400 ----
   * Return TRUE if a message was given.
   */
      int
! do_sub_msg(
!     int	    count_only)		/* used 'n' flag for ":s" */
  {
      /*
       * Only report substitutions when:
***************
*** 5494,5501 ****
   * lines we do not know where to search for the next match.
   */
      void
! ex_global(eap)
!     exarg_T	*eap;
  {
      linenr_T	lnum;		/* line number according to old situation */
      int		ndone = 0;
--- 5453,5459 ----
   * lines we do not know where to search for the next match.
   */
      void
! ex_global(exarg_T *eap)
  {
      linenr_T	lnum;		/* line number according to old situation */
      int		ndone = 0;
***************
*** 5615,5622 ****
   * Execute "cmd" on lines marked with ml_setmarked().
   */
      void
! global_exe(cmd)
!     char_u	*cmd;
  {
      linenr_T old_lcount;	/* b_ml.ml_line_count before the command */
      buf_T    *old_buf = curbuf;	/* remember what buffer we started in */
--- 5573,5579 ----
   * Execute "cmd" on lines marked with ml_setmarked().
   */
      void
! global_exe(char_u *cmd)
  {
      linenr_T old_lcount;	/* b_ml.ml_line_count before the command */
      buf_T    *old_buf = curbuf;	/* remember what buffer we started in */
***************
*** 5673,5681 ****
  
  #ifdef FEAT_VIMINFO
      int
! read_viminfo_sub_string(virp, force)
!     vir_T	*virp;
!     int		force;
  {
      if (force)
  	vim_free(old_sub);
--- 5630,5636 ----
  
  #ifdef FEAT_VIMINFO
      int
! read_viminfo_sub_string(vir_T *virp, int force)
  {
      if (force)
  	vim_free(old_sub);
***************
*** 5685,5692 ****
  }
  
      void
! write_viminfo_sub_string(fp)
!     FILE    *fp;
  {
      if (get_viminfo_parameter('/') != 0 && old_sub != NULL)
      {
--- 5640,5646 ----
  }
  
      void
! write_viminfo_sub_string(FILE *fp)
  {
      if (get_viminfo_parameter('/') != 0 && old_sub != NULL)
      {
***************
*** 5698,5704 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_old_sub()
  {
      vim_free(old_sub);
  }
--- 5652,5658 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_old_sub(void)
  {
      vim_free(old_sub);
  }
***************
*** 5710,5717 ****
   * Return TRUE when it was created.
   */
      int
! prepare_tagpreview(undo_sync)
!     int		undo_sync;	/* sync undo when leaving the window */
  {
      win_T	*wp;
  
--- 5664,5671 ----
   * Return TRUE when it was created.
   */
      int
! prepare_tagpreview(
!     int		undo_sync)	/* sync undo when leaving the window */
  {
      win_T	*wp;
  
***************
*** 5760,5767 ****
   * ":help": open a read-only window on a help file
   */
      void
! ex_help(eap)
!     exarg_T	*eap;
  {
      char_u	*arg;
      char_u	*tag;
--- 5714,5720 ----
   * ":help": open a read-only window on a help file
   */
      void
! ex_help(exarg_T *eap)
  {
      char_u	*arg;
      char_u	*tag;
***************
*** 5978,5985 ****
   * ":helpclose": Close one help window
   */
      void
! ex_helpclose(eap)
!     exarg_T	*eap UNUSED;
  {
  #if defined(FEAT_WINDOWS)
      win_T *win;
--- 5931,5937 ----
   * ":helpclose": Close one help window
   */
      void
! ex_helpclose(exarg_T *eap UNUSED)
  {
  #if defined(FEAT_WINDOWS)
      win_T *win;
***************
*** 6002,6009 ****
   * Returns NULL if not found.
   */
      char_u *
! check_help_lang(arg)
!     char_u *arg;
  {
      int len = (int)STRLEN(arg);
  
--- 5954,5960 ----
   * Returns NULL if not found.
   */
      char_u *
! check_help_lang(char_u *arg)
  {
      int len = (int)STRLEN(arg);
  
***************
*** 6029,6038 ****
   * match some string for which help is requested.  webb.
   */
      int
! help_heuristic(matched_string, offset, wrong_case)
!     char_u	*matched_string;
!     int		offset;			/* offset for match */
!     int		wrong_case;		/* no matching case */
  {
      int		num_letters;
      char_u	*p;
--- 5980,5989 ----
   * match some string for which help is requested.  webb.
   */
      int
! help_heuristic(
!     char_u	*matched_string,
!     int		offset,			/* offset for match */
!     int		wrong_case)		/* no matching case */
  {
      int		num_letters;
      char_u	*p;
***************
*** 6073,6081 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! help_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      char    *p1;
      char    *p2;
--- 6024,6030 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! help_compare(const void *s1, const void *s2)
  {
      char    *p1;
      char    *p2;
***************
*** 6092,6102 ****
   * When "keep_lang" is TRUE try keeping the language of the current buffer.
   */
      int
! find_help_tags(arg, num_matches, matches, keep_lang)
!     char_u	*arg;
!     int		*num_matches;
!     char_u	***matches;
!     int		keep_lang;
  {
      char_u	*s, *d;
      int		i;
--- 6041,6051 ----
   * When "keep_lang" is TRUE try keeping the language of the current buffer.
   */
      int
! find_help_tags(
!     char_u	*arg,
!     int		*num_matches,
!     char_u	***matches,
!     int		keep_lang)
  {
      char_u	*s, *d;
      int		i;
***************
*** 6300,6306 ****
   * Called when starting to edit a buffer for a help file.
   */
      static void
! prepare_help_buffer()
  {
      char_u	*p;
  
--- 6249,6255 ----
   * Called when starting to edit a buffer for a help file.
   */
      static void
! prepare_help_buffer(void)
  {
      char_u	*p;
  
***************
*** 6368,6374 ****
   * highlighting is not used.
   */
      void
! fix_help_buffer()
  {
      linenr_T	lnum;
      char_u	*line;
--- 6317,6323 ----
   * highlighting is not used.
   */
      void
! fix_help_buffer(void)
  {
      linenr_T	lnum;
      char_u	*line;
***************
*** 6610,6617 ****
   * ":exusage"
   */
      void
! ex_exusage(eap)
!     exarg_T	*eap UNUSED;
  {
      do_cmdline_cmd((char_u *)"help ex-cmd-index");
  }
--- 6559,6565 ----
   * ":exusage"
   */
      void
! ex_exusage(exarg_T *eap UNUSED)
  {
      do_cmdline_cmd((char_u *)"help ex-cmd-index");
  }
***************
*** 6620,6627 ****
   * ":viusage"
   */
      void
! ex_viusage(eap)
!     exarg_T	*eap UNUSED;
  {
      do_cmdline_cmd((char_u *)"help normal-index");
  }
--- 6568,6574 ----
   * ":viusage"
   */
      void
! ex_viusage(exarg_T *eap UNUSED)
  {
      do_cmdline_cmd((char_u *)"help normal-index");
  }
***************
*** 6633,6640 ****
   * ":helptags"
   */
      void
! ex_helptags(eap)
!     exarg_T	*eap;
  {
      garray_T	ga;
      int		i, j;
--- 6580,6586 ----
   * ":helptags"
   */
      void
! ex_helptags(exarg_T *eap)
  {
      garray_T	ga;
      int		i, j;
***************
*** 6758,6768 ****
  }
  
      static void
! helptags_one(dir, ext, tagfname, add_help_tags)
!     char_u	*dir;		/* doc directory */
!     char_u	*ext;		/* suffix, ".txt", ".itx", ".frx", etc. */
!     char_u	*tagfname;	/* "tags" for English, "tags-fr" for French. */
!     int		add_help_tags;	/* add "help-tags" tag */
  {
      FILE	*fd_tags;
      FILE	*fd;
--- 6704,6714 ----
  }
  
      static void
! helptags_one(
!     char_u	*dir,		/* doc directory */
!     char_u	*ext,		/* suffix, ".txt", ".itx", ".frx", etc. */
!     char_u	*tagfname,	/* "tags" for English, "tags-fr" for French. */
!     int		add_help_tags)	/* add "help-tags" tag */
  {
      FILE	*fd_tags;
      FILE	*fd;
***************
*** 7064,7072 ****
   * "*end_cmd" must be writable.
   */
      static int
! sign_cmd_idx(begin_cmd, end_cmd)
!     char_u	*begin_cmd;	/* begin of sign subcmd */
!     char_u	*end_cmd;	/* just after sign subcmd */
  {
      int		idx;
      char	save = *end_cmd;
--- 7010,7018 ----
   * "*end_cmd" must be writable.
   */
      static int
! sign_cmd_idx(
!     char_u	*begin_cmd,	/* begin of sign subcmd */
!     char_u	*end_cmd)	/* just after sign subcmd */
  {
      int		idx;
      char	save = *end_cmd;
***************
*** 7083,7090 ****
   * ":sign" command
   */
      void
! ex_sign(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      char_u	*p;
--- 7029,7035 ----
   * ":sign" command
   */
      void
! ex_sign(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      char_u	*p;
***************
*** 7490,7496 ****
   * signs before it starts.
   */
      void
! sign_gui_started()
  {
      sign_T	*sp;
  
--- 7435,7441 ----
   * signs before it starts.
   */
      void
! sign_gui_started(void)
  {
      sign_T	*sp;
  
***************
*** 7504,7511 ****
   * List one sign.
   */
      static void
! sign_list_defined(sp)
!     sign_T	*sp;
  {
      char_u	*p;
  
--- 7449,7455 ----
   * List one sign.
   */
      static void
! sign_list_defined(sign_T *sp)
  {
      char_u	*p;
  
***************
*** 7550,7558 ****
   * Undefine a sign and free its memory.
   */
      static void
! sign_undefine(sp, sp_prev)
!     sign_T	*sp;
!     sign_T	*sp_prev;
  {
      vim_free(sp->sn_name);
      vim_free(sp->sn_icon);
--- 7494,7500 ----
   * Undefine a sign and free its memory.
   */
      static void
! sign_undefine(sign_T *sp, sign_T *sp_prev)
  {
      vim_free(sp->sn_name);
      vim_free(sp->sn_icon);
***************
*** 7576,7584 ****
   * If "line" is TRUE: line highl, if FALSE: text highl.
   */
      int
! sign_get_attr(typenr, line)
!     int		typenr;
!     int		line;
  {
      sign_T	*sp;
  
--- 7518,7524 ----
   * If "line" is TRUE: line highl, if FALSE: text highl.
   */
      int
! sign_get_attr(int typenr, int line)
  {
      sign_T	*sp;
  
***************
*** 7605,7612 ****
   * Returns NULL if there isn't one.
   */
      char_u *
! sign_get_text(typenr)
!     int		typenr;
  {
      sign_T	*sp;
  
--- 7545,7551 ----
   * Returns NULL if there isn't one.
   */
      char_u *
! sign_get_text(int typenr)
  {
      sign_T	*sp;
  
***************
*** 7618,7625 ****
  
  # if defined(FEAT_SIGN_ICONS) || defined(PROTO)
      void *
! sign_get_image(typenr)
!     int		typenr;		/* the attribute which may have a sign */
  {
      sign_T	*sp;
  
--- 7557,7564 ----
  
  # if defined(FEAT_SIGN_ICONS) || defined(PROTO)
      void *
! sign_get_image(
!     int		typenr)		/* the attribute which may have a sign */
  {
      sign_T	*sp;
  
***************
*** 7634,7641 ****
   * Get the name of a sign by its typenr.
   */
      char_u *
! sign_typenr2name(typenr)
!     int		typenr;
  {
      sign_T	*sp;
  
--- 7573,7579 ----
   * Get the name of a sign by its typenr.
   */
      char_u *
! sign_typenr2name(int typenr)
  {
      sign_T	*sp;
  
***************
*** 7650,7656 ****
   * Undefine/free all signs.
   */
      void
! free_signs()
  {
      while (first_sign != NULL)
  	sign_undefine(first_sign, NULL);
--- 7588,7594 ----
   * Undefine/free all signs.
   */
      void
! free_signs(void)
  {
      while (first_sign != NULL)
  	sign_undefine(first_sign, NULL);
***************
*** 7672,7680 ****
   * expansion.
   */
      char_u *
! get_sign_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      sign_T	*sp;
      int		current_idx;
--- 7610,7616 ----
   * expansion.
   */
      char_u *
! get_sign_name(expand_T *xp UNUSED, int idx)
  {
      sign_T	*sp;
      int		current_idx;
***************
*** 7720,7728 ****
   * Handle command line completion for :sign command.
   */
      void
! set_context_in_sign_cmd(xp, arg)
!     expand_T	*xp;
!     char_u	*arg;
  {
      char_u	*p;
      char_u	*end_subcmd;
--- 7656,7662 ----
   * Handle command line completion for :sign command.
   */
      void
! set_context_in_sign_cmd(expand_T *xp, char_u *arg)
  {
      char_u	*p;
      char_u	*end_subcmd;
***************
*** 7842,7849 ****
   * Make the user happy.
   */
      void
! ex_smile(eap)
!     exarg_T	*eap UNUSED;
  {
      static char *code = "\34 \4o\14$\4ox\30 \2o\30$\1ox\25 \2o\36$\1o\11 \1o\1$\3 \2$\1 \1o\1$x\5 \1o\1 \1$\1 \2o\10 \1o\44$\1o\7 \2$\1 \2$\1 \2$\1o\1$x\2 \2o\1 \1$\1 \1$\1 \1\"\1$\6 \1o\11$\4 \15$\4 \11$\1o\7 \3$\1o\2$\1o\1$x\2 \1\"\6$\1o\1$\5 \1o\11$\6 \13$\6 \12$\1o\4 \10$x\4 \7$\4 \13$\6 \13$\6 \27$x\4 \27$\4 \15$\4 \16$\2 \3\"\3$x\5 \1\"\3$\4\"\61$\5 \1\"\3$x\6 \3$\3 \1o\62$\5 \1\"\3$\1ox\5 \1o\2$\1\"\3 \63$\7 \3$\1ox\5 \3$\4 \55$\1\"\1 \1\"\6$\5o\4$\1ox\4 \1o\3$\4o\5$\2 \45$\3 \1o\21$x\4 \10$\1\"\4$\3 \42$\5 \4$\10\"x\3 \4\"\7 \4$\4 \1\"\34$\1\"\6 \1o\3$x\16 \1\"\3$\1o\5 \3\"\22$\1\"\2$\1\"\11 \3$x\20 \3$\1o\12 \1\"\2$\2\"\6$\4\"\13 \1o\3$x\21 \4$\1o\40 \1o\3$\1\"x\22 \1\"\4$\1o\6 \1o\6$\1o\1\"\4$\1o\10 \1o\4$x\24 \1\"\5$\2o\5 \2\"\4$\1o\5$\1o\3 \1o\4$\2\"x\27 \2\"\5$\4o\2 \1\"\3$\1o\11$\3\"x\32 \2\"\7$\2o\1 \12$x\42 \4\"\13$x\46 \14$x\47 \12$\1\"x\50 \1\"\3$\4\"x";
      char *p;
--- 7776,7782 ----
   * Make the user happy.
   */
      void
! ex_smile(exarg_T *eap UNUSED)
  {
      static char *code = "\34 \4o\14$\4ox\30 \2o\30$\1ox\25 \2o\36$\1o\11 \1o\1$\3 \2$\1 \1o\1$x\5 \1o\1 \1$\1 \2o\10 \1o\44$\1o\7 \2$\1 \2$\1 \2$\1o\1$x\2 \2o\1 \1$\1 \1$\1 \1\"\1$\6 \1o\11$\4 \15$\4 \11$\1o\7 \3$\1o\2$\1o\1$x\2 \1\"\6$\1o\1$\5 \1o\11$\6 \13$\6 \12$\1o\4 \10$x\4 \7$\4 \13$\6 \13$\6 \27$x\4 \27$\4 \15$\4 \16$\2 \3\"\3$x\5 \1\"\3$\4\"\61$\5 \1\"\3$x\6 \3$\3 \1o\62$\5 \1\"\3$\1ox\5 \1o\2$\1\"\3 \63$\7 \3$\1ox\5 \3$\4 \55$\1\"\1 \1\"\6$\5o\4$\1ox\4 \1o\3$\4o\5$\2 \45$\3 \1o\21$x\4 \10$\1\"\4$\3 \42$\5 \4$\10\"x\3 \4\"\7 \4$\4 \1\"\34$\1\"\6 \1o\3$x\16 \1\"\3$\1o\5 \3\"\22$\1\"\2$\1\"\11 \3$x\20 \3$\1o\12 \1\"\2$\2\"\6$\4\"\13 \1o\3$x\21 \4$\1o\40 \1o\3$\1\"x\22 \1\"\4$\1o\6 \1o\6$\1o\1\"\4$\1o\10 \1o\4$x\24 \1\"\5$\2o\5 \2\"\4$\1o\5$\1o\3 \1o\4$\2\"x\27 \2\"\5$\4o\2 \1\"\3$\1o\11$\3\"x\32 \2\"\7$\2o\1 \12$x\42 \4\"\13$x\46 \14$x\47 \12$\1\"x\50 \1\"\3$\4\"x";
      char *p;
***************
*** 7870,7877 ****
   * the argument list is redefined.
   */
      void
! ex_drop(eap)
!     exarg_T	*eap;
  {
      int		split = FALSE;
      win_T	*wp;
--- 7803,7809 ----
   * the argument list is redefined.
   */
      void
! ex_drop(exarg_T *eap)
  {
      int		split = FALSE;
      win_T	*wp;
*** ../vim-7.4.1205/src/ex_cmds2.c	2016-01-29 23:20:35.297308288 +0100
--- src/ex_cmds2.c	2016-01-30 15:25:31.672332792 +0100
***************
*** 78,85 ****
   * Repeatedly get Ex commands, until told to continue normal execution.
   */
      void
! do_debug(cmd)
!     char_u	*cmd;
  {
      int		save_msg_scroll = msg_scroll;
      int		save_State = State;
--- 78,84 ----
   * Repeatedly get Ex commands, until told to continue normal execution.
   */
      void
! do_debug(char_u *cmd)
  {
      int		save_msg_scroll = msg_scroll;
      int		save_State = State;
***************
*** 433,440 ****
   * ":debug".
   */
      void
! ex_debug(eap)
!     exarg_T	*eap;
  {
      int		debug_break_level_save = debug_break_level;
  
--- 432,438 ----
   * ":debug".
   */
      void
! ex_debug(exarg_T *eap)
  {
      int		debug_break_level_save = debug_break_level;
  
***************
*** 464,471 ****
   * Called from do_one_cmd() before executing a command.
   */
      void
! dbg_check_breakpoint(eap)
!     exarg_T	*eap;
  {
      char_u	*p;
  
--- 462,468 ----
   * Called from do_one_cmd() before executing a command.
   */
      void
! dbg_check_breakpoint(exarg_T *eap)
  {
      char_u	*p;
  
***************
*** 512,519 ****
   * set.  Return TRUE when the debug mode is entered this time.
   */
      int
! dbg_check_skipped(eap)
!     exarg_T	*eap;
  {
      int		prev_got_int;
  
--- 509,515 ----
   * set.  Return TRUE when the debug mode is entered this time.
   */
      int
! dbg_check_skipped(exarg_T *eap)
  {
      int		prev_got_int;
  
***************
*** 572,580 ****
   * Returns FAIL for failure.
   */
      static int
! dbg_parsearg(arg, gap)
!     char_u	*arg;
!     garray_T	*gap;	    /* either &dbg_breakp or &prof_ga */
  {
      char_u	*p = arg;
      char_u	*q;
--- 568,576 ----
   * Returns FAIL for failure.
   */
      static int
! dbg_parsearg(
!     char_u	*arg,
!     garray_T	*gap)	    /* either &dbg_breakp or &prof_ga */
  {
      char_u	*p = arg;
      char_u	*q;
***************
*** 669,676 ****
   * ":breakadd".
   */
      void
! ex_breakadd(eap)
!     exarg_T	*eap;
  {
      struct debuggy *bp;
      char_u	*pat;
--- 665,671 ----
   * ":breakadd".
   */
      void
! ex_breakadd(exarg_T *eap)
  {
      struct debuggy *bp;
      char_u	*pat;
***************
*** 715,722 ****
   * ":debuggreedy".
   */
      void
! ex_debuggreedy(eap)
!     exarg_T	*eap;
  {
      if (eap->addr_count == 0 || eap->line2 != 0)
  	debug_greedy = TRUE;
--- 710,716 ----
   * ":debuggreedy".
   */
      void
! ex_debuggreedy(exarg_T *eap)
  {
      if (eap->addr_count == 0 || eap->line2 != 0)
  	debug_greedy = TRUE;
***************
*** 728,735 ****
   * ":breakdel" and ":profdel".
   */
      void
! ex_breakdel(eap)
!     exarg_T	*eap;
  {
      struct debuggy *bp, *bpi;
      int		nr;
--- 722,728 ----
   * ":breakdel" and ":profdel".
   */
      void
! ex_breakdel(exarg_T *eap)
  {
      struct debuggy *bp, *bpi;
      int		nr;
***************
*** 819,826 ****
   * ":breaklist".
   */
      void
! ex_breaklist(eap)
!     exarg_T	*eap UNUSED;
  {
      struct debuggy *bp;
      int		i;
--- 812,818 ----
   * ":breaklist".
   */
      void
! ex_breaklist(exarg_T *eap UNUSED)
  {
      struct debuggy *bp;
      int		i;
***************
*** 846,855 ****
   * Returns line number at which to break; zero when no matching breakpoint.
   */
      linenr_T
! dbg_find_breakpoint(file, fname, after)
!     int		file;	    /* TRUE for a file, FALSE for a function */
!     char_u	*fname;	    /* file or function name */
!     linenr_T	after;	    /* after this line number */
  {
      return debuggy_find(file, fname, after, &dbg_breakp, NULL);
  }
--- 838,847 ----
   * Returns line number at which to break; zero when no matching breakpoint.
   */
      linenr_T
! dbg_find_breakpoint(
!     int		file,	    /* TRUE for a file, FALSE for a function */
!     char_u	*fname,	    /* file or function name */
!     linenr_T	after)	    /* after this line number */
  {
      return debuggy_find(file, fname, after, &dbg_breakp, NULL);
  }
***************
*** 859,868 ****
   * Return TRUE if profiling is on for a function or sourced file.
   */
      int
! has_profiling(file, fname, fp)
!     int		file;	    /* TRUE for a file, FALSE for a function */
!     char_u	*fname;	    /* file or function name */
!     int		*fp;	    /* return: forceit */
  {
      return (debuggy_find(file, fname, (linenr_T)0, &prof_ga, fp)
  							      != (linenr_T)0);
--- 851,860 ----
   * Return TRUE if profiling is on for a function or sourced file.
   */
      int
! has_profiling(
!     int		file,	    /* TRUE for a file, FALSE for a function */
!     char_u	*fname,	    /* file or function name */
!     int		*fp)	    /* return: forceit */
  {
      return (debuggy_find(file, fname, (linenr_T)0, &prof_ga, fp)
  							      != (linenr_T)0);
***************
*** 873,884 ****
   * Common code for dbg_find_breakpoint() and has_profiling().
   */
      static linenr_T
! debuggy_find(file, fname, after, gap, fp)
!     int		file;	    /* TRUE for a file, FALSE for a function */
!     char_u	*fname;	    /* file or function name */
!     linenr_T	after;	    /* after this line number */
!     garray_T	*gap;	    /* either &dbg_breakp or &prof_ga */
!     int		*fp;	    /* if not NULL: return forceit */
  {
      struct debuggy *bp;
      int		i;
--- 865,876 ----
   * Common code for dbg_find_breakpoint() and has_profiling().
   */
      static linenr_T
! debuggy_find(
!     int		file,	    /* TRUE for a file, FALSE for a function */
!     char_u	*fname,	    /* file or function name */
!     linenr_T	after,	    /* after this line number */
!     garray_T	*gap,	    /* either &dbg_breakp or &prof_ga */
!     int		*fp)	    /* if not NULL: return forceit */
  {
      struct debuggy *bp;
      int		i;
***************
*** 940,948 ****
   * Called when a breakpoint was encountered.
   */
      void
! dbg_breakpoint(name, lnum)
!     char_u	*name;
!     linenr_T	lnum;
  {
      /* We need to check if this line is actually executed in do_one_cmd() */
      debug_breakpoint_name = name;
--- 932,938 ----
   * Called when a breakpoint was encountered.
   */
      void
! dbg_breakpoint(char_u *name, linenr_T lnum)
  {
      /* We need to check if this line is actually executed in do_one_cmd() */
      debug_breakpoint_name = name;
***************
*** 955,962 ****
   * Store the current time in "tm".
   */
      void
! profile_start(tm)
!     proftime_T *tm;
  {
  # ifdef WIN3264
      QueryPerformanceCounter(tm);
--- 945,951 ----
   * Store the current time in "tm".
   */
      void
! profile_start(proftime_T *tm)
  {
  # ifdef WIN3264
      QueryPerformanceCounter(tm);
***************
*** 969,976 ****
   * Compute the elapsed time from "tm" till now and store in "tm".
   */
      void
! profile_end(tm)
!     proftime_T *tm;
  {
      proftime_T now;
  
--- 958,964 ----
   * Compute the elapsed time from "tm" till now and store in "tm".
   */
      void
! profile_end(proftime_T *tm)
  {
      proftime_T now;
  
***************
*** 993,1000 ****
   * Subtract the time "tm2" from "tm".
   */
      void
! profile_sub(tm, tm2)
!     proftime_T *tm, *tm2;
  {
  # ifdef WIN3264
      tm->QuadPart -= tm2->QuadPart;
--- 981,987 ----
   * Subtract the time "tm2" from "tm".
   */
      void
! profile_sub(proftime_T *tm, proftime_T *tm2)
  {
  # ifdef WIN3264
      tm->QuadPart -= tm2->QuadPart;
***************
*** 1014,1021 ****
   * Uses a static buffer!
   */
      char *
! profile_msg(tm)
!     proftime_T *tm;
  {
      static char buf[50];
  
--- 1001,1007 ----
   * Uses a static buffer!
   */
      char *
! profile_msg(proftime_T *tm)
  {
      static char buf[50];
  
***************
*** 1034,1042 ****
   * Put the time "msec" past now in "tm".
   */
      void
! profile_setlimit(msec, tm)
!     long	msec;
!     proftime_T	*tm;
  {
      if (msec <= 0)   /* no limit */
  	profile_zero(tm);
--- 1020,1026 ----
   * Put the time "msec" past now in "tm".
   */
      void
! profile_setlimit(long msec, proftime_T *tm)
  {
      if (msec <= 0)   /* no limit */
  	profile_zero(tm);
***************
*** 1063,1070 ****
   * Return TRUE if the current time is past "tm".
   */
      int
! profile_passed_limit(tm)
!     proftime_T	*tm;
  {
      proftime_T	now;
  
--- 1047,1053 ----
   * Return TRUE if the current time is past "tm".
   */
      int
! profile_passed_limit(proftime_T *tm)
  {
      proftime_T	now;
  
***************
*** 1086,1093 ****
   * Set the time in "tm" to zero.
   */
      void
! profile_zero(tm)
!     proftime_T *tm;
  {
  # ifdef WIN3264
      tm->QuadPart = 0;
--- 1069,1075 ----
   * Set the time in "tm" to zero.
   */
      void
! profile_zero(proftime_T *tm)
  {
  # ifdef WIN3264
      tm->QuadPart = 0;
***************
*** 1108,1117 ****
   * Divide the time "tm" by "count" and store in "tm2".
   */
      void
! profile_divide(tm, count, tm2)
!     proftime_T  *tm;
!     proftime_T  *tm2;
!     int		count;
  {
      if (count == 0)
  	profile_zero(tm2);
--- 1090,1096 ----
   * Divide the time "tm" by "count" and store in "tm2".
   */
      void
! profile_divide(proftime_T *tm, int count, proftime_T *tm2)
  {
      if (count == 0)
  	profile_zero(tm2);
***************
*** 1141,1148 ****
   * Add the time "tm2" to "tm".
   */
      void
! profile_add(tm, tm2)
!     proftime_T *tm, *tm2;
  {
  # ifdef WIN3264
      tm->QuadPart += tm2->QuadPart;
--- 1120,1126 ----
   * Add the time "tm2" to "tm".
   */
      void
! profile_add(proftime_T *tm, proftime_T *tm2)
  {
  # ifdef WIN3264
      tm->QuadPart += tm2->QuadPart;
***************
*** 1161,1168 ****
   * Add the "self" time from the total time and the children's time.
   */
      void
! profile_self(self, total, children)
!     proftime_T *self, *total, *children;
  {
      /* Check that the result won't be negative.  Can happen with recursive
       * calls. */
--- 1139,1145 ----
   * Add the "self" time from the total time and the children's time.
   */
      void
! profile_self(proftime_T *self, proftime_T *total, proftime_T *children)
  {
      /* Check that the result won't be negative.  Can happen with recursive
       * calls. */
***************
*** 1183,1190 ****
   * Get the current waittime.
   */
      void
! profile_get_wait(tm)
!     proftime_T *tm;
  {
      *tm = prof_wait_time;
  }
--- 1160,1166 ----
   * Get the current waittime.
   */
      void
! profile_get_wait(proftime_T *tm)
  {
      *tm = prof_wait_time;
  }
***************
*** 1193,1200 ****
   * Subtract the passed waittime since "tm" from "tma".
   */
      void
! profile_sub_wait(tm, tma)
!     proftime_T *tm, *tma;
  {
      proftime_T tm3 = prof_wait_time;
  
--- 1169,1175 ----
   * Subtract the passed waittime since "tm" from "tma".
   */
      void
! profile_sub_wait(proftime_T *tm, proftime_T *tma)
  {
      proftime_T tm3 = prof_wait_time;
  
***************
*** 1206,1213 ****
   * Return TRUE if "tm1" and "tm2" are equal.
   */
      int
! profile_equal(tm1, tm2)
!     proftime_T *tm1, *tm2;
  {
  # ifdef WIN3264
      return (tm1->QuadPart == tm2->QuadPart);
--- 1181,1187 ----
   * Return TRUE if "tm1" and "tm2" are equal.
   */
      int
! profile_equal(proftime_T *tm1, proftime_T *tm2)
  {
  # ifdef WIN3264
      return (tm1->QuadPart == tm2->QuadPart);
***************
*** 1220,1227 ****
   * Return <0, 0 or >0 if "tm1" < "tm2", "tm1" == "tm2" or "tm1" > "tm2"
   */
      int
! profile_cmp(tm1, tm2)
!     const proftime_T *tm1, *tm2;
  {
  # ifdef WIN3264
      return (int)(tm2->QuadPart - tm1->QuadPart);
--- 1194,1200 ----
   * Return <0, 0 or >0 if "tm1" < "tm2", "tm1" == "tm2" or "tm1" > "tm2"
   */
      int
! profile_cmp(const proftime_T *tm1, const proftime_T *tm2)
  {
  # ifdef WIN3264
      return (int)(tm2->QuadPart - tm1->QuadPart);
***************
*** 1239,1246 ****
   * ":profile cmd args"
   */
      void
! ex_profile(eap)
!     exarg_T	*eap;
  {
      char_u	*e;
      int		len;
--- 1212,1218 ----
   * ":profile cmd args"
   */
      void
! ex_profile(exarg_T *eap)
  {
      char_u	*e;
      int		len;
***************
*** 1308,1316 ****
   * specific expansion.
   */
      char_u *
! get_profile_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      switch (pexpand_what)
      {
--- 1280,1286 ----
   * specific expansion.
   */
      char_u *
! get_profile_name(expand_T *xp UNUSED, int idx)
  {
      switch (pexpand_what)
      {
***************
*** 1326,1334 ****
   * Handle command line completion for :profile command.
   */
      void
! set_context_in_profile_cmd(xp, arg)
!     expand_T	*xp;
!     char_u	*arg;
  {
      char_u	*end_subcmd;
  
--- 1296,1302 ----
   * Handle command line completion for :profile command.
   */
      void
! set_context_in_profile_cmd(expand_T *xp, char_u *arg)
  {
      char_u	*end_subcmd;
  
***************
*** 1356,1362 ****
   * Dump the profiling info.
   */
      void
! profile_dump()
  {
      FILE	*fd;
  
--- 1324,1330 ----
   * Dump the profiling info.
   */
      void
! profile_dump(void)
  {
      FILE	*fd;
  
***************
*** 1378,1385 ****
   * Start profiling script "fp".
   */
      static void
! script_do_profile(si)
!     scriptitem_T    *si;
  {
      si->sn_pr_count = 0;
      profile_zero(&si->sn_pr_total);
--- 1346,1352 ----
   * Start profiling script "fp".
   */
      static void
! script_do_profile(scriptitem_T *si)
  {
      si->sn_pr_count = 0;
      profile_zero(&si->sn_pr_total);
***************
*** 1395,1402 ****
   * save time when starting to invoke another script or function.
   */
      void
! script_prof_save(tm)
!     proftime_T	*tm;	    /* place to store wait time */
  {
      scriptitem_T    *si;
  
--- 1362,1369 ----
   * save time when starting to invoke another script or function.
   */
      void
! script_prof_save(
!     proftime_T	*tm)	    /* place to store wait time */
  {
      scriptitem_T    *si;
  
***************
*** 1413,1420 ****
   * Count time spent in children after invoking another script or function.
   */
      void
! script_prof_restore(tm)
!     proftime_T	*tm;
  {
      scriptitem_T    *si;
  
--- 1380,1386 ----
   * Count time spent in children after invoking another script or function.
   */
      void
! script_prof_restore(proftime_T *tm)
  {
      scriptitem_T    *si;
  
***************
*** 1437,1443 ****
   * Called when starting to wait for the user to type a character.
   */
      void
! prof_inchar_enter()
  {
      profile_start(&inchar_time);
  }
--- 1403,1409 ----
   * Called when starting to wait for the user to type a character.
   */
      void
! prof_inchar_enter(void)
  {
      profile_start(&inchar_time);
  }
***************
*** 1446,1452 ****
   * Called when finished waiting for the user to type a character.
   */
      void
! prof_inchar_exit()
  {
      profile_end(&inchar_time);
      profile_add(&prof_wait_time, &inchar_time);
--- 1412,1418 ----
   * Called when finished waiting for the user to type a character.
   */
      void
! prof_inchar_exit(void)
  {
      profile_end(&inchar_time);
      profile_add(&prof_wait_time, &inchar_time);
***************
*** 1456,1463 ****
   * Dump the profiling results for all scripts in file "fd".
   */
      static void
! script_dump_profile(fd)
!     FILE    *fd;
  {
      int		    id;
      scriptitem_T    *si;
--- 1422,1428 ----
   * Dump the profiling results for all scripts in file "fd".
   */
      static void
! script_dump_profile(FILE *fd)
  {
      int		    id;
      scriptitem_T    *si;
***************
*** 1515,1521 ****
   * profiled.
   */
      int
! prof_def_func()
  {
      if (current_SID > 0)
  	return SCRIPT_ITEM(current_SID).sn_pr_force;
--- 1480,1486 ----
   * profiled.
   */
      int
! prof_def_func(void)
  {
      if (current_SID > 0)
  	return SCRIPT_ITEM(current_SID).sn_pr_force;
***************
*** 1532,1540 ****
   * return FAIL for failure, OK otherwise
   */
      int
! autowrite(buf, forceit)
!     buf_T	*buf;
!     int		forceit;
  {
      int		r;
  
--- 1497,1503 ----
   * return FAIL for failure, OK otherwise
   */
      int
! autowrite(buf_T *buf, int forceit)
  {
      int		r;
  
***************
*** 1558,1564 ****
   * flush all buffers, except the ones that are readonly
   */
      void
! autowrite_all()
  {
      buf_T	*buf;
  
--- 1521,1527 ----
   * flush all buffers, except the ones that are readonly
   */
      void
! autowrite_all(void)
  {
      buf_T	*buf;
  
***************
*** 1581,1589 ****
   * For flags use the CCGD_ values.
   */
      int
! check_changed(buf, flags)
!     buf_T	*buf;
!     int		flags;
  {
      int forceit = (flags & CCGD_FORCEIT);
  
--- 1544,1550 ----
   * For flags use the CCGD_ values.
   */
      int
! check_changed(buf_T *buf, int flags)
  {
      int forceit = (flags & CCGD_FORCEIT);
  
***************
*** 1637,1644 ****
   * When wanting to write a file without a file name, ask the user for a name.
   */
      void
! browse_save_fname(buf)
!     buf_T	*buf;
  {
      if (buf->b_fname == NULL)
      {
--- 1598,1604 ----
   * When wanting to write a file without a file name, ask the user for a name.
   */
      void
! browse_save_fname(buf_T *buf)
  {
      if (buf->b_fname == NULL)
      {
***************
*** 1661,1669 ****
   * Must check 'write' option first!
   */
      void
! dialog_changed(buf, checkall)
!     buf_T	*buf;
!     int		checkall;	/* may abandon all changed buffers */
  {
      char_u	buff[DIALOG_MSG_SIZE];
      int		ret;
--- 1621,1629 ----
   * Must check 'write' option first!
   */
      void
! dialog_changed(
!     buf_T	*buf,
!     int		checkall)	/* may abandon all changed buffers */
  {
      char_u	buff[DIALOG_MSG_SIZE];
      int		ret;
***************
*** 1746,1754 ****
   * hidden, autowriting it or unloading it.
   */
      int
! can_abandon(buf, forceit)
!     buf_T	*buf;
!     int		forceit;
  {
      return (	   P_HID(buf)
  		|| !bufIsChanged(buf)
--- 1706,1712 ----
   * hidden, autowriting it or unloading it.
   */
      int
! can_abandon(buf_T *buf, int forceit)
  {
      return (	   P_HID(buf)
  		|| !bufIsChanged(buf)
***************
*** 1763,1772 ****
   * Add a buffer number to "bufnrs", unless it's already there.
   */
      static void
! add_bufnum(bufnrs, bufnump, nr)
!     int	    *bufnrs;
!     int	    *bufnump;
!     int	    nr;
  {
      int i;
  
--- 1721,1727 ----
   * Add a buffer number to "bufnrs", unless it's already there.
   */
      static void
! add_bufnum(int *bufnrs, int *bufnump, int nr)
  {
      int i;
  
***************
*** 1784,1792 ****
   * hidden.  This is used for ":q!".
   */
      int
! check_changed_any(hidden, unload)
!     int		hidden;		/* Only check hidden buffers */
!     int		unload;
  {
      int		ret = FALSE;
      buf_T	*buf;
--- 1739,1747 ----
   * hidden.  This is used for ":q!".
   */
      int
! check_changed_any(
!     int		hidden,		/* Only check hidden buffers */
!     int		unload)
  {
      int		ret = FALSE;
      buf_T	*buf;
***************
*** 1909,1915 ****
   * give error message for FAIL
   */
      int
! check_fname()
  {
      if (curbuf->b_ffname == NULL)
      {
--- 1864,1870 ----
   * give error message for FAIL
   */
      int
! check_fname(void)
  {
      if (curbuf->b_ffname == NULL)
      {
***************
*** 1925,1933 ****
   * return FAIL for failure, OK otherwise
   */
      int
! buf_write_all(buf, forceit)
!     buf_T	*buf;
!     int		forceit;
  {
      int	    retval;
  #ifdef FEAT_AUTOCMD
--- 1880,1886 ----
   * return FAIL for failure, OK otherwise
   */
      int
! buf_write_all(buf_T *buf, int forceit)
  {
      int	    retval;
  #ifdef FEAT_AUTOCMD
***************
*** 1968,1975 ****
   * Return a pointer to the start of the next argument.
   */
      static char_u *
! do_one_arg(str)
!     char_u *str;
  {
      char_u	*p;
      int		inbacktick;
--- 1921,1927 ----
   * Return a pointer to the start of the next argument.
   */
      static char_u *
! do_one_arg(char_u *str)
  {
      char_u	*p;
      int		inbacktick;
***************
*** 2005,2013 ****
   * growarray "gap".
   */
      int
! get_arglist(gap, str)
!     garray_T	*gap;
!     char_u	*str;
  {
      ga_init2(gap, (int)sizeof(char_u *), 20);
      while (*str != NUL)
--- 1957,1963 ----
   * growarray "gap".
   */
      int
! get_arglist(garray_T *gap, char_u *str)
  {
      ga_init2(gap, (int)sizeof(char_u *), 20);
      while (*str != NUL)
***************
*** 2032,2042 ****
   * Return FAIL or OK.
   */
      int
! get_arglist_exp(str, fcountp, fnamesp, wig)
!     char_u	*str;
!     int		*fcountp;
!     char_u	***fnamesp;
!     int		wig;
  {
      garray_T	ga;
      int		i;
--- 1982,1992 ----
   * Return FAIL or OK.
   */
      int
! get_arglist_exp(
!     char_u	*str,
!     int		*fcountp,
!     char_u	***fnamesp,
!     int		wig)
  {
      garray_T	ga;
      int		i;
***************
*** 2060,2067 ****
   * Redefine the argument list.
   */
      void
! set_arglist(str)
!     char_u	*str;
  {
      do_arglist(str, AL_SET, 0);
  }
--- 2010,2016 ----
   * Redefine the argument list.
   */
      void
! set_arglist(char_u *str)
  {
      do_arglist(str, AL_SET, 0);
  }
***************
*** 2075,2084 ****
   * Return FAIL for failure, OK otherwise.
   */
      static int
! do_arglist(str, what, after)
!     char_u	*str;
!     int		what UNUSED;
!     int		after UNUSED;		/* 0 means before first one */
  {
      garray_T	new_ga;
      int		exp_count;
--- 2024,2033 ----
   * Return FAIL for failure, OK otherwise.
   */
      static int
! do_arglist(
!     char_u	*str,
!     int		what UNUSED,
!     int		after UNUSED)		/* 0 means before first one */
  {
      garray_T	new_ga;
      int		exp_count;
***************
*** 2183,2189 ****
   * Check the validity of the arg_idx for each other window.
   */
      static void
! alist_check_arg_idx()
  {
  #ifdef FEAT_WINDOWS
      win_T	*win;
--- 2132,2138 ----
   * Check the validity of the arg_idx for each other window.
   */
      static void
! alist_check_arg_idx(void)
  {
  #ifdef FEAT_WINDOWS
      win_T	*win;
***************
*** 2202,2209 ****
   * index.
   */
      static int
! editing_arg_idx(win)
!     win_T	*win;
  {
      return !(win->w_arg_idx >= WARGCOUNT(win)
  		|| (win->w_buffer->b_fnum
--- 2151,2157 ----
   * index.
   */
      static int
! editing_arg_idx(win_T *win)
  {
      return !(win->w_arg_idx >= WARGCOUNT(win)
  		|| (win->w_buffer->b_fnum
***************
*** 2218,2225 ****
   * Check if window "win" is editing the w_arg_idx file in its argument list.
   */
      void
! check_arg_idx(win)
!     win_T	*win;
  {
      if (WARGCOUNT(win) > 1 && !editing_arg_idx(win))
      {
--- 2166,2172 ----
   * Check if window "win" is editing the w_arg_idx file in its argument list.
   */
      void
! check_arg_idx(win_T *win)
  {
      if (WARGCOUNT(win) > 1 && !editing_arg_idx(win))
      {
***************
*** 2257,2264 ****
   * ":args", ":argslocal" and ":argsglobal".
   */
      void
! ex_args(eap)
!     exarg_T	*eap;
  {
      int		i;
  
--- 2204,2210 ----
   * ":args", ":argslocal" and ":argsglobal".
   */
      void
! ex_args(exarg_T *eap)
  {
      int		i;
  
***************
*** 2334,2341 ****
   * ":previous", ":sprevious", ":Next" and ":sNext".
   */
      void
! ex_previous(eap)
!     exarg_T	*eap;
  {
      /* If past the last one already, go to the last one. */
      if (curwin->w_arg_idx - (int)eap->line2 >= ARGCOUNT)
--- 2280,2286 ----
   * ":previous", ":sprevious", ":Next" and ":sNext".
   */
      void
! ex_previous(exarg_T *eap)
  {
      /* If past the last one already, go to the last one. */
      if (curwin->w_arg_idx - (int)eap->line2 >= ARGCOUNT)
***************
*** 2348,2355 ****
   * ":rewind", ":first", ":sfirst" and ":srewind".
   */
      void
! ex_rewind(eap)
!     exarg_T	*eap;
  {
      do_argfile(eap, 0);
  }
--- 2293,2299 ----
   * ":rewind", ":first", ":sfirst" and ":srewind".
   */
      void
! ex_rewind(exarg_T *eap)
  {
      do_argfile(eap, 0);
  }
***************
*** 2358,2365 ****
   * ":last" and ":slast".
   */
      void
! ex_last(eap)
!     exarg_T	*eap;
  {
      do_argfile(eap, ARGCOUNT - 1);
  }
--- 2302,2308 ----
   * ":last" and ":slast".
   */
      void
! ex_last(exarg_T *eap)
  {
      do_argfile(eap, ARGCOUNT - 1);
  }
***************
*** 2368,2375 ****
   * ":argument" and ":sargument".
   */
      void
! ex_argument(eap)
!     exarg_T	*eap;
  {
      int		i;
  
--- 2311,2317 ----
   * ":argument" and ":sargument".
   */
      void
! ex_argument(exarg_T *eap)
  {
      int		i;
  
***************
*** 2384,2392 ****
   * Edit file "argn" of the argument lists.
   */
      void
! do_argfile(eap, argn)
!     exarg_T	*eap;
!     int		argn;
  {
      int		other;
      char_u	*p;
--- 2326,2332 ----
   * Edit file "argn" of the argument lists.
   */
      void
! do_argfile(exarg_T *eap, int argn)
  {
      int		other;
      char_u	*p;
***************
*** 2464,2471 ****
   * ":next", and commands that behave like it.
   */
      void
! ex_next(eap)
!     exarg_T	*eap;
  {
      int		i;
  
--- 2404,2410 ----
   * ":next", and commands that behave like it.
   */
      void
! ex_next(exarg_T *eap)
  {
      int		i;
  
***************
*** 2496,2503 ****
   * ":argedit"
   */
      void
! ex_argedit(eap)
!     exarg_T	*eap;
  {
      int		fnum;
      int		i;
--- 2435,2441 ----
   * ":argedit"
   */
      void
! ex_argedit(exarg_T *eap)
  {
      int		fnum;
      int		i;
***************
*** 2533,2540 ****
   * ":argadd"
   */
      void
! ex_argadd(eap)
!     exarg_T	*eap;
  {
      do_arglist(eap->arg, AL_ADD,
  	       eap->addr_count > 0 ? (int)eap->line2 : curwin->w_arg_idx + 1);
--- 2471,2477 ----
   * ":argadd"
   */
      void
! ex_argadd(exarg_T *eap)
  {
      do_arglist(eap->arg, AL_ADD,
  	       eap->addr_count > 0 ? (int)eap->line2 : curwin->w_arg_idx + 1);
***************
*** 2547,2554 ****
   * ":argdelete"
   */
      void
! ex_argdelete(eap)
!     exarg_T	*eap;
  {
      int		i;
      int		n;
--- 2484,2490 ----
   * ":argdelete"
   */
      void
! ex_argdelete(exarg_T *eap)
  {
      int		i;
      int		n;
***************
*** 2591,2598 ****
   * ":argdo", ":windo", ":bufdo", ":tabdo", ":cdo", ":ldo", ":cfdo" and ":lfdo"
   */
      void
! ex_listdo(eap)
!     exarg_T	*eap;
  {
      int		i;
  #ifdef FEAT_WINDOWS
--- 2527,2533 ----
   * ":argdo", ":windo", ":bufdo", ":tabdo", ":cdo", ":ldo", ":cfdo" and ":lfdo"
   */
      void
! ex_listdo(exarg_T *eap)
  {
      int		i;
  #ifdef FEAT_WINDOWS
***************
*** 2840,2849 ****
   * Returns index of first added argument.  Returns -1 when failed (out of mem).
   */
      static int
! alist_add_list(count, files, after)
!     int		count;
!     char_u	**files;
!     int		after;	    /* where to add: 0 = before first one */
  {
      int		i;
      int		old_argcount = ARGCOUNT;
--- 2775,2784 ----
   * Returns index of first added argument.  Returns -1 when failed (out of mem).
   */
      static int
! alist_add_list(
!     int		count,
!     char_u	**files,
!     int		after)	    /* where to add: 0 = before first one */
  {
      int		i;
      int		old_argcount = ARGCOUNT;
***************
*** 2880,2887 ****
   * ":compiler[!] {name}"
   */
      void
! ex_compiler(eap)
!     exarg_T	*eap;
  {
      char_u	*buf;
      char_u	*old_cur_comp = NULL;
--- 2815,2821 ----
   * ":compiler[!] {name}"
   */
      void
! ex_compiler(exarg_T *eap)
  {
      char_u	*buf;
      char_u	*old_cur_comp = NULL;
***************
*** 2954,2961 ****
   * ":runtime {name}"
   */
      void
! ex_runtime(eap)
!     exarg_T	*eap;
  {
      source_runtime(eap->arg, eap->forceit);
  }
--- 2888,2894 ----
   * ":runtime {name}"
   */
      void
! ex_runtime(exarg_T *eap)
  {
      source_runtime(eap->arg, eap->forceit);
  }
***************
*** 2963,2971 ****
  static void source_callback(char_u *fname, void *cookie);
  
      static void
! source_callback(fname, cookie)
!     char_u	*fname;
!     void	*cookie UNUSED;
  {
      (void)do_source(fname, FALSE, DOSO_NONE);
  }
--- 2896,2902 ----
  static void source_callback(char_u *fname, void *cookie);
  
      static void
! source_callback(char_u *fname, void *cookie UNUSED)
  {
      (void)do_source(fname, FALSE, DOSO_NONE);
  }
***************
*** 2977,2985 ****
   * return FAIL when no file could be sourced, OK otherwise.
   */
      int
! source_runtime(name, all)
!     char_u	*name;
!     int		all;
  {
      return do_in_runtimepath(name, all, source_callback, NULL);
  }
--- 2908,2914 ----
   * return FAIL when no file could be sourced, OK otherwise.
   */
      int
! source_runtime(char_u *name, int all)
  {
      return do_in_runtimepath(name, all, source_callback, NULL);
  }
***************
*** 2996,3006 ****
   * has done its job.
   */
      int
! do_in_runtimepath(name, all, callback, cookie)
!     char_u	*name;
!     int		all;
!     void	(*callback)(char_u *fname, void *ck);
!     void	*cookie;
  {
      char_u	*rtp;
      char_u	*np;
--- 2925,2935 ----
   * has done its job.
   */
      int
! do_in_runtimepath(
!     char_u	*name,
!     int		all,
!     void	(*callback)(char_u *fname, void *ck),
!     void	*cookie)
  {
      char_u	*rtp;
      char_u	*np;
***************
*** 3103,3110 ****
   * ":options"
   */
      void
! ex_options(eap)
!     exarg_T	*eap UNUSED;
  {
      cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);
  }
--- 3032,3039 ----
   * ":options"
   */
      void
! ex_options(
!     exarg_T	*eap UNUSED)
  {
      cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);
  }
***************
*** 3114,3121 ****
   * ":source {fname}"
   */
      void
! ex_source(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_BROWSE
      if (cmdmod.browse)
--- 3043,3049 ----
   * ":source {fname}"
   */
      void
! ex_source(exarg_T *eap)
  {
  #ifdef FEAT_BROWSE
      if (cmdmod.browse)
***************
*** 3136,3144 ****
  }
  
      static void
! cmd_source(fname, eap)
!     char_u	*fname;
!     exarg_T	*eap;
  {
      if (*fname == NUL)
  	EMSG(_(e_argreq));
--- 3064,3070 ----
  }
  
      static void
! cmd_source(char_u *fname, exarg_T *eap)
  {
      if (*fname == NUL)
  	EMSG(_(e_argreq));
***************
*** 3197,3204 ****
   * Return the address holding the next breakpoint line for a source cookie.
   */
      linenr_T *
! source_breakpoint(cookie)
!     void *cookie;
  {
      return &((struct source_cookie *)cookie)->breakpoint;
  }
--- 3123,3129 ----
   * Return the address holding the next breakpoint line for a source cookie.
   */
      linenr_T *
! source_breakpoint(void *cookie)
  {
      return &((struct source_cookie *)cookie)->breakpoint;
  }
***************
*** 3207,3214 ****
   * Return the address holding the debug tick for a source cookie.
   */
      int *
! source_dbg_tick(cookie)
!     void *cookie;
  {
      return &((struct source_cookie *)cookie)->dbg_tick;
  }
--- 3132,3138 ----
   * Return the address holding the debug tick for a source cookie.
   */
      int *
! source_dbg_tick(void *cookie)
  {
      return &((struct source_cookie *)cookie)->dbg_tick;
  }
***************
*** 3217,3224 ****
   * Return the nesting level for a source cookie.
   */
      int
! source_level(cookie)
!     void *cookie;
  {
      return ((struct source_cookie *)cookie)->level;
  }
--- 3141,3147 ----
   * Return the nesting level for a source cookie.
   */
      int
! source_level(void *cookie)
  {
      return ((struct source_cookie *)cookie)->level;
  }
***************
*** 3235,3242 ****
   * When possible the handle is closed on exec().
   */
      static FILE *
! fopen_noinh_readbin(filename)
!     char    *filename;
  {
  # ifdef WIN32
      int	fd_tmp = mch_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);
--- 3158,3164 ----
   * When possible the handle is closed on exec().
   */
      static FILE *
! fopen_noinh_readbin(char *filename)
  {
  # ifdef WIN32
      int	fd_tmp = mch_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);
***************
*** 3268,3277 ****
   * return FAIL if file could not be opened, OK otherwise
   */
      int
! do_source(fname, check_other, is_vimrc)
!     char_u	*fname;
!     int		check_other;	    /* check for .vimrc and _vimrc */
!     int		is_vimrc;	    /* DOSO_ value */
  {
      struct source_cookie    cookie;
      char_u		    *save_sourcing_name;
--- 3190,3199 ----
   * return FAIL if file could not be opened, OK otherwise
   */
      int
! do_source(
!     char_u	*fname,
!     int		check_other,	    /* check for .vimrc and _vimrc */
!     int		is_vimrc)	    /* DOSO_ value */
  {
      struct source_cookie    cookie;
      char_u		    *save_sourcing_name;
***************
*** 3628,3635 ****
   * ":scriptnames"
   */
      void
! ex_scriptnames(eap)
!     exarg_T	*eap UNUSED;
  {
      int i;
  
--- 3550,3556 ----
   * ":scriptnames"
   */
      void
! ex_scriptnames(exarg_T *eap UNUSED)
  {
      int i;
  
***************
*** 3647,3653 ****
   * Fix slashes in the list of script names for 'shellslash'.
   */
      void
! scriptnames_slash_adjust()
  {
      int i;
  
--- 3568,3574 ----
   * Fix slashes in the list of script names for 'shellslash'.
   */
      void
! scriptnames_slash_adjust(void)
  {
      int i;
  
***************
*** 3661,3668 ****
   * Get a pointer to a script name.  Used for ":verbose set".
   */
      char_u *
! get_scriptname(id)
!     scid_T	id;
  {
      if (id == SID_MODELINE)
  	return (char_u *)_("modeline");
--- 3582,3588 ----
   * Get a pointer to a script name.  Used for ":verbose set".
   */
      char_u *
! get_scriptname(scid_T id)
  {
      if (id == SID_MODELINE)
  	return (char_u *)_("modeline");
***************
*** 3679,3685 ****
  
  # if defined(EXITFREE) || defined(PROTO)
      void
! free_scriptnames()
  {
      int			i;
  
--- 3599,3605 ----
  
  # if defined(EXITFREE) || defined(PROTO)
      void
! free_scriptnames(void)
  {
      int			i;
  
***************
*** 3701,3710 ****
   * Codewarrior Pro 2.
   */
      char *
! fgets_cr(s, n, stream)
!     char	*s;
!     int		n;
!     FILE	*stream;
  {
      return fgets(s, n, stream);
  }
--- 3621,3627 ----
   * Codewarrior Pro 2.
   */
      char *
! fgets_cr(char *s, int n, FILE *stream)
  {
      return fgets(s, n, stream);
  }
***************
*** 3758,3767 ****
   * Return NULL for end-of-file or some error.
   */
      char_u *
! getsourceline(c, cookie, indent)
!     int		c UNUSED;
!     void	*cookie;
!     int		indent UNUSED;
  {
      struct source_cookie *sp = (struct source_cookie *)cookie;
      char_u		*line;
--- 3675,3681 ----
   * Return NULL for end-of-file or some error.
   */
      char_u *
! getsourceline(int c UNUSED, void *cookie, int indent UNUSED)
  {
      struct source_cookie *sp = (struct source_cookie *)cookie;
      char_u		*line;
***************
*** 3872,3879 ****
  }
  
      static char_u *
! get_one_sourceline(sp)
!     struct source_cookie    *sp;
  {
      garray_T		ga;
      int			len;
--- 3786,3792 ----
  }
  
      static char_u *
! get_one_sourceline(struct source_cookie *sp)
  {
      garray_T		ga;
      int			len;
***************
*** 4029,4035 ****
   * until later and we need to store the time now.
   */
      void
! script_line_start()
  {
      scriptitem_T    *si;
      sn_prl_T	    *pp;
--- 3942,3948 ----
   * until later and we need to store the time now.
   */
      void
! script_line_start(void)
  {
      scriptitem_T    *si;
      sn_prl_T	    *pp;
***************
*** 4064,4070 ****
   * Called when actually executing a function line.
   */
      void
! script_line_exec()
  {
      scriptitem_T    *si;
  
--- 3977,3983 ----
   * Called when actually executing a function line.
   */
      void
! script_line_exec(void)
  {
      scriptitem_T    *si;
  
***************
*** 4079,4085 ****
   * Called when done with a function line.
   */
      void
! script_line_end()
  {
      scriptitem_T    *si;
      sn_prl_T	    *pp;
--- 3992,3998 ----
   * Called when done with a function line.
   */
      void
! script_line_end(void)
  {
      scriptitem_T    *si;
      sn_prl_T	    *pp;
***************
*** 4110,4117 ****
   * Without the multi-byte feature it's simply ignored.
   */
      void
! ex_scriptencoding(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_MBYTE
      struct source_cookie	*sp;
--- 4023,4029 ----
   * Without the multi-byte feature it's simply ignored.
   */
      void
! ex_scriptencoding(exarg_T *eap UNUSED)
  {
  #ifdef FEAT_MBYTE
      struct source_cookie	*sp;
***************
*** 4146,4153 ****
   * ":finish": Mark a sourced file as finished.
   */
      void
! ex_finish(eap)
!     exarg_T	*eap;
  {
      if (getline_equal(eap->getline, eap->cookie, getsourceline))
  	do_finish(eap, FALSE);
--- 4058,4064 ----
   * ":finish": Mark a sourced file as finished.
   */
      void
! ex_finish(exarg_T *eap)
  {
      if (getline_equal(eap->getline, eap->cookie, getsourceline))
  	do_finish(eap, FALSE);
***************
*** 4161,4169 ****
   * an extra do_cmdline().  "reanimate" is used in the latter case.
   */
      void
! do_finish(eap, reanimate)
!     exarg_T	*eap;
!     int		reanimate;
  {
      int		idx;
  
--- 4072,4078 ----
   * an extra do_cmdline().  "reanimate" is used in the latter case.
   */
      void
! do_finish(exarg_T *eap, int reanimate)
  {
      int		idx;
  
***************
*** 4195,4203 ****
   * Return FALSE when not sourcing a file.
   */
      int
! source_finished(fgetline, cookie)
!     char_u	*(*fgetline)(int, void *, int);
!     void	*cookie;
  {
      return (getline_equal(fgetline, cookie, getsourceline)
  	    && ((struct source_cookie *)getline_cookie(
--- 4104,4112 ----
   * Return FALSE when not sourcing a file.
   */
      int
! source_finished(
!     char_u	*(*fgetline)(int, void *, int),
!     void	*cookie)
  {
      return (getline_equal(fgetline, cookie, getsourceline)
  	    && ((struct source_cookie *)getline_cookie(
***************
*** 4210,4217 ****
   * ":checktime [buffer]"
   */
      void
! ex_checktime(eap)
!     exarg_T	*eap;
  {
      buf_T	*buf;
      int		save_no_check_timestamps = no_check_timestamps;
--- 4119,4125 ----
   * ":checktime [buffer]"
   */
      void
! ex_checktime(exarg_T *eap)
  {
      buf_T	*buf;
      int		save_no_check_timestamps = no_check_timestamps;
***************
*** 4235,4242 ****
  static char *get_locale_val(int what);
  
      static char *
! get_locale_val(what)
!     int		what;
  {
      char	*loc;
  
--- 4143,4149 ----
  static char *get_locale_val(int what);
  
      static char *
! get_locale_val(int what)
  {
      char	*loc;
  
***************
*** 4317,4323 ****
   * 'helplang'.  May return NULL or an empty string.
   */
      char_u *
! get_mess_lang()
  {
      char_u *p;
  
--- 4224,4230 ----
   * 'helplang'.  May return NULL or an empty string.
   */
      char_u *
! get_mess_lang(void)
  {
      char_u *p;
  
***************
*** 4359,4365 ****
   * Get the language used for messages from the environment.
   */
      static char_u *
! get_mess_env()
  {
      char_u	*p;
  
--- 4266,4272 ----
   * Get the language used for messages from the environment.
   */
      static char_u *
! get_mess_env(void)
  {
      char_u	*p;
  
***************
*** 4389,4395 ****
   * Also do "v:lc_time"and "v:ctype".
   */
      void
! set_lang_var()
  {
      char_u	*loc;
  
--- 4296,4302 ----
   * Also do "v:lc_time"and "v:ctype".
   */
      void
! set_lang_var(void)
  {
      char_u	*loc;
  
***************
*** 4423,4430 ****
   * ":language":  Set the language (locale).
   */
      void
! ex_language(eap)
!     exarg_T	*eap;
  {
      char	*loc;
      char_u	*p;
--- 4330,4336 ----
   * ":language":  Set the language (locale).
   */
      void
! ex_language(exarg_T *eap)
  {
      char	*loc;
      char_u	*p;
***************
*** 4562,4568 ****
   * Lazy initialization of all available locales.
   */
      static void
! init_locales()
  {
      if (!did_init_locales)
      {
--- 4468,4474 ----
   * Lazy initialization of all available locales.
   */
      static void
! init_locales(void)
  {
      if (!did_init_locales)
      {
***************
*** 4574,4580 ****
  /* Return an array of strings for all available locales + NULL for the
   * last element.  Return NULL in case of error. */
      static char_u **
! find_locales()
  {
      garray_T	locales_ga;
      char_u	*loc;
--- 4480,4486 ----
  /* Return an array of strings for all available locales + NULL for the
   * last element.  Return NULL in case of error. */
      static char_u **
! find_locales(void)
  {
      garray_T	locales_ga;
      char_u	*loc;
***************
*** 4614,4620 ****
  
  #  if defined(EXITFREE) || defined(PROTO)
      void
! free_locales()
  {
      int			i;
      if (locales != NULL)
--- 4520,4526 ----
  
  #  if defined(EXITFREE) || defined(PROTO)
      void
! free_locales(void)
  {
      int			i;
      if (locales != NULL)
***************
*** 4632,4640 ****
   * ":language" command.
   */
      char_u *
! get_lang_arg(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (idx == 0)
  	return (char_u *)"messages";
--- 4538,4544 ----
   * ":language" command.
   */
      char_u *
! get_lang_arg(expand_T *xp UNUSED, int idx)
  {
      if (idx == 0)
  	return (char_u *)"messages";
***************
*** 4653,4661 ****
   * Function given to ExpandGeneric() to obtain the available locales.
   */
      char_u *
! get_locales(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      init_locales();
      if (locales == NULL)
--- 4557,4563 ----
   * Function given to ExpandGeneric() to obtain the available locales.
   */
      char_u *
! get_locales(expand_T *xp UNUSED, int idx)
  {
      init_locales();
      if (locales == NULL)
*** ../vim-7.4.1205/src/ex_docmd.c	2016-01-29 22:03:43.481945824 +0100
--- src/ex_docmd.c	2016-01-30 15:35:48.461944849 +0100
***************
*** 586,593 ****
  static void restore_dbg_stuff(struct dbg_stuff *dsp);
  
      static void
! save_dbg_stuff(dsp)
!     struct dbg_stuff *dsp;
  {
      dsp->trylevel	= trylevel;		trylevel = 0;
      dsp->force_abort	= force_abort;		force_abort = FALSE;
--- 586,592 ----
  static void restore_dbg_stuff(struct dbg_stuff *dsp);
  
      static void
! save_dbg_stuff(struct dbg_stuff *dsp)
  {
      dsp->trylevel	= trylevel;		trylevel = 0;
      dsp->force_abort	= force_abort;		force_abort = FALSE;
***************
*** 605,612 ****
  }
  
      static void
! restore_dbg_stuff(dsp)
!     struct dbg_stuff *dsp;
  {
      suppress_errthrow = FALSE;
      trylevel = dsp->trylevel;
--- 604,610 ----
  }
  
      static void
! restore_dbg_stuff(struct dbg_stuff *dsp)
  {
      suppress_errthrow = FALSE;
      trylevel = dsp->trylevel;
***************
*** 629,636 ****
   * command is given.
   */
      void
! do_exmode(improved)
!     int		improved;	    /* TRUE for "improved Ex" mode */
  {
      int		save_msg_scroll;
      int		prev_msg_row;
--- 627,634 ----
   * command is given.
   */
      void
! do_exmode(
!     int		improved)	    /* TRUE for "improved Ex" mode */
  {
      int		save_msg_scroll;
      int		prev_msg_row;
***************
*** 732,739 ****
   * Execute a simple command line.  Used for translated commands like "*".
   */
      int
! do_cmdline_cmd(cmd)
!     char_u	*cmd;
  {
      return do_cmdline(cmd, NULL, NULL,
  				   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);
--- 730,736 ----
   * Execute a simple command line.  Used for translated commands like "*".
   */
      int
! do_cmdline_cmd(char_u *cmd)
  {
      return do_cmdline(cmd, NULL, NULL,
  				   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);
***************
*** 759,769 ****
   * return FAIL if cmdline could not be executed, OK otherwise
   */
      int
! do_cmdline(cmdline, fgetline, cookie, flags)
!     char_u	*cmdline;
!     char_u	*(*fgetline)(int, void *, int);
!     void	*cookie;		/* argument for fgetline() */
!     int		flags;
  {
      char_u	*next_cmdline;		/* next cmd to execute */
      char_u	*cmdline_copy = NULL;	/* copy of cmd line */
--- 756,766 ----
   * return FAIL if cmdline could not be executed, OK otherwise
   */
      int
! do_cmdline(
!     char_u	*cmdline,
!     char_u	*(*fgetline)(int, void *, int),
!     void	*cookie,		/* argument for fgetline() */
!     int		flags)
  {
      char_u	*next_cmdline;		/* next cmd to execute */
      char_u	*cmdline_copy = NULL;	/* copy of cmd line */
***************
*** 1558,1567 ****
   * Obtain a line when inside a ":while" or ":for" loop.
   */
      static char_u *
! get_loop_line(c, cookie, indent)
!     int		c;
!     void	*cookie;
!     int		indent;
  {
      struct loop_cookie	*cp = (struct loop_cookie *)cookie;
      wcmd_T		*wp;
--- 1555,1561 ----
   * Obtain a line when inside a ":while" or ":for" loop.
   */
      static char_u *
! get_loop_line(int c, void *cookie, int indent)
  {
      struct loop_cookie	*cp = (struct loop_cookie *)cookie;
      wcmd_T		*wp;
***************
*** 1594,1602 ****
   * Store a line in "gap" so that a ":while" loop can execute it again.
   */
      static int
! store_loop_line(gap, line)
!     garray_T	*gap;
!     char_u	*line;
  {
      if (ga_grow(gap, 1) == FAIL)
  	return FAIL;
--- 1588,1594 ----
   * Store a line in "gap" so that a ":while" loop can execute it again.
   */
      static int
! store_loop_line(garray_T *gap, char_u *line)
  {
      if (ga_grow(gap, 1) == FAIL)
  	return FAIL;
***************
*** 1610,1617 ****
   * Free the lines stored for a ":while" or ":for" loop.
   */
      static void
! free_cmdlines(gap)
!     garray_T	*gap;
  {
      while (gap->ga_len > 0)
      {
--- 1602,1608 ----
   * Free the lines stored for a ":while" or ":for" loop.
   */
      static void
! free_cmdlines(garray_T *gap)
  {
      while (gap->ga_len > 0)
      {
***************
*** 1626,1635 ****
   * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
      int
! getline_equal(fgetline, cookie, func)
!     char_u	*(*fgetline)(int, void *, int);
!     void	*cookie UNUSED;		/* argument for fgetline() */
!     char_u	*(*func)(int, void *, int);
  {
  #ifdef FEAT_EVAL
      char_u		*(*gp)(int, void *, int);
--- 1617,1626 ----
   * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
      int
! getline_equal(
!     char_u	*(*fgetline)(int, void *, int),
!     void	*cookie UNUSED,		/* argument for fgetline() */
!     char_u	*(*func)(int, void *, int))
  {
  #ifdef FEAT_EVAL
      char_u		*(*gp)(int, void *, int);
***************
*** 1657,1665 ****
   * getline function.  Otherwise return "cookie".
   */
      void *
! getline_cookie(fgetline, cookie)
!     char_u	*(*fgetline)(int, void *, int) UNUSED;
!     void	*cookie;		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
      char_u		*(*gp)(int, void *, int);
--- 1648,1656 ----
   * getline function.  Otherwise return "cookie".
   */
      void *
! getline_cookie(
!     char_u	*(*fgetline)(int, void *, int) UNUSED,
!     void	*cookie)		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
      char_u		*(*gp)(int, void *, int);
***************
*** 1689,1698 ****
   * Returns the buffer number.
   */
      static int
! compute_buffer_local_count(addr_type, lnum, offset)
!     int	    addr_type;
!     int	    lnum;
!     int	    offset;
  {
      buf_T   *buf;
      buf_T   *nextbuf;
--- 1680,1686 ----
   * Returns the buffer number.
   */
      static int
! compute_buffer_local_count(int addr_type, int lnum, int offset)
  {
      buf_T   *buf;
      buf_T   *nextbuf;
***************
*** 1735,1742 ****
  static int current_tab_nr(tabpage_T *tab);
  
      static int
! current_win_nr(win)
!     win_T	*win;
  {
      win_T	*wp;
      int		nr = 0;
--- 1723,1729 ----
  static int current_tab_nr(tabpage_T *tab);
  
      static int
! current_win_nr(win_T *win)
  {
      win_T	*wp;
      int		nr = 0;
***************
*** 1751,1758 ****
  }
  
      static int
! current_tab_nr(tab)
!     tabpage_T   *tab;
  {
      tabpage_T	*tp;
      int		nr = 0;
--- 1738,1744 ----
  }
  
      static int
! current_tab_nr(tabpage_T *tab)
  {
      tabpage_T	*tp;
      int		nr = 0;
***************
*** 1802,1819 ****
   #pragma optimize( "g", off )
  #endif
      static char_u *
! do_one_cmd(cmdlinep, sourcing,
! #ifdef FEAT_EVAL
! 			    cstack,
! #endif
! 				    fgetline, cookie)
!     char_u		**cmdlinep;
!     int			sourcing;
  #ifdef FEAT_EVAL
!     struct condstack	*cstack;
  #endif
!     char_u		*(*fgetline)(int, void *, int);
!     void		*cookie;		/* argument for fgetline() */
  {
      char_u		*p;
      linenr_T		lnum;
--- 1788,1801 ----
   #pragma optimize( "g", off )
  #endif
      static char_u *
! do_one_cmd(
!     char_u		**cmdlinep,
!     int			sourcing,
  #ifdef FEAT_EVAL
!     struct condstack	*cstack,
  #endif
!     char_u		*(*fgetline)(int, void *, int),
!     void		*cookie)		/* argument for fgetline() */
  {
      char_u		*p;
      linenr_T		lnum;
***************
*** 3064,3073 ****
   * If there is a match advance "pp" to the argument and return TRUE.
   */
      int
! checkforcmd(pp, cmd, len)
!     char_u	**pp;		/* start of command */
!     char	*cmd;		/* name of command */
!     int		len;		/* required length */
  {
      int		i;
  
--- 3046,3055 ----
   * If there is a match advance "pp" to the argument and return TRUE.
   */
      int
! checkforcmd(
!     char_u	**pp,		/* start of command */
!     char	*cmd,		/* name of command */
!     int		len)		/* required length */
  {
      int		i;
  
***************
*** 3088,3095 ****
   * invisible otherwise.
   */
      static void
! append_command(cmd)
!     char_u *cmd;
  {
      char_u *s = cmd;
      char_u *d;
--- 3070,3076 ----
   * invisible otherwise.
   */
      static void
! append_command(char_u *cmd)
  {
      char_u *s = cmd;
      char_u *d;
***************
*** 3126,3134 ****
   * Returns NULL for an ambiguous user command.
   */
      static char_u *
! find_command(eap, full)
!     exarg_T	*eap;
!     int		*full UNUSED;
  {
      int		len;
      char_u	*p;
--- 3107,3113 ----
   * Returns NULL for an ambiguous user command.
   */
      static char_u *
! find_command(exarg_T *eap, int *full UNUSED)
  {
      int		len;
      char_u	*p;
***************
*** 3235,3246 ****
   * Return NULL if there is no matching command.
   */
      static char_u *
! find_ucmd(eap, p, full, xp, compl)
!     exarg_T	*eap;
!     char_u	*p;	/* end of the command (possibly including count) */
!     int		*full;	/* set to TRUE for a full match */
!     expand_T	*xp;	/* used for completion, NULL otherwise */
!     int		*compl;	/* completion flags or NULL */
  {
      int		len = (int)(p - eap->cmd);
      int		j, k, matchlen = 0;
--- 3214,3225 ----
   * Return NULL if there is no matching command.
   */
      static char_u *
! find_ucmd(
!     exarg_T	*eap,
!     char_u	*p,	/* end of the command (possibly including count) */
!     int		*full,	/* set to TRUE for a full match */
!     expand_T	*xp,	/* used for completion, NULL otherwise */
!     int		*compl)	/* completion flags or NULL */
  {
      int		len = (int)(p - eap->cmd);
      int		j, k, matchlen = 0;
***************
*** 3380,3387 ****
   * Return zero when it's not a modifier.
   */
      int
! modifier_len(cmd)
!     char_u	*cmd;
  {
      int		i, j;
      char_u	*p = cmd;
--- 3359,3365 ----
   * Return zero when it's not a modifier.
   */
      int
! modifier_len(char_u *cmd)
  {
      int		i, j;
      char_u	*p = cmd;
***************
*** 3406,3413 ****
   * Return 3 if there is an ambiguous match.
   */
      int
! cmd_exists(name)
!     char_u	*name;
  {
      exarg_T	ea;
      int		full = FALSE;
--- 3384,3390 ----
   * Return 3 if there is an ambiguous match.
   */
      int
! cmd_exists(char_u *name)
  {
      exarg_T	ea;
      int		full = FALSE;
***************
*** 3448,3456 ****
   * probably won't change that much -- webb.
   */
      char_u *
! set_one_cmd_context(xp, buff)
!     expand_T	*xp;
!     char_u	*buff;	    /* buffer for command string */
  {
      char_u		*p;
      char_u		*cmd, *arg;
--- 3425,3433 ----
   * probably won't change that much -- webb.
   */
      char_u *
! set_one_cmd_context(
!     expand_T	*xp,
!     char_u	*buff)	    /* buffer for command string */
  {
      char_u		*p;
      char_u		*cmd, *arg;
***************
*** 4308,4316 ****
   * Returns the "cmd" pointer advanced to beyond the range.
   */
      char_u *
! skip_range(cmd, ctx)
!     char_u	*cmd;
!     int		*ctx;	/* pointer to xp_context or NULL */
  {
      unsigned	delim;
  
--- 4285,4293 ----
   * Returns the "cmd" pointer advanced to beyond the range.
   */
      char_u *
! skip_range(
!     char_u	*cmd,
!     int		*ctx)	/* pointer to xp_context or NULL */
  {
      unsigned	delim;
  
***************
*** 4350,4361 ****
   * Return MAXLNUM when no Ex address was found.
   */
      static linenr_T
! get_address(eap, ptr, addr_type, skip, to_other_file)
!     exarg_T	*eap UNUSED;
!     char_u	**ptr;
!     int		addr_type;  /* flag: one of ADDR_LINES, ... */
!     int		skip;	    /* only skip the address, don't use it */
!     int		to_other_file;  /* flag: may jump to other file */
  {
      int		c;
      int		i;
--- 4327,4338 ----
   * Return MAXLNUM when no Ex address was found.
   */
      static linenr_T
! get_address(
!     exarg_T	*eap UNUSED,
!     char_u	**ptr,
!     int		addr_type,  /* flag: one of ADDR_LINES, ... */
!     int		skip,	    /* only skip the address, don't use it */
!     int		to_other_file)  /* flag: may jump to other file */
  {
      int		c;
      int		i;
***************
*** 4647,4654 ****
   * Get flags from an Ex command argument.
   */
      static void
! get_flags(eap)
!     exarg_T *eap;
  {
      while (vim_strchr((char_u *)"lp#", *eap->arg) != NULL)
      {
--- 4624,4630 ----
   * Get flags from an Ex command argument.
   */
      static void
! get_flags(exarg_T *eap)
  {
      while (vim_strchr((char_u *)"lp#", *eap->arg) != NULL)
      {
***************
*** 4666,4673 ****
   * Function called for command which is Not Implemented.  NI!
   */
      void
! ex_ni(eap)
!     exarg_T	*eap;
  {
      if (!eap->skip)
  	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
--- 4642,4648 ----
   * Function called for command which is Not Implemented.  NI!
   */
      void
! ex_ni(exarg_T *eap)
  {
      if (!eap->skip)
  	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
***************
*** 4679,4686 ****
   * Skips over ":perl <<EOF" constructs.
   */
      static void
! ex_script_ni(eap)
!     exarg_T	*eap;
  {
      if (!eap->skip)
  	ex_ni(eap);
--- 4654,4660 ----
   * Skips over ":perl <<EOF" constructs.
   */
      static void
! ex_script_ni(exarg_T *eap)
  {
      if (!eap->skip)
  	ex_ni(eap);
***************
*** 4694,4701 ****
   * Return NULL when valid, error message when invalid.
   */
      static char_u *
! invalid_range(eap)
!     exarg_T	*eap;
  {
      buf_T	*buf;
      if (       eap->line1 < 0
--- 4668,4674 ----
   * Return NULL when valid, error message when invalid.
   */
      static char_u *
! invalid_range(exarg_T *eap)
  {
      buf_T	*buf;
      if (       eap->line1 < 0
***************
*** 4769,4776 ****
   * Correct the range for zero line number, if required.
   */
      static void
! correct_range(eap)
!     exarg_T	*eap;
  {
      if (!(eap->argt & ZEROR))	    /* zero in range not allowed */
      {
--- 4742,4748 ----
   * Correct the range for zero line number, if required.
   */
      static void
! correct_range(exarg_T *eap)
  {
      if (!(eap->argt & ZEROR))	    /* zero in range not allowed */
      {
***************
*** 4789,4796 ****
   * pattern.  Otherwise return eap->arg.
   */
      static char_u *
! skip_grep_pat(eap)
!     exarg_T	*eap;
  {
      char_u	*p = eap->arg;
  
--- 4761,4767 ----
   * pattern.  Otherwise return eap->arg.
   */
      static char_u *
! skip_grep_pat(exarg_T *eap)
  {
      char_u	*p = eap->arg;
  
***************
*** 4811,4820 ****
   * in the command line, so that things like % get expanded.
   */
      static char_u *
! replace_makeprg(eap, p, cmdlinep)
!     exarg_T	*eap;
!     char_u	*p;
!     char_u	**cmdlinep;
  {
      char_u	*new_cmdline;
      char_u	*program;
--- 4782,4788 ----
   * in the command line, so that things like % get expanded.
   */
      static char_u *
! replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)
  {
      char_u	*new_cmdline;
      char_u	*program;
***************
*** 4896,4905 ****
   * Return FAIL for failure, OK otherwise.
   */
      int
! expand_filename(eap, cmdlinep, errormsgp)
!     exarg_T	*eap;
!     char_u	**cmdlinep;
!     char_u	**errormsgp;
  {
      int		has_wildcards;	/* need to expand wildcards */
      char_u	*repl;
--- 4864,4873 ----
   * Return FAIL for failure, OK otherwise.
   */
      int
! expand_filename(
!     exarg_T	*eap,
!     char_u	**cmdlinep,
!     char_u	**errormsgp)
  {
      int		has_wildcards;	/* need to expand wildcards */
      char_u	*repl;
***************
*** 5138,5149 ****
   * Returns NULL for failure.
   */
      static char_u *
! repl_cmdline(eap, src, srclen, repl, cmdlinep)
!     exarg_T	*eap;
!     char_u	*src;
!     int		srclen;
!     char_u	*repl;
!     char_u	**cmdlinep;
  {
      int		len;
      int		i;
--- 5106,5117 ----
   * Returns NULL for failure.
   */
      static char_u *
! repl_cmdline(
!     exarg_T	*eap,
!     char_u	*src,
!     int		srclen,
!     char_u	*repl,
!     char_u	**cmdlinep)
  {
      int		len;
      int		i;
***************
*** 5195,5202 ****
   * Check for '|' to separate commands and '"' to start comments.
   */
      void
! separate_nextcmd(eap)
!     exarg_T	*eap;
  {
      char_u	*p;
  
--- 5163,5169 ----
   * Check for '|' to separate commands and '"' to start comments.
   */
      void
! separate_nextcmd(exarg_T *eap)
  {
      char_u	*p;
  
***************
*** 5265,5272 ****
   * get + command from ex argument
   */
      static char_u *
! getargcmd(argp)
!     char_u **argp;
  {
      char_u *arg = *argp;
      char_u *command = NULL;
--- 5232,5238 ----
   * get + command from ex argument
   */
      static char_u *
! getargcmd(char_u **argp)
  {
      char_u *arg = *argp;
      char_u *command = NULL;
***************
*** 5294,5302 ****
   * Find end of "+command" argument.  Skip over "\ " and "\\".
   */
      static char_u *
! skip_cmd_arg(p, rembs)
!     char_u *p;
!     int	   rembs;	/* TRUE to halve the number of backslashes */
  {
      while (*p && !vim_isspace(*p))
      {
--- 5260,5268 ----
   * Find end of "+command" argument.  Skip over "\ " and "\\".
   */
      static char_u *
! skip_cmd_arg(
!     char_u *p,
!     int	   rembs)	/* TRUE to halve the number of backslashes */
  {
      while (*p && !vim_isspace(*p))
      {
***************
*** 5317,5324 ****
   * Return FAIL or OK.
   */
      static int
! getargopt(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg + 2;
      int		*pp = NULL;
--- 5283,5289 ----
   * Return FAIL or OK.
   */
      static int
! getargopt(exarg_T *eap)
  {
      char_u	*arg = eap->arg + 2;
      int		*pp = NULL;
***************
*** 5423,5430 ****
   * ":abbreviate" and friends.
   */
      static void
! ex_abbreviate(eap)
!     exarg_T	*eap;
  {
      do_exmap(eap, TRUE);	/* almost the same as mapping */
  }
--- 5388,5394 ----
   * ":abbreviate" and friends.
   */
      static void
! ex_abbreviate(exarg_T *eap)
  {
      do_exmap(eap, TRUE);	/* almost the same as mapping */
  }
***************
*** 5433,5440 ****
   * ":map" and friends.
   */
      static void
! ex_map(eap)
!     exarg_T	*eap;
  {
      /*
       * If we are sourcing .exrc or .vimrc in current directory we
--- 5397,5403 ----
   * ":map" and friends.
   */
      static void
! ex_map(exarg_T *eap)
  {
      /*
       * If we are sourcing .exrc or .vimrc in current directory we
***************
*** 5453,5460 ****
   * ":unmap" and friends.
   */
      static void
! ex_unmap(eap)
!     exarg_T	*eap;
  {
      do_exmap(eap, FALSE);
  }
--- 5416,5422 ----
   * ":unmap" and friends.
   */
      static void
! ex_unmap(exarg_T *eap)
  {
      do_exmap(eap, FALSE);
  }
***************
*** 5463,5470 ****
   * ":mapclear" and friends.
   */
      static void
! ex_mapclear(eap)
!     exarg_T	*eap;
  {
      map_clear(eap->cmd, eap->arg, eap->forceit, FALSE);
  }
--- 5425,5431 ----
   * ":mapclear" and friends.
   */
      static void
! ex_mapclear(exarg_T *eap)
  {
      map_clear(eap->cmd, eap->arg, eap->forceit, FALSE);
  }
***************
*** 5473,5488 ****
   * ":abclear" and friends.
   */
      static void
! ex_abclear(eap)
!     exarg_T	*eap;
  {
      map_clear(eap->cmd, eap->arg, TRUE, TRUE);
  }
  
  #if defined(FEAT_AUTOCMD) || defined(PROTO)
      static void
! ex_autocmd(eap)
!     exarg_T	*eap;
  {
      /*
       * Disallow auto commands from .exrc and .vimrc in current
--- 5434,5447 ----
   * ":abclear" and friends.
   */
      static void
! ex_abclear(exarg_T *eap)
  {
      map_clear(eap->cmd, eap->arg, TRUE, TRUE);
  }
  
  #if defined(FEAT_AUTOCMD) || defined(PROTO)
      static void
! ex_autocmd(exarg_T *eap)
  {
      /*
       * Disallow auto commands from .exrc and .vimrc in current
***************
*** 5503,5510 ****
   * ":doautocmd": Apply the automatic commands to the current buffer.
   */
      static void
! ex_doautocmd(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      int		call_do_modelines = check_nomodeline(&arg);
--- 5462,5468 ----
   * ":doautocmd": Apply the automatic commands to the current buffer.
   */
      static void
! ex_doautocmd(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      int		call_do_modelines = check_nomodeline(&arg);
***************
*** 5522,5529 ****
   * :[N]bwipeout[!] [N] [bufname] delete buffer really
   */
      static void
! ex_bunload(eap)
!     exarg_T	*eap;
  {
      eap->errmsg = do_bufdel(
  	    eap->cmdidx == CMD_bdelete ? DOBUF_DEL
--- 5480,5486 ----
   * :[N]bwipeout[!] [N] [bufname] delete buffer really
   */
      static void
! ex_bunload(exarg_T *eap)
  {
      eap->errmsg = do_bufdel(
  	    eap->cmdidx == CMD_bdelete ? DOBUF_DEL
***************
*** 5537,5544 ****
   * :[N]sbuffer [N]	to buffer N
   */
      static void
! ex_buffer(eap)
!     exarg_T	*eap;
  {
      if (*eap->arg)
  	eap->errmsg = e_trailing;
--- 5494,5500 ----
   * :[N]sbuffer [N]	to buffer N
   */
      static void
! ex_buffer(exarg_T *eap)
  {
      if (*eap->arg)
  	eap->errmsg = e_trailing;
***************
*** 5558,5565 ****
   * :[N]sbmodified [N]	to next mod. buffer
   */
      static void
! ex_bmodified(eap)
!     exarg_T	*eap;
  {
      goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);
      if (eap->do_ecmd_cmd != NULL)
--- 5514,5520 ----
   * :[N]sbmodified [N]	to next mod. buffer
   */
      static void
! ex_bmodified(exarg_T *eap)
  {
      goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);
      if (eap->do_ecmd_cmd != NULL)
***************
*** 5571,5578 ****
   * :[N]sbnext [N]	split and to next buffer
   */
      static void
! ex_bnext(eap)
!     exarg_T	*eap;
  {
      goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);
      if (eap->do_ecmd_cmd != NULL)
--- 5526,5532 ----
   * :[N]sbnext [N]	split and to next buffer
   */
      static void
! ex_bnext(exarg_T *eap)
  {
      goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);
      if (eap->do_ecmd_cmd != NULL)
***************
*** 5586,5593 ****
   * :[N]sbprevious [N]	split and to previous buffer
   */
      static void
! ex_bprevious(eap)
!     exarg_T	*eap;
  {
      goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);
      if (eap->do_ecmd_cmd != NULL)
--- 5540,5546 ----
   * :[N]sbprevious [N]	split and to previous buffer
   */
      static void
! ex_bprevious(exarg_T *eap)
  {
      goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);
      if (eap->do_ecmd_cmd != NULL)
***************
*** 5601,5608 ****
   * :sbfirst		split and to first buffer
   */
      static void
! ex_brewind(eap)
!     exarg_T	*eap;
  {
      goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);
      if (eap->do_ecmd_cmd != NULL)
--- 5554,5560 ----
   * :sbfirst		split and to first buffer
   */
      static void
! ex_brewind(exarg_T *eap)
  {
      goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);
      if (eap->do_ecmd_cmd != NULL)
***************
*** 5614,5621 ****
   * :sblast		split and to last buffer
   */
      static void
! ex_blast(eap)
!     exarg_T	*eap;
  {
      goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);
      if (eap->do_ecmd_cmd != NULL)
--- 5566,5572 ----
   * :sblast		split and to last buffer
   */
      static void
! ex_blast(exarg_T *eap)
  {
      goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);
      if (eap->do_ecmd_cmd != NULL)
***************
*** 5624,5631 ****
  #endif
  
      int
! ends_excmd(c)
!     int	    c;
  {
      return (c == NUL || c == '|' || c == '"' || c == '\n');
  }
--- 5575,5581 ----
  #endif
  
      int
! ends_excmd(int c)
  {
      return (c == NUL || c == '|' || c == '"' || c == '\n');
  }
***************
*** 5637,5644 ****
   * Return NULL if not found.
   */
      char_u *
! find_nextcmd(p)
!     char_u	*p;
  {
      while (*p != '|' && *p != '\n')
      {
--- 5587,5593 ----
   * Return NULL if not found.
   */
      char_u *
! find_nextcmd(char_u *p)
  {
      while (*p != '|' && *p != '\n')
      {
***************
*** 5655,5662 ****
   * Return NULL if it isn't, (p + 1) if it is.
   */
      char_u *
! check_nextcmd(p)
!     char_u	*p;
  {
      p = skipwhite(p);
      if (*p == '|' || *p == '\n')
--- 5604,5610 ----
   * Return NULL if it isn't, (p + 1) if it is.
   */
      char_u *
! check_nextcmd(char_u *p)
  {
      p = skipwhite(p);
      if (*p == '|' || *p == '\n')
***************
*** 5674,5682 ****
   * return OK otherwise
   */
      static int
! check_more(message, forceit)
!     int message;	    /* when FALSE check only, no messages */
!     int forceit;
  {
      int	    n = ARGCOUNT - curwin->w_arg_idx - 1;
  
--- 5622,5630 ----
   * return OK otherwise
   */
      static int
! check_more(
!     int message,	    /* when FALSE check only, no messages */
!     int forceit)
  {
      int	    n = ARGCOUNT - curwin->w_arg_idx - 1;
  
***************
*** 5718,5726 ****
   * Function given to ExpandGeneric() to obtain the list of command names.
   */
      char_u *
! get_command_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (idx >= (int)CMD_SIZE)
  # ifdef FEAT_USR_CMDS
--- 5666,5672 ----
   * Function given to ExpandGeneric() to obtain the list of command names.
   */
      char_u *
! get_command_name(expand_T *xp UNUSED, int idx)
  {
      if (idx >= (int)CMD_SIZE)
  # ifdef FEAT_USR_CMDS
***************
*** 5740,5756 ****
  static size_t	uc_check_code(char_u *code, size_t len, char_u *buf, ucmd_T *cmd, exarg_T *eap, char_u **split_buf, size_t *split_len);
  
      static int
! uc_add_command(name, name_len, rep, argt, def, flags, compl, compl_arg, addr_type, force)
!     char_u	*name;
!     size_t	name_len;
!     char_u	*rep;
!     long	argt;
!     long	def;
!     int		flags;
!     int		compl;
!     char_u	*compl_arg;
!     int		addr_type;
!     int		force;
  {
      ucmd_T	*cmd = NULL;
      char_u	*p;
--- 5686,5702 ----
  static size_t	uc_check_code(char_u *code, size_t len, char_u *buf, ucmd_T *cmd, exarg_T *eap, char_u **split_buf, size_t *split_len);
  
      static int
! uc_add_command(
!     char_u	*name,
!     size_t	name_len,
!     char_u	*rep,
!     long	argt,
!     long	def,
!     int		flags,
!     int		compl,
!     char_u	*compl_arg,
!     int		addr_type,
!     int		force)
  {
      ucmd_T	*cmd = NULL;
      char_u	*p;
***************
*** 5937,5945 ****
  
  #if defined(FEAT_USR_CMDS) || defined(PROTO)
      static void
! uc_list(name, name_len)
!     char_u	*name;
!     size_t	name_len;
  {
      int		i, j;
      int		found = FALSE;
--- 5883,5889 ----
  
  #if defined(FEAT_USR_CMDS) || defined(PROTO)
      static void
! uc_list(char_u *name, size_t name_len)
  {
      int		i, j;
      int		found = FALSE;
***************
*** 6073,6079 ****
  }
  
      static char_u *
! uc_fun_cmd()
  {
      static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,
  			    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,
--- 6017,6023 ----
  }
  
      static char_u *
! uc_fun_cmd(void)
  {
      static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,
  			    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,
***************
*** 6088,6102 ****
  }
  
      static int
! uc_scan_attr(attr, len, argt, def, flags, compl, compl_arg, addr_type_arg)
!     char_u	*attr;
!     size_t	len;
!     long	*argt;
!     long	*def;
!     int		*flags;
!     int		*compl;
!     char_u	**compl_arg;
!     int		*addr_type_arg;
  {
      char_u	*p;
  
--- 6032,6046 ----
  }
  
      static int
! uc_scan_attr(
!     char_u	*attr,
!     size_t	len,
!     long	*argt,
!     long	*def,
!     int		*flags,
!     int		*compl,
!     char_u	**compl_arg,
!     int		*addr_type_arg)
  {
      char_u	*p;
  
***************
*** 6246,6253 ****
   * ":command ..."
   */
      static void
! ex_command(eap)
!     exarg_T   *eap;
  {
      char_u  *name;
      char_u  *end;
--- 6190,6196 ----
   * ":command ..."
   */
      static void
! ex_command(exarg_T *eap)
  {
      char_u  *name;
      char_u  *end;
***************
*** 6317,6324 ****
   * Clear all user commands, global and for current buffer.
   */
      void
! ex_comclear(eap)
!     exarg_T	*eap UNUSED;
  {
      uc_clear(&ucmds);
      uc_clear(&curbuf->b_ucmds);
--- 6260,6266 ----
   * Clear all user commands, global and for current buffer.
   */
      void
! ex_comclear(exarg_T *eap UNUSED)
  {
      uc_clear(&ucmds);
      uc_clear(&curbuf->b_ucmds);
***************
*** 6328,6335 ****
   * Clear all user commands for "gap".
   */
      void
! uc_clear(gap)
!     garray_T	*gap;
  {
      int		i;
      ucmd_T	*cmd;
--- 6270,6276 ----
   * Clear all user commands for "gap".
   */
      void
! uc_clear(garray_T *gap)
  {
      int		i;
      ucmd_T	*cmd;
***************
*** 6347,6354 ****
  }
  
      static void
! ex_delcommand(eap)
!     exarg_T	*eap;
  {
      int		i = 0;
      ucmd_T	*cmd = NULL;
--- 6288,6294 ----
  }
  
      static void
! ex_delcommand(exarg_T *eap)
  {
      int		i = 0;
      ucmd_T	*cmd = NULL;
***************
*** 6392,6400 ****
   * split and quote args for <f-args>
   */
      static char_u *
! uc_split_args(arg, lenp)
!     char_u *arg;
!     size_t *lenp;
  {
      char_u *buf;
      char_u *p;
--- 6332,6338 ----
   * split and quote args for <f-args>
   */
      static char_u *
! uc_split_args(char_u *arg, size_t *lenp)
  {
      char_u *buf;
      char_u *p;
***************
*** 6501,6514 ****
   * Returns -1 if there was no match, and only the "<" has been copied.
   */
      static size_t
! uc_check_code(code, len, buf, cmd, eap, split_buf, split_len)
!     char_u	*code;
!     size_t	len;
!     char_u	*buf;
!     ucmd_T	*cmd;		/* the user command we're expanding */
!     exarg_T	*eap;		/* ex arguments */
!     char_u	**split_buf;
!     size_t	*split_len;
  {
      size_t	result = 0;
      char_u	*p = code + 1;
--- 6439,6452 ----
   * Returns -1 if there was no match, and only the "<" has been copied.
   */
      static size_t
! uc_check_code(
!     char_u	*code,
!     size_t	len,
!     char_u	*buf,
!     ucmd_T	*cmd,		/* the user command we're expanding */
!     exarg_T	*eap,		/* ex arguments */
!     char_u	**split_buf,
!     size_t	*split_len)
  {
      size_t	result = 0;
      char_u	*p = code + 1;
***************
*** 6697,6704 ****
  }
  
      static void
! do_ucmd(eap)
!     exarg_T	*eap;
  {
      char_u	*buf;
      char_u	*p;
--- 6635,6641 ----
  }
  
      static void
! do_ucmd(exarg_T *eap)
  {
      char_u	*buf;
      char_u	*p;
***************
*** 6827,6834 ****
  
  # if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      static char_u *
! get_user_command_name(idx)
!     int		idx;
  {
      return get_user_commands(NULL, idx - (int)CMD_SIZE);
  }
--- 6764,6770 ----
  
  # if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      static char_u *
! get_user_command_name(int idx)
  {
      return get_user_commands(NULL, idx - (int)CMD_SIZE);
  }
***************
*** 6837,6845 ****
   * Function given to ExpandGeneric() to obtain the list of user command names.
   */
      char_u *
! get_user_commands(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (idx < curbuf->b_ucmds.ga_len)
  	return USER_CMD_GA(&curbuf->b_ucmds, idx)->uc_name;
--- 6773,6779 ----
   * Function given to ExpandGeneric() to obtain the list of user command names.
   */
      char_u *
! get_user_commands(expand_T *xp UNUSED, int idx)
  {
      if (idx < curbuf->b_ucmds.ga_len)
  	return USER_CMD_GA(&curbuf->b_ucmds, idx)->uc_name;
***************
*** 6853,6861 ****
   * Function given to ExpandGeneric() to obtain the list of user address type names.
   */
      char_u *
! get_user_cmd_addr_type(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      return (char_u *)addr_type_complete[idx].name;
  }
--- 6787,6793 ----
   * Function given to ExpandGeneric() to obtain the list of user address type names.
   */
      char_u *
! get_user_cmd_addr_type(expand_T *xp UNUSED, int idx)
  {
      return (char_u *)addr_type_complete[idx].name;
  }
***************
*** 6865,6873 ****
   * attributes.
   */
      char_u *
! get_user_cmd_flags(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      static char *user_cmd_flags[] =
  	{"addr", "bang", "bar", "buffer", "complete",
--- 6797,6803 ----
   * attributes.
   */
      char_u *
! get_user_cmd_flags(expand_T *xp UNUSED, int idx)
  {
      static char *user_cmd_flags[] =
  	{"addr", "bang", "bar", "buffer", "complete",
***************
*** 6882,6890 ****
   * Function given to ExpandGeneric() to obtain the list of values for -nargs.
   */
      char_u *
! get_user_cmd_nargs(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
  
--- 6812,6818 ----
   * Function given to ExpandGeneric() to obtain the list of values for -nargs.
   */
      char_u *
! get_user_cmd_nargs(expand_T *xp UNUSED, int idx)
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
  
***************
*** 6897,6905 ****
   * Function given to ExpandGeneric() to obtain the list of values for -complete.
   */
      char_u *
! get_user_cmd_complete(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      return (char_u *)command_complete[idx].name;
  }
--- 6825,6831 ----
   * Function given to ExpandGeneric() to obtain the list of values for -complete.
   */
      char_u *
! get_user_cmd_complete(expand_T *xp UNUSED, int idx)
  {
      return (char_u *)command_complete[idx].name;
  }
***************
*** 6909,6919 ****
   * Parse address type argument
   */
      int
! parse_addr_type_arg(value, vallen, argt, addr_type_arg)
!     char_u	*value;
!     int		vallen;
!     long	*argt;
!     int		*addr_type_arg;
  {
      int	    i, a, b;
  
--- 6835,6845 ----
   * Parse address type argument
   */
      int
! parse_addr_type_arg(
!     char_u	*value,
!     int		vallen,
!     long	*argt,
!     int		*addr_type_arg)
  {
      int	    i, a, b;
  
***************
*** 6956,6967 ****
   * Returns FAIL if something is wrong.
   */
      int
! parse_compl_arg(value, vallen, complp, argt, compl_arg)
!     char_u	*value;
!     int		vallen;
!     int		*complp;
!     long	*argt;
!     char_u	**compl_arg UNUSED;
  {
      char_u	*arg = NULL;
  # if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
--- 6882,6893 ----
   * Returns FAIL if something is wrong.
   */
      int
! parse_compl_arg(
!     char_u	*value,
!     int		vallen,
!     int		*complp,
!     long	*argt,
!     char_u	**compl_arg UNUSED)
  {
      char_u	*arg = NULL;
  # if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
***************
*** 7032,7039 ****
  #endif
  
      static void
! ex_colorscheme(eap)
!     exarg_T	*eap;
  {
      if (*eap->arg == NUL)
      {
--- 6958,6964 ----
  #endif
  
      static void
! ex_colorscheme(exarg_T *eap)
  {
      if (*eap->arg == NUL)
      {
***************
*** 7064,7071 ****
  }
  
      static void
! ex_highlight(eap)
!     exarg_T	*eap;
  {
      if (*eap->arg == NUL && eap->cmd[2] == '!')
  	MSG(_("Greetings, Vim user!"));
--- 6989,6995 ----
  }
  
      static void
! ex_highlight(exarg_T *eap)
  {
      if (*eap->arg == NUL && eap->cmd[2] == '!')
  	MSG(_("Greetings, Vim user!"));
***************
*** 7078,7084 ****
   * (because of an error).  May need to restore the terminal mode.
   */
      void
! not_exiting()
  {
      exiting = FALSE;
      settmode(TMODE_RAW);
--- 7002,7008 ----
   * (because of an error).  May need to restore the terminal mode.
   */
      void
! not_exiting(void)
  {
      exiting = FALSE;
      settmode(TMODE_RAW);
***************
*** 7088,7095 ****
   * ":quit": quit current window, quit Vim if the last window is closed.
   */
      static void
! ex_quit(eap)
!     exarg_T	*eap;
  {
  #if defined(FEAT_WINDOWS) || defined(FEAT_AUTOCMD)
      win_T	*wp;
--- 7012,7018 ----
   * ":quit": quit current window, quit Vim if the last window is closed.
   */
      static void
! ex_quit(exarg_T *eap)
  {
  #if defined(FEAT_WINDOWS) || defined(FEAT_AUTOCMD)
      win_T	*wp;
***************
*** 7177,7184 ****
   * ":cquit".
   */
      static void
! ex_cquit(eap)
!     exarg_T	*eap UNUSED;
  {
      getout(1);	/* this does not always pass on the exit code to the Manx
  		   compiler. why? */
--- 7100,7106 ----
   * ":cquit".
   */
      static void
! ex_cquit(exarg_T *eap UNUSED)
  {
      getout(1);	/* this does not always pass on the exit code to the Manx
  		   compiler. why? */
***************
*** 7188,7195 ****
   * ":qall": try to quit all windows
   */
      static void
! ex_quit_all(eap)
!     exarg_T	*eap;
  {
  # ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
--- 7110,7116 ----
   * ":qall": try to quit all windows
   */
      static void
! ex_quit_all(exarg_T *eap)
  {
  # ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
***************
*** 7227,7234 ****
   * ":close": close current window, unless it is the last one
   */
      static void
! ex_close(eap)
!     exarg_T	*eap;
  {
      win_T	*win;
      int		winnr = 0;
--- 7148,7154 ----
   * ":close": close current window, unless it is the last one
   */
      static void
! ex_close(exarg_T *eap)
  {
      win_T	*win;
      int		winnr = 0;
***************
*** 7264,7271 ****
   * ":pclose": Close any preview window.
   */
      static void
! ex_pclose(eap)
!     exarg_T	*eap;
  {
      win_T	*win;
  
--- 7184,7190 ----
   * ":pclose": Close any preview window.
   */
      static void
! ex_pclose(exarg_T *eap)
  {
      win_T	*win;
  
***************
*** 7283,7292 ****
   * modified buffer.
   */
      static void
! ex_win_close(forceit, win, tp)
!     int		forceit;
!     win_T	*win;
!     tabpage_T	*tp;		/* NULL or the tab page "win" is in */
  {
      int		need_hide;
      buf_T	*buf = win->w_buffer;
--- 7202,7211 ----
   * modified buffer.
   */
      static void
! ex_win_close(
!     int		forceit,
!     win_T	*win,
!     tabpage_T	*tp)		/* NULL or the tab page "win" is in */
  {
      int		need_hide;
      buf_T	*buf = win->w_buffer;
***************
*** 7326,7333 ****
   * ":tabclose N": close tab page N.
   */
      static void
! ex_tabclose(eap)
!     exarg_T	*eap;
  {
      tabpage_T	*tp;
  
--- 7245,7251 ----
   * ":tabclose N": close tab page N.
   */
      static void
! ex_tabclose(exarg_T *eap)
  {
      tabpage_T	*tp;
  
***************
*** 7367,7374 ****
   * ":tabonly": close all tab pages except the current one
   */
      static void
! ex_tabonly(eap)
!     exarg_T	*eap;
  {
      tabpage_T	*tp;
      int		done;
--- 7285,7291 ----
   * ":tabonly": close all tab pages except the current one
   */
      static void
! ex_tabonly(exarg_T *eap)
  {
      tabpage_T	*tp;
      int		done;
***************
*** 7408,7415 ****
   * Close the current tab page.
   */
      void
! tabpage_close(forceit)
!     int	    forceit;
  {
      /* First close all the windows but the current one.  If that worked then
       * close the last window in this tab, that will close it. */
--- 7325,7331 ----
   * Close the current tab page.
   */
      void
! tabpage_close(int forceit)
  {
      /* First close all the windows but the current one.  If that worked then
       * close the last window in this tab, that will close it. */
***************
*** 7429,7437 ****
   * last-but-one tab page.
   */
      void
! tabpage_close_other(tp, forceit)
!     tabpage_T	*tp;
!     int		forceit;
  {
      int		done = 0;
      win_T	*wp;
--- 7345,7351 ----
   * last-but-one tab page.
   */
      void
! tabpage_close_other(tabpage_T *tp, int forceit)
  {
      int		done = 0;
      win_T	*wp;
***************
*** 7459,7466 ****
   * ":only".
   */
      static void
! ex_only(eap)
!     exarg_T	*eap;
  {
      win_T   *wp;
      int	    wnr;
--- 7373,7379 ----
   * ":only".
   */
      static void
! ex_only(exarg_T *eap)
  {
      win_T   *wp;
      int	    wnr;
***************
*** 7487,7494 ****
   * Also used for ":tab drop file ..." after setting the argument list.
   */
      void
! ex_all(eap)
!     exarg_T	*eap;
  {
      if (eap->addr_count == 0)
  	eap->line2 = 9999;
--- 7400,7406 ----
   * Also used for ":tab drop file ..." after setting the argument list.
   */
      void
! ex_all(exarg_T *eap)
  {
      if (eap->addr_count == 0)
  	eap->line2 = 9999;
***************
*** 7497,7504 ****
  #endif /* FEAT_WINDOWS */
  
      static void
! ex_hide(eap)
!     exarg_T	*eap;
  {
      if (*eap->arg != NUL && check_nextcmd(eap->arg) == NULL)
  	eap->errmsg = e_invarg;
--- 7409,7415 ----
  #endif /* FEAT_WINDOWS */
  
      static void
! ex_hide(exarg_T *eap)
  {
      if (*eap->arg != NUL && check_nextcmd(eap->arg) == NULL)
  	eap->errmsg = e_invarg;
***************
*** 7538,7545 ****
   * ":stop" and ":suspend": Suspend Vim.
   */
      static void
! ex_stop(eap)
!     exarg_T	*eap;
  {
      /*
       * Disallow suspending for "rvim".
--- 7449,7455 ----
   * ":stop" and ":suspend": Suspend Vim.
   */
      static void
! ex_stop(exarg_T *eap)
  {
      /*
       * Disallow suspending for "rvim".
***************
*** 7579,7586 ****
   * ":exit", ":xit" and ":wq": Write file and exit Vim.
   */
      static void
! ex_exit(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
--- 7489,7495 ----
   * ":exit", ":xit" and ":wq": Write file and exit Vim.
   */
      static void
! ex_exit(exarg_T *eap)
  {
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
***************
*** 7636,7643 ****
   * ":print", ":list", ":number".
   */
      static void
! ex_print(eap)
!     exarg_T	*eap;
  {
      if (curbuf->b_ml.ml_flags & ML_EMPTY)
  	EMSG(_(e_emptybuf));
--- 7545,7551 ----
   * ":print", ":list", ":number".
   */
      static void
! ex_print(exarg_T *eap)
  {
      if (curbuf->b_ml.ml_flags & ML_EMPTY)
  	EMSG(_(e_emptybuf));
***************
*** 7664,7671 ****
  
  #ifdef FEAT_BYTEOFF
      static void
! ex_goto(eap)
!     exarg_T	*eap;
  {
      goto_byte(eap->line2);
  }
--- 7572,7578 ----
  
  #ifdef FEAT_BYTEOFF
      static void
! ex_goto(exarg_T *eap)
  {
      goto_byte(eap->line2);
  }
***************
*** 7675,7682 ****
   * ":shell".
   */
      static void
! ex_shell(eap)
!     exarg_T	*eap UNUSED;
  {
      do_shell(NULL, 0);
  }
--- 7582,7588 ----
   * ":shell".
   */
      static void
! ex_shell(exarg_T *eap UNUSED)
  {
      do_shell(NULL, 0);
  }
***************
*** 7705,7714 ****
   * problem.
   */
      void
! handle_drop(filec, filev, split)
!     int		filec;		/* the number of files dropped */
!     char_u	**filev;	/* the list of files dropped */
!     int		split;		/* force splitting the window */
  {
      exarg_T	ea;
      int		save_msg_scroll = msg_scroll;
--- 7611,7620 ----
   * problem.
   */
      void
! handle_drop(
!     int		filec,		/* the number of files dropped */
!     char_u	**filev,	/* the list of files dropped */
!     int		split)		/* force splitting the window */
  {
      exarg_T	ea;
      int		save_msg_scroll = msg_scroll;
***************
*** 7780,7787 ****
   * Clear an argument list: free all file names and reset it to zero entries.
   */
      void
! alist_clear(al)
!     alist_T	*al;
  {
      while (--al->al_ga.ga_len >= 0)
  	vim_free(AARGLIST(al)[al->al_ga.ga_len].ae_fname);
--- 7686,7692 ----
   * Clear an argument list: free all file names and reset it to zero entries.
   */
      void
! alist_clear(alist_T *al)
  {
      while (--al->al_ga.ga_len >= 0)
  	vim_free(AARGLIST(al)[al->al_ga.ga_len].ae_fname);
***************
*** 7792,7799 ****
   * Init an argument list.
   */
      void
! alist_init(al)
!     alist_T	*al;
  {
      ga_init2(&al->al_ga, (int)sizeof(aentry_T), 5);
  }
--- 7697,7703 ----
   * Init an argument list.
   */
      void
! alist_init(alist_T *al)
  {
      ga_init2(&al->al_ga, (int)sizeof(aentry_T), 5);
  }
***************
*** 7806,7813 ****
   * If the argument list is no longer used by any window, free it.
   */
      void
! alist_unlink(al)
!     alist_T	*al;
  {
      if (al != &global_alist && --al->al_refcount <= 0)
      {
--- 7710,7716 ----
   * If the argument list is no longer used by any window, free it.
   */
      void
! alist_unlink(alist_T *al)
  {
      if (al != &global_alist && --al->al_refcount <= 0)
      {
***************
*** 7821,7827 ****
   * Create a new argument list and use it for the current window.
   */
      void
! alist_new()
  {
      curwin->w_alist = (alist_T *)alloc((unsigned)sizeof(alist_T));
      if (curwin->w_alist == NULL)
--- 7724,7730 ----
   * Create a new argument list and use it for the current window.
   */
      void
! alist_new(void)
  {
      curwin->w_alist = (alist_T *)alloc((unsigned)sizeof(alist_T));
      if (curwin->w_alist == NULL)
***************
*** 7846,7854 ****
   * numbers to be re-used.
   */
      void
! alist_expand(fnum_list, fnum_len)
!     int		*fnum_list;
!     int		fnum_len;
  {
      char_u	**old_arg_files;
      int		old_arg_count;
--- 7749,7755 ----
   * numbers to be re-used.
   */
      void
! alist_expand(int *fnum_list, int fnum_len)
  {
      char_u	**old_arg_files;
      int		old_arg_count;
***************
*** 7886,7898 ****
   * Takes over the allocated files[] and the allocated fnames in it.
   */
      void
! alist_set(al, count, files, use_curbuf, fnum_list, fnum_len)
!     alist_T	*al;
!     int		count;
!     char_u	**files;
!     int		use_curbuf;
!     int		*fnum_list;
!     int		fnum_len;
  {
      int		i;
  
--- 7787,7799 ----
   * Takes over the allocated files[] and the allocated fnames in it.
   */
      void
! alist_set(
!     alist_T	*al,
!     int		count,
!     char_u	**files,
!     int		use_curbuf,
!     int		*fnum_list,
!     int		fnum_len)
  {
      int		i;
  
***************
*** 7933,7942 ****
   * "fname" must have been allocated and "al" must have been checked for room.
   */
      void
! alist_add(al, fname, set_fnum)
!     alist_T	*al;
!     char_u	*fname;
!     int		set_fnum;	/* 1: set buffer number; 2: re-use curbuf */
  {
      if (fname == NULL)		/* don't add NULL file names */
  	return;
--- 7834,7843 ----
   * "fname" must have been allocated and "al" must have been checked for room.
   */
      void
! alist_add(
!     alist_T	*al,
!     char_u	*fname,
!     int		set_fnum)	/* 1: set buffer number; 2: re-use curbuf */
  {
      if (fname == NULL)		/* don't add NULL file names */
  	return;
***************
*** 7955,7961 ****
   * Adjust slashes in file names.  Called after 'shellslash' was set.
   */
      void
! alist_slash_adjust()
  {
      int		i;
  # ifdef FEAT_WINDOWS
--- 7856,7862 ----
   * Adjust slashes in file names.  Called after 'shellslash' was set.
   */
      void
! alist_slash_adjust(void)
  {
      int		i;
  # ifdef FEAT_WINDOWS
***************
*** 7980,7987 ****
   * ":preserve".
   */
      static void
! ex_preserve(eap)
!     exarg_T	*eap UNUSED;
  {
      curbuf->b_flags |= BF_PRESERVED;
      ml_preserve(curbuf, TRUE);
--- 7881,7887 ----
   * ":preserve".
   */
      static void
! ex_preserve(exarg_T *eap UNUSED)
  {
      curbuf->b_flags |= BF_PRESERVED;
      ml_preserve(curbuf, TRUE);
***************
*** 7991,7998 ****
   * ":recover".
   */
      static void
! ex_recover(eap)
!     exarg_T	*eap;
  {
      /* Set recoverymode right away to avoid the ATTENTION prompt. */
      recoverymode = TRUE;
--- 7891,7897 ----
   * ":recover".
   */
      static void
! ex_recover(exarg_T *eap)
  {
      /* Set recoverymode right away to avoid the ATTENTION prompt. */
      recoverymode = TRUE;
***************
*** 8011,8018 ****
   * Command modifier used in a wrong way.
   */
      static void
! ex_wrongmodifier(eap)
!     exarg_T	*eap;
  {
      eap->errmsg = e_invcmd;
  }
--- 7910,7916 ----
   * Command modifier used in a wrong way.
   */
      static void
! ex_wrongmodifier(exarg_T *eap)
  {
      eap->errmsg = e_invcmd;
  }
***************
*** 8032,8039 ****
   * :tabfind [+command] file	open new Tab page and find "file"
   */
      void
! ex_splitview(eap)
!     exarg_T	*eap;
  {
      win_T	*old_curwin = curwin;
  # if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)
--- 7930,7936 ----
   * :tabfind [+command] file	open new Tab page and find "file"
   */
      void
! ex_splitview(exarg_T *eap)
  {
      win_T	*old_curwin = curwin;
  # if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)
***************
*** 8169,8175 ****
   * Open a new tab page.
   */
      void
! tabpage_new()
  {
      exarg_T	ea;
  
--- 8066,8072 ----
   * Open a new tab page.
   */
      void
! tabpage_new(void)
  {
      exarg_T	ea;
  
***************
*** 8184,8191 ****
   * :tabnext command
   */
      static void
! ex_tabnext(eap)
!     exarg_T	*eap;
  {
      switch (eap->cmdidx)
      {
--- 8081,8087 ----
   * :tabnext command
   */
      static void
! ex_tabnext(exarg_T *eap)
  {
      switch (eap->cmdidx)
      {
***************
*** 8210,8217 ****
   * :tabmove command
   */
      static void
! ex_tabmove(eap)
!     exarg_T	*eap;
  {
      int tab_number;
  
--- 8106,8112 ----
   * :tabmove command
   */
      static void
! ex_tabmove(exarg_T *eap)
  {
      int tab_number;
  
***************
*** 8274,8281 ****
   * :tabs command: List tabs and their contents.
   */
      static void
! ex_tabs(eap)
!     exarg_T	*eap UNUSED;
  {
      tabpage_T	*tp;
      win_T	*wp;
--- 8169,8175 ----
   * :tabs command: List tabs and their contents.
   */
      static void
! ex_tabs(exarg_T *eap UNUSED)
  {
      tabpage_T	*tp;
      win_T	*wp;
***************
*** 8321,8328 ****
   * If no argument given, just get the screen size and redraw.
   */
      static void
! ex_mode(eap)
!     exarg_T	*eap;
  {
      if (*eap->arg == NUL)
  	shell_resized();
--- 8215,8221 ----
   * If no argument given, just get the screen size and redraw.
   */
      static void
! ex_mode(exarg_T *eap)
  {
      if (*eap->arg == NUL)
  	shell_resized();
***************
*** 8336,8343 ****
   * set, increment or decrement current window height
   */
      static void
! ex_resize(eap)
!     exarg_T	*eap;
  {
      int		n;
      win_T	*wp = curwin;
--- 8229,8235 ----
   * set, increment or decrement current window height
   */
      static void
! ex_resize(exarg_T *eap)
  {
      int		n;
      win_T	*wp = curwin;
***************
*** 8378,8385 ****
   * ":find [+command] <file>" command.
   */
      static void
! ex_find(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_SEARCHPATH
      char_u	*fname;
--- 8270,8276 ----
   * ":find [+command] <file>" command.
   */
      static void
! ex_find(exarg_T *eap)
  {
  #ifdef FEAT_SEARCHPATH
      char_u	*fname;
***************
*** 8415,8422 ****
   * ":open" simulation: for now just work like ":visual".
   */
      static void
! ex_open(eap)
!     exarg_T	*eap;
  {
      regmatch_T	regmatch;
      char_u	*p;
--- 8306,8312 ----
   * ":open" simulation: for now just work like ":visual".
   */
      static void
! ex_open(exarg_T *eap)
  {
      regmatch_T	regmatch;
      char_u	*p;
***************
*** 8453,8460 ****
   * ":edit", ":badd", ":visual".
   */
      static void
! ex_edit(eap)
!     exarg_T	*eap;
  {
      do_exedit(eap, NULL);
  }
--- 8343,8349 ----
   * ":edit", ":badd", ":visual".
   */
      static void
! ex_edit(exarg_T *eap)
  {
      do_exedit(eap, NULL);
  }
***************
*** 8463,8471 ****
   * ":edit <file>" command and alikes.
   */
      void
! do_exedit(eap, old_curwin)
!     exarg_T	*eap;
!     win_T	*old_curwin;	    /* curwin before doing a split or NULL */
  {
      int		n;
  #ifdef FEAT_WINDOWS
--- 8352,8360 ----
   * ":edit <file>" command and alikes.
   */
      void
! do_exedit(
!     exarg_T	*eap,
!     win_T	*old_curwin)	    /* curwin before doing a split or NULL */
  {
      int		n;
  #ifdef FEAT_WINDOWS
***************
*** 8650,8657 ****
   * ":gui" and ":gvim" when there is no GUI.
   */
      static void
! ex_nogui(eap)
!     exarg_T	*eap;
  {
      eap->errmsg = e_nogvim;
  }
--- 8539,8545 ----
   * ":gui" and ":gvim" when there is no GUI.
   */
      static void
! ex_nogui(exarg_T *eap)
  {
      eap->errmsg = e_nogvim;
  }
***************
*** 8659,8666 ****
  
  #if defined(FEAT_GUI_W32) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)
      static void
! ex_tearoff(eap)
!     exarg_T	*eap;
  {
      gui_make_tearoff(eap->arg);
  }
--- 8547,8553 ----
  
  #if defined(FEAT_GUI_W32) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)
      static void
! ex_tearoff(exarg_T *eap)
  {
      gui_make_tearoff(eap->arg);
  }
***************
*** 8668,8683 ****
  
  #if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)) && defined(FEAT_MENU)
      static void
! ex_popup(eap)
!     exarg_T	*eap;
  {
      gui_make_popup(eap->arg, eap->forceit);
  }
  #endif
  
      static void
! ex_swapname(eap)
!     exarg_T	*eap UNUSED;
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
  	MSG(_("No swap file"));
--- 8555,8568 ----
  
  #if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)) && defined(FEAT_MENU)
      static void
! ex_popup(exarg_T *eap)
  {
      gui_make_popup(eap->arg, eap->forceit);
  }
  #endif
  
      static void
! ex_swapname(exarg_T *eap UNUSED)
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
  	MSG(_("No swap file"));
***************
*** 8691,8698 ****
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
      static void
! ex_syncbind(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_SCROLLBIND
      win_T	*wp;
--- 8576,8582 ----
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
      static void
! ex_syncbind(exarg_T *eap UNUSED)
  {
  #ifdef FEAT_SCROLLBIND
      win_T	*wp;
***************
*** 8769,8776 ****
  
  
      static void
! ex_read(eap)
!     exarg_T	*eap;
  {
      int		i;
      int		empty = (curbuf->b_ml.ml_flags & ML_EMPTY);
--- 8653,8659 ----
  
  
      static void
! ex_read(exarg_T *eap)
  {
      int		i;
      int		empty = (curbuf->b_ml.ml_flags & ML_EMPTY);
***************
*** 8851,8857 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_cd_dir()
  {
      vim_free(prev_dir);
      prev_dir = NULL;
--- 8734,8740 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_cd_dir(void)
  {
      vim_free(prev_dir);
      prev_dir = NULL;
***************
*** 8866,8873 ****
   * When "local" is TRUE then this was after an ":lcd" command.
   */
      void
! post_chdir(local)
!     int		local;
  {
      vim_free(curwin->w_localdir);
      curwin->w_localdir = NULL;
--- 8749,8755 ----
   * When "local" is TRUE then this was after an ":lcd" command.
   */
      void
! post_chdir(int local)
  {
      vim_free(curwin->w_localdir);
      curwin->w_localdir = NULL;
***************
*** 8897,8904 ****
   * ":cd", ":lcd", ":chdir" and ":lchdir".
   */
      void
! ex_cd(eap)
!     exarg_T	*eap;
  {
      char_u		*new_dir;
      char_u		*tofree;
--- 8779,8785 ----
   * ":cd", ":lcd", ":chdir" and ":lchdir".
   */
      void
! ex_cd(exarg_T *eap)
  {
      char_u		*new_dir;
      char_u		*tofree;
***************
*** 8977,8984 ****
   * ":pwd".
   */
      static void
! ex_pwd(eap)
!     exarg_T	*eap UNUSED;
  {
      if (mch_dirname(NameBuff, MAXPATHL) == OK)
      {
--- 8858,8864 ----
   * ":pwd".
   */
      static void
! ex_pwd(exarg_T *eap UNUSED)
  {
      if (mch_dirname(NameBuff, MAXPATHL) == OK)
      {
***************
*** 8995,9010 ****
   * ":=".
   */
      static void
! ex_equal(eap)
!     exarg_T	*eap;
  {
      smsg((char_u *)"%ld", (long)eap->line2);
      ex_may_print(eap);
  }
  
      static void
! ex_sleep(eap)
!     exarg_T	*eap;
  {
      int		n;
      long	len;
--- 8875,8888 ----
   * ":=".
   */
      static void
! ex_equal(exarg_T *eap)
  {
      smsg((char_u *)"%ld", (long)eap->line2);
      ex_may_print(eap);
  }
  
      static void
! ex_sleep(exarg_T *eap)
  {
      int		n;
      long	len;
***************
*** 9030,9037 ****
   * Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.
   */
      void
! do_sleep(msec)
!     long	msec;
  {
      long	done;
  
--- 8908,8914 ----
   * Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.
   */
      void
! do_sleep(long msec)
  {
      long	done;
  
***************
*** 9051,9059 ****
  }
  
      static void
! do_exmap(eap, isabbrev)
!     exarg_T	*eap;
!     int		isabbrev;
  {
      int	    mode;
      char_u  *cmdp;
--- 8928,8934 ----
  }
  
      static void
! do_exmap(exarg_T *eap, int isabbrev)
  {
      int	    mode;
      char_u  *cmdp;
***************
*** 9075,9082 ****
   * ":winsize" command (obsolete).
   */
      static void
! ex_winsize(eap)
!     exarg_T	*eap;
  {
      int		w, h;
      char_u	*arg = eap->arg;
--- 8950,8956 ----
   * ":winsize" command (obsolete).
   */
      static void
! ex_winsize(exarg_T *eap)
  {
      int		w, h;
      char_u	*arg = eap->arg;
***************
*** 9094,9101 ****
  
  #ifdef FEAT_WINDOWS
      static void
! ex_wincmd(eap)
!     exarg_T	*eap;
  {
      int		xchar = NUL;
      char_u	*p;
--- 8968,8974 ----
  
  #ifdef FEAT_WINDOWS
      static void
! ex_wincmd(exarg_T *eap)
  {
      int		xchar = NUL;
      char_u	*p;
***************
*** 9135,9142 ****
   * ":winpos".
   */
      static void
! ex_winpos(eap)
!     exarg_T	*eap;
  {
      int		x, y;
      char_u	*arg = eap->arg;
--- 9008,9014 ----
   * ":winpos".
   */
      static void
! ex_winpos(exarg_T *eap)
  {
      int		x, y;
      char_u	*arg = eap->arg;
***************
*** 9198,9205 ****
   * Handle command that work like operators: ":delete", ":yank", ":>" and ":<".
   */
      static void
! ex_operators(eap)
!     exarg_T	*eap;
  {
      oparg_T	oa;
  
--- 9070,9076 ----
   * Handle command that work like operators: ":delete", ":yank", ":>" and ":<".
   */
      static void
! ex_operators(exarg_T *eap)
  {
      oparg_T	oa;
  
***************
*** 9258,9265 ****
   * ":put".
   */
      static void
! ex_put(eap)
!     exarg_T	*eap;
  {
      /* ":0put" works like ":1put!". */
      if (eap->line2 == 0)
--- 9129,9135 ----
   * ":put".
   */
      static void
! ex_put(exarg_T *eap)
  {
      /* ":0put" works like ":1put!". */
      if (eap->line2 == 0)
***************
*** 9276,9283 ****
   * Handle ":copy" and ":move".
   */
      static void
! ex_copymove(eap)
!     exarg_T	*eap;
  {
      long	n;
  
--- 9146,9152 ----
   * Handle ":copy" and ":move".
   */
      static void
! ex_copymove(exarg_T *eap)
  {
      long	n;
  
***************
*** 9314,9321 ****
   * Print the current line if flags were given to the Ex command.
   */
      void
! ex_may_print(eap)
!     exarg_T	*eap;
  {
      if (eap->flags != 0)
      {
--- 9183,9189 ----
   * Print the current line if flags were given to the Ex command.
   */
      void
! ex_may_print(exarg_T *eap)
  {
      if (eap->flags != 0)
      {
***************
*** 9329,9336 ****
   * ":smagic" and ":snomagic".
   */
      static void
! ex_submagic(eap)
!     exarg_T	*eap;
  {
      int		magic_save = p_magic;
  
--- 9197,9203 ----
   * ":smagic" and ":snomagic".
   */
      static void
! ex_submagic(exarg_T *eap)
  {
      int		magic_save = p_magic;
  
***************
*** 9343,9350 ****
   * ":join".
   */
      static void
! ex_join(eap)
!     exarg_T	*eap;
  {
      curwin->w_cursor.lnum = eap->line1;
      if (eap->line1 == eap->line2)
--- 9210,9216 ----
   * ":join".
   */
      static void
! ex_join(exarg_T *eap)
  {
      curwin->w_cursor.lnum = eap->line1;
      if (eap->line1 == eap->line2)
***************
*** 9367,9374 ****
   * ":[addr]@r" or ":[addr]*r": execute register
   */
      static void
! ex_at(eap)
!     exarg_T	*eap;
  {
      int		c;
      int		prev_len = typebuf.tb_len;
--- 9233,9239 ----
   * ":[addr]@r" or ":[addr]*r": execute register
   */
      static void
! ex_at(exarg_T *eap)
  {
      int		c;
      int		prev_len = typebuf.tb_len;
***************
*** 9411,9418 ****
   * ":!".
   */
      static void
! ex_bang(eap)
!     exarg_T	*eap;
  {
      do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);
  }
--- 9276,9282 ----
   * ":!".
   */
      static void
! ex_bang(exarg_T *eap)
  {
      do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);
  }
***************
*** 9421,9428 ****
   * ":undo".
   */
      static void
! ex_undo(eap)
!     exarg_T	*eap UNUSED;
  {
      if (eap->addr_count == 1)	    /* :undo 123 */
  	undo_time(eap->line2, FALSE, FALSE, TRUE);
--- 9285,9291 ----
   * ":undo".
   */
      static void
! ex_undo(exarg_T *eap UNUSED)
  {
      if (eap->addr_count == 1)	    /* :undo 123 */
  	undo_time(eap->line2, FALSE, FALSE, TRUE);
***************
*** 9432,9439 ****
  
  #ifdef FEAT_PERSISTENT_UNDO
      static void
! ex_wundo(eap)
!     exarg_T *eap;
  {
      char_u hash[UNDO_HASH_SIZE];
  
--- 9295,9301 ----
  
  #ifdef FEAT_PERSISTENT_UNDO
      static void
! ex_wundo(exarg_T *eap)
  {
      char_u hash[UNDO_HASH_SIZE];
  
***************
*** 9442,9449 ****
  }
  
      static void
! ex_rundo(eap)
!     exarg_T *eap;
  {
      char_u hash[UNDO_HASH_SIZE];
  
--- 9304,9310 ----
  }
  
      static void
! ex_rundo(exarg_T *eap)
  {
      char_u hash[UNDO_HASH_SIZE];
  
***************
*** 9456,9463 ****
   * ":redo".
   */
      static void
! ex_redo(eap)
!     exarg_T	*eap UNUSED;
  {
      u_redo(1);
  }
--- 9317,9323 ----
   * ":redo".
   */
      static void
! ex_redo(exarg_T *eap UNUSED)
  {
      u_redo(1);
  }
***************
*** 9466,9473 ****
   * ":earlier" and ":later".
   */
      static void
! ex_later(eap)
!     exarg_T	*eap;
  {
      long	count = 0;
      int		sec = FALSE;
--- 9326,9332 ----
   * ":earlier" and ":later".
   */
      static void
! ex_later(exarg_T *eap)
  {
      long	count = 0;
      int		sec = FALSE;
***************
*** 9500,9507 ****
   * ":redir": start/stop redirection.
   */
      static void
! ex_redir(eap)
!     exarg_T	*eap;
  {
      char	*mode;
      char_u	*fname;
--- 9359,9365 ----
   * ":redir": start/stop redirection.
   */
      static void
! ex_redir(exarg_T *eap)
  {
      char	*mode;
      char_u	*fname;
***************
*** 9622,9629 ****
   * ":redraw": force redraw
   */
      static void
! ex_redraw(eap)
!     exarg_T	*eap;
  {
      int		r = RedrawingDisabled;
      int		p = p_lz;
--- 9480,9486 ----
   * ":redraw": force redraw
   */
      static void
! ex_redraw(exarg_T *eap)
  {
      int		r = RedrawingDisabled;
      int		p = p_lz;
***************
*** 9653,9660 ****
   * ":redrawstatus": force redraw of status line(s)
   */
      static void
! ex_redrawstatus(eap)
!     exarg_T	*eap UNUSED;
  {
  #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
--- 9510,9516 ----
   * ":redrawstatus": force redraw of status line(s)
   */
      static void
! ex_redrawstatus(exarg_T *eap UNUSED)
  {
  #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
***************
*** 9674,9680 ****
  }
  
      static void
! close_redir()
  {
      if (redir_fd != NULL)
      {
--- 9530,9536 ----
  }
  
      static void
! close_redir(void)
  {
      if (redir_fd != NULL)
      {
***************
*** 9700,9707 ****
   * ":mkexrc", ":mkvimrc", ":mkview" and ":mksession".
   */
      static void
! ex_mkrc(eap)
!     exarg_T	*eap;
  {
      FILE	*fd;
      int		failed = FALSE;
--- 9556,9563 ----
   * ":mkexrc", ":mkvimrc", ":mkview" and ":mksession".
   */
      static void
! ex_mkrc(
!     exarg_T	*eap)
  {
      FILE	*fd;
      int		failed = FALSE;
***************
*** 9926,9934 ****
  #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
  	|| defined(PROTO)
      int
! vim_mkdir_emsg(name, prot)
!     char_u	*name;
!     int		prot UNUSED;
  {
      if (vim_mkdir(name, prot) != 0)
      {
--- 9782,9788 ----
  #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
  	|| defined(PROTO)
      int
! vim_mkdir_emsg(char_u *name, int prot UNUSED)
  {
      if (vim_mkdir(name, prot) != 0)
      {
***************
*** 9944,9953 ****
   * Return file descriptor, or NULL on failure.
   */
      FILE *
! open_exfile(fname, forceit, mode)
!     char_u	*fname;
!     int		forceit;
!     char	*mode;	    /* "w" for create new file or "a" for append */
  {
      FILE	*fd;
  
--- 9798,9807 ----
   * Return file descriptor, or NULL on failure.
   */
      FILE *
! open_exfile(
!     char_u	*fname,
!     int		forceit,
!     char	*mode)	    /* "w" for create new file or "a" for append */
  {
      FILE	*fd;
  
***************
*** 9975,9982 ****
   * ":mark" and ":k".
   */
      static void
! ex_mark(eap)
!     exarg_T	*eap;
  {
      pos_T	pos;
  
--- 9829,9835 ----
   * ":mark" and ":k".
   */
      static void
! ex_mark(exarg_T *eap)
  {
      pos_T	pos;
  
***************
*** 9999,10005 ****
   * Update w_topline, w_leftcol and the cursor position.
   */
      void
! update_topline_cursor()
  {
      check_cursor();		/* put cursor on valid line */
      update_topline();
--- 9852,9858 ----
   * Update w_topline, w_leftcol and the cursor position.
   */
      void
! update_topline_cursor(void)
  {
      check_cursor();		/* put cursor on valid line */
      update_topline();
***************
*** 10013,10020 ****
   * ":normal[!] {commands}": Execute normal mode commands.
   */
      static void
! ex_normal(eap)
!     exarg_T	*eap;
  {
      int		save_msg_scroll = msg_scroll;
      int		save_restart_edit = restart_edit;
--- 9866,9872 ----
   * ":normal[!] {commands}": Execute normal mode commands.
   */
      static void
! ex_normal(exarg_T *eap)
  {
      int		save_msg_scroll = msg_scroll;
      int		save_restart_edit = restart_edit;
***************
*** 10173,10180 ****
   * ":startinsert", ":startreplace" and ":startgreplace"
   */
      static void
! ex_startinsert(eap)
!     exarg_T	*eap;
  {
      if (eap->forceit)
      {
--- 10025,10031 ----
   * ":startinsert", ":startreplace" and ":startgreplace"
   */
      static void
! ex_startinsert(exarg_T *eap)
  {
      if (eap->forceit)
      {
***************
*** 10207,10214 ****
   * ":stopinsert"
   */
      static void
! ex_stopinsert(eap)
!     exarg_T	*eap UNUSED;
  {
      restart_edit = 0;
      stop_insert_mode = TRUE;
--- 10058,10064 ----
   * ":stopinsert"
   */
      static void
! ex_stopinsert(exarg_T *eap UNUSED)
  {
      restart_edit = 0;
      stop_insert_mode = TRUE;
***************
*** 10221,10230 ****
   * "remap" can be REMAP_NONE or REMAP_YES.
   */
      void
! exec_normal_cmd(cmd, remap, silent)
!     char_u	*cmd;
!     int		remap;
!     int		silent;
  {
      /* Stuff the argument into the typeahead buffer. */
      ins_typebuf(cmd, remap, 0, TRUE, silent);
--- 10071,10077 ----
   * "remap" can be REMAP_NONE or REMAP_YES.
   */
      void
! exec_normal_cmd(char_u *cmd, int remap, int silent)
  {
      /* Stuff the argument into the typeahead buffer. */
      ins_typebuf(cmd, remap, 0, TRUE, silent);
***************
*** 10255,10262 ****
  
  #ifdef FEAT_FIND_ID
      static void
! ex_checkpath(eap)
!     exarg_T	*eap;
  {
      find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,
  				   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,
--- 10102,10108 ----
  
  #ifdef FEAT_FIND_ID
      static void
! ex_checkpath(exarg_T *eap)
  {
      find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,
  				   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,
***************
*** 10268,10275 ****
   * ":psearch"
   */
      static void
! ex_psearch(eap)
!     exarg_T	*eap;
  {
      g_do_tagpreview = p_pvh;
      ex_findpat(eap);
--- 10114,10120 ----
   * ":psearch"
   */
      static void
! ex_psearch(exarg_T *eap)
  {
      g_do_tagpreview = p_pvh;
      ex_findpat(eap);
***************
*** 10278,10285 ****
  #endif
  
      static void
! ex_findpat(eap)
!     exarg_T	*eap;
  {
      int		whole = TRUE;
      long	n;
--- 10123,10129 ----
  #endif
  
      static void
! ex_findpat(exarg_T *eap)
  {
      int		whole = TRUE;
      long	n;
***************
*** 10343,10350 ****
   * ":ptag", ":ptselect", ":ptjump", ":ptnext", etc.
   */
      static void
! ex_ptag(eap)
!     exarg_T	*eap;
  {
      g_do_tagpreview = p_pvh;  /* will be reset to 0 in ex_tag_cmd() */
      ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);
--- 10187,10193 ----
   * ":ptag", ":ptselect", ":ptjump", ":ptnext", etc.
   */
      static void
! ex_ptag(exarg_T *eap)
  {
      g_do_tagpreview = p_pvh;  /* will be reset to 0 in ex_tag_cmd() */
      ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);
***************
*** 10354,10361 ****
   * ":pedit"
   */
      static void
! ex_pedit(eap)
!     exarg_T	*eap;
  {
      win_T	*curwin_save = curwin;
  
--- 10197,10203 ----
   * ":pedit"
   */
      static void
! ex_pedit(exarg_T *eap)
  {
      win_T	*curwin_save = curwin;
  
***************
*** 10379,10386 ****
   * ":stag", ":stselect" and ":stjump".
   */
      static void
! ex_stag(eap)
!     exarg_T	*eap;
  {
      postponed_split = -1;
      postponed_split_flags = cmdmod.split;
--- 10221,10227 ----
   * ":stag", ":stselect" and ":stjump".
   */
      static void
! ex_stag(exarg_T *eap)
  {
      postponed_split = -1;
      postponed_split_flags = cmdmod.split;
***************
*** 10395,10410 ****
   * ":tag", ":tselect", ":tjump", ":tnext", etc.
   */
      static void
! ex_tag(eap)
!     exarg_T	*eap;
  {
      ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);
  }
  
      static void
! ex_tag_cmd(eap, name)
!     exarg_T	*eap;
!     char_u	*name;
  {
      int		cmd;
  
--- 10236,10248 ----
   * ":tag", ":tselect", ":tjump", ":tnext", etc.
   */
      static void
! ex_tag(exarg_T *eap)
  {
      ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);
  }
  
      static void
! ex_tag_cmd(exarg_T *eap, char_u *name)
  {
      int		cmd;
  
***************
*** 10459,10467 ****
   * the variable.  Otherwise return -1 and "*usedlen" is unchanged.
   */
      int
! find_cmdline_var(src, usedlen)
!     char_u	*src;
!     int		*usedlen;
  {
      int		len;
      int		i;
--- 10297,10303 ----
   * the variable.  Otherwise return -1 and "*usedlen" is unchanged.
   */
      int
! find_cmdline_var(char_u *src, int *usedlen)
  {
      int		len;
      int		i;
***************
*** 10531,10543 ****
   * number of characters to skip.
   */
      char_u *
! eval_vars(src, srcstart, usedlen, lnump, errormsg, escaped)
!     char_u	*src;		/* pointer into commandline */
!     char_u	*srcstart;	/* beginning of valid memory for src */
!     int		*usedlen;	/* characters after src that are used */
!     linenr_T	*lnump;		/* line number for :e command, or NULL */
!     char_u	**errormsg;	/* pointer to error message */
!     int		*escaped;	/* return value has escaped white space (can
  				 * be NULL) */
  {
      int		i;
--- 10367,10379 ----
   * number of characters to skip.
   */
      char_u *
! eval_vars(
!     char_u	*src,		/* pointer into commandline */
!     char_u	*srcstart,	/* beginning of valid memory for src */
!     int		*usedlen,	/* characters after src that are used */
!     linenr_T	*lnump,		/* line number for :e command, or NULL */
!     char_u	**errormsg,	/* pointer to error message */
!     int		*escaped)	/* return value has escaped white space (can
  				 * be NULL) */
  {
      int		i;
***************
*** 10794,10800 ****
   * Returns NULL when out of memory.
   */
      static char_u *
! arg_all()
  {
      int		len;
      int		idx;
--- 10630,10636 ----
   * Returns NULL when out of memory.
   */
      static char_u *
! arg_all(void)
  {
      int		len;
      int		idx;
***************
*** 10864,10871 ****
   * Returns an allocated string, or NULL for any error.
   */
      char_u *
! expand_sfile(arg)
!     char_u	*arg;
  {
      char_u	*errormsg;
      int		len;
--- 10700,10706 ----
   * Returns an allocated string, or NULL for any error.
   */
      char_u *
! expand_sfile(char_u *arg)
  {
      char_u	*errormsg;
      int		len;
***************
*** 10938,10946 ****
   * Return FAIL on error, OK otherwise.
   */
      static int
! makeopens(fd, dirnow)
!     FILE	*fd;
!     char_u	*dirnow;	/* Current directory name */
  {
      buf_T	*buf;
      int		only_save_windows = TRUE;
--- 10773,10781 ----
   * Return FAIL on error, OK otherwise.
   */
      static int
! makeopens(
!     FILE	*fd,
!     char_u	*dirnow)	/* Current directory name */
  {
      buf_T	*buf;
      int		only_save_windows = TRUE;
***************
*** 11256,11265 ****
  }
  
      static int
! ses_winsizes(fd, restore_size, tab_firstwin)
!     FILE	*fd;
!     int		restore_size;
!     win_T	*tab_firstwin;
  {
      int		n = 0;
      win_T	*wp;
--- 11091,11100 ----
  }
  
      static int
! ses_winsizes(
!     FILE	*fd,
!     int		restore_size,
!     win_T	*tab_firstwin)
  {
      int		n = 0;
      win_T	*wp;
***************
*** 11304,11312 ****
   * Returns FAIL when writing the commands to "fd" fails.
   */
      static int
! ses_win_rec(fd, fr)
!     FILE	*fd;
!     frame_T	*fr;
  {
      frame_T	*frc;
      int		count = 0;
--- 11139,11145 ----
   * Returns FAIL when writing the commands to "fd" fails.
   */
      static int
! ses_win_rec(FILE *fd, frame_T *fr)
  {
      frame_T	*frc;
      int		count = 0;
***************
*** 11354,11361 ****
   * Returns NULL when there none.
   */
      static frame_T *
! ses_skipframe(fr)
!     frame_T	*fr;
  {
      frame_T	*frc;
  
--- 11187,11193 ----
   * Returns NULL when there none.
   */
      static frame_T *
! ses_skipframe(frame_T *fr)
  {
      frame_T	*frc;
  
***************
*** 11370,11377 ****
   * the Session.
   */
      static int
! ses_do_frame(fr)
!     frame_T	*fr;
  {
      frame_T	*frc;
  
--- 11202,11208 ----
   * the Session.
   */
      static int
! ses_do_frame(frame_T *fr)
  {
      frame_T	*frc;
  
***************
*** 11387,11394 ****
   * Return non-zero if window "wp" is to be stored in the Session.
   */
      static int
! ses_do_win(wp)
!     win_T	*wp;
  {
      if (wp->w_buffer->b_fname == NULL
  #ifdef FEAT_QUICKFIX
--- 11218,11224 ----
   * Return non-zero if window "wp" is to be stored in the Session.
   */
      static int
! ses_do_win(win_T *wp)
  {
      if (wp->w_buffer->b_fname == NULL
  #ifdef FEAT_QUICKFIX
***************
*** 11407,11418 ****
   * Caller must make sure 'scrolloff' is zero.
   */
      static int
! put_view(fd, wp, add_edit, flagp, current_arg_idx)
!     FILE	*fd;
!     win_T	*wp;
!     int		add_edit;	/* add ":edit" command to view */
!     unsigned	*flagp;		/* vop_flags or ssop_flags */
!     int		current_arg_idx; /* current argument index of the window, use
  				  * -1 if unknown */
  {
      win_T	*save_curwin;
--- 11237,11248 ----
   * Caller must make sure 'scrolloff' is zero.
   */
      static int
! put_view(
!     FILE	*fd,
!     win_T	*wp,
!     int		add_edit,	/* add ":edit" command to view */
!     unsigned	*flagp,		/* vop_flags or ssop_flags */
!     int		current_arg_idx) /* current argument index of the window, use
  				  * -1 if unknown */
  {
      win_T	*save_curwin;
***************
*** 11612,11623 ****
   * Returns FAIL if writing fails.
   */
      static int
! ses_arglist(fd, cmd, gap, fullname, flagp)
!     FILE	*fd;
!     char	*cmd;
!     garray_T	*gap;
!     int		fullname;	/* TRUE: use full path name */
!     unsigned	*flagp;
  {
      int		i;
      char_u	*buf = NULL;
--- 11442,11453 ----
   * Returns FAIL if writing fails.
   */
      static int
! ses_arglist(
!     FILE	*fd,
!     char	*cmd,
!     garray_T	*gap,
!     int		fullname,	/* TRUE: use full path name */
!     unsigned	*flagp)
  {
      int		i;
      char_u	*buf = NULL;
***************
*** 11661,11670 ****
   * Returns FAIL if writing fails.
   */
      static int
! ses_fname(fd, buf, flagp)
!     FILE	*fd;
!     buf_T	*buf;
!     unsigned	*flagp;
  {
      char_u	*name;
  
--- 11491,11497 ----
   * Returns FAIL if writing fails.
   */
      static int
! ses_fname(FILE *fd, buf_T *buf, unsigned *flagp)
  {
      char_u	*name;
  
***************
*** 11695,11704 ****
   * Returns FAIL if writing fails or out of memory.
   */
      static int
! ses_put_fname(fd, name, flagp)
!     FILE	*fd;
!     char_u	*name;
!     unsigned	*flagp;
  {
      char_u	*sname;
      char_u	*p;
--- 11522,11528 ----
   * Returns FAIL if writing fails or out of memory.
   */
      static int
! ses_put_fname(FILE *fd, char_u *name, unsigned *flagp)
  {
      char_u	*sname;
      char_u	*p;
***************
*** 11734,11741 ****
   * ":loadview [nr]"
   */
      static void
! ex_loadview(eap)
!     exarg_T	*eap;
  {
      char_u	*fname;
  
--- 11558,11564 ----
   * ":loadview [nr]"
   */
      static void
! ex_loadview(exarg_T *eap)
  {
      char_u	*fname;
  
***************
*** 11751,11758 ****
   * Get the name of the view file for the current buffer.
   */
      static char_u *
! get_view_file(c)
!     int		c;
  {
      int		len = 0;
      char_u	*p, *s;
--- 11574,11580 ----
   * Get the name of the view file for the current buffer.
   */
      static char_u *
! get_view_file(int c)
  {
      int		len = 0;
      char_u	*p, *s;
***************
*** 11820,11827 ****
   * Return FAIL for a write error.
   */
      int
! put_eol(fd)
!     FILE	*fd;
  {
      if (
  #ifdef USE_CRNL
--- 11642,11648 ----
   * Return FAIL for a write error.
   */
      int
! put_eol(FILE *fd)
  {
      if (
  #ifdef USE_CRNL
***************
*** 11841,11849 ****
   * Return FAIL for a write error.
   */
      int
! put_line(fd, s)
!     FILE	*fd;
!     char	*s;
  {
      if (fputs(s, fd) < 0 || put_eol(fd) == FAIL)
  	return FAIL;
--- 11662,11668 ----
   * Return FAIL for a write error.
   */
      int
! put_line(FILE *fd, char *s)
  {
      if (fputs(s, fd) < 0 || put_eol(fd) == FAIL)
  	return FAIL;
***************
*** 11855,11862 ****
   * ":rviminfo" and ":wviminfo".
   */
      static void
! ex_viminfo(eap)
!     exarg_T	*eap;
  {
      char_u	*save_viminfo;
  
--- 11674,11681 ----
   * ":rviminfo" and ":wviminfo".
   */
      static void
! ex_viminfo(
!     exarg_T	*eap)
  {
      char_u	*save_viminfo;
  
***************
*** 11881,11890 ****
   * "format" must contain "%s".
   */
      void
! dialog_msg(buff, format, fname)
!     char_u	*buff;
!     char	*format;
!     char_u	*fname;
  {
      if (fname == NULL)
  	fname = (char_u *)_("Untitled");
--- 11700,11706 ----
   * "format" must contain "%s".
   */
      void
! dialog_msg(char_u *buff, char *format, char_u *fname)
  {
      if (fname == NULL)
  	fname = (char_u *)_("Untitled");
***************
*** 11896,11903 ****
   * ":behave {mswin,xterm}"
   */
      static void
! ex_behave(eap)
!     exarg_T	*eap;
  {
      if (STRCMP(eap->arg, "mswin") == 0)
      {
--- 11712,11718 ----
   * ":behave {mswin,xterm}"
   */
      static void
! ex_behave(exarg_T *eap)
  {
      if (STRCMP(eap->arg, "mswin") == 0)
      {
***************
*** 11924,11932 ****
   * ":behave {mswin,xterm}" command.
   */
      char_u *
! get_behave_arg(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (idx == 0)
  	return (char_u *)"mswin";
--- 11739,11745 ----
   * ":behave {mswin,xterm}" command.
   */
      char_u *
! get_behave_arg(expand_T *xp UNUSED, int idx)
  {
      if (idx == 0)
  	return (char_u *)"mswin";
***************
*** 11951,11958 ****
   * indent off: load indoff.vim
   */
      static void
! ex_filetype(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      int		plugin = FALSE;
--- 11764,11770 ----
   * indent off: load indoff.vim
   */
      static void
! ex_filetype(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      int		plugin = FALSE;
***************
*** 12037,12044 ****
   * ":setfiletype {name}"
   */
      static void
! ex_setfiletype(eap)
!     exarg_T	*eap;
  {
      if (!did_filetype)
  	set_option_value((char_u *)"filetype", 0L, eap->arg, OPT_LOCAL);
--- 11849,11855 ----
   * ":setfiletype {name}"
   */
      static void
! ex_setfiletype(exarg_T *eap)
  {
      if (!did_filetype)
  	set_option_value((char_u *)"filetype", 0L, eap->arg, OPT_LOCAL);
***************
*** 12046,12053 ****
  #endif
  
      static void
! ex_digraphs(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_DIGRAPHS
      if (*eap->arg != NUL)
--- 11857,11863 ----
  #endif
  
      static void
! ex_digraphs(exarg_T *eap UNUSED)
  {
  #ifdef FEAT_DIGRAPHS
      if (*eap->arg != NUL)
***************
*** 12060,12067 ****
  }
  
      static void
! ex_set(eap)
!     exarg_T	*eap;
  {
      int		flags = 0;
  
--- 11870,11876 ----
  }
  
      static void
! ex_set(exarg_T *eap)
  {
      int		flags = 0;
  
***************
*** 12082,12089 ****
   * ":nohlsearch"
   */
      static void
! ex_nohlsearch(eap)
!     exarg_T	*eap UNUSED;
  {
      SET_NO_HLSEARCH(TRUE);
      redraw_all_later(SOME_VALID);
--- 11891,11897 ----
   * ":nohlsearch"
   */
      static void
! ex_nohlsearch(exarg_T *eap UNUSED)
  {
      SET_NO_HLSEARCH(TRUE);
      redraw_all_later(SOME_VALID);
***************
*** 12095,12102 ****
   * skipping commands to find the next command.
   */
      static void
! ex_match(eap)
!     exarg_T	*eap;
  {
      char_u	*p;
      char_u	*g = NULL;
--- 11903,11909 ----
   * skipping commands to find the next command.
   */
      static void
! ex_match(exarg_T *eap)
  {
      char_u	*p;
      char_u	*g = NULL;
***************
*** 12166,12173 ****
   * ":X": Get crypt key
   */
      static void
! ex_X(eap)
!     exarg_T	*eap UNUSED;
  {
      crypt_check_current_method();
      (void)crypt_get_key(TRUE, TRUE);
--- 11973,11979 ----
   * ":X": Get crypt key
   */
      static void
! ex_X(exarg_T *eap UNUSED)
  {
      crypt_check_current_method();
      (void)crypt_get_key(TRUE, TRUE);
***************
*** 12176,12199 ****
  
  #ifdef FEAT_FOLDING
      static void
! ex_fold(eap)
!     exarg_T	*eap;
  {
      if (foldManualAllowed(TRUE))
  	foldCreate(eap->line1, eap->line2);
  }
  
      static void
! ex_foldopen(eap)
!     exarg_T	*eap;
  {
      opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,
  							 eap->forceit, FALSE);
  }
  
      static void
! ex_folddo(eap)
!     exarg_T	*eap;
  {
      linenr_T	lnum;
  
--- 11982,12002 ----
  
  #ifdef FEAT_FOLDING
      static void
! ex_fold(exarg_T *eap)
  {
      if (foldManualAllowed(TRUE))
  	foldCreate(eap->line1, eap->line2);
  }
  
      static void
! ex_foldopen(exarg_T *eap)
  {
      opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,
  							 eap->forceit, FALSE);
  }
  
      static void
! ex_folddo(exarg_T *eap)
  {
      linenr_T	lnum;
  
*** ../vim-7.4.1205/src/ex_eval.c	2016-01-29 22:13:26.035781650 +0100
--- src/ex_eval.c	2016-01-30 15:37:52.280662434 +0100
***************
*** 93,99 ****
   * due to a parsing error, aborting() always returns the same value.
   */
      int
! aborting()
  {
      return (did_emsg && force_abort) || got_int || did_throw;
  }
--- 93,99 ----
   * due to a parsing error, aborting() always returns the same value.
   */
      int
! aborting(void)
  {
      return (did_emsg && force_abort) || got_int || did_throw;
  }
***************
*** 105,111 ****
   * error message has been reached.  update_force_abort() should be called then.
   */
      void
! update_force_abort()
  {
      if (cause_abort)
  	force_abort = TRUE;
--- 105,111 ----
   * error message has been reached.  update_force_abort() should be called then.
   */
      void
! update_force_abort(void)
  {
      if (cause_abort)
  	force_abort = TRUE;
***************
*** 118,125 ****
   * displayed and actually caused the abortion.
   */
      int
! should_abort(retcode)
!     int		retcode;
  {
      return ((retcode == FAIL && trylevel != 0 && !emsg_silent) || aborting());
  }
--- 118,124 ----
   * displayed and actually caused the abortion.
   */
      int
! should_abort(int retcode)
  {
      return ((retcode == FAIL && trylevel != 0 && !emsg_silent) || aborting());
  }
***************
*** 131,137 ****
   * commands are still reported.
   */
      int
! aborted_in_try()
  {
      /* This function is only called after an error.  In this case, "force_abort"
       * determines whether searching for finally clauses is necessary. */
--- 130,136 ----
   * commands are still reported.
   */
      int
! aborted_in_try(void)
  {
      /* This function is only called after an error.  In this case, "force_abort"
       * determines whether searching for finally clauses is necessary. */
***************
*** 148,157 ****
   * set to TRUE, if a later but severer message should be used instead.
   */
      int
! cause_errthrow(mesg, severe, ignore)
!     char_u	*mesg;
!     int		severe;
!     int		*ignore;
  {
      struct msglist *elem;
      struct msglist **plist;
--- 147,156 ----
   * set to TRUE, if a later but severer message should be used instead.
   */
      int
! cause_errthrow(
!     char_u	*mesg,
!     int		severe,
!     int		*ignore)
  {
      struct msglist *elem;
      struct msglist **plist;
***************
*** 305,312 ****
   * Free a "msg_list" and the messages it contains.
   */
      static void
! free_msglist(l)
!     struct msglist  *l;
  {
      struct msglist  *messages, *next;
  
--- 304,310 ----
   * Free a "msg_list" and the messages it contains.
   */
      static void
! free_msglist(struct msglist *l)
  {
      struct msglist  *messages, *next;
  
***************
*** 325,331 ****
   * to NULL.
   */
      void
! free_global_msglist()
  {
      free_msglist(*msg_list);
      *msg_list = NULL;
--- 323,329 ----
   * to NULL.
   */
      void
! free_global_msglist(void)
  {
      free_msglist(*msg_list);
      *msg_list = NULL;
***************
*** 337,345 ****
   * has returned (see do_one_cmd()).
   */
      void
! do_errthrow(cstack, cmdname)
!     struct condstack	*cstack;
!     char_u		*cmdname;
  {
      /*
       * Ensure that all commands in nested function calls and sourced files
--- 335,341 ----
   * has returned (see do_one_cmd()).
   */
      void
! do_errthrow(struct condstack *cstack, char_u *cmdname)
  {
      /*
       * Ensure that all commands in nested function calls and sourced files
***************
*** 374,381 ****
   * FALSE otherwise.
   */
      int
! do_intthrow(cstack)
!     struct condstack	*cstack;
  {
      /*
       * If no interrupt occurred or no try conditional is active and no exception
--- 370,376 ----
   * FALSE otherwise.
   */
      int
! do_intthrow(struct condstack *cstack)
  {
      /*
       * If no interrupt occurred or no try conditional is active and no exception
***************
*** 425,435 ****
   * Get an exception message that is to be stored in current_exception->value.
   */
      char_u *
! get_exception_string(value, type, cmdname, should_free)
!     void	*value;
!     int		type;
!     char_u	*cmdname;
!     int		*should_free;
  {
      char_u	*ret, *mesg;
      int		cmdlen;
--- 420,430 ----
   * Get an exception message that is to be stored in current_exception->value.
   */
      char_u *
! get_exception_string(
!     void	*value,
!     int		type,
!     char_u	*cmdname,
!     int		*should_free)
  {
      char_u	*ret, *mesg;
      int		cmdlen;
***************
*** 508,517 ****
   * error exception.
   */
      static int
! throw_exception(value, type, cmdname)
!     void	*value;
!     int		type;
!     char_u	*cmdname;
  {
      except_T	*excp;
      int		should_free;
--- 503,509 ----
   * error exception.
   */
      static int
! throw_exception(void *value, int type, char_u *cmdname)
  {
      except_T	*excp;
      int		should_free;
***************
*** 597,605 ****
   * caught and the catch clause has been ended normally.
   */
      static void
! discard_exception(excp, was_finished)
!     except_T		*excp;
!     int			was_finished;
  {
      char_u		*saved_IObuff;
  
--- 589,595 ----
   * caught and the catch clause has been ended normally.
   */
      static void
! discard_exception(except_T *excp, int was_finished)
  {
      char_u		*saved_IObuff;
  
***************
*** 648,654 ****
   * Discard the exception currently being thrown.
   */
      void
! discard_current_exception()
  {
      discard_exception(current_exception, FALSE);
      current_exception = NULL;
--- 638,644 ----
   * Discard the exception currently being thrown.
   */
      void
! discard_current_exception(void)
  {
      discard_exception(current_exception, FALSE);
      current_exception = NULL;
***************
*** 660,667 ****
   * Put an exception on the caught stack.
   */
      static void
! catch_exception(excp)
!     except_T	*excp;
  {
      excp->caught = caught_stack;
      caught_stack = excp;
--- 650,656 ----
   * Put an exception on the caught stack.
   */
      static void
! catch_exception(except_T *excp)
  {
      excp->caught = caught_stack;
      caught_stack = excp;
***************
*** 708,715 ****
   * Remove an exception from the caught stack.
   */
      static void
! finish_exception(excp)
!     except_T	*excp;
  {
      if (excp != caught_stack)
  	EMSG(_(e_internal));
--- 697,703 ----
   * Remove an exception from the caught stack.
   */
      static void
! finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
  	EMSG(_(e_internal));
***************
*** 758,767 ****
   * or the exception value for a pending exception.
   */
      static void
! report_pending(action, pending, value)
!     int		action;
!     int		pending;
!     void	*value;
  {
      char_u	*mesg;
      char	*s;
--- 746,752 ----
   * or the exception value for a pending exception.
   */
      static void
! report_pending(int action, int pending, void *value)
  {
      char_u	*mesg;
      char	*s;
***************
*** 841,849 ****
   * the 'verbose' option or when debugging.
   */
      void
! report_make_pending(pending, value)
!     int		pending;
!     void	*value;
  {
      if (p_verbose >= 14 || debug_break_level > 0)
      {
--- 826,832 ----
   * the 'verbose' option or when debugging.
   */
      void
! report_make_pending(int pending, void *value)
  {
      if (p_verbose >= 14 || debug_break_level > 0)
      {
***************
*** 860,868 ****
   * it if required by the 'verbose' option or when debugging.
   */
      void
! report_resume_pending(pending, value)
!     int		pending;
!     void	*value;
  {
      if (p_verbose >= 14 || debug_break_level > 0)
      {
--- 843,849 ----
   * it if required by the 'verbose' option or when debugging.
   */
      void
! report_resume_pending(int pending, void *value)
  {
      if (p_verbose >= 14 || debug_break_level > 0)
      {
***************
*** 879,887 ****
   * by the 'verbose' option or when debugging.
   */
      void
! report_discard_pending(pending, value)
!     int		pending;
!     void	*value;
  {
      if (p_verbose >= 14 || debug_break_level > 0)
      {
--- 860,866 ----
   * by the 'verbose' option or when debugging.
   */
      void
! report_discard_pending(int pending, void *value)
  {
      if (p_verbose >= 14 || debug_break_level > 0)
      {
***************
*** 898,905 ****
   * ":if".
   */
      void
! ex_if(eap)
!     exarg_T	*eap;
  {
      int		error;
      int		skip;
--- 877,883 ----
   * ":if".
   */
      void
! ex_if(exarg_T *eap)
  {
      int		error;
      int		skip;
***************
*** 937,944 ****
   * ":endif".
   */
      void
! ex_endif(eap)
!     exarg_T	*eap;
  {
      did_endif = TRUE;
      if (eap->cstack->cs_idx < 0
--- 915,921 ----
   * ":endif".
   */
      void
! ex_endif(exarg_T *eap)
  {
      did_endif = TRUE;
      if (eap->cstack->cs_idx < 0
***************
*** 968,975 ****
   * ":else" and ":elseif".
   */
      void
! ex_else(eap)
!     exarg_T	*eap;
  {
      int		error;
      int		skip;
--- 945,951 ----
   * ":else" and ":elseif".
   */
      void
! ex_else(exarg_T *eap)
  {
      int		error;
      int		skip;
***************
*** 1060,1067 ****
   * Handle ":while" and ":for".
   */
      void
! ex_while(eap)
!     exarg_T	*eap;
  {
      int		error;
      int		skip;
--- 1036,1042 ----
   * Handle ":while" and ":for".
   */
      void
! ex_while(exarg_T *eap)
  {
      int		error;
      int		skip;
***************
*** 1160,1167 ****
   * ":continue"
   */
      void
! ex_continue(eap)
!     exarg_T	*eap;
  {
      int		idx;
      struct condstack	*cstack = eap->cstack;
--- 1135,1141 ----
   * ":continue"
   */
      void
! ex_continue(exarg_T *eap)
  {
      int		idx;
      struct condstack	*cstack = eap->cstack;
***************
*** 1199,1206 ****
   * ":break"
   */
      void
! ex_break(eap)
!     exarg_T	*eap;
  {
      int		idx;
      struct condstack	*cstack = eap->cstack;
--- 1173,1179 ----
   * ":break"
   */
      void
! ex_break(exarg_T *eap)
  {
      int		idx;
      struct condstack	*cstack = eap->cstack;
***************
*** 1226,1233 ****
   * ":endwhile" and ":endfor"
   */
      void
! ex_endwhile(eap)
!     exarg_T	*eap;
  {
      struct condstack	*cstack = eap->cstack;
      int			idx;
--- 1199,1205 ----
   * ":endwhile" and ":endfor"
   */
      void
! ex_endwhile(exarg_T *eap)
  {
      struct condstack	*cstack = eap->cstack;
      int			idx;
***************
*** 1313,1320 ****
   * ":throw expr"
   */
      void
! ex_throw(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      char_u	*value;
--- 1285,1291 ----
   * ":throw expr"
   */
      void
! ex_throw(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      char_u	*value;
***************
*** 1344,1351 ****
   * used for rethrowing an uncaught exception.
   */
      void
! do_throw(cstack)
!     struct condstack	*cstack;
  {
      int		idx;
      int		inactivate_try = FALSE;
--- 1315,1321 ----
   * used for rethrowing an uncaught exception.
   */
      void
! do_throw(struct condstack *cstack)
  {
      int		idx;
      int		inactivate_try = FALSE;
***************
*** 1426,1433 ****
   * ":try"
   */
      void
! ex_try(eap)
!     exarg_T	*eap;
  {
      int		skip;
      struct condstack	*cstack = eap->cstack;
--- 1396,1402 ----
   * ":try"
   */
      void
! ex_try(exarg_T *eap)
  {
      int		skip;
      struct condstack	*cstack = eap->cstack;
***************
*** 1496,1503 ****
   * ":catch /{pattern}/" and ":catch"
   */
      void
! ex_catch(eap)
!     exarg_T	*eap;
  {
      int		idx = 0;
      int		give_up = FALSE;
--- 1465,1471 ----
   * ":catch /{pattern}/" and ":catch"
   */
      void
! ex_catch(exarg_T *eap)
  {
      int		idx = 0;
      int		give_up = FALSE;
***************
*** 1657,1664 ****
   * ":finally"
   */
      void
! ex_finally(eap)
!     exarg_T	*eap;
  {
      int		idx;
      int		skip = FALSE;
--- 1625,1631 ----
   * ":finally"
   */
      void
! ex_finally(exarg_T *eap)
  {
      int		idx;
      int		skip = FALSE;
***************
*** 1785,1792 ****
   * ":endtry"
   */
      void
! ex_endtry(eap)
!     exarg_T	*eap;
  {
      int		idx;
      int		skip;
--- 1752,1758 ----
   * ":endtry"
   */
      void
! ex_endtry(exarg_T *eap)
  {
      int		idx;
      int		skip;
***************
*** 1984,1991 ****
   * execution.
   */
      void
! enter_cleanup(csp)
!     cleanup_T	*csp;
  {
      int		pending = CSTP_NONE;
  
--- 1950,1956 ----
   * execution.
   */
      void
! enter_cleanup(cleanup_T *csp)
  {
      int		pending = CSTP_NONE;
  
***************
*** 2047,2054 ****
   * exception state is discarded.
   */
      void
! leave_cleanup(csp)
!     cleanup_T	*csp;
  {
      int		pending = csp->pending;
  
--- 2012,2018 ----
   * exception state is discarded.
   */
      void
! leave_cleanup(cleanup_T *csp)
  {
      int		pending = csp->pending;
  
***************
*** 2133,2142 ****
   * when such a try conditional is left.
   */
      int
! cleanup_conditionals(cstack, searched_cond, inclusive)
!     struct condstack   *cstack;
!     int		searched_cond;
!     int		inclusive;
  {
      int		idx;
      int		stop = FALSE;
--- 2097,2106 ----
   * when such a try conditional is left.
   */
      int
! cleanup_conditionals(
!     struct condstack   *cstack,
!     int		searched_cond,
!     int		inclusive)
  {
      int		idx;
      int		stop = FALSE;
***************
*** 2256,2263 ****
   * Return an appropriate error message for a missing endwhile/endfor/endif.
   */
     static char_u *
! get_end_emsg(cstack)
!     struct condstack	*cstack;
  {
      if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)
  	return e_endwhile;
--- 2220,2226 ----
   * Return an appropriate error message for a missing endwhile/endfor/endif.
   */
     static char_u *
! get_end_emsg(struct condstack *cstack)
  {
      if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)
  	return e_endwhile;
***************
*** 2275,2285 ****
   * Also free "for info" structures where needed.
   */
      void
! rewind_conditionals(cstack, idx, cond_type, cond_level)
!     struct condstack   *cstack;
!     int		idx;
!     int		cond_type;
!     int		*cond_level;
  {
      while (cstack->cs_idx > idx)
      {
--- 2238,2248 ----
   * Also free "for info" structures where needed.
   */
      void
! rewind_conditionals(
!     struct condstack   *cstack,
!     int		idx,
!     int		cond_type,
!     int		*cond_level)
  {
      while (cstack->cs_idx > idx)
      {
***************
*** 2295,2302 ****
   * ":endfunction" when not after a ":function"
   */
      void
! ex_endfunction(eap)
!     exarg_T	*eap UNUSED;
  {
      EMSG(_("E193: :endfunction not inside a function"));
  }
--- 2258,2264 ----
   * ":endfunction" when not after a ":function"
   */
      void
! ex_endfunction(exarg_T *eap UNUSED)
  {
      EMSG(_("E193: :endfunction not inside a function"));
  }
***************
*** 2305,2312 ****
   * Return TRUE if the string "p" looks like a ":while" or ":for" command.
   */
      int
! has_loop_cmd(p)
!     char_u	*p;
  {
      int		len;
  
--- 2267,2273 ----
   * Return TRUE if the string "p" looks like a ":while" or ":for" command.
   */
      int
! has_loop_cmd(char_u *p)
  {
      int		len;
  
*** ../vim-7.4.1205/src/ex_getln.c	2016-01-29 23:20:35.301308246 +0100
--- src/ex_getln.c	2016-01-30 15:41:36.462340590 +0100
***************
*** 156,165 ****
   * otherwise.
   */
      char_u *
! getcmdline(firstc, count, indent)
!     int		firstc;
!     long	count UNUSED;	/* only used for incremental search */
!     int		indent;		/* indent for inside conditionals */
  {
      int		c;
      int		i;
--- 156,165 ----
   * otherwise.
   */
      char_u *
! getcmdline(
!     int		firstc,
!     long	count UNUSED,	/* only used for incremental search */
!     int		indent)		/* indent for inside conditionals */
  {
      int		c;
      int		i;
***************
*** 1988,1999 ****
   * Returns the command line in allocated memory, or NULL.
   */
      char_u *
! getcmdline_prompt(firstc, prompt, attr, xp_context, xp_arg)
!     int		firstc;
!     char_u	*prompt;	/* command line prompt */
!     int		attr;		/* attributes for prompt */
!     int		xp_context;	/* type of expansion */
!     char_u	*xp_arg;	/* user-defined expansion argument */
  {
      char_u		*s;
      struct cmdline_info	save_ccline;
--- 1988,1999 ----
   * Returns the command line in allocated memory, or NULL.
   */
      char_u *
! getcmdline_prompt(
!     int		firstc,
!     char_u	*prompt,	/* command line prompt */
!     int		attr,		/* attributes for prompt */
!     int		xp_context,	/* type of expansion */
!     char_u	*xp_arg)	/* user-defined expansion argument */
  {
      char_u		*s;
      struct cmdline_info	save_ccline;
***************
*** 2026,2032 ****
   * 'balloonexpr', etc.
   */
      int
! text_locked()
  {
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
--- 2026,2032 ----
   * 'balloonexpr', etc.
   */
      int
! text_locked(void)
  {
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
***************
*** 2040,2046 ****
   * window is open or editing the cmdline in another way.
   */
      void
! text_locked_msg()
  {
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
--- 2040,2046 ----
   * window is open or editing the cmdline in another way.
   */
      void
! text_locked_msg(void)
  {
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
***************
*** 2056,2062 ****
   * and give an error message.
   */
      int
! curbuf_locked()
  {
      if (curbuf_lock > 0)
      {
--- 2056,2062 ----
   * and give an error message.
   */
      int
! curbuf_locked(void)
  {
      if (curbuf_lock > 0)
      {
***************
*** 2071,2077 ****
   * message.
   */
      int
! allbuf_locked()
  {
      if (allbuf_lock > 0)
      {
--- 2071,2077 ----
   * message.
   */
      int
! allbuf_locked(void)
  {
      if (allbuf_lock > 0)
      {
***************
*** 2083,2090 ****
  #endif
  
      static int
! cmdline_charsize(idx)
!     int		idx;
  {
  #if defined(FEAT_CRYPT) || defined(FEAT_EVAL)
      if (cmdline_star > 0)	    /* showing '*', always 1 position */
--- 2083,2089 ----
  #endif
  
      static int
! cmdline_charsize(int idx)
  {
  #if defined(FEAT_CRYPT) || defined(FEAT_EVAL)
      if (cmdline_star > 0)	    /* showing '*', always 1 position */
***************
*** 2098,2104 ****
   * indent.
   */
      static void
! set_cmdspos()
  {
      if (ccline.cmdfirstc != NUL)
  	ccline.cmdspos = 1 + ccline.cmdindent;
--- 2097,2103 ----
   * indent.
   */
      static void
! set_cmdspos(void)
  {
      if (ccline.cmdfirstc != NUL)
  	ccline.cmdspos = 1 + ccline.cmdindent;
***************
*** 2110,2116 ****
   * Compute the screen position for the cursor on the command line.
   */
      static void
! set_cmdspos_cursor()
  {
      int		i, m, c;
  
--- 2109,2115 ----
   * Compute the screen position for the cursor on the command line.
   */
      static void
! set_cmdspos_cursor(void)
  {
      int		i, m, c;
  
***************
*** 2151,2159 ****
   * character that doesn't fit, so that a ">" must be displayed.
   */
      static void
! correct_cmdspos(idx, cells)
!     int		idx;
!     int		cells;
  {
      if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1
  		&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1
--- 2150,2156 ----
   * character that doesn't fit, so that a ">" must be displayed.
   */
      static void
! correct_cmdspos(int idx, int cells)
  {
      if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1
  		&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1
***************
*** 2166,2175 ****
   * Get an Ex command line for the ":" command.
   */
      char_u *
! getexline(c, cookie, indent)
!     int		c;		/* normally ':', NUL for ":append" */
!     void	*cookie UNUSED;
!     int		indent;		/* indent for inside conditionals */
  {
      /* When executing a register, remove ':' that's in front of each line. */
      if (exec_from_reg && vpeekc() == ':')
--- 2163,2172 ----
   * Get an Ex command line for the ":" command.
   */
      char_u *
! getexline(
!     int		c,		/* normally ':', NUL for ":append" */
!     void	*cookie UNUSED,
!     int		indent)		/* indent for inside conditionals */
  {
      /* When executing a register, remove ':' that's in front of each line. */
      if (exec_from_reg && vpeekc() == ':')
***************
*** 2184,2194 ****
   * Returns a string in allocated memory or NULL.
   */
      char_u *
! getexmodeline(promptc, cookie, indent)
!     int		promptc;	/* normally ':', NUL for ":append" and '?' for
  				   :s prompt */
!     void	*cookie UNUSED;
!     int		indent;		/* indent for inside conditionals */
  {
      garray_T	line_ga;
      char_u	*pend;
--- 2181,2191 ----
   * Returns a string in allocated memory or NULL.
   */
      char_u *
! getexmodeline(
!     int		promptc,	/* normally ':', NUL for ":append" and '?' for
  				   :s prompt */
!     void	*cookie UNUSED,
!     int		indent)		/* indent for inside conditionals */
  {
      garray_T	line_ga;
      char_u	*pend;
***************
*** 2473,2479 ****
   * Return TRUE if ccline.overstrike is on.
   */
      int
! cmdline_overstrike()
  {
      return ccline.overstrike;
  }
--- 2470,2476 ----
   * Return TRUE if ccline.overstrike is on.
   */
      int
! cmdline_overstrike(void)
  {
      return ccline.overstrike;
  }
***************
*** 2482,2488 ****
   * Return TRUE if the cursor is at the end of the cmdline.
   */
      int
! cmdline_at_end()
  {
      return (ccline.cmdpos >= ccline.cmdlen);
  }
--- 2479,2485 ----
   * Return TRUE if the cursor is at the end of the cmdline.
   */
      int
! cmdline_at_end(void)
  {
      return (ccline.cmdpos >= ccline.cmdlen);
  }
***************
*** 2494,2500 ****
   * This is used by the IM code to obtain the start of the preedit string.
   */
      colnr_T
! cmdline_getvcol_cursor()
  {
      if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)
  	return MAXCOL;
--- 2491,2497 ----
   * This is used by the IM code to obtain the start of the preedit string.
   */
      colnr_T
! cmdline_getvcol_cursor(void)
  {
      if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)
  	return MAXCOL;
***************
*** 2522,2528 ****
   * IM feedback attributes.  The cursor position is restored after drawing.
   */
      static void
! redrawcmd_preedit()
  {
      if ((State & CMDLINE)
  	    && xic != NULL
--- 2519,2525 ----
   * IM feedback attributes.  The cursor position is restored after drawing.
   */
      static void
! redrawcmd_preedit(void)
  {
      if ((State & CMDLINE)
  	    && xic != NULL
***************
*** 2594,2601 ****
   * Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.
   */
      static void
! alloc_cmdbuff(len)
!     int	    len;
  {
      /*
       * give some extra space to avoid having to allocate all the time
--- 2591,2597 ----
   * Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.
   */
      static void
! alloc_cmdbuff(int len)
  {
      /*
       * give some extra space to avoid having to allocate all the time
***************
*** 2614,2621 ****
   * return FAIL for failure, OK otherwise
   */
      static int
! realloc_cmdbuff(len)
!     int	    len;
  {
      char_u	*p;
  
--- 2610,2616 ----
   * return FAIL for failure, OK otherwise
   */
      static int
! realloc_cmdbuff(int len)
  {
      char_u	*p;
  
***************
*** 2656,2662 ****
  
  # if defined(EXITFREE) || defined(PROTO)
      void
! free_cmdline_buf()
  {
      vim_free(arshape_buf);
  }
--- 2651,2657 ----
  
  # if defined(EXITFREE) || defined(PROTO)
      void
! free_cmdline_buf(void)
  {
      vim_free(arshape_buf);
  }
***************
*** 2668,2676 ****
   * when cmdline_star is TRUE.
   */
      static void
! draw_cmdline(start, len)
!     int		start;
!     int		len;
  {
  #if defined(FEAT_CRYPT) || defined(FEAT_EVAL)
      int		i;
--- 2663,2669 ----
   * when cmdline_star is TRUE.
   */
      static void
! draw_cmdline(int start, int len)
  {
  #if defined(FEAT_CRYPT) || defined(FEAT_EVAL)
      int		i;
***************
*** 2791,2799 ****
   * "c" must be printable (fit in one display cell)!
   */
      void
! putcmdline(c, shift)
!     int		c;
!     int		shift;
  {
      if (cmd_silent)
  	return;
--- 2784,2790 ----
   * "c" must be printable (fit in one display cell)!
   */
      void
! putcmdline(int c, int shift)
  {
      if (cmd_silent)
  	return;
***************
*** 2809,2815 ****
   * Undo a putcmdline(c, FALSE).
   */
      void
! unputcmdline()
  {
      if (cmd_silent)
  	return;
--- 2800,2806 ----
   * Undo a putcmdline(c, FALSE).
   */
      void
! unputcmdline(void)
  {
      if (cmd_silent)
  	return;
***************
*** 2836,2845 ****
   * called afterwards.
   */
      int
! put_on_cmdline(str, len, redraw)
!     char_u	*str;
!     int		len;
!     int		redraw;
  {
      int		retval;
      int		i;
--- 2827,2833 ----
   * called afterwards.
   */
      int
! put_on_cmdline(char_u *str, int len, int redraw)
  {
      int		retval;
      int		i;
***************
*** 3009,3016 ****
   * available globally in prev_ccline.
   */
      static void
! save_cmdline(ccp)
!     struct cmdline_info *ccp;
  {
      if (!prev_ccline_used)
      {
--- 2997,3003 ----
   * available globally in prev_ccline.
   */
      static void
! save_cmdline(struct cmdline_info *ccp)
  {
      if (!prev_ccline_used)
      {
***************
*** 3028,3035 ****
   * Restore ccline after it has been saved with save_cmdline().
   */
      static void
! restore_cmdline(ccp)
!     struct cmdline_info *ccp;
  {
      ccline = prev_ccline;
      prev_ccline = *ccp;
--- 3015,3021 ----
   * Restore ccline after it has been saved with save_cmdline().
   */
      static void
! restore_cmdline(struct cmdline_info *ccp)
  {
      ccline = prev_ccline;
      prev_ccline = *ccp;
***************
*** 3042,3048 ****
   * Returns NULL when failed.
   */
      char_u *
! save_cmdline_alloc()
  {
      struct cmdline_info *p;
  
--- 3028,3034 ----
   * Returns NULL when failed.
   */
      char_u *
! save_cmdline_alloc(void)
  {
      struct cmdline_info *p;
  
***************
*** 3056,3063 ****
   * Restore the command line from the return value of save_cmdline_alloc().
   */
      void
! restore_cmdline_alloc(p)
!     char_u  *p;
  {
      if (p != NULL)
      {
--- 3042,3048 ----
   * Restore the command line from the return value of save_cmdline_alloc().
   */
      void
! restore_cmdline_alloc(char_u *p)
  {
      if (p != NULL)
      {
***************
*** 3076,3085 ****
   * Return FAIL for failure, OK otherwise.
   */
      static int
! cmdline_paste(regname, literally, remcr)
!     int regname;
!     int literally;	/* Insert text literally instead of "as typed" */
!     int remcr;		/* remove trailing CR */
  {
      long		i;
      char_u		*arg;
--- 3061,3070 ----
   * Return FAIL for failure, OK otherwise.
   */
      static int
! cmdline_paste(
!     int regname,
!     int literally,	/* Insert text literally instead of "as typed" */
!     int remcr)		/* remove trailing CR */
  {
      long		i;
      char_u		*arg;
***************
*** 3165,3173 ****
   * line.
   */
      void
! cmdline_paste_str(s, literally)
!     char_u	*s;
!     int		literally;
  {
      int		c, cv;
  
--- 3150,3156 ----
   * line.
   */
      void
! cmdline_paste_str(char_u *s, int literally)
  {
      int		c, cv;
  
***************
*** 3202,3209 ****
   * position.
   */
      static void
! cmdline_del(from)
!     int from;
  {
      mch_memmove(ccline.cmdbuff + from, ccline.cmdbuff + ccline.cmdpos,
  	    (size_t)(ccline.cmdlen - ccline.cmdpos + 1));
--- 3185,3191 ----
   * position.
   */
      static void
! cmdline_del(int from)
  {
      mch_memmove(ccline.cmdbuff + from, ccline.cmdbuff + ccline.cmdpos,
  	    (size_t)(ccline.cmdlen - ccline.cmdpos + 1));
***************
*** 3217,3223 ****
   * search
   */
      void
! redrawcmdline()
  {
      if (cmd_silent)
  	return;
--- 3199,3205 ----
   * search
   */
      void
! redrawcmdline(void)
  {
      if (cmd_silent)
  	return;
***************
*** 3228,3234 ****
  }
  
      static void
! redrawcmdprompt()
  {
      int		i;
  
--- 3210,3216 ----
  }
  
      static void
! redrawcmdprompt(void)
  {
      int		i;
  
***************
*** 3253,3259 ****
   * Redraw what is currently on the command line.
   */
      void
! redrawcmd()
  {
      if (cmd_silent)
  	return;
--- 3235,3241 ----
   * Redraw what is currently on the command line.
   */
      void
! redrawcmd(void)
  {
      if (cmd_silent)
  	return;
***************
*** 3289,3295 ****
  }
  
      void
! compute_cmdrow()
  {
      if (exmode_active || msg_scrolled != 0)
  	cmdline_row = Rows - 1;
--- 3271,3277 ----
  }
  
      void
! compute_cmdrow(void)
  {
      if (exmode_active || msg_scrolled != 0)
  	cmdline_row = Rows - 1;
***************
*** 3299,3305 ****
  }
  
      static void
! cursorcmd()
  {
      if (cmd_silent)
  	return;
--- 3281,3287 ----
  }
  
      static void
! cursorcmd(void)
  {
      if (cmd_silent)
  	return;
***************
*** 3331,3338 ****
  }
  
      void
! gotocmdline(clr)
!     int		    clr;
  {
      msg_start();
  #ifdef FEAT_RIGHTLEFT
--- 3313,3319 ----
  }
  
      void
! gotocmdline(int clr)
  {
      msg_start();
  #ifdef FEAT_RIGHTLEFT
***************
*** 3353,3360 ****
   * backspaces and the replacement string is inserted, followed by "c".
   */
      static int
! ccheck_abbr(c)
!     int c;
  {
      if (p_paste || no_abbr)	    /* no abbreviations or in paste mode */
  	return FALSE;
--- 3334,3340 ----
   * backspaces and the replacement string is inserted, followed by "c".
   */
      static int
! ccheck_abbr(int c)
  {
      if (p_paste || no_abbr)	    /* no abbreviations or in paste mode */
  	return FALSE;
***************
*** 3367,3375 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_func_compare(s1, s2)
!     const void *s1;
!     const void *s2;
  {
      char_u *p1 = *(char_u **)s1;
      char_u *p2 = *(char_u **)s2;
--- 3347,3353 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_func_compare(const void *s1, const void *s2)
  {
      char_u *p1 = *(char_u **)s1;
      char_u *p2 = *(char_u **)s2;
***************
*** 3387,3397 ****
   * normal character (instead of being expanded).  This allows :s/^I^D etc.
   */
      static int
! nextwild(xp, type, options, escape)
!     expand_T	*xp;
!     int		type;
!     int		options;	/* extra options for ExpandOne() */
!     int		escape;		/* if TRUE, escape the returned matches */
  {
      int		i, j;
      char_u	*p1;
--- 3365,3375 ----
   * normal character (instead of being expanded).  This allows :s/^I^D etc.
   */
      static int
! nextwild(
!     expand_T	*xp,
!     int		type,
!     int		options,	/* extra options for ExpandOne() */
!     int		escape)		/* if TRUE, escape the returned matches */
  {
      int		i, j;
      char_u	*p1;
***************
*** 3540,3551 ****
   * The variables xp->xp_context and xp->xp_backslash must have been set!
   */
      char_u *
! ExpandOne(xp, str, orig, options, mode)
!     expand_T	*xp;
!     char_u	*str;
!     char_u	*orig;	    /* allocated copy of original of expanded string */
!     int		options;
!     int		mode;
  {
      char_u	*ss = NULL;
      static int	findex;
--- 3518,3529 ----
   * The variables xp->xp_context and xp->xp_backslash must have been set!
   */
      char_u *
! ExpandOne(
!     expand_T	*xp,
!     char_u	*str,
!     char_u	*orig,	    /* allocated copy of original of expanded string */
!     int		options,
!     int		mode)
  {
      char_u	*ss = NULL;
      static int	findex;
***************
*** 3771,3778 ****
   * Prepare an expand structure for use.
   */
      void
! ExpandInit(xp)
!     expand_T	*xp;
  {
      xp->xp_pattern = NULL;
      xp->xp_pattern_len = 0;
--- 3749,3755 ----
   * Prepare an expand structure for use.
   */
      void
! ExpandInit(expand_T *xp)
  {
      xp->xp_pattern = NULL;
      xp->xp_pattern_len = 0;
***************
*** 3792,3799 ****
   * Cleanup an expand structure after use.
   */
      void
! ExpandCleanup(xp)
!     expand_T	*xp;
  {
      if (xp->xp_numfiles >= 0)
      {
--- 3769,3775 ----
   * Cleanup an expand structure after use.
   */
      void
! ExpandCleanup(expand_T *xp)
  {
      if (xp->xp_numfiles >= 0)
      {
***************
*** 3803,3814 ****
  }
  
      void
! ExpandEscape(xp, str, numfiles, files, options)
!     expand_T	*xp;
!     char_u	*str;
!     int		numfiles;
!     char_u	**files;
!     int		options;
  {
      int		i;
      char_u	*p;
--- 3779,3790 ----
  }
  
      void
! ExpandEscape(
!     expand_T	*xp,
!     char_u	*str,
!     int		numfiles,
!     char_u	**files,
!     int		options)
  {
      int		i;
      char_u	*p;
***************
*** 3899,3907 ****
   * Returns the result in allocated memory.
   */
      char_u *
! vim_strsave_fnameescape(fname, shell)
!     char_u *fname;
!     int    shell;
  {
      char_u	*p;
  #ifdef BACKSLASH_IN_FILENAME
--- 3875,3881 ----
   * Returns the result in allocated memory.
   */
      char_u *
! vim_strsave_fnameescape(char_u *fname, int shell)
  {
      char_u	*p;
  #ifdef BACKSLASH_IN_FILENAME
***************
*** 3940,3947 ****
   * Put a backslash before the file name in "pp", which is in allocated memory.
   */
      static void
! escape_fname(pp)
!     char_u **pp;
  {
      char_u	*p;
  
--- 3914,3920 ----
   * Put a backslash before the file name in "pp", which is in allocated memory.
   */
      static void
! escape_fname(char_u **pp)
  {
      char_u	*p;
  
***************
*** 3960,3969 ****
   * If 'orig_pat' starts with "~/", replace the home directory with "~".
   */
      void
! tilde_replace(orig_pat, num_files, files)
!     char_u  *orig_pat;
!     int	    num_files;
!     char_u  **files;
  {
      int	    i;
      char_u  *p;
--- 3933,3942 ----
   * If 'orig_pat' starts with "~/", replace the home directory with "~".
   */
      void
! tilde_replace(
!     char_u  *orig_pat,
!     int	    num_files,
!     char_u  **files)
  {
      int	    i;
      char_u  *p;
***************
*** 3988,3996 ****
   * be inserted like a normal character.
   */
      static int
! showmatches(xp, wildmenu)
!     expand_T	*xp;
!     int		wildmenu UNUSED;
  {
  #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
      int		num_files;
--- 3961,3967 ----
   * be inserted like a normal character.
   */
      static int
! showmatches(expand_T *xp, int wildmenu UNUSED)
  {
  #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
      int		num_files;
***************
*** 4172,4179 ****
   * Find tail of file name path, but ignore trailing "/".
   */
      char_u *
! sm_gettail(s)
!     char_u	*s;
  {
      char_u	*p;
      char_u	*t = s;
--- 4143,4149 ----
   * Find tail of file name path, but ignore trailing "/".
   */
      char_u *
! sm_gettail(char_u *s)
  {
      char_u	*p;
      char_u	*t = s;
***************
*** 4203,4210 ****
   * returned.
   */
      static int
! expand_showtail(xp)
!     expand_T	*xp;
  {
      char_u	*s;
      char_u	*end;
--- 4173,4179 ----
   * returned.
   */
      static int
! expand_showtail(expand_T *xp)
  {
      char_u	*s;
      char_u	*end;
***************
*** 4239,4248 ****
   * the name into allocated memory and prepend "^".
   */
      char_u *
! addstar(fname, len, context)
!     char_u	*fname;
!     int		len;
!     int		context;	/* EXPAND_FILES etc. */
  {
      char_u	*retval;
      int		i, j;
--- 4208,4217 ----
   * the name into allocated memory and prepend "^".
   */
      char_u *
! addstar(
!     char_u	*fname,
!     int		len,
!     int		context)	/* EXPAND_FILES etc. */
  {
      char_u	*retval;
      int		i, j;
***************
*** 4408,4415 ****
   *  EXPAND_USER		    Complete user names
   */
      static void
! set_expand_context(xp)
!     expand_T	*xp;
  {
      /* only expansion for ':', '>' and '=' command-lines */
      if (ccline.cmdfirstc != ':'
--- 4377,4383 ----
   *  EXPAND_USER		    Complete user names
   */
      static void
! set_expand_context(expand_T *xp)
  {
      /* only expansion for ':', '>' and '=' command-lines */
      if (ccline.cmdfirstc != ':'
***************
*** 4426,4436 ****
  }
  
      void
! set_cmd_context(xp, str, len, col)
!     expand_T	*xp;
!     char_u	*str;	    /* start of command line */
!     int		len;	    /* length of command line (excl. NUL) */
!     int		col;	    /* position of cursor */
  {
      int		old_char = NUL;
      char_u	*nextcomm;
--- 4394,4404 ----
  }
  
      void
! set_cmd_context(
!     expand_T	*xp,
!     char_u	*str,	    /* start of command line */
!     int		len,	    /* length of command line (excl. NUL) */
!     int		col)	    /* position of cursor */
  {
      int		old_char = NUL;
      char_u	*nextcomm;
***************
*** 4485,4496 ****
   * Returns EXPAND_OK otherwise.
   */
      int
! expand_cmdline(xp, str, col, matchcount, matches)
!     expand_T	*xp;
!     char_u	*str;		/* start of command line */
!     int		col;		/* position of cursor */
!     int		*matchcount;	/* return: nr of matches */
!     char_u	***matches;	/* return: array of pointers to matches */
  {
      char_u	*file_str = NULL;
      int		options = WILD_ADD_SLASH|WILD_SILENT;
--- 4453,4464 ----
   * Returns EXPAND_OK otherwise.
   */
      int
! expand_cmdline(
!     expand_T	*xp,
!     char_u	*str,		/* start of command line */
!     int		col,		/* position of cursor */
!     int		*matchcount,	/* return: nr of matches */
!     char_u	***matches)	/* return: array of pointers to matches */
  {
      char_u	*file_str = NULL;
      int		options = WILD_ADD_SLASH|WILD_SILENT;
***************
*** 4533,4541 ****
  static void	cleanup_help_tags(int num_file, char_u **file);
  
      static void
! cleanup_help_tags(num_file, file)
!     int		num_file;
!     char_u	**file;
  {
      int		i, j;
      int		len;
--- 4501,4507 ----
  static void	cleanup_help_tags(int num_file, char_u **file);
  
      static void
! cleanup_help_tags(int num_file, char_u **file)
  {
      int		i, j;
      int		len;
***************
*** 4563,4574 ****
   * Do the expansion based on xp->xp_context and "pat".
   */
      static int
! ExpandFromContext(xp, pat, num_file, file, options)
!     expand_T	*xp;
!     char_u	*pat;
!     int		*num_file;
!     char_u	***file;
!     int		options;  /* EW_ flags */
  {
  #ifdef FEAT_CMDL_COMPL
      regmatch_T	regmatch;
--- 4529,4540 ----
   * Do the expansion based on xp->xp_context and "pat".
   */
      static int
! ExpandFromContext(
!     expand_T	*xp,
!     char_u	*pat,
!     int		*num_file,
!     char_u	***file,
!     int		options)  /* EW_ flags */
  {
  #ifdef FEAT_CMDL_COMPL
      regmatch_T	regmatch;
***************
*** 4799,4812 ****
   * Returns OK when no problems encountered, FAIL for error (out of memory).
   */
      int
! ExpandGeneric(xp, regmatch, num_file, file, func, escaped)
!     expand_T	*xp;
!     regmatch_T	*regmatch;
!     int		*num_file;
!     char_u	***file;
!     char_u	*((*func)(expand_T *, int));
  					  /* returns a string from the list */
!     int		escaped;
  {
      int		i;
      int		count = 0;
--- 4765,4778 ----
   * Returns OK when no problems encountered, FAIL for error (out of memory).
   */
      int
! ExpandGeneric(
!     expand_T	*xp,
!     regmatch_T	*regmatch,
!     int		*num_file,
!     char_u	***file,
!     char_u	*((*func)(expand_T *, int)),
  					  /* returns a string from the list */
!     int		escaped)
  {
      int		i;
      int		count = 0;
***************
*** 4891,4901 ****
   * Returns FAIL or OK;
   */
      static int
! expand_shellcmd(filepat, num_file, file, flagsarg)
!     char_u	*filepat;	/* pattern to match with command names */
!     int		*num_file;	/* return: number of matches */
!     char_u	***file;	/* return: array with matches */
!     int		flagsarg;	/* EW_ flags */
  {
      char_u	*pat;
      int		i;
--- 4857,4867 ----
   * Returns FAIL or OK;
   */
      static int
! expand_shellcmd(
!     char_u	*filepat,	/* pattern to match with command names */
!     int		*num_file,	/* return: number of matches */
!     char_u	***file,	/* return: array with matches */
!     int		flagsarg)	/* EW_ flags */
  {
      char_u	*pat;
      int		i;
***************
*** 5016,5026 ****
   * the result (either a string or a List).
   */
      static void *
! call_user_expand_func(user_expand_func, xp, num_file, file)
!     void	*(*user_expand_func)(char_u *, int, char_u **, int);
!     expand_T	*xp;
!     int		*num_file;
!     char_u	***file;
  {
      int		keep = 0;
      char_u	num[50];
--- 4982,4992 ----
   * the result (either a string or a List).
   */
      static void *
! call_user_expand_func(
!     void	*(*user_expand_func)(char_u *, int, char_u **, int),
!     expand_T	*xp,
!     int		*num_file,
!     char_u	***file)
  {
      int		keep = 0;
      char_u	num[50];
***************
*** 5066,5076 ****
   * Expand names with a function defined by the user.
   */
      static int
! ExpandUserDefined(xp, regmatch, num_file, file)
!     expand_T	*xp;
!     regmatch_T	*regmatch;
!     int		*num_file;
!     char_u	***file;
  {
      char_u	*retstr;
      char_u	*s;
--- 5032,5042 ----
   * Expand names with a function defined by the user.
   */
      static int
! ExpandUserDefined(
!     expand_T	*xp,
!     regmatch_T	*regmatch,
!     int		*num_file,
!     char_u	***file)
  {
      char_u	*retstr;
      char_u	*s;
***************
*** 5119,5128 ****
   * Expand names with a list returned by a function defined by the user.
   */
      static int
! ExpandUserList(xp, num_file, file)
!     expand_T	*xp;
!     int		*num_file;
!     char_u	***file;
  {
      list_T      *retlist;
      listitem_T	*li;
--- 5085,5094 ----
   * Expand names with a list returned by a function defined by the user.
   */
      static int
! ExpandUserList(
!     expand_T	*xp,
!     int		*num_file,
!     char_u	***file)
  {
      list_T      *retlist;
      listitem_T	*li;
***************
*** 5160,5170 ****
   * "dirnames" is an array with one or more directory names.
   */
      static int
! ExpandRTDir(pat, num_file, file, dirnames)
!     char_u	*pat;
!     int		*num_file;
!     char_u	***file;
!     char	*dirnames[];
  {
      char_u	*s;
      char_u	*e;
--- 5126,5136 ----
   * "dirnames" is an array with one or more directory names.
   */
      static int
! ExpandRTDir(
!     char_u	*pat,
!     int		*num_file,
!     char_u	***file,
!     char	*dirnames[])
  {
      char_u	*s;
      char_u	*e;
***************
*** 5228,5238 ****
   * Adds the matches to "ga".  Caller must init "ga".
   */
      void
! globpath(path, file, ga, expand_options)
!     char_u	*path;
!     char_u	*file;
!     garray_T	*ga;
!     int		expand_options;
  {
      expand_T	xpc;
      char_u	*buf;
--- 5194,5204 ----
   * Adds the matches to "ga".  Caller must init "ga".
   */
      void
! globpath(
!     char_u	*path,
!     char_u	*file,
!     garray_T	*ga,
!     int		expand_options)
  {
      expand_T	xpc;
      char_u	*buf;
***************
*** 5298,5305 ****
   * Translate a history character to the associated type number.
   */
      static int
! hist_char2type(c)
!     int	    c;
  {
      if (c == ':')
  	return HIST_CMD;
--- 5264,5270 ----
   * Translate a history character to the associated type number.
   */
      static int
! hist_char2type(int c)
  {
      if (c == ':')
  	return HIST_CMD;
***************
*** 5334,5342 ****
   * arguments of the ":history command.
   */
      static char_u *
! get_history_arg(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      static char_u compl[2] = { NUL, NUL };
      char *short_names = ":=@>?/";
--- 5299,5305 ----
   * arguments of the ":history command.
   */
      static char_u *
! get_history_arg(expand_T *xp UNUSED, int idx)
  {
      static char_u compl[2] = { NUL, NUL };
      char *short_names = ":=@>?/";
***************
*** 5361,5367 ****
   * Also used to re-allocate the history when the size changes.
   */
      void
! init_history()
  {
      int		newlen;	    /* new length of history table */
      histentry_T	*temp;
--- 5324,5330 ----
   * Also used to re-allocate the history when the size changes.
   */
      void
! init_history(void)
  {
      int		newlen;	    /* new length of history table */
      histentry_T	*temp;
***************
*** 5439,5446 ****
  }
  
      static void
! clear_hist_entry(hisptr)
!     histentry_T	*hisptr;
  {
      hisptr->hisnum = 0;
      hisptr->viminfo = FALSE;
--- 5402,5408 ----
  }
  
      static void
! clear_hist_entry(histentry_T *hisptr)
  {
      hisptr->hisnum = 0;
      hisptr->viminfo = FALSE;
***************
*** 5452,5463 ****
   * If 'move_to_front' is TRUE, matching entry is moved to end of history.
   */
      static int
! in_history(type, str, move_to_front, sep, writing)
!     int	    type;
!     char_u  *str;
!     int	    move_to_front;	/* Move the entry to the front if it exists */
!     int	    sep;
!     int	    writing;		/* ignore entries read from viminfo */
  {
      int	    i;
      int	    last_i = -1;
--- 5414,5425 ----
   * If 'move_to_front' is TRUE, matching entry is moved to end of history.
   */
      static int
! in_history(
!     int	    type,
!     char_u  *str,
!     int	    move_to_front,	/* Move the entry to the front if it exists */
!     int	    sep,
!     int	    writing)		/* ignore entries read from viminfo */
  {
      int	    i;
      int	    last_i = -1;
***************
*** 5511,5518 ****
   * Returns -1 for unknown history name.
   */
      int
! get_histtype(name)
!     char_u	*name;
  {
      int		i;
      int		len = (int)STRLEN(name);
--- 5473,5479 ----
   * Returns -1 for unknown history name.
   */
      int
! get_histtype(char_u *name)
  {
      int		i;
      int		len = (int)STRLEN(name);
***************
*** 5539,5549 ****
   * values.
   */
      void
! add_to_history(histype, new_entry, in_map, sep)
!     int		histype;
!     char_u	*new_entry;
!     int		in_map;		/* consider maptick when inside a mapping */
!     int		sep;		/* separator character used (search hist) */
  {
      histentry_T	*hisptr;
      int		len;
--- 5500,5510 ----
   * values.
   */
      void
! add_to_history(
!     int		histype,
!     char_u	*new_entry,
!     int		in_map,		/* consider maptick when inside a mapping */
!     int		sep)		/* separator character used (search hist) */
  {
      histentry_T	*hisptr;
      int		len;
***************
*** 5600,5607 ****
   * "histype" may be one of the HIST_ values.
   */
      int
! get_history_idx(histype)
!     int	    histype;
  {
      if (hislen == 0 || histype < 0 || histype >= HIST_COUNT
  		    || hisidx[histype] < 0)
--- 5561,5567 ----
   * "histype" may be one of the HIST_ values.
   */
      int
! get_history_idx(int histype)
  {
      if (hislen == 0 || histype < 0 || histype >= HIST_COUNT
  		    || hisidx[histype] < 0)
***************
*** 5617,5623 ****
   * ccline and put the previous value in prev_ccline.
   */
      static struct cmdline_info *
! get_ccline_ptr()
  {
      if ((State & CMDLINE) == 0)
  	return NULL;
--- 5577,5583 ----
   * ccline and put the previous value in prev_ccline.
   */
      static struct cmdline_info *
! get_ccline_ptr(void)
  {
      if ((State & CMDLINE) == 0)
  	return NULL;
***************
*** 5634,5640 ****
   * Returns NULL when something is wrong.
   */
      char_u *
! get_cmdline_str()
  {
      struct cmdline_info *p = get_ccline_ptr();
  
--- 5594,5600 ----
   * Returns NULL when something is wrong.
   */
      char_u *
! get_cmdline_str(void)
  {
      struct cmdline_info *p = get_ccline_ptr();
  
***************
*** 5650,5656 ****
   * Returns -1 when something is wrong.
   */
      int
! get_cmdline_pos()
  {
      struct cmdline_info *p = get_ccline_ptr();
  
--- 5610,5616 ----
   * Returns -1 when something is wrong.
   */
      int
! get_cmdline_pos(void)
  {
      struct cmdline_info *p = get_ccline_ptr();
  
***************
*** 5665,5672 ****
   * Returns 1 when failed, 0 when OK.
   */
      int
! set_cmdline_pos(pos)
!     int		pos;
  {
      struct cmdline_info *p = get_ccline_ptr();
  
--- 5625,5632 ----
   * Returns 1 when failed, 0 when OK.
   */
      int
! set_cmdline_pos(
!     int		pos)
  {
      struct cmdline_info *p = get_ccline_ptr();
  
***************
*** 5707,5715 ****
   * "histype" may be one of the HIST_ values.
   */
      static int
! calc_hist_idx(histype, num)
!     int		histype;
!     int		num;
  {
      int		i;
      histentry_T	*hist;
--- 5667,5673 ----
   * "histype" may be one of the HIST_ values.
   */
      static int
! calc_hist_idx(int histype, int num)
  {
      int		i;
      histentry_T	*hist;
***************
*** 5749,5757 ****
   * "histype" may be one of the HIST_ values.
   */
      char_u *
! get_history_entry(histype, idx)
!     int	    histype;
!     int	    idx;
  {
      idx = calc_hist_idx(histype, idx);
      if (idx >= 0)
--- 5707,5713 ----
   * "histype" may be one of the HIST_ values.
   */
      char_u *
! get_history_entry(int histype, int idx)
  {
      idx = calc_hist_idx(histype, idx);
      if (idx >= 0)
***************
*** 5765,5772 ****
   * "histype" may be one of the HIST_ values.
   */
      int
! clr_history(histype)
!     int		histype;
  {
      int		i;
      histentry_T	*hisptr;
--- 5721,5727 ----
   * "histype" may be one of the HIST_ values.
   */
      int
! clr_history(int histype)
  {
      int		i;
      histentry_T	*hisptr;
***************
*** 5791,5799 ****
   * "histype" may be one of the HIST_ values.
   */
      int
! del_history_entry(histype, str)
!     int		histype;
!     char_u	*str;
  {
      regmatch_T	regmatch;
      histentry_T	*hisptr;
--- 5746,5752 ----
   * "histype" may be one of the HIST_ values.
   */
      int
! del_history_entry(int histype, char_u *str)
  {
      regmatch_T	regmatch;
      histentry_T	*hisptr;
***************
*** 5849,5857 ****
   * "histype" may be one of the HIST_ values.
   */
      int
! del_history_idx(histype, idx)
!     int	    histype;
!     int	    idx;
  {
      int	    i, j;
  
--- 5802,5808 ----
   * "histype" may be one of the HIST_ values.
   */
      int
! del_history_idx(int histype, int idx)
  {
      int	    i, j;
  
***************
*** 5888,5894 ****
   * history.
   */
      void
! remove_key_from_history()
  {
      char_u	*p;
      int		i;
--- 5839,5845 ----
   * history.
   */
      void
! remove_key_from_history(void)
  {
      char_u	*p;
      int		i;
***************
*** 5923,5932 ****
   * Returns OK if parsed successfully, otherwise FAIL.
   */
      int
! get_list_range(str, num1, num2)
!     char_u	**str;
!     int		*num1;
!     int		*num2;
  {
      int		len;
      int		first = FALSE;
--- 5874,5880 ----
   * Returns OK if parsed successfully, otherwise FAIL.
   */
      int
! get_list_range(char_u **str, int *num1, int *num2)
  {
      int		len;
      int		first = FALSE;
***************
*** 5964,5971 ****
   * :history command - print a history
   */
      void
! ex_history(eap)
!     exarg_T	*eap;
  {
      histentry_T	*hist;
      int		histype1 = HIST_CMD;
--- 5912,5918 ----
   * :history command - print a history
   */
      void
! ex_history(exarg_T *eap)
  {
      histentry_T	*hist;
      int		histype1 = HIST_CMD;
***************
*** 6072,6080 ****
   * Translate a history type number to the associated character.
   */
      static int
! hist_type2char(type, use_question)
!     int	    type;
!     int	    use_question;	    /* use '?' instead of '/' */
  {
      if (type == HIST_CMD)
  	return ':';
--- 6019,6027 ----
   * Translate a history type number to the associated character.
   */
      static int
! hist_type2char(
!     int	    type,
!     int	    use_question)	    /* use '?' instead of '/' */
  {
      if (type == HIST_CMD)
  	return ':';
***************
*** 6095,6103 ****
   * This allocates history arrays to store the read history lines.
   */
      void
! prepare_viminfo_history(asklen, writing)
!     int	    asklen;
!     int	    writing;
  {
      int	    i;
      int	    num;
--- 6042,6048 ----
   * This allocates history arrays to store the read history lines.
   */
      void
! prepare_viminfo_history(int asklen, int writing)
  {
      int	    i;
      int	    num;
***************
*** 6137,6145 ****
   * new.
   */
      int
! read_viminfo_history(virp, writing)
!     vir_T	*virp;
!     int		writing;
  {
      int		type;
      long_u	len;
--- 6082,6088 ----
   * new.
   */
      int
! read_viminfo_history(vir_T *virp, int writing)
  {
      int		type;
      long_u	len;
***************
*** 6189,6195 ****
   * Finish reading history lines from viminfo.  Not used when writing viminfo.
   */
      void
! finish_viminfo_history()
  {
      int idx;
      int i;
--- 6132,6138 ----
   * Finish reading history lines from viminfo.  Not used when writing viminfo.
   */
      void
! finish_viminfo_history(void)
  {
      int idx;
      int i;
***************
*** 6249,6257 ****
   * When "merge" is FALSE just write all history lines.  Used for ":wviminfo!".
   */
      void
! write_viminfo_history(fp, merge)
!     FILE    *fp;
!     int	    merge;
  {
      int	    i;
      int	    type;
--- 6192,6200 ----
   * When "merge" is FALSE just write all history lines.  Used for ":wviminfo!".
   */
      void
! write_viminfo_history(
!     FILE    *fp,
!     int	    merge)
  {
      int	    i;
      int	    type;
***************
*** 6348,6355 ****
   * It is directly written into the command buffer block.
   */
      void
! cmd_pchar(c, offset)
!     int	    c, offset;
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
--- 6291,6297 ----
   * It is directly written into the command buffer block.
   */
      void
! cmd_pchar(int c, int offset)
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
***************
*** 6361,6368 ****
  }
  
      int
! cmd_gchar(offset)
!     int	    offset;
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
--- 6303,6309 ----
  }
  
      int
! cmd_gchar(int offset)
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
***************
*** 6383,6389 ****
   *	K_IGNORE if editing continues
   */
      static int
! ex_window()
  {
      struct cmdline_info	save_ccline;
      buf_T		*old_curbuf = curbuf;
--- 6324,6330 ----
   *	K_IGNORE if editing continues
   */
      static int
! ex_window(void)
  {
      struct cmdline_info	save_ccline;
      buf_T		*old_curbuf = curbuf;
***************
*** 6674,6682 ****
   * Returns a pointer to allocated memory with {script} or NULL.
   */
      char_u *
! script_get(eap, cmd)
!     exarg_T	*eap;
!     char_u	*cmd;
  {
      char_u	*theline;
      char	*end_pattern = NULL;
--- 6615,6621 ----
   * Returns a pointer to allocated memory with {script} or NULL.
   */
      char_u *
! script_get(exarg_T *eap, char_u *cmd)
  {
      char_u	*theline;
      char	*end_pattern = NULL;
*** ../vim-7.4.1205/src/farsi.c	2016-01-29 22:13:26.039781608 +0100
--- src/farsi.c	2016-01-30 15:43:38.293078706 +0100
***************
*** 38,45 ****
  ** Convert the given Farsi character into a _X or _X_ type
  */
      static int
! toF_Xor_X_(c)
!     int	c;
  {
      int tempc;
  
--- 38,44 ----
  ** Convert the given Farsi character into a _X or _X_ type
  */
      static int
! toF_Xor_X_(int c)
  {
      int tempc;
  
***************
*** 132,139 ****
  ** Convert the given Farsi character into Farsi capital character .
  */
      int
! toF_TyA(c)
!     int	c ;
  {
      switch (c)
      {
--- 131,137 ----
  ** Convert the given Farsi character into Farsi capital character .
  */
      int
! toF_TyA(int c )
  {
      switch (c)
      {
***************
*** 212,219 ****
  ** Note: the offset is used only for command line buffer.
  */
      static int
! F_is_TyB_TyC_TyD(src, offset)
!     int		src, offset;
  {
      int		c;
  
--- 210,216 ----
  ** Note: the offset is used only for command line buffer.
  */
      static int
! F_is_TyB_TyC_TyD(int src, int offset)
  {
      int		c;
  
***************
*** 264,271 ****
  ** Is the Farsi character one of the terminating only type.
  */
      static int
! F_is_TyE(c)
!     int	    c;
  {
      switch (c)
      {
--- 261,267 ----
  ** Is the Farsi character one of the terminating only type.
  */
      static int
! F_is_TyE(int c)
  {
      switch (c)
      {
***************
*** 288,295 ****
  ** Is the Farsi character one of the none leading type.
  */
      static int
! F_is_TyC_TyD(c)
!     int	    c;
  {
      switch (c)
      {
--- 284,290 ----
  ** Is the Farsi character one of the none leading type.
  */
      static int
! F_is_TyC_TyD(int c)
  {
      switch (c)
      {
***************
*** 313,320 ****
  ** Convert a none leading Farsi char into a leading type.
  */
      static int
! toF_TyB(c)
!     int	    c;
  {
      switch (c)
      {
--- 308,314 ----
  ** Convert a none leading Farsi char into a leading type.
  */
      static int
! toF_TyB(int c)
  {
      switch (c)
      {
***************
*** 337,344 ****
  ** Overwrite the current redo and cursor characters + left adjust
  */
      static void
! put_curr_and_l_to_X(c)
!     int		  c;
  {
      int	tempc;
  
--- 331,337 ----
  ** Overwrite the current redo and cursor characters + left adjust
  */
      static void
! put_curr_and_l_to_X(int c)
  {
      int	tempc;
  
***************
*** 372,379 ****
  }
  
      static void
! put_and_redo(c)
!     int c;
  {
      pchar_cursor(c);
      AppendCharToRedobuff(K_BS);
--- 365,371 ----
  }
  
      static void
! put_and_redo(int c)
  {
      pchar_cursor(c);
      AppendCharToRedobuff(K_BS);
***************
*** 384,390 ****
  ** Change the char. under the cursor to a X_ or X type
  */
      static void
! chg_c_toX_orX()
  {
      int	tempc, curc;
  
--- 376,382 ----
  ** Change the char. under the cursor to a X_ or X type
  */
      static void
! chg_c_toX_orX(void)
  {
      int	tempc, curc;
  
***************
*** 509,515 ****
  */
  
      static void
! chg_c_to_X_orX_()
  {
      int	tempc;
  
--- 501,507 ----
  */
  
      static void
! chg_c_to_X_orX_(void)
  {
      int	tempc;
  
***************
*** 560,566 ****
  ** Change the char. under the cursor to a _X_ or _X type
  */
      static void
! chg_c_to_X_or_X ()
  {
      int	tempc;
  
--- 552,558 ----
  ** Change the char. under the cursor to a _X_ or _X type
  */
      static void
! chg_c_to_X_or_X (void)
  {
      int	tempc;
  
***************
*** 591,597 ****
  ** Change the character left to the cursor to a _X_ or X_ type
  */
      static void
! chg_l_to_X_orX_ ()
  {
      int	tempc;
  
--- 583,589 ----
  ** Change the character left to the cursor to a _X_ or X_ type
  */
      static void
! chg_l_to_X_orX_ (void)
  {
      int	tempc;
  
***************
*** 660,666 ****
  */
  
      static void
! chg_l_toXor_X ()
  {
      int	tempc;
  
--- 652,658 ----
  */
  
      static void
! chg_l_toXor_X (void)
  {
      int	tempc;
  
***************
*** 729,735 ****
  */
  
      static void
! chg_r_to_Xor_X_()
  {
      int tempc, c;
  
--- 721,727 ----
  */
  
      static void
! chg_r_to_Xor_X_(void)
  {
      int tempc, c;
  
***************
*** 754,761 ****
  */
  
      int
! fkmap(c)
!     int c;
  {
      int		tempc;
      static int	revins;
--- 746,752 ----
  */
  
      int
! fkmap(int c)
  {
      int		tempc;
      static int	revins;
***************
*** 1473,1480 ****
  ** Convert a none leading Farsi char into a leading type.
  */
      static int
! toF_leading(c)
!     int	    c;
  {
      switch (c)
      {
--- 1464,1470 ----
  ** Convert a none leading Farsi char into a leading type.
  */
      static int
! toF_leading(int c)
  {
      switch (c)
      {
***************
*** 1528,1535 ****
  ** Convert a given Farsi char into right joining type.
  */
      static int
! toF_Rjoin(c)
!     int	    c;
  {
      switch (c)
      {
--- 1518,1524 ----
  ** Convert a given Farsi char into right joining type.
  */
      static int
! toF_Rjoin(int c)
  {
      switch (c)
      {
***************
*** 1585,1592 ****
  ** Can a given Farsi character join via its left edj.
  */
      static int
! canF_Ljoin(c)
!     int	c;
  {
      switch (c)
      {
--- 1574,1580 ----
  ** Can a given Farsi character join via its left edj.
  */
      static int
! canF_Ljoin(int c)
  {
      switch (c)
      {
***************
*** 1660,1667 ****
  ** Can a given Farsi character join via its right edj.
  */
      static int
! canF_Rjoin(c)
!     int	    c;
  {
      switch (c)
      {
--- 1648,1654 ----
  ** Can a given Farsi character join via its right edj.
  */
      static int
! canF_Rjoin(int c)
  {
      switch (c)
      {
***************
*** 1689,1696 ****
  ** is a given Farsi character a terminating type.
  */
      static int
! F_isterm(c)
!     int	    c;
  {
      switch (c)
      {
--- 1676,1682 ----
  ** is a given Farsi character a terminating type.
  */
      static int
! F_isterm(int c)
  {
      switch (c)
      {
***************
*** 1717,1724 ****
  ** Convert the given Farsi character into a ending type .
  */
      static int
! toF_ending(c)
!     int	    c;
  {
  
      switch (c)
--- 1703,1709 ----
  ** Convert the given Farsi character into a ending type .
  */
      static int
! toF_ending(int c)
  {
  
      switch (c)
***************
*** 1795,1801 ****
  ** Convert the Farsi 3342 standard into Farsi VIM.
  */
      void
! conv_to_pvim()
  {
      char_u	*ptr;
      int		lnum, llen, i;
--- 1780,1786 ----
  ** Convert the Farsi 3342 standard into Farsi VIM.
  */
      void
! conv_to_pvim(void)
  {
      char_u	*ptr;
      int		lnum, llen, i;
***************
*** 1844,1850 ****
   * Convert the Farsi VIM into Farsi 3342 standard.
   */
      void
! conv_to_pstd()
  {
      char_u	*ptr;
      int		lnum, llen, i;
--- 1829,1835 ----
   * Convert the Farsi VIM into Farsi 3342 standard.
   */
      void
! conv_to_pstd(void)
  {
      char_u	*ptr;
      int		lnum, llen, i;
***************
*** 1877,1885 ****
   * left-right swap the characters in buf[len].
   */
      static void
! lrswapbuf(buf, len)
!     char_u	*buf;
!     int		len;
  {
      char_u	*s, *e;
      int		c;
--- 1862,1868 ----
   * left-right swap the characters in buf[len].
   */
      static void
! lrswapbuf(char_u *buf, int len)
  {
      char_u	*s, *e;
      int		c;
***************
*** 1901,1908 ****
   * swap all the characters in reverse direction
   */
      char_u *
! lrswap(ibuf)
!     char_u	*ibuf;
  {
      if (ibuf != NULL && *ibuf != NUL)
  	lrswapbuf(ibuf, (int)STRLEN(ibuf));
--- 1884,1890 ----
   * swap all the characters in reverse direction
   */
      char_u *
! lrswap(char_u *ibuf)
  {
      if (ibuf != NULL && *ibuf != NUL)
  	lrswapbuf(ibuf, (int)STRLEN(ibuf));
***************
*** 1913,1921 ****
   * swap all the Farsi characters in reverse direction
   */
      char_u *
! lrFswap(cmdbuf, len)
!     char_u	*cmdbuf;
!     int		len;
  {
      int		i, cnt;
  
--- 1895,1901 ----
   * swap all the Farsi characters in reverse direction
   */
      char_u *
! lrFswap(char_u *cmdbuf, int len)
  {
      int		i, cnt;
  
***************
*** 1945,1952 ****
   * TODO: handle different separator characters.  Use skip_regexp().
   */
      char_u *
! lrF_sub(ibuf)
!     char_u	*ibuf;
  {
      char_u	*p, *ep;
      int		i, cnt;
--- 1925,1931 ----
   * TODO: handle different separator characters.  Use skip_regexp().
   */
      char_u *
! lrF_sub(char_u *ibuf)
  {
      char_u	*p, *ep;
      int		i, cnt;
***************
*** 1986,1993 ****
   * Map Farsi keyboard when in cmd_fkmap mode.
   */
      int
! cmdl_fkmap(c)
!     int c;
  {
      int	    tempc;
  
--- 1965,1971 ----
   * Map Farsi keyboard when in cmd_fkmap mode.
   */
      int
! cmdl_fkmap(int c)
  {
      int	    tempc;
  
***************
*** 2246,2253 ****
   * F_isalpha returns TRUE if 'c' is a Farsi alphabet
   */
      int
! F_isalpha(c)
!     int	c;
  {
      return (( c >= TEE_ && c <= _YE)
  	    || (c >= ALEF_A && c <= YE)
--- 2224,2230 ----
   * F_isalpha returns TRUE if 'c' is a Farsi alphabet
   */
      int
! F_isalpha(int c)
  {
      return (( c >= TEE_ && c <= _YE)
  	    || (c >= ALEF_A && c <= YE)
***************
*** 2258,2265 ****
   * F_isdigit returns TRUE if 'c' is a Farsi digit
   */
      int
! F_isdigit(c)
!     int	c;
  {
      return (c >= FARSI_0 && c <= FARSI_9);
  }
--- 2235,2241 ----
   * F_isdigit returns TRUE if 'c' is a Farsi digit
   */
      int
! F_isdigit(int c)
  {
      return (c >= FARSI_0 && c <= FARSI_9);
  }
***************
*** 2268,2282 ****
   * F_ischar returns TRUE if 'c' is a Farsi character.
   */
      int
! F_ischar(c)
!     int	c;
  {
!     return (c >= TEE_ && c <= YE_);
  }
  
      void
! farsi_fkey(cap)
!     cmdarg_T	*cap;
  {
      int		c = cap->cmdchar;
  
--- 2244,2257 ----
   * F_ischar returns TRUE if 'c' is a Farsi character.
   */
      int
! F_ischar(int c)
  {
!  return (c >= TEE_ && c <= YE_);
  }
  
      void
! farsi_fkey(
!     cmdarg_T	*cap)
  {
      int		c = cap->cmdchar;
  
*** ../vim-7.4.1205/src/fileio.c	2016-01-29 22:13:26.043781566 +0100
--- src/fileio.c	2016-01-30 15:48:08.262281519 +0100
***************
*** 144,154 ****
  #endif
  
      void
! filemess(buf, name, s, attr)
!     buf_T	*buf;
!     char_u	*name;
!     char_u	*s;
!     int		attr;
  {
      int		msg_scroll_save;
  
--- 144,154 ----
  #endif
  
      void
! filemess(
!     buf_T	*buf,
!     char_u	*name,
!     char_u	*s,
!     int		attr)
  {
      int		msg_scroll_save;
  
***************
*** 204,217 ****
   * return FAIL for failure, OK otherwise
   */
      int
! readfile(fname, sfname, from, lines_to_skip, lines_to_read, eap, flags)
!     char_u	*fname;
!     char_u	*sfname;
!     linenr_T	from;
!     linenr_T	lines_to_skip;
!     linenr_T	lines_to_read;
!     exarg_T	*eap;			/* can be NULL! */
!     int		flags;
  {
      int		fd = 0;
      int		newfile = (flags & READ_NEW);
--- 204,217 ----
   * return FAIL for failure, OK otherwise
   */
      int
! readfile(
!     char_u	*fname,
!     char_u	*sfname,
!     linenr_T	from,
!     linenr_T	lines_to_skip,
!     linenr_T	lines_to_read,
!     exarg_T	*eap,			/* can be NULL! */
!     int		flags)
  {
      int		fd = 0;
      int		newfile = (flags & READ_NEW);
***************
*** 2696,2703 ****
   * Do not accept "/dev/fd/[012]", opening these may hang Vim.
   */
      static int
! is_dev_fd_file(fname)
!     char_u	*fname;
  {
      return (STRNCMP(fname, "/dev/fd/", 8) == 0
  	    && VIM_ISDIGIT(fname[8])
--- 2696,2702 ----
   * Do not accept "/dev/fd/[012]", opening these may hang Vim.
   */
      static int
! is_dev_fd_file(char_u *fname)
  {
      return (STRNCMP(fname, "/dev/fd/", 8) == 0
  	    && VIM_ISDIGIT(fname[8])
***************
*** 2715,2724 ****
   * Used for error messages that include a line number.
   */
      static linenr_T
! readfile_linenr(linecnt, p, endp)
!     linenr_T	linecnt;	/* line count before reading more bytes */
!     char_u	*p;		/* start of more bytes read */
!     char_u	*endp;		/* end of more bytes read */
  {
      char_u	*s;
      linenr_T	lnum;
--- 2714,2723 ----
   * Used for error messages that include a line number.
   */
      static linenr_T
! readfile_linenr(
!     linenr_T	linecnt,	/* line count before reading more bytes */
!     char_u	*p,		/* start of more bytes read */
!     char_u	*endp)		/* end of more bytes read */
  {
      char_u	*s;
      linenr_T	lnum;
***************
*** 2737,2745 ****
   * Returns OK or FAIL.
   */
      int
! prep_exarg(eap, buf)
!     exarg_T	*eap;
!     buf_T	*buf;
  {
      eap->cmd = alloc((unsigned)(STRLEN(buf->b_p_ff)
  #ifdef FEAT_MBYTE
--- 2736,2742 ----
   * Returns OK or FAIL.
   */
      int
! prep_exarg(exarg_T *eap, buf_T *buf)
  {
      eap->cmd = alloc((unsigned)(STRLEN(buf->b_p_ff)
  #ifdef FEAT_MBYTE
***************
*** 2768,2776 ****
   * Set default or forced 'fileformat' and 'binary'.
   */
      void
! set_file_options(set_options, eap)
!     int set_options;
!     exarg_T *eap;
  {
      /* set default 'fileformat' */
      if (set_options)
--- 2765,2771 ----
   * Set default or forced 'fileformat' and 'binary'.
   */
      void
! set_file_options(int set_options, exarg_T *eap)
  {
      /* set default 'fileformat' */
      if (set_options)
***************
*** 2796,2803 ****
   * Set forced 'fileencoding'.
   */
      void
! set_forced_fenc(eap)
!     exarg_T *eap;
  {
      if (eap->force_enc != 0)
      {
--- 2791,2797 ----
   * Set forced 'fileencoding'.
   */
      void
! set_forced_fenc(exarg_T *eap)
  {
      if (eap->force_enc != 0)
      {
***************
*** 2818,2825 ****
   * When *pp is not set to NULL, the result is in allocated memory.
   */
      static char_u *
! next_fenc(pp)
!     char_u	**pp;
  {
      char_u	*p;
      char_u	*r;
--- 2812,2818 ----
   * When *pp is not set to NULL, the result is in allocated memory.
   */
      static char_u *
! next_fenc(char_u **pp)
  {
      char_u	*p;
      char_u	*r;
***************
*** 2864,2873 ****
   * Returns NULL if the conversion failed ("*fdp" is not set) .
   */
      static char_u *
! readfile_charconvert(fname, fenc, fdp)
!     char_u	*fname;		/* name of input file */
!     char_u	*fenc;		/* converted from */
!     int		*fdp;		/* in/out: file descriptor of file */
  {
      char_u	*tmpname;
      char_u	*errmsg = NULL;
--- 2857,2866 ----
   * Returns NULL if the conversion failed ("*fdp" is not set) .
   */
      static char_u *
! readfile_charconvert(
!     char_u	*fname,		/* name of input file */
!     char_u	*fenc,		/* converted from */
!     int		*fdp)		/* in/out: file descriptor of file */
  {
      char_u	*tmpname;
      char_u	*errmsg = NULL;
***************
*** 2916,2922 ****
   * buffer marks and the buffer has a name.
   */
      static void
! check_marks_read()
  {
      if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
  						  && curbuf->b_ffname != NULL)
--- 2909,2915 ----
   * buffer marks and the buffer has a name.
   */
      static void
! check_marks_read(void)
  {
      if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
  						  && curbuf->b_ffname != NULL)
***************
*** 2936,2949 ****
   * Return the (new) encryption key, NULL for no encryption.
   */
      static char_u *
! check_for_cryptkey(cryptkey, ptr, sizep, filesizep, newfile, fname, did_ask)
!     char_u	*cryptkey;	/* previous encryption key or NULL */
!     char_u	*ptr;		/* pointer to read bytes */
!     long	*sizep;		/* length of read bytes */
!     off_t	*filesizep;	/* nr of bytes used from file */
!     int		newfile;	/* editing a new buffer */
!     char_u	*fname;		/* file name to display */
!     int		*did_ask;	/* flag: whether already asked for key */
  {
      int method = crypt_method_nr_from_magic((char *)ptr, *sizep);
      int b_p_ro = curbuf->b_p_ro;
--- 2929,2942 ----
   * Return the (new) encryption key, NULL for no encryption.
   */
      static char_u *
! check_for_cryptkey(
!     char_u	*cryptkey,	/* previous encryption key or NULL */
!     char_u	*ptr,		/* pointer to read bytes */
!     long	*sizep,		/* length of read bytes */
!     off_t	*filesizep,	/* nr of bytes used from file */
!     int		newfile,	/* editing a new buffer */
!     char_u	*fname,		/* file name to display */
!     int		*did_ask)	/* flag: whether already asked for key */
  {
      int method = crypt_method_nr_from_magic((char *)ptr, *sizep);
      int b_p_ro = curbuf->b_p_ro;
***************
*** 3011,3020 ****
  
  #ifdef UNIX
      static void
! set_file_time(fname, atime, mtime)
!     char_u  *fname;
!     time_t  atime;	    /* access time */
!     time_t  mtime;	    /* modification time */
  {
  # if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)
      struct utimbuf  buf;
--- 3004,3013 ----
  
  #ifdef UNIX
      static void
! set_file_time(
!     char_u  *fname,
!     time_t  atime,	    /* access time */
!     time_t  mtime)	    /* modification time */
  {
  # if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)
      struct utimbuf  buf;
***************
*** 3049,3057 ****
   * Return TRUE if a file appears to be read-only from the file permissions.
   */
      int
! check_file_readonly(fname, perm)
!     char_u	*fname;		/* full path to file */
!     int		perm;		/* known permissions on file */
  {
  #ifndef USE_MCH_ACCESS
      int	    fd = 0;
--- 3042,3050 ----
   * Return TRUE if a file appears to be read-only from the file permissions.
   */
      int
! check_file_readonly(
!     char_u	*fname,		/* full path to file */
!     int		perm)		/* known permissions on file */
  {
  #ifndef USE_MCH_ACCESS
      int	    fd = 0;
***************
*** 3088,3105 ****
   * return FAIL for failure, OK otherwise
   */
      int
! buf_write(buf, fname, sfname, start, end, eap, append, forceit,
! 						      reset_changed, filtering)
!     buf_T	    *buf;
!     char_u	    *fname;
!     char_u	    *sfname;
!     linenr_T	    start, end;
!     exarg_T	    *eap;		/* for forced 'ff' and 'fenc', can be
  					   NULL! */
!     int		    append;		/* append to the file */
!     int		    forceit;
!     int		    reset_changed;
!     int		    filtering;
  {
      int		    fd;
      char_u	    *backup = NULL;
--- 3081,3098 ----
   * return FAIL for failure, OK otherwise
   */
      int
! buf_write(
!     buf_T	    *buf,
!     char_u	    *fname,
!     char_u	    *sfname,
!     linenr_T	    start,
!     linenr_T	    end,
!     exarg_T	    *eap,		/* for forced 'ff' and 'fenc', can be
  					   NULL! */
!     int		    append,		/* append to the file */
!     int		    forceit,
!     int		    reset_changed,
!     int		    filtering)
  {
      int		    fd;
      char_u	    *backup = NULL;
***************
*** 5123,5131 ****
   * name and a ":r" or ":w" command with a file name is used.
   */
      static int
! set_rw_fname(fname, sfname)
!     char_u	*fname;
!     char_u	*sfname;
  {
  #ifdef FEAT_AUTOCMD
      buf_T	*buf = curbuf;
--- 5116,5122 ----
   * name and a ":r" or ":w" command with a file name is used.
   */
      static int
! set_rw_fname(char_u *fname, char_u *sfname)
  {
  #ifdef FEAT_AUTOCMD
      buf_T	*buf = curbuf;
***************
*** 5175,5183 ****
   * Put file name into IObuff with quotes.
   */
      void
! msg_add_fname(buf, fname)
!     buf_T	*buf;
!     char_u	*fname;
  {
      if (fname == NULL)
  	fname = (char_u *)"-stdin-";
--- 5166,5172 ----
   * Put file name into IObuff with quotes.
   */
      void
! msg_add_fname(buf_T *buf, char_u *fname)
  {
      if (fname == NULL)
  	fname = (char_u *)"-stdin-";
***************
*** 5191,5198 ****
   * Return TRUE if something appended.
   */
      static int
! msg_add_fileformat(eol_type)
!     int	    eol_type;
  {
  #ifndef USE_CRNL
      if (eol_type == EOL_DOS)
--- 5180,5186 ----
   * Return TRUE if something appended.
   */
      static int
! msg_add_fileformat(int eol_type)
  {
  #ifndef USE_CRNL
      if (eol_type == EOL_DOS)
***************
*** 5222,5231 ****
   * Append line and character count to IObuff.
   */
      void
! msg_add_lines(insert_space, lnum, nchars)
!     int	    insert_space;
!     long    lnum;
!     off_t   nchars;
  {
      char_u  *p;
  
--- 5210,5219 ----
   * Append line and character count to IObuff.
   */
      void
! msg_add_lines(
!     int	    insert_space,
!     long    lnum,
!     off_t   nchars)
  {
      char_u  *p;
  
***************
*** 5267,5273 ****
   * Append message for missing line separator to IObuff.
   */
      static void
! msg_add_eol()
  {
      STRCAT(IObuff, shortmess(SHM_LAST) ? _("[noeol]") : _("[Incomplete last line]"));
  }
--- 5255,5261 ----
   * Append message for missing line separator to IObuff.
   */
      static void
! msg_add_eol(void)
  {
      STRCAT(IObuff, shortmess(SHM_LAST) ? _("[noeol]") : _("[Incomplete last line]"));
  }
***************
*** 5278,5286 ****
   * using the same timestamp but can't set the size.
   */
      static int
! check_mtime(buf, st)
!     buf_T		*buf;
!     struct stat		*st;
  {
      if (buf->b_mtime_read != 0
  	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
--- 5266,5272 ----
   * using the same timestamp but can't set the size.
   */
      static int
! check_mtime(buf_T *buf, struct stat *st)
  {
      if (buf->b_mtime_read != 0
  	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
***************
*** 5299,5306 ****
  }
  
      static int
! time_differs(t1, t2)
!     long	t1, t2;
  {
  #if defined(__linux__) || defined(MSDOS) || defined(MSWIN)
      /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store
--- 5285,5291 ----
  }
  
      static int
! time_differs(long t1, long t2)
  {
  #if defined(__linux__) || defined(MSDOS) || defined(MSWIN)
      /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store
***************
*** 5319,5326 ****
   * Return FAIL for failure, OK otherwise.
   */
      static int
! buf_write_bytes(ip)
!     struct bw_info *ip;
  {
      int		wlen;
      char_u	*buf = ip->bw_buf;	/* data to write */
--- 5304,5310 ----
   * Return FAIL for failure, OK otherwise.
   */
      static int
! buf_write_bytes(struct bw_info *ip)
  {
      int		wlen;
      char_u	*buf = ip->bw_buf;	/* data to write */
***************
*** 5714,5723 ****
   * Return TRUE for an error, FALSE when it's OK.
   */
      static int
! ucs2bytes(c, pp, flags)
!     unsigned	c;		/* in: character */
!     char_u	**pp;		/* in/out: pointer to result */
!     int		flags;		/* FIO_ flags */
  {
      char_u	*p = *pp;
      int		error = FALSE;
--- 5698,5707 ----
   * Return TRUE for an error, FALSE when it's OK.
   */
      static int
! ucs2bytes(
!     unsigned	c,		/* in: character */
!     char_u	**pp,		/* in/out: pointer to result */
!     int		flags)		/* FIO_ flags */
  {
      char_u	*p = *pp;
      int		error = FALSE;
***************
*** 5799,5806 ****
   * 'encoding'.
   */
      static int
! need_conversion(fenc)
!     char_u	*fenc;
  {
      int		same_encoding;
      int		enc_flags;
--- 5783,5789 ----
   * 'encoding'.
   */
      static int
! need_conversion(char_u *fenc)
  {
      int		same_encoding;
      int		enc_flags;
***************
*** 5837,5844 ****
   * if "ptr" is an empty string, use 'encoding'.
   */
      static int
! get_fio_flags(ptr)
!     char_u	*ptr;
  {
      int		prop;
  
--- 5820,5826 ----
   * if "ptr" is an empty string, use 'encoding'.
   */
      static int
! get_fio_flags(char_u *ptr)
  {
      int		prop;
  
***************
*** 5881,5888 ****
   * Used for conversion between 'encoding' and 'fileencoding'.
   */
      static int
! get_win_fio_flags(ptr)
!     char_u	*ptr;
  {
      int		cp;
  
--- 5863,5869 ----
   * Used for conversion between 'encoding' and 'fileencoding'.
   */
      static int
! get_win_fio_flags(char_u *ptr)
  {
      int		cp;
  
***************
*** 5910,5917 ****
   * needed for the internal conversion to/from utf-8 or latin1.
   */
      static int
! get_mac_fio_flags(ptr)
!     char_u	*ptr;
  {
      if ((enc_utf8 || STRCMP(p_enc, "latin1") == 0)
  				     && (enc_canon_props(ptr) & ENC_MACROMAN))
--- 5891,5897 ----
   * needed for the internal conversion to/from utf-8 or latin1.
   */
      static int
! get_mac_fio_flags(char_u *ptr)
  {
      if ((enc_utf8 || STRCMP(p_enc, "latin1") == 0)
  				     && (enc_canon_props(ptr) & ENC_MACROMAN))
***************
*** 5927,5937 ****
   * Returns NULL when no BOM found.
   */
      static char_u *
! check_for_bom(p, size, lenp, flags)
!     char_u	*p;
!     long	size;
!     int		*lenp;
!     int		flags;
  {
      char	*name = NULL;
      int		len = 2;
--- 5907,5917 ----
   * Returns NULL when no BOM found.
   */
      static char_u *
! check_for_bom(
!     char_u	*p,
!     long	size,
!     int		*lenp,
!     int		flags)
  {
      char	*name = NULL;
      int		len = 2;
***************
*** 5981,5989 ****
   * Return the length of the BOM (zero when no BOM).
   */
      static int
! make_bom(buf, name)
!     char_u	*buf;
!     char_u	*name;
  {
      int		flags;
      char_u	*p;
--- 5961,5967 ----
   * Return the length of the BOM (zero when no BOM).
   */
      static int
! make_bom(char_u *buf, char_u *name)
  {
      int		flags;
      char_u	*p;
***************
*** 6015,6022 ****
   * Returns "full_path" or pointer into "full_path" if shortened.
   */
      char_u *
! shorten_fname1(full_path)
!     char_u	*full_path;
  {
      char_u	*dirname;
      char_u	*p = full_path;
--- 5993,5999 ----
   * Returns "full_path" or pointer into "full_path" if shortened.
   */
      char_u *
! shorten_fname1(char_u *full_path)
  {
      char_u	*dirname;
      char_u	*p = full_path;
***************
*** 6042,6050 ****
   * otherwise.
   */
      char_u *
! shorten_fname(full_path, dir_name)
!     char_u	*full_path;
!     char_u	*dir_name;
  {
      int		len;
      char_u	*p;
--- 6019,6025 ----
   * otherwise.
   */
      char_u *
! shorten_fname(char_u *full_path, char_u *dir_name)
  {
      int		len;
      char_u	*p;
***************
*** 6099,6106 ****
   * name.
   */
      void
! shorten_fnames(force)
!     int		force;
  {
      char_u	dirname[MAXPATHL];
      buf_T	*buf;
--- 6074,6080 ----
   * name.
   */
      void
! shorten_fnames(int force)
  {
      char_u	dirname[MAXPATHL];
      buf_T	*buf;
***************
*** 6148,6156 ****
   * Shorten all filenames in "fnames[count]" by current directory.
   */
      void
! shorten_filenames(fnames, count)
!     char_u	**fnames;
!     int		count;
  {
      int		i;
      char_u	dirname[MAXPATHL];
--- 6122,6128 ----
   * Shorten all filenames in "fnames[count]" by current directory.
   */
      void
! shorten_filenames(char_u **fnames, int count)
  {
      int		i;
      char_u	dirname[MAXPATHL];
***************
*** 6186,6194 ****
   * Returns NULL when out of memory.
   */
      char_u *
! modname(fname, ext, prepend_dot)
!     char_u *fname, *ext;
!     int	    prepend_dot;	/* may prepend a '.' to file name */
  {
      return buf_modname(
  #ifdef SHORT_FNAME
--- 6158,6167 ----
   * Returns NULL when out of memory.
   */
      char_u *
! modname(
!     char_u *fname,
!     char_u *ext,
!     int	    prepend_dot)	/* may prepend a '.' to file name */
  {
      return buf_modname(
  #ifdef SHORT_FNAME
***************
*** 6200,6209 ****
  }
  
      char_u *
! buf_modname(shortname, fname, ext, prepend_dot)
!     int	    shortname;		/* use 8.3 file name */
!     char_u  *fname, *ext;
!     int	    prepend_dot;	/* may prepend a '.' to file name */
  {
      char_u	*retval;
      char_u	*s;
--- 6173,6183 ----
  }
  
      char_u *
! buf_modname(
!     int	    shortname,		/* use 8.3 file name */
!     char_u  *fname,
!     char_u  *ext,
!     int	    prepend_dot)	/* may prepend a '.' to file name */
  {
      char_u	*retval;
      char_u	*s;
***************
*** 6387,6396 ****
   * rest of the line is thrown away.  Returns TRUE for end-of-file.
   */
      int
! vim_fgets(buf, size, fp)
!     char_u	*buf;
!     int		size;
!     FILE	*fp;
  {
      char	*eof;
  #define FGETS_SIZE 200
--- 6361,6367 ----
   * rest of the line is thrown away.  Returns TRUE for end-of-file.
   */
      int
! vim_fgets(char_u *buf, int size, FILE *fp)
  {
      char	*eof;
  #define FGETS_SIZE 200
***************
*** 6427,6436 ****
   * Only used for the Mac, because it's much slower than vim_fgets().
   */
      int
! tag_fgets(buf, size, fp)
!     char_u	*buf;
!     int		size;
!     FILE	*fp;
  {
      int		i = 0;
      int		c;
--- 6398,6404 ----
   * Only used for the Mac, because it's much slower than vim_fgets().
   */
      int
! tag_fgets(char_u *buf, int size, FILE *fp)
  {
      int		i = 0;
      int		c;
***************
*** 6470,6478 ****
   * Return -1 for failure, 0 for success.
   */
      int
! vim_rename(from, to)
!     char_u	*from;
!     char_u	*to;
  {
      int		fd_in;
      int		fd_out;
--- 6438,6444 ----
   * Return -1 for failure, 0 for success.
   */
      int
! vim_rename(char_u *from, char_u *to)
  {
      int		fd_in;
      int		fd_out;
***************
*** 6690,6697 ****
   * cursor positioned).
   */
      int
! check_timestamps(focus)
!     int		focus;		/* called for GUI focus event */
  {
      buf_T	*buf;
      int		didit = 0;
--- 6656,6663 ----
   * cursor positioned).
   */
      int
! check_timestamps(
!     int		focus)		/* called for GUI focus event */
  {
      buf_T	*buf;
      int		didit = 0;
***************
*** 6758,6766 ****
   * empty.
   */
      static int
! move_lines(frombuf, tobuf)
!     buf_T	*frombuf;
!     buf_T	*tobuf;
  {
      buf_T	*tbuf = curbuf;
      int		retval = OK;
--- 6724,6730 ----
   * empty.
   */
      static int
! move_lines(buf_T *frombuf, buf_T *tobuf)
  {
      buf_T	*tbuf = curbuf;
      int		retval = OK;
***************
*** 6807,6815 ****
   * return 0 otherwise.
   */
      int
! buf_check_timestamp(buf, focus)
!     buf_T	*buf;
!     int		focus UNUSED;	/* called for GUI focus event */
  {
      struct stat	st;
      int		stat_res;
--- 6771,6779 ----
   * return 0 otherwise.
   */
      int
! buf_check_timestamp(
!     buf_T	*buf,
!     int		focus UNUSED)	/* called for GUI focus event */
  {
      struct stat	st;
      int		stat_res;
***************
*** 7100,7108 ****
   * buf->b_orig_mode may have been reset already.
   */
      void
! buf_reload(buf, orig_mode)
!     buf_T	*buf;
!     int		orig_mode;
  {
      exarg_T	ea;
      pos_T	old_cursor;
--- 7064,7070 ----
   * buf->b_orig_mode may have been reset already.
   */
      void
! buf_reload(buf_T *buf, int orig_mode)
  {
      exarg_T	ea;
      pos_T	old_cursor;
***************
*** 7254,7263 ****
  }
  
      void
! buf_store_time(buf, st, fname)
!     buf_T	*buf;
!     struct stat	*st;
!     char_u	*fname UNUSED;
  {
      buf->b_mtime = (long)st->st_mtime;
      buf->b_orig_size = st->st_size;
--- 7216,7222 ----
  }
  
      void
! buf_store_time(buf_T *buf, struct stat *st, char_u *fname UNUSED)
  {
      buf->b_mtime = (long)st->st_mtime;
      buf->b_orig_size = st->st_size;
***************
*** 7273,7280 ****
   * Used for do_filter(), when the input lines for the filter are deleted.
   */
      void
! write_lnum_adjust(offset)
!     linenr_T	offset;
  {
      if (curbuf->b_no_eol_lnum != 0)	/* only if there is a missing eol */
  	curbuf->b_no_eol_lnum += offset;
--- 7232,7238 ----
   * Used for do_filter(), when the input lines for the filter are deleted.
   */
      void
! write_lnum_adjust(linenr_T offset)
  {
      if (curbuf->b_no_eol_lnum != 0)	/* only if there is a missing eol */
  	curbuf->b_no_eol_lnum += offset;
***************
*** 7335,7341 ****
   * Delete the temp directory and all files it contains.
   */
      void
! vim_deltempdir()
  {
      if (vim_tempdir != NULL)
      {
--- 7293,7299 ----
   * Delete the temp directory and all files it contains.
   */
      void
! vim_deltempdir(void)
  {
      if (vim_tempdir != NULL)
      {
***************
*** 7353,7360 ****
   * "tempdir" must be no longer than MAXPATHL.
   */
      static void
! vim_settempdir(tempdir)
!     char_u	*tempdir;
  {
      char_u	*buf;
  
--- 7311,7317 ----
   * "tempdir" must be no longer than MAXPATHL.
   */
      static void
! vim_settempdir(char_u *tempdir)
  {
      char_u	*buf;
  
***************
*** 7385,7393 ****
   * The returned pointer is NULL if no valid name was found.
   */
      char_u  *
! vim_tempname(extra_char, keep)
!     int	    extra_char UNUSED;  /* char to use in the name instead of '?' */
!     int	    keep UNUSED;
  {
  #ifdef USE_TMPNAM
      char_u	itmp[L_tmpnam];	/* use tmpnam() */
--- 7342,7350 ----
   * The returned pointer is NULL if no valid name was found.
   */
      char_u  *
! vim_tempname(
!     int	    extra_char UNUSED,  /* char to use in the name instead of '?' */
!     int	    keep UNUSED)
  {
  #ifdef USE_TMPNAM
      char_u	itmp[L_tmpnam];	/* use tmpnam() */
***************
*** 7587,7594 ****
   * it looks like a URL.
   */
      void
! forward_slash(fname)
!     char_u	*fname;
  {
      char_u	*p;
  
--- 7544,7550 ----
   * it looks like a URL.
   */
      void
! forward_slash(char_u *fname)
  {
      char_u	*p;
  
***************
*** 7838,7846 ****
   * Show the autocommands for one AutoPat.
   */
      static void
! show_autocmd(ap, event)
!     AutoPat	*ap;
!     event_T	event;
  {
      AutoCmd *ac;
  
--- 7794,7800 ----
   * Show the autocommands for one AutoPat.
   */
      static void
! show_autocmd(AutoPat *ap, event_T event)
  {
      AutoCmd *ac;
  
***************
*** 7904,7911 ****
   * Mark an autocommand pattern for deletion.
   */
      static void
! au_remove_pat(ap)
!     AutoPat *ap;
  {
      vim_free(ap->pat);
      ap->pat = NULL;
--- 7858,7864 ----
   * Mark an autocommand pattern for deletion.
   */
      static void
! au_remove_pat(AutoPat *ap)
  {
      vim_free(ap->pat);
      ap->pat = NULL;
***************
*** 7917,7924 ****
   * Mark all commands for a pattern for deletion.
   */
      static void
! au_remove_cmds(ap)
!     AutoPat *ap;
  {
      AutoCmd *ac;
  
--- 7870,7876 ----
   * Mark all commands for a pattern for deletion.
   */
      static void
! au_remove_cmds(AutoPat *ap)
  {
      AutoCmd *ac;
  
***************
*** 7935,7941 ****
   * This is only done when not executing autocommands.
   */
      static void
! au_cleanup()
  {
      AutoPat	*ap, **prev_ap;
      AutoCmd	*ac, **prev_ac;
--- 7887,7893 ----
   * This is only done when not executing autocommands.
   */
      static void
! au_cleanup(void)
  {
      AutoPat	*ap, **prev_ap;
      AutoCmd	*ac, **prev_ac;
***************
*** 7988,7995 ****
   * autocmds.
   */
      void
! aubuflocal_remove(buf)
!     buf_T	*buf;
  {
      AutoPat	*ap;
      event_T	event;
--- 7940,7946 ----
   * autocmds.
   */
      void
! aubuflocal_remove(buf_T *buf)
  {
      AutoPat	*ap;
      event_T	event;
***************
*** 8025,8032 ****
   * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.
   */
      static int
! au_new_group(name)
!     char_u	*name;
  {
      int		i;
  
--- 7976,7982 ----
   * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.
   */
      static int
! au_new_group(char_u *name)
  {
      int		i;
  
***************
*** 8051,8058 ****
  }
  
      static void
! au_del_group(name)
!     char_u	*name;
  {
      int	    i;
  
--- 8001,8007 ----
  }
  
      static void
! au_del_group(char_u *name)
  {
      int	    i;
  
***************
*** 8071,8078 ****
   * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.
   */
      static int
! au_find_group(name)
!     char_u	*name;
  {
      int	    i;
  
--- 8020,8026 ----
   * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.
   */
      static int
! au_find_group(char_u *name)
  {
      int	    i;
  
***************
*** 8086,8093 ****
   * Return TRUE if augroup "name" exists.
   */
      int
! au_has_group(name)
!     char_u	*name;
  {
      return au_find_group(name) != AUGROUP_ERROR;
  }
--- 8034,8040 ----
   * Return TRUE if augroup "name" exists.
   */
      int
! au_has_group(char_u *name)
  {
      return au_find_group(name) != AUGROUP_ERROR;
  }
***************
*** 8096,8104 ****
   * ":augroup {name}".
   */
      void
! do_augroup(arg, del_group)
!     char_u	*arg;
!     int		del_group;
  {
      int	    i;
  
--- 8043,8049 ----
   * ":augroup {name}".
   */
      void
! do_augroup(char_u *arg, int del_group)
  {
      int	    i;
  
***************
*** 8135,8141 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_all_autocmds()
  {
      for (current_augroup = -1; current_augroup < augroups.ga_len;
  							    ++current_augroup)
--- 8080,8086 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_all_autocmds(void)
  {
      for (current_augroup = -1; current_augroup < augroups.ga_len;
  							    ++current_augroup)
***************
*** 8150,8158 ****
   * Return a pointer to the next event name in "end".
   */
      static event_T
! event_name2nr(start, end)
!     char_u  *start;
!     char_u  **end;
  {
      char_u	*p;
      int		i;
--- 8095,8101 ----
   * Return a pointer to the next event name in "end".
   */
      static event_T
! event_name2nr(char_u *start, char_u **end)
  {
      char_u	*p;
      int		i;
***************
*** 8179,8186 ****
   * Return the name for event "event".
   */
      static char_u *
! event_nr2name(event)
!     event_T	event;
  {
      int	    i;
  
--- 8122,8128 ----
   * Return the name for event "event".
   */
      static char_u *
! event_nr2name(event_T event)
  {
      int	    i;
  
***************
*** 8194,8202 ****
   * Scan over the events.  "*" stands for all events.
   */
      static char_u *
! find_end_event(arg, have_group)
!     char_u  *arg;
!     int	    have_group;	    /* TRUE when group name was found */
  {
      char_u  *pat;
      char_u  *p;
--- 8136,8144 ----
   * Scan over the events.  "*" stands for all events.
   */
      static char_u *
! find_end_event(
!     char_u  *arg,
!     int	    have_group)	    /* TRUE when group name was found */
  {
      char_u  *pat;
      char_u  *p;
***************
*** 8231,8238 ****
   * Return TRUE if "event" is included in 'eventignore'.
   */
      static int
! event_ignored(event)
!     event_T	event;
  {
      char_u	*p = p_ei;
  
--- 8173,8179 ----
   * Return TRUE if "event" is included in 'eventignore'.
   */
      static int
! event_ignored(event_T event)
  {
      char_u	*p = p_ei;
  
***************
*** 8251,8257 ****
   * Return OK when the contents of p_ei is valid, FAIL otherwise.
   */
      int
! check_ei()
  {
      char_u	*p = p_ei;
  
--- 8192,8198 ----
   * Return OK when the contents of p_ei is valid, FAIL otherwise.
   */
      int
! check_ei(void)
  {
      char_u	*p = p_ei;
  
***************
*** 8278,8285 ****
   * Returns the old value of 'eventignore' in allocated memory.
   */
      char_u *
! au_event_disable(what)
!     char	*what;
  {
      char_u	*new_ei;
      char_u	*save_ei;
--- 8219,8225 ----
   * Returns the old value of 'eventignore' in allocated memory.
   */
      char_u *
! au_event_disable(char *what)
  {
      char_u	*new_ei;
      char_u	*save_ei;
***************
*** 8303,8310 ****
  }
  
      void
! au_event_restore(old_ei)
!     char_u	*old_ei;
  {
      if (old_ei != NULL)
      {
--- 8243,8249 ----
  }
  
      void
! au_event_restore(char_u *old_ei)
  {
      if (old_ei != NULL)
      {
***************
*** 8348,8356 ****
   * Mostly a {group} argument can optionally appear before <event>.
   */
      void
! do_autocmd(arg, forceit)
!     char_u  *arg;
!     int	    forceit;
  {
      char_u	*pat;
      char_u	*envpat = NULL;
--- 8287,8293 ----
   * Mostly a {group} argument can optionally appear before <event>.
   */
      void
! do_autocmd(char_u *arg, int forceit)
  {
      char_u	*pat;
      char_u	*envpat = NULL;
***************
*** 8466,8473 ****
   * Returns the group ID, AUGROUP_ERROR for error (out of memory).
   */
      static int
! au_get_grouparg(argp)
!     char_u	**argp;
  {
      char_u	*group_name;
      char_u	*p;
--- 8403,8409 ----
   * Returns the group ID, AUGROUP_ERROR for error (out of memory).
   */
      static int
! au_get_grouparg(char_u **argp)
  {
      char_u	*group_name;
      char_u	*p;
***************
*** 8498,8510 ****
   * If group is not AUGROUP_ALL, only use this group.
   */
      static int
! do_autocmd_event(event, pat, nested, cmd, forceit, group)
!     event_T	event;
!     char_u	*pat;
!     int		nested;
!     char_u	*cmd;
!     int		forceit;
!     int		group;
  {
      AutoPat	*ap;
      AutoPat	**prev_ap;
--- 8434,8446 ----
   * If group is not AUGROUP_ALL, only use this group.
   */
      static int
! do_autocmd_event(
!     event_T	event,
!     char_u	*pat,
!     int		nested,
!     char_u	*cmd,
!     int		forceit,
!     int		group)
  {
      AutoPat	*ap;
      AutoPat	**prev_ap;
***************
*** 8747,8755 ****
   * Return OK for success, FAIL for failure;
   */
      int
! do_doautocmd(arg, do_msg)
!     char_u	*arg;
!     int		do_msg;	    /* give message for no matching autocmds? */
  {
      char_u	*fname;
      int		nothing_done = TRUE;
--- 8683,8691 ----
   * Return OK for success, FAIL for failure;
   */
      int
! do_doautocmd(
!     char_u	*arg,
!     int		do_msg)	    /* give message for no matching autocmds? */
  {
      char_u	*fname;
      int		nothing_done = TRUE;
***************
*** 8800,8807 ****
   * ":doautoall": execute autocommands for each loaded buffer.
   */
      void
! ex_doautoall(eap)
!     exarg_T	*eap;
  {
      int		retval;
      aco_save_T	aco;
--- 8736,8742 ----
   * ":doautoall": execute autocommands for each loaded buffer.
   */
      void
! ex_doautoall(exarg_T *eap)
  {
      int		retval;
      aco_save_T	aco;
***************
*** 8852,8859 ****
   * Thus return TRUE when do_modelines() should be called.
   */
      int
! check_nomodeline(argp)
!     char_u **argp;
  {
      if (STRNCMP(*argp, "<nomodeline>", 12) == 0)
      {
--- 8787,8793 ----
   * Thus return TRUE when do_modelines() should be called.
   */
      int
! check_nomodeline(char_u **argp)
  {
      if (STRNCMP(*argp, "<nomodeline>", 12) == 0)
      {
***************
*** 8871,8879 ****
   * When FEAT_AUTOCMD is not defined another version is used, see below.
   */
      void
! aucmd_prepbuf(aco, buf)
!     aco_save_T	*aco;		/* structure to save values in */
!     buf_T	*buf;		/* new curbuf */
  {
      win_T	*win;
  #ifdef FEAT_WINDOWS
--- 8805,8813 ----
   * When FEAT_AUTOCMD is not defined another version is used, see below.
   */
      void
! aucmd_prepbuf(
!     aco_save_T	*aco,		/* structure to save values in */
!     buf_T	*buf)		/* new curbuf */
  {
      win_T	*win;
  #ifdef FEAT_WINDOWS
***************
*** 8974,8981 ****
   * When FEAT_AUTOCMD is not defined another version is used, see below.
   */
      void
! aucmd_restbuf(aco)
!     aco_save_T	*aco;		/* structure holding saved values */
  {
  #ifdef FEAT_WINDOWS
      int dummy;
--- 8908,8915 ----
   * When FEAT_AUTOCMD is not defined another version is used, see below.
   */
      void
! aucmd_restbuf(
!     aco_save_T	*aco)		/* structure holding saved values */
  {
  #ifdef FEAT_WINDOWS
      int dummy;
***************
*** 9089,9100 ****
   * Return TRUE if some commands were executed.
   */
      int
! apply_autocmds(event, fname, fname_io, force, buf)
!     event_T	event;
!     char_u	*fname;	    /* NULL or empty means use actual file name */
!     char_u	*fname_io;  /* fname to use for <afile> on cmdline */
!     int		force;	    /* when TRUE, ignore autocmd_busy */
!     buf_T	*buf;	    /* buffer for <abuf> */
  {
      return apply_autocmds_group(event, fname, fname_io, force,
  						      AUGROUP_ALL, buf, NULL);
--- 9023,9034 ----
   * Return TRUE if some commands were executed.
   */
      int
! apply_autocmds(
!     event_T	event,
!     char_u	*fname,	    /* NULL or empty means use actual file name */
!     char_u	*fname_io,  /* fname to use for <afile> on cmdline */
!     int		force,	    /* when TRUE, ignore autocmd_busy */
!     buf_T	*buf)	    /* buffer for <abuf> */
  {
      return apply_autocmds_group(event, fname, fname_io, force,
  						      AUGROUP_ALL, buf, NULL);
***************
*** 9105,9117 ****
   * setting v:filearg.
   */
      static int
! apply_autocmds_exarg(event, fname, fname_io, force, buf, eap)
!     event_T	event;
!     char_u	*fname;
!     char_u	*fname_io;
!     int		force;
!     buf_T	*buf;
!     exarg_T	*eap;
  {
      return apply_autocmds_group(event, fname, fname_io, force,
  						       AUGROUP_ALL, buf, eap);
--- 9039,9051 ----
   * setting v:filearg.
   */
      static int
! apply_autocmds_exarg(
!     event_T	event,
!     char_u	*fname,
!     char_u	*fname_io,
!     int		force,
!     buf_T	*buf,
!     exarg_T	*eap)
  {
      return apply_autocmds_group(event, fname, fname_io, force,
  						       AUGROUP_ALL, buf, eap);
***************
*** 9124,9136 ****
   * cause the script to be aborted, retval is set to FAIL.
   */
      int
! apply_autocmds_retval(event, fname, fname_io, force, buf, retval)
!     event_T	event;
!     char_u	*fname;	    /* NULL or empty means use actual file name */
!     char_u	*fname_io;  /* fname to use for <afile> on cmdline */
!     int		force;	    /* when TRUE, ignore autocmd_busy */
!     buf_T	*buf;	    /* buffer for <abuf> */
!     int		*retval;    /* pointer to caller's retval */
  {
      int		did_cmd;
  
--- 9058,9070 ----
   * cause the script to be aborted, retval is set to FAIL.
   */
      int
! apply_autocmds_retval(
!     event_T	event,
!     char_u	*fname,	    /* NULL or empty means use actual file name */
!     char_u	*fname_io,  /* fname to use for <afile> on cmdline */
!     int		force,	    /* when TRUE, ignore autocmd_busy */
!     buf_T	*buf,	    /* buffer for <abuf> */
!     int		*retval)    /* pointer to caller's retval */
  {
      int		did_cmd;
  
***************
*** 9154,9160 ****
   * Return TRUE when there is a CursorHold autocommand defined.
   */
      int
! has_cursorhold()
  {
      return (first_autopat[(int)(get_real_state() == NORMAL_BUSY
  			    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);
--- 9088,9094 ----
   * Return TRUE when there is a CursorHold autocommand defined.
   */
      int
! has_cursorhold(void)
  {
      return (first_autopat[(int)(get_real_state() == NORMAL_BUSY
  			    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);
***************
*** 9164,9170 ****
   * Return TRUE if the CursorHold event can be triggered.
   */
      int
! trigger_cursorhold()
  {
      int		state;
  
--- 9098,9104 ----
   * Return TRUE if the CursorHold event can be triggered.
   */
      int
! trigger_cursorhold(void)
  {
      int		state;
  
***************
*** 9188,9194 ****
   * Return TRUE when there is a CursorMoved autocommand defined.
   */
      int
! has_cursormoved()
  {
      return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);
  }
--- 9122,9128 ----
   * Return TRUE when there is a CursorMoved autocommand defined.
   */
      int
! has_cursormoved(void)
  {
      return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);
  }
***************
*** 9197,9203 ****
   * Return TRUE when there is a CursorMovedI autocommand defined.
   */
      int
! has_cursormovedI()
  {
      return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);
  }
--- 9131,9137 ----
   * Return TRUE when there is a CursorMovedI autocommand defined.
   */
      int
! has_cursormovedI(void)
  {
      return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);
  }
***************
*** 9206,9212 ****
   * Return TRUE when there is a TextChanged autocommand defined.
   */
      int
! has_textchanged()
  {
      return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);
  }
--- 9140,9146 ----
   * Return TRUE when there is a TextChanged autocommand defined.
   */
      int
! has_textchanged(void)
  {
      return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);
  }
***************
*** 9215,9221 ****
   * Return TRUE when there is a TextChangedI autocommand defined.
   */
      int
! has_textchangedI()
  {
      return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);
  }
--- 9149,9155 ----
   * Return TRUE when there is a TextChangedI autocommand defined.
   */
      int
! has_textchangedI(void)
  {
      return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);
  }
***************
*** 9224,9230 ****
   * Return TRUE when there is an InsertCharPre autocommand defined.
   */
      int
! has_insertcharpre()
  {
      return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);
  }
--- 9158,9164 ----
   * Return TRUE when there is an InsertCharPre autocommand defined.
   */
      int
! has_insertcharpre(void)
  {
      return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);
  }
***************
*** 9233,9239 ****
   * Return TRUE when there is an CmdUndefined autocommand defined.
   */
      int
! has_cmdundefined()
  {
      return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);
  }
--- 9167,9173 ----
   * Return TRUE when there is an CmdUndefined autocommand defined.
   */
      int
! has_cmdundefined(void)
  {
      return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);
  }
***************
*** 9242,9262 ****
   * Return TRUE when there is an FuncUndefined autocommand defined.
   */
      int
! has_funcundefined()
  {
      return (first_autopat[(int)EVENT_FUNCUNDEFINED] != NULL);
  }
  
      static int
! apply_autocmds_group(event, fname, fname_io, force, group, buf, eap)
!     event_T	event;
!     char_u	*fname;	    /* NULL or empty means use actual file name */
!     char_u	*fname_io;  /* fname to use for <afile> on cmdline, NULL means
  			       use fname */
!     int		force;	    /* when TRUE, ignore autocmd_busy */
!     int		group;	    /* group ID, or AUGROUP_ALL */
!     buf_T	*buf;	    /* buffer for <abuf> */
!     exarg_T	*eap;	    /* command arguments */
  {
      char_u	*sfname = NULL;	/* short file name */
      char_u	*tail;
--- 9176,9196 ----
   * Return TRUE when there is an FuncUndefined autocommand defined.
   */
      int
! has_funcundefined(void)
  {
      return (first_autopat[(int)EVENT_FUNCUNDEFINED] != NULL);
  }
  
      static int
! apply_autocmds_group(
!     event_T	event,
!     char_u	*fname,	    /* NULL or empty means use actual file name */
!     char_u	*fname_io,  /* fname to use for <afile> on cmdline, NULL means
  			       use fname */
!     int		force,	    /* when TRUE, ignore autocmd_busy */
!     int		group,	    /* group ID, or AUGROUP_ALL */
!     buf_T	*buf,	    /* buffer for <abuf> */
!     exarg_T	*eap)	    /* command arguments */
  {
      char_u	*sfname = NULL;	/* short file name */
      char_u	*tail;
***************
*** 9647,9653 ****
   * Can be used recursively, so long as it's symmetric.
   */
      void
! block_autocmds()
  {
  # ifdef FEAT_EVAL
      /* Remember the value of v:termresponse. */
--- 9581,9587 ----
   * Can be used recursively, so long as it's symmetric.
   */
      void
! block_autocmds(void)
  {
  # ifdef FEAT_EVAL
      /* Remember the value of v:termresponse. */
***************
*** 9658,9664 ****
  }
  
      void
! unblock_autocmds()
  {
      --autocmd_blocked;
  
--- 9592,9598 ----
  }
  
      void
! unblock_autocmds(void)
  {
      --autocmd_blocked;
  
***************
*** 9673,9679 ****
  }
  
      int
! is_autocmd_blocked()
  {
      return autocmd_blocked != 0;
  }
--- 9607,9613 ----
  }
  
      int
! is_autocmd_blocked(void)
  {
      return autocmd_blocked != 0;
  }
***************
*** 9682,9690 ****
   * Find next autocommand pattern that matches.
   */
      static void
! auto_next_pat(apc, stop_at_last)
!     AutoPatCmd	*apc;
!     int		stop_at_last;	    /* stop when 'last' flag is set */
  {
      AutoPat	*ap;
      AutoCmd	*cp;
--- 9616,9624 ----
   * Find next autocommand pattern that matches.
   */
      static void
! auto_next_pat(
!     AutoPatCmd	*apc,
!     int		stop_at_last)	    /* stop when 'last' flag is set */
  {
      AutoPat	*ap;
      AutoCmd	*cp;
***************
*** 9748,9757 ****
   * Returns allocated string, or NULL for end of autocommands.
   */
      char_u *
! getnextac(c, cookie, indent)
!     int	    c UNUSED;
!     void    *cookie;
!     int	    indent UNUSED;
  {
      AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
      char_u	    *retval;
--- 9682,9688 ----
   * Returns allocated string, or NULL for end of autocommands.
   */
      char_u *
! getnextac(int c UNUSED, void *cookie, int indent UNUSED)
  {
      AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
      char_u	    *retval;
***************
*** 9812,9821 ****
   * in which buffer the file will be opened.
   */
      int
! has_autocmd(event, sfname, buf)
!     event_T	event;
!     char_u	*sfname;
!     buf_T       *buf;
  {
      AutoPat	*ap;
      char_u	*fname;
--- 9743,9749 ----
   * in which buffer the file will be opened.
   */
      int
! has_autocmd(event_T event, char_u *sfname, buf_T *buf)
  {
      AutoPat	*ap;
      char_u	*fname;
***************
*** 9863,9871 ****
   * names.
   */
      char_u *
! get_augroup_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (idx == augroups.ga_len)		/* add "END" add the end */
  	return (char_u *)"END";
--- 9791,9797 ----
   * names.
   */
      char_u *
! get_augroup_name(expand_T *xp UNUSED, int idx)
  {
      if (idx == augroups.ga_len)		/* add "END" add the end */
  	return (char_u *)"END";
***************
*** 9879,9888 ****
  static int include_groups = FALSE;
  
      char_u  *
! set_context_in_autocmd(xp, arg, doautocmd)
!     expand_T	*xp;
!     char_u	*arg;
!     int		doautocmd;	/* TRUE for :doauto*, FALSE for :autocmd */
  {
      char_u	*p;
      int		group;
--- 9805,9814 ----
  static int include_groups = FALSE;
  
      char_u  *
! set_context_in_autocmd(
!     expand_T	*xp,
!     char_u	*arg,
!     int		doautocmd)	/* TRUE for :doauto*, FALSE for :autocmd */
  {
      char_u	*p;
      int		group;
***************
*** 9931,9939 ****
   * Function given to ExpandGeneric() to obtain the list of event names.
   */
      char_u *
! get_event_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (idx < augroups.ga_len)		/* First list group names, if wanted */
      {
--- 9857,9863 ----
   * Function given to ExpandGeneric() to obtain the list of event names.
   */
      char_u *
! get_event_name(expand_T *xp UNUSED, int idx)
  {
      if (idx < augroups.ga_len)		/* First list group names, if wanted */
      {
***************
*** 9950,9957 ****
   * Return TRUE if autocmd is supported.
   */
      int
! autocmd_supported(name)
!     char_u	*name;
  {
      char_u *p;
  
--- 9874,9880 ----
   * Return TRUE if autocmd is supported.
   */
      int
! autocmd_supported(char_u *name)
  {
      char_u *p;
  
***************
*** 9971,9978 ****
   *	exists("#Event#pat")
   */
      int
! au_exists(arg)
!     char_u	*arg;
  {
      char_u	*arg_save;
      char_u	*pattern = NULL;
--- 9894,9900 ----
   *	exists("#Event#pat")
   */
      int
! au_exists(char_u *arg)
  {
      char_u	*arg_save;
      char_u	*pattern = NULL;
***************
*** 10102,10114 ****
   * Returns TRUE if there is a match, FALSE otherwise.
   */
      static int
! match_file_pat(pattern, prog, fname, sfname, tail, allow_dirs)
!     char_u	*pattern;		/* pattern to match with */
!     regprog_T	**prog;			/* pre-compiled regprog or NULL */
!     char_u	*fname;			/* full path of file name */
!     char_u	*sfname;		/* short file name or NULL */
!     char_u	*tail;			/* tail of path */
!     int		allow_dirs;		/* allow matching with dir */
  {
      regmatch_T	regmatch;
      int		result = FALSE;
--- 10024,10036 ----
   * Returns TRUE if there is a match, FALSE otherwise.
   */
      static int
! match_file_pat(
!     char_u	*pattern,		/* pattern to match with */
!     regprog_T	**prog,			/* pre-compiled regprog or NULL */
!     char_u	*fname,			/* full path of file name */
!     char_u	*sfname,		/* short file name or NULL */
!     char_u	*tail,			/* tail of path */
!     int		allow_dirs)		/* allow matching with dir */
  {
      regmatch_T	regmatch;
      int		result = FALSE;
***************
*** 10148,10157 ****
   * "sfname" is the short file name or NULL, "ffname" the long file name.
   */
      int
! match_file_list(list, sfname, ffname)
!     char_u	*list;
!     char_u	*sfname;
!     char_u	*ffname;
  {
      char_u	buf[100];
      char_u	*tail;
--- 10070,10076 ----
   * "sfname" is the short file name or NULL, "ffname" the long file name.
   */
      int
! match_file_list(char_u *list, char_u *sfname, char_u *ffname)
  {
      char_u	buf[100];
      char_u	*tail;
***************
*** 10190,10200 ****
   * Returns NULL when out of memory.
   */
      char_u *
! file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
!     char_u	*pat;
!     char_u	*pat_end;	/* first char after pattern or NULL */
!     char	*allow_dirs;	/* Result passed back out in here */
!     int		no_bslash UNUSED; /* Don't use a backward slash as pathsep */
  {
      int		size = 2; /* '^' at start, '$' at end */
      char_u	*endp;
--- 10109,10119 ----
   * Returns NULL when out of memory.
   */
      char_u *
! file_pat_to_reg_pat(
!     char_u	*pat,
!     char_u	*pat_end,	/* first char after pattern or NULL */
!     char	*allow_dirs,	/* Result passed back out in here */
!     int		no_bslash UNUSED) /* Don't use a backward slash as pathsep */
  {
      int		size = 2; /* '^' at start, '$' at end */
      char_u	*endp;
***************
*** 10400,10409 ****
   * by a SIGWINCH).
   */
      long
! read_eintr(fd, buf, bufsize)
!     int	    fd;
!     void    *buf;
!     size_t  bufsize;
  {
      long ret;
  
--- 10319,10325 ----
   * by a SIGWINCH).
   */
      long
! read_eintr(int fd, void *buf, size_t bufsize)
  {
      long ret;
  
***************
*** 10421,10430 ****
   * by a SIGWINCH).
   */
      long
! write_eintr(fd, buf, bufsize)
!     int	    fd;
!     void    *buf;
!     size_t  bufsize;
  {
      long    ret = 0;
      long    wlen;
--- 10337,10343 ----
   * by a SIGWINCH).
   */
      long
! write_eintr(int fd, void *buf, size_t bufsize)
  {
      long    ret = 0;
      long    wlen;
*** ../vim-7.4.1205/src/version.c	2016-01-30 15:14:02.547448831 +0100
--- src/version.c	2016-01-30 15:25:46.620178405 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1206,
  /**/


-- 
hundred-and-one symptoms of being an internet addict:
91. It's Saturday afternoon in the middle of May and you
    are on computer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
