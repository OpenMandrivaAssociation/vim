To: vim_dev@googlegroups.com
Subject: Patch 7.4.1207
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1207
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/fold.c, src/getchar.c, src/gui_at_fs.c, src/gui_athena.c,
            src/gui_at_sb.c, src/gui_beval.c, src/gui.c, src/gui_gtk.c,
            src/gui_gtk_x11.c, src/gui_mac.c, src/gui_motif.c


*** ../vim-7.4.1206/src/fold.c	2016-01-29 23:20:35.301308246 +0100
--- src/fold.c	2016-01-30 16:16:27.128682725 +0100
***************
*** 100,108 ****
   * Copy that folding state from window "wp_from" to window "wp_to".
   */
      void
! copyFoldingState(wp_from, wp_to)
!     win_T	*wp_from;
!     win_T	*wp_to;
  {
      wp_to->w_fold_manual = wp_from->w_fold_manual;
      wp_to->w_foldinvalid = wp_from->w_foldinvalid;
--- 100,106 ----
   * Copy that folding state from window "wp_from" to window "wp_to".
   */
      void
! copyFoldingState(win_T *wp_from, win_T *wp_to)
  {
      wp_to->w_fold_manual = wp_from->w_fold_manual;
      wp_to->w_foldinvalid = wp_from->w_foldinvalid;
***************
*** 115,122 ****
   * Return TRUE if there may be folded lines in the current window.
   */
      int
! hasAnyFolding(win)
!     win_T	*win;
  {
      /* very simple now, but can become more complex later */
      return (win->w_p_fen
--- 113,119 ----
   * Return TRUE if there may be folded lines in the current window.
   */
      int
! hasAnyFolding(win_T *win)
  {
      /* very simple now, but can become more complex later */
      return (win->w_p_fen
***************
*** 131,153 ****
   * lnum of the sequence of folded lines (skipped when NULL).
   */
      int
! hasFolding(lnum, firstp, lastp)
!     linenr_T	lnum;
!     linenr_T	*firstp;
!     linenr_T	*lastp;
  {
      return hasFoldingWin(curwin, lnum, firstp, lastp, TRUE, NULL);
  }
  
  /* hasFoldingWin() {{{2 */
      int
! hasFoldingWin(win, lnum, firstp, lastp, cache, infop)
!     win_T	*win;
!     linenr_T	lnum;
!     linenr_T	*firstp;
!     linenr_T	*lastp;
!     int		cache;		/* when TRUE: use cached values of window */
!     foldinfo_T	*infop;		/* where to store fold info */
  {
      int		had_folded = FALSE;
      linenr_T	first = 0;
--- 128,147 ----
   * lnum of the sequence of folded lines (skipped when NULL).
   */
      int
! hasFolding(linenr_T lnum, linenr_T *firstp, linenr_T *lastp)
  {
      return hasFoldingWin(curwin, lnum, firstp, lastp, TRUE, NULL);
  }
  
  /* hasFoldingWin() {{{2 */
      int
! hasFoldingWin(
!     win_T	*win,
!     linenr_T	lnum,
!     linenr_T	*firstp,
!     linenr_T	*lastp,
!     int		cache,		/* when TRUE: use cached values of window */
!     foldinfo_T	*infop)		/* where to store fold info */
  {
      int		had_folded = FALSE;
      linenr_T	first = 0;
***************
*** 254,261 ****
   * Return fold level at line number "lnum" in the current window.
   */
      int
! foldLevel(lnum)
!     linenr_T	lnum;
  {
      /* While updating the folds lines between invalid_top and invalid_bot have
       * an undefined fold level.  Otherwise update the folds first. */
--- 248,254 ----
   * Return fold level at line number "lnum" in the current window.
   */
      int
! foldLevel(linenr_T lnum)
  {
      /* While updating the folds lines between invalid_top and invalid_bot have
       * an undefined fold level.  Otherwise update the folds first. */
***************
*** 281,289 ****
   * Return MAYBE if the line is folded when next to a folded line.
   */
      int
! lineFolded(win, lnum)
!     win_T	*win;
!     linenr_T	lnum;
  {
      return foldedCount(win, lnum, NULL) != 0;
  }
--- 274,280 ----
   * Return MAYBE if the line is folded when next to a folded line.
   */
      int
! lineFolded(win_T *win, linenr_T lnum)
  {
      return foldedCount(win, lnum, NULL) != 0;
  }
***************
*** 298,307 ****
   * When "infop" is not NULL, fills *infop with the fold level info.
   */
      long
! foldedCount(win, lnum, infop)
!     win_T	*win;
!     linenr_T	lnum;
!     foldinfo_T	*infop;
  {
      linenr_T	last;
  
--- 289,295 ----
   * When "infop" is not NULL, fills *infop with the fold level info.
   */
      long
! foldedCount(win_T *win, linenr_T lnum, foldinfo_T *infop)
  {
      linenr_T	last;
  
***************
*** 315,322 ****
   * Return TRUE if 'foldmethod' is "manual"
   */
      int
! foldmethodIsManual(wp)
!     win_T	*wp;
  {
      return (wp->w_p_fdm[3] == 'u');
  }
--- 303,309 ----
   * Return TRUE if 'foldmethod' is "manual"
   */
      int
! foldmethodIsManual(win_T *wp)
  {
      return (wp->w_p_fdm[3] == 'u');
  }
***************
*** 326,333 ****
   * Return TRUE if 'foldmethod' is "indent"
   */
      int
! foldmethodIsIndent(wp)
!     win_T	*wp;
  {
      return (wp->w_p_fdm[0] == 'i');
  }
--- 313,319 ----
   * Return TRUE if 'foldmethod' is "indent"
   */
      int
! foldmethodIsIndent(win_T *wp)
  {
      return (wp->w_p_fdm[0] == 'i');
  }
***************
*** 337,344 ****
   * Return TRUE if 'foldmethod' is "expr"
   */
      int
! foldmethodIsExpr(wp)
!     win_T	*wp;
  {
      return (wp->w_p_fdm[1] == 'x');
  }
--- 323,329 ----
   * Return TRUE if 'foldmethod' is "expr"
   */
      int
! foldmethodIsExpr(win_T *wp)
  {
      return (wp->w_p_fdm[1] == 'x');
  }
***************
*** 348,355 ****
   * Return TRUE if 'foldmethod' is "marker"
   */
      int
! foldmethodIsMarker(wp)
!     win_T	*wp;
  {
      return (wp->w_p_fdm[2] == 'r');
  }
--- 333,339 ----
   * Return TRUE if 'foldmethod' is "marker"
   */
      int
! foldmethodIsMarker(win_T *wp)
  {
      return (wp->w_p_fdm[2] == 'r');
  }
***************
*** 359,366 ****
   * Return TRUE if 'foldmethod' is "syntax"
   */
      int
! foldmethodIsSyntax(wp)
!     win_T	*wp;
  {
      return (wp->w_p_fdm[0] == 's');
  }
--- 343,349 ----
   * Return TRUE if 'foldmethod' is "syntax"
   */
      int
! foldmethodIsSyntax(win_T *wp)
  {
      return (wp->w_p_fdm[0] == 's');
  }
***************
*** 370,377 ****
   * Return TRUE if 'foldmethod' is "diff"
   */
      int
! foldmethodIsDiff(wp)
!     win_T	*wp;
  {
      return (wp->w_p_fdm[0] == 'd');
  }
--- 353,359 ----
   * Return TRUE if 'foldmethod' is "diff"
   */
      int
! foldmethodIsDiff(win_T *wp)
  {
      return (wp->w_p_fdm[0] == 'd');
  }
***************
*** 382,390 ****
   * Repeat "count" times.
   */
      void
! closeFold(lnum, count)
!     linenr_T	lnum;
!     long	count;
  {
      setFoldRepeat(lnum, count, FALSE);
  }
--- 364,370 ----
   * Repeat "count" times.
   */
      void
! closeFold(linenr_T lnum, long count)
  {
      setFoldRepeat(lnum, count, FALSE);
  }
***************
*** 394,401 ****
   * Close fold for current window at line "lnum" recursively.
   */
      void
! closeFoldRecurse(lnum)
!     linenr_T	lnum;
  {
      (void)setManualFold(lnum, FALSE, TRUE, NULL);
  }
--- 374,380 ----
   * Close fold for current window at line "lnum" recursively.
   */
      void
! closeFoldRecurse(linenr_T lnum)
  {
      (void)setManualFold(lnum, FALSE, TRUE, NULL);
  }
***************
*** 406,417 ****
   * Used for "zo", "zO", "zc" and "zC" in Visual mode.
   */
      void
! opFoldRange(first, last, opening, recurse, had_visual)
!     linenr_T	first;
!     linenr_T	last;
!     int		opening;	/* TRUE to open, FALSE to close */
!     int		recurse;	/* TRUE to do it recursively */
!     int		had_visual;	/* TRUE when Visual selection used */
  {
      int		done = DONE_NOTHING;	/* avoid error messages */
      linenr_T	lnum;
--- 385,396 ----
   * Used for "zo", "zO", "zc" and "zC" in Visual mode.
   */
      void
! opFoldRange(
!     linenr_T	first,
!     linenr_T	last,
!     int		opening,	/* TRUE to open, FALSE to close */
!     int		recurse,	/* TRUE to do it recursively */
!     int		had_visual)	/* TRUE when Visual selection used */
  {
      int		done = DONE_NOTHING;	/* avoid error messages */
      linenr_T	lnum;
***************
*** 443,451 ****
   * Repeat "count" times.
   */
      void
! openFold(lnum, count)
!     linenr_T	lnum;
!     long	count;
  {
      setFoldRepeat(lnum, count, TRUE);
  }
--- 422,428 ----
   * Repeat "count" times.
   */
      void
! openFold(linenr_T lnum, long count)
  {
      setFoldRepeat(lnum, count, TRUE);
  }
***************
*** 455,462 ****
   * Open fold for current window at line "lnum" recursively.
   */
      void
! openFoldRecurse(lnum)
!     linenr_T	lnum;
  {
      (void)setManualFold(lnum, TRUE, TRUE, NULL);
  }
--- 432,438 ----
   * Open fold for current window at line "lnum" recursively.
   */
      void
! openFoldRecurse(linenr_T lnum)
  {
      (void)setManualFold(lnum, TRUE, TRUE, NULL);
  }
***************
*** 466,472 ****
   * Open folds until the cursor line is not in a closed fold.
   */
      void
! foldOpenCursor()
  {
      int		done;
  
--- 442,448 ----
   * Open folds until the cursor line is not in a closed fold.
   */
      void
! foldOpenCursor(void)
  {
      int		done;
  
***************
*** 486,492 ****
   * Set new foldlevel for current window.
   */
      void
! newFoldLevel()
  {
      newFoldLevelWin(curwin);
  
--- 462,468 ----
   * Set new foldlevel for current window.
   */
      void
! newFoldLevel(void)
  {
      newFoldLevelWin(curwin);
  
***************
*** 511,518 ****
  }
  
      static void
! newFoldLevelWin(wp)
!     win_T	*wp;
  {
      fold_T	*fp;
      int		i;
--- 487,493 ----
  }
  
      static void
! newFoldLevelWin(win_T *wp)
  {
      fold_T	*fp;
      int		i;
***************
*** 536,542 ****
   * Apply 'foldlevel' to all folds that don't contain the cursor.
   */
      void
! foldCheckClose()
  {
      if (*p_fcl != NUL)	/* can only be "all" right now */
      {
--- 511,517 ----
   * Apply 'foldlevel' to all folds that don't contain the cursor.
   */
      void
! foldCheckClose(void)
  {
      if (*p_fcl != NUL)	/* can only be "all" right now */
      {
***************
*** 549,558 ****
  
  /* checkCloseRec() {{{2 */
      static int
! checkCloseRec(gap, lnum, level)
!     garray_T	*gap;
!     linenr_T	lnum;
!     int		level;
  {
      fold_T	*fp;
      int		retval = FALSE;
--- 524,530 ----
  
  /* checkCloseRec() {{{2 */
      static int
! checkCloseRec(garray_T *gap, linenr_T lnum, int level)
  {
      fold_T	*fp;
      int		retval = FALSE;
***************
*** 584,591 ****
   * Give an error message and return FALSE if not.
   */
      int
! foldManualAllowed(create)
!     int		create;
  {
      if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))
  	return TRUE;
--- 556,562 ----
   * Give an error message and return FALSE if not.
   */
      int
! foldManualAllowed(int create)
  {
      if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))
  	return TRUE;
***************
*** 602,610 ****
   * window.
   */
      void
! foldCreate(start, end)
!     linenr_T	start;
!     linenr_T	end;
  {
      fold_T	*fp;
      garray_T	*gap;
--- 573,579 ----
   * window.
   */
      void
! foldCreate(linenr_T start, linenr_T end)
  {
      fold_T	*fp;
      garray_T	*gap;
***************
*** 729,739 ****
   * When "recursive" is TRUE delete recursively.
   */
      void
! deleteFold(start, end, recursive, had_visual)
!     linenr_T	start;
!     linenr_T	end;
!     int		recursive;
!     int		had_visual;	/* TRUE when Visual selection used */
  {
      garray_T	*gap;
      fold_T	*fp;
--- 698,708 ----
   * When "recursive" is TRUE delete recursively.
   */
      void
! deleteFold(
!     linenr_T	start,
!     linenr_T	end,
!     int		recursive,
!     int		had_visual)	/* TRUE when Visual selection used */
  {
      garray_T	*gap;
      fold_T	*fp;
***************
*** 824,831 ****
   * Remove all folding for window "win".
   */
      void
! clearFolding(win)
!     win_T	*win;
  {
      deleteFoldRecurse(&win->w_folds);
      win->w_foldinvalid = FALSE;
--- 793,799 ----
   * Remove all folding for window "win".
   */
      void
! clearFolding(win_T *win)
  {
      deleteFoldRecurse(&win->w_folds);
      win->w_foldinvalid = FALSE;
***************
*** 839,848 ****
   * The changes in lines from top to bot (inclusive).
   */
      void
! foldUpdate(wp, top, bot)
!     win_T	*wp;
!     linenr_T	top;
!     linenr_T	bot;
  {
      fold_T	*fp;
  
--- 807,813 ----
   * The changes in lines from top to bot (inclusive).
   */
      void
! foldUpdate(win_T *wp, linenr_T top, linenr_T bot)
  {
      fold_T	*fp;
  
***************
*** 880,887 ****
   * every time a setting is changed or a syntax item is added.
   */
      void
! foldUpdateAll(win)
!     win_T	*win;
  {
      win->w_foldinvalid = TRUE;
      redraw_win_later(win, NOT_VALID);
--- 845,851 ----
   * every time a setting is changed or a syntax item is added.
   */
      void
! foldUpdateAll(win_T *win)
  {
      win->w_foldinvalid = TRUE;
      redraw_win_later(win, NOT_VALID);
***************
*** 894,903 ****
   * If not moved return FAIL.
   */
      int
! foldMoveTo(updown, dir, count)
!     int		updown;
!     int		dir;	    /* FORWARD or BACKWARD */
!     long	count;
  {
      long	n;
      int		retval = FAIL;
--- 858,867 ----
   * If not moved return FAIL.
   */
      int
! foldMoveTo(
!     int		updown,
!     int		dir,	    /* FORWARD or BACKWARD */
!     long	count)
  {
      long	n;
      int		retval = FAIL;
***************
*** 1031,1038 ****
   * Init the fold info in a new window.
   */
      void
! foldInitWin(new_win)
!     win_T	*new_win;
  {
      ga_init2(&new_win->w_folds, (int)sizeof(fold_T), 10);
  }
--- 995,1001 ----
   * Init the fold info in a new window.
   */
      void
! foldInitWin(win_T *new_win)
  {
      ga_init2(&new_win->w_folds, (int)sizeof(fold_T), 10);
  }
***************
*** 1045,1053 ****
   * Returns index of entry or -1 if not found.
   */
      int
! find_wl_entry(win, lnum)
!     win_T	*win;
!     linenr_T	lnum;
  {
      int		i;
  
--- 1008,1014 ----
   * Returns index of entry or -1 if not found.
   */
      int
! find_wl_entry(win_T *win, linenr_T lnum)
  {
      int		i;
  
***************
*** 1067,1073 ****
   * Adjust the Visual area to include any fold at the start or end completely.
   */
      void
! foldAdjustVisual()
  {
      pos_T	*start, *end;
      char_u	*ptr;
--- 1028,1034 ----
   * Adjust the Visual area to include any fold at the start or end completely.
   */
      void
! foldAdjustVisual(void)
  {
      pos_T	*start, *end;
      char_u	*ptr;
***************
*** 1106,1112 ****
   * Move the cursor to the first line of a closed fold.
   */
      void
! foldAdjustCursor()
  {
      (void)hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL);
  }
--- 1067,1073 ----
   * Move the cursor to the first line of a closed fold.
   */
      void
! foldAdjustCursor(void)
  {
      (void)hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL);
  }
***************
*** 1119,1127 ****
   * Return FAIL if the operation cannot be completed, otherwise OK.
   */
      void
! cloneFoldGrowArray(from, to)
!     garray_T	*from;
!     garray_T	*to;
  {
      int		i;
      fold_T	*from_p;
--- 1080,1086 ----
   * Return FAIL if the operation cannot be completed, otherwise OK.
   */
      void
! cloneFoldGrowArray(garray_T *from, garray_T *to)
  {
      int		i;
      fold_T	*from_p;
***************
*** 1155,1164 ****
   * Returns FALSE when there is no fold that contains "lnum".
   */
      static int
! foldFind(gap, lnum, fpp)
!     garray_T	*gap;
!     linenr_T	lnum;
!     fold_T	**fpp;
  {
      linenr_T	low, high;
      fold_T	*fp;
--- 1114,1120 ----
   * Returns FALSE when there is no fold that contains "lnum".
   */
      static int
! foldFind(garray_T *gap, linenr_T lnum, fold_T **fpp)
  {
      linenr_T	low, high;
      fold_T	*fp;
***************
*** 1197,1205 ****
   * Return fold level at line number "lnum" in window "wp".
   */
      static int
! foldLevelWin(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      fold_T	*fp;
      linenr_T	lnum_rel = lnum;
--- 1153,1159 ----
   * Return fold level at line number "lnum" in window "wp".
   */
      static int
! foldLevelWin(win_T *wp, linenr_T lnum)
  {
      fold_T	*fp;
      linenr_T	lnum_rel = lnum;
***************
*** 1226,1233 ****
   * Check if the folds in window "wp" are invalid and update them if needed.
   */
      static void
! checkupdate(wp)
!     win_T	*wp;
  {
      if (wp->w_foldinvalid)
      {
--- 1180,1186 ----
   * Check if the folds in window "wp" are invalid and update them if needed.
   */
      static void
! checkupdate(win_T *wp)
  {
      if (wp->w_foldinvalid)
      {
***************
*** 1242,1251 ****
   * Repeat "count" times.
   */
      static void
! setFoldRepeat(lnum, count, do_open)
!     linenr_T	lnum;
!     long	count;
!     int		do_open;
  {
      int		done;
      long	n;
--- 1195,1201 ----
   * Repeat "count" times.
   */
      static void
! setFoldRepeat(linenr_T lnum, long count, int do_open)
  {
      int		done;
      long	n;
***************
*** 1270,1280 ****
   * Also does this for other windows in diff mode when needed.
   */
      static linenr_T
! setManualFold(lnum, opening, recurse, donep)
!     linenr_T	lnum;
!     int		opening;    /* TRUE when opening, FALSE when closing */
!     int		recurse;    /* TRUE when closing/opening recursive */
!     int		*donep;
  {
  #ifdef FEAT_DIFF
      if (foldmethodIsDiff(curwin) && curwin->w_p_scb)
--- 1220,1230 ----
   * Also does this for other windows in diff mode when needed.
   */
      static linenr_T
! setManualFold(
!     linenr_T	lnum,
!     int		opening,    /* TRUE when opening, FALSE when closing */
!     int		recurse,    /* TRUE when closing/opening recursive */
!     int		*donep)
  {
  #ifdef FEAT_DIFF
      if (foldmethodIsDiff(curwin) && curwin->w_p_scb)
***************
*** 1312,1323 ****
   * It's only valid when "opening" is TRUE!
   */
      static linenr_T
! setManualFoldWin(wp, lnum, opening, recurse, donep)
!     win_T	*wp;
!     linenr_T	lnum;
!     int		opening;    /* TRUE when opening, FALSE when closing */
!     int		recurse;    /* TRUE when closing/opening recursive */
!     int		*donep;
  {
      fold_T	*fp;
      fold_T	*fp2;
--- 1262,1273 ----
   * It's only valid when "opening" is TRUE!
   */
      static linenr_T
! setManualFoldWin(
!     win_T	*wp,
!     linenr_T	lnum,
!     int		opening,    /* TRUE when opening, FALSE when closing */
!     int		recurse,    /* TRUE when closing/opening recursive */
!     int		*donep)
  {
      fold_T	*fp;
      fold_T	*fp2;
***************
*** 1423,1430 ****
   * Open all nested folds in fold "fpr" recursively.
   */
      static void
! foldOpenNested(fpr)
!     fold_T	*fpr;
  {
      int		i;
      fold_T	*fp;
--- 1373,1379 ----
   * Open all nested folds in fold "fpr" recursively.
   */
      static void
! foldOpenNested(fold_T *fpr)
  {
      int		i;
      fold_T	*fp;
***************
*** 1444,1453 ****
   * When "recursive" is FALSE contained folds are moved one level up.
   */
      static void
! deleteFoldEntry(gap, idx, recursive)
!     garray_T	*gap;
!     int		idx;
!     int		recursive;
  {
      fold_T	*fp;
      int		i;
--- 1393,1399 ----
   * When "recursive" is FALSE contained folds are moved one level up.
   */
      static void
! deleteFoldEntry(garray_T *gap, int idx, int recursive)
  {
      fold_T	*fp;
      int		i;
***************
*** 1501,1508 ****
   * Delete nested folds in a fold.
   */
      void
! deleteFoldRecurse(gap)
!     garray_T	*gap;
  {
      int		i;
  
--- 1447,1453 ----
   * Delete nested folds in a fold.
   */
      void
! deleteFoldRecurse(garray_T *gap)
  {
      int		i;
  
***************
*** 1516,1527 ****
   * Update line numbers of folds for inserted/deleted lines.
   */
      void
! foldMarkAdjust(wp, line1, line2, amount, amount_after)
!     win_T	*wp;
!     linenr_T	line1;
!     linenr_T	line2;
!     long	amount;
!     long	amount_after;
  {
      /* If deleting marks from line1 to line2, but not deleting all those
       * lines, set line2 so that only deleted lines have their folds removed. */
--- 1461,1472 ----
   * Update line numbers of folds for inserted/deleted lines.
   */
      void
! foldMarkAdjust(
!     win_T	*wp,
!     linenr_T	line1,
!     linenr_T	line2,
!     long	amount,
!     long	amount_after)
  {
      /* If deleting marks from line1 to line2, but not deleting all those
       * lines, set line2 so that only deleted lines have their folds removed. */
***************
*** 1536,1547 ****
  
  /* foldMarkAdjustRecurse() {{{2 */
      static void
! foldMarkAdjustRecurse(gap, line1, line2, amount, amount_after)
!     garray_T	*gap;
!     linenr_T	line1;
!     linenr_T	line2;
!     long	amount;
!     long	amount_after;
  {
      fold_T	*fp;
      int		i;
--- 1481,1492 ----
  
  /* foldMarkAdjustRecurse() {{{2 */
      static void
! foldMarkAdjustRecurse(
!     garray_T	*gap,
!     linenr_T	line1,
!     linenr_T	line2,
!     long	amount,
!     long	amount_after)
  {
      fold_T	*fp;
      int		i;
***************
*** 1653,1667 ****
   * current window open.
   */
      int
! getDeepestNesting()
  {
      checkupdate(curwin);
      return getDeepestNestingRecurse(&curwin->w_folds);
  }
  
      static int
! getDeepestNestingRecurse(gap)
!     garray_T	*gap;
  {
      int		i;
      int		level;
--- 1598,1611 ----
   * current window open.
   */
      int
! getDeepestNesting(void)
  {
      checkupdate(curwin);
      return getDeepestNestingRecurse(&curwin->w_folds);
  }
  
      static int
! getDeepestNestingRecurse(garray_T *gap)
  {
      int		i;
      int		level;
***************
*** 1684,1696 ****
   * Check if a fold is closed and update the info needed to check nested folds.
   */
      static int
! check_closed(win, fp, use_levelp, level, maybe_smallp, lnum_off)
!     win_T	*win;
!     fold_T	*fp;
!     int		*use_levelp;	    /* TRUE: outer fold had FD_LEVEL */
!     int		level;		    /* folding depth */
!     int		*maybe_smallp;	    /* TRUE: outer this had fd_small == MAYBE */
!     linenr_T	lnum_off;	    /* line number offset for fp->fd_top */
  {
      int		closed = FALSE;
  
--- 1628,1640 ----
   * Check if a fold is closed and update the info needed to check nested folds.
   */
      static int
! check_closed(
!     win_T	*win,
!     fold_T	*fp,
!     int		*use_levelp,	    /* TRUE: outer fold had FD_LEVEL */
!     int		level,		    /* folding depth */
!     int		*maybe_smallp,	    /* TRUE: outer this had fd_small == MAYBE */
!     linenr_T	lnum_off)	    /* line number offset for fp->fd_top */
  {
      int		closed = FALSE;
  
***************
*** 1724,1733 ****
   * Update fd_small field of fold "fp".
   */
      static void
! checkSmall(wp, fp, lnum_off)
!     win_T	*wp;
!     fold_T	*fp;
!     linenr_T	lnum_off;	/* offset for fp->fd_top */
  {
      int		count;
      int		n;
--- 1668,1677 ----
   * Update fd_small field of fold "fp".
   */
      static void
! checkSmall(
!     win_T	*wp,
!     fold_T	*fp,
!     linenr_T	lnum_off)	/* offset for fp->fd_top */
  {
      int		count;
      int		n;
***************
*** 1761,1768 ****
   * Set small flags in "gap" to MAYBE.
   */
      static void
! setSmallMaybe(gap)
!     garray_T	*gap;
  {
      int		i;
      fold_T	*fp;
--- 1705,1711 ----
   * Set small flags in "gap" to MAYBE.
   */
      static void
! setSmallMaybe(garray_T *gap)
  {
      int		i;
      fold_T	*fp;
***************
*** 1778,1786 ****
   * window by adding markers.
   */
      static void
! foldCreateMarkers(start, end)
!     linenr_T	start;
!     linenr_T	end;
  {
      if (!curbuf->b_p_ma)
      {
--- 1721,1727 ----
   * window by adding markers.
   */
      static void
! foldCreateMarkers(linenr_T start, linenr_T end)
  {
      if (!curbuf->b_p_ma)
      {
***************
*** 1802,1811 ****
   * Add "marker[markerlen]" in 'commentstring' to line "lnum".
   */
      static void
! foldAddMarker(lnum, marker, markerlen)
!     linenr_T	lnum;
!     char_u	*marker;
!     int		markerlen;
  {
      char_u	*cms = curbuf->b_p_cms;
      char_u	*line;
--- 1743,1749 ----
   * Add "marker[markerlen]" in 'commentstring' to line "lnum".
   */
      static void
! foldAddMarker(linenr_T lnum, char_u *marker, int markerlen)
  {
      char_u	*cms = curbuf->b_p_cms;
      char_u	*line;
***************
*** 1841,1850 ****
   * Delete the markers for a fold, causing it to be deleted.
   */
      static void
! deleteFoldMarkers(fp, recursive, lnum_off)
!     fold_T	*fp;
!     int		recursive;
!     linenr_T	lnum_off;	/* offset for fp->fd_top */
  {
      int		i;
  
--- 1779,1788 ----
   * Delete the markers for a fold, causing it to be deleted.
   */
      static void
! deleteFoldMarkers(
!     fold_T	*fp,
!     int		recursive,
!     linenr_T	lnum_off)	/* offset for fp->fd_top */
  {
      int		i;
  
***************
*** 1865,1874 ****
   * close-marker.
   */
      static void
! foldDelMarker(lnum, marker, markerlen)
!     linenr_T	lnum;
!     char_u	*marker;
!     int		markerlen;
  {
      char_u	*line;
      char_u	*newline;
--- 1803,1809 ----
   * close-marker.
   */
      static void
! foldDelMarker(linenr_T lnum, char_u *marker, int markerlen)
  {
      char_u	*line;
      char_u	*newline;
***************
*** 1919,1929 ****
   * result is in allocated memory.
   */
      char_u *
! get_foldtext(wp, lnum, lnume, foldinfo, buf)
!     win_T	*wp;
!     linenr_T	lnum, lnume;
!     foldinfo_T	*foldinfo;
!     char_u	*buf;
  {
      char_u	*text = NULL;
  #ifdef FEAT_EVAL
--- 1854,1865 ----
   * result is in allocated memory.
   */
      char_u *
! get_foldtext(
!     win_T	*wp,
!     linenr_T	lnum,
!     linenr_T	lnume,
!     foldinfo_T	*foldinfo,
!     char_u	*buf)
  {
      char_u	*text = NULL;
  #ifdef FEAT_EVAL
***************
*** 2033,2040 ****
   * Remove 'foldmarker' and 'commentstring' from "str" (in-place).
   */
      void
! foldtext_cleanup(str)
!     char_u	*str;
  {
      char_u	*cms_start;	/* first part or the whole comment */
      int		cms_slen = 0;	/* length of cms_start */
--- 1969,1975 ----
   * Remove 'foldmarker' and 'commentstring' from "str" (in-place).
   */
      void
! foldtext_cleanup(char_u *str)
  {
      char_u	*cms_start;	/* first part or the whole comment */
      int		cms_slen = 0;	/* length of cms_start */
***************
*** 2161,2170 ****
   * Return TRUE if any folds did change.
   */
      static void
! foldUpdateIEMS(wp, top, bot)
!     win_T	*wp;
!     linenr_T	top;
!     linenr_T	bot;
  {
      linenr_T	start;
      linenr_T	end;
--- 2096,2102 ----
   * Return TRUE if any folds did change.
   */
      static void
! foldUpdateIEMS(win_T *wp, linenr_T top, linenr_T bot)
  {
      linenr_T	start;
      linenr_T	end;
***************
*** 2417,2430 ****
   * updated as a result of a detected change in the fold.
   */
      static linenr_T
! foldUpdateIEMSRecurse(gap, level, startlnum, flp, getlevel, bot, topflags)
!     garray_T	*gap;
!     int		level;
!     linenr_T	startlnum;
!     fline_T	*flp;
!     void	(*getlevel)(fline_T *);
!     linenr_T	bot;
!     int		topflags;	/* flags used by containing fold */
  {
      linenr_T	ll;
      fold_T	*fp = NULL;
--- 2349,2362 ----
   * updated as a result of a detected change in the fold.
   */
      static linenr_T
! foldUpdateIEMSRecurse(
!     garray_T	*gap,
!     int		level,
!     linenr_T	startlnum,
!     fline_T	*flp,
!     void	(*getlevel)(fline_T *),
!     linenr_T	bot,
!     int		topflags)	/* flags used by containing fold */
  {
      linenr_T	ll;
      fold_T	*fp = NULL;
***************
*** 2831,2839 ****
   * Returns OK for success, FAIL for failure.
   */
      static int
! foldInsert(gap, i)
!     garray_T	*gap;
!     int		i;
  {
      fold_T	*fp;
  
--- 2763,2769 ----
   * Returns OK for success, FAIL for failure.
   */
      static int
! foldInsert(garray_T *gap, int i)
  {
      fold_T	*fp;
  
***************
*** 2856,2866 ****
   * "bot"!
   */
      static void
! foldSplit(gap, i, top, bot)
!     garray_T	*gap;
!     int		i;
!     linenr_T	top;
!     linenr_T	bot;
  {
      fold_T	*fp;
      fold_T	*fp2;
--- 2786,2796 ----
   * "bot"!
   */
      static void
! foldSplit(
!     garray_T	*gap,
!     int		i,
!     linenr_T	top,
!     linenr_T	bot)
  {
      fold_T	*fp;
      fold_T	*fp2;
***************
*** 2920,2929 ****
   * 6: not changed
   */
      static void
! foldRemove(gap, top, bot)
!     garray_T	*gap;
!     linenr_T	top;
!     linenr_T	bot;
  {
      fold_T	*fp = NULL;
  
--- 2850,2856 ----
   * 6: not changed
   */
      static void
! foldRemove(garray_T *gap, linenr_T top, linenr_T bot)
  {
      fold_T	*fp = NULL;
  
***************
*** 2986,2995 ****
   * Fold entry "fp2" in "gap" is deleted.
   */
      static void
! foldMerge(fp1, gap, fp2)
!     fold_T	*fp1;
!     garray_T	*gap;
!     fold_T	*fp2;
  {
      fold_T	*fp3;
      fold_T	*fp4;
--- 2913,2919 ----
   * Fold entry "fp2" in "gap" is deleted.
   */
      static void
! foldMerge(fold_T *fp1, garray_T *gap, fold_T *fp2)
  {
      fold_T	*fp3;
      fold_T	*fp4;
***************
*** 3027,3034 ****
   * Returns a level of -1 if the foldlevel depends on surrounding lines.
   */
      static void
! foldlevelIndent(flp)
!     fline_T	*flp;
  {
      char_u	*s;
      buf_T	*buf;
--- 2951,2957 ----
   * Returns a level of -1 if the foldlevel depends on surrounding lines.
   */
      static void
! foldlevelIndent(fline_T *flp)
  {
      char_u	*s;
      buf_T	*buf;
***************
*** 3064,3071 ****
   * Doesn't use any caching.
   */
      static void
! foldlevelDiff(flp)
!     fline_T	*flp;
  {
      if (diff_infold(flp->wp, flp->lnum + flp->off))
  	flp->lvl = 1;
--- 2987,2993 ----
   * Doesn't use any caching.
   */
      static void
! foldlevelDiff(fline_T *flp)
  {
      if (diff_infold(flp->wp, flp->lnum + flp->off))
  	flp->lvl = 1;
***************
*** 3081,3088 ****
   * Returns a level of -1 if the foldlevel depends on surrounding lines.
   */
      static void
! foldlevelExpr(flp)
!     fline_T	*flp;
  {
  #ifndef FEAT_EVAL
      flp->start = FALSE;
--- 3003,3009 ----
   * Returns a level of -1 if the foldlevel depends on surrounding lines.
   */
      static void
! foldlevelExpr(fline_T *flp)
  {
  #ifndef FEAT_EVAL
      flp->start = FALSE;
***************
*** 3184,3191 ****
   * Relies on the option value to have been checked for correctness already.
   */
      static void
! parseMarker(wp)
!     win_T	*wp;
  {
      foldendmarker = vim_strchr(wp->w_p_fmr, ',');
      foldstartmarkerlen = (int)(foldendmarker++ - wp->w_p_fmr);
--- 3105,3111 ----
   * Relies on the option value to have been checked for correctness already.
   */
      static void
! parseMarker(win_T *wp)
  {
      foldendmarker = vim_strchr(wp->w_p_fmr, ',');
      foldstartmarkerlen = (int)(foldendmarker++ - wp->w_p_fmr);
***************
*** 3203,3210 ****
   * Sets flp->start when a start marker was found.
   */
      static void
! foldlevelMarker(flp)
!     fline_T	*flp;
  {
      char_u	*startmarker;
      int		cstart;
--- 3123,3129 ----
   * Sets flp->start when a start marker was found.
   */
      static void
! foldlevelMarker(fline_T *flp)
  {
      char_u	*startmarker;
      int		cstart;
***************
*** 3286,3293 ****
   * Doesn't use any caching.
   */
      static void
! foldlevelSyntax(flp)
!     fline_T	*flp;
  {
  #ifndef FEAT_SYN_HL
      flp->start = 0;
--- 3205,3211 ----
   * Doesn't use any caching.
   */
      static void
! foldlevelSyntax(fline_T *flp)
  {
  #ifndef FEAT_SYN_HL
      flp->start = 0;
***************
*** 3323,3331 ****
   * Return FAIL if writing fails.
   */
      int
! put_folds(fd, wp)
!     FILE	*fd;
!     win_T	*wp;
  {
      if (foldmethodIsManual(wp))
      {
--- 3241,3247 ----
   * Return FAIL if writing fails.
   */
      int
! put_folds(FILE *fd, win_T *wp)
  {
      if (foldmethodIsManual(wp))
      {
***************
*** 3347,3356 ****
   * Returns FAIL when writing failed.
   */
      static int
! put_folds_recurse(fd, gap, off)
!     FILE	*fd;
!     garray_T	*gap;
!     linenr_T	off;
  {
      int		i;
      fold_T	*fp;
--- 3263,3269 ----
   * Returns FAIL when writing failed.
   */
      static int
! put_folds_recurse(FILE *fd, garray_T *gap, linenr_T off)
  {
      int		i;
      fold_T	*fp;
***************
*** 3376,3386 ****
   * Returns FAIL when writing failed.
   */
      static int
! put_foldopen_recurse(fd, wp, gap, off)
!     FILE	*fd;
!     win_T	*wp;
!     garray_T	*gap;
!     linenr_T	off;
  {
      int		i;
      int		level;
--- 3289,3299 ----
   * Returns FAIL when writing failed.
   */
      static int
! put_foldopen_recurse(
!     FILE	*fd,
!     win_T	*wp,
!     garray_T	*gap,
!     linenr_T	off)
  {
      int		i;
      int		level;
***************
*** 3433,3442 ****
   * Returns FAIL when writing failed.
   */
      static int
! put_fold_open_close(fd, fp, off)
!     FILE	*fd;
!     fold_T	*fp;
!     linenr_T	off;
  {
      if (fprintf(fd, "%ld", fp->fd_top + off) < 0
  	    || put_eol(fd) == FAIL
--- 3346,3352 ----
   * Returns FAIL when writing failed.
   */
      static int
! put_fold_open_close(FILE *fd, fold_T *fp, linenr_T off)
  {
      if (fprintf(fd, "%ld", fp->fd_top + off) < 0
  	    || put_eol(fd) == FAIL
*** ../vim-7.4.1206/src/getchar.c	2016-01-29 22:13:26.047781524 +0100
--- src/getchar.c	2016-01-30 16:20:27.534183155 +0100
***************
*** 137,144 ****
   * Free and clear a buffer.
   */
      void
! free_buff(buf)
!     buffheader_T	*buf;
  {
      buffblock_T	*p, *np;
  
--- 137,143 ----
   * Free and clear a buffer.
   */
      void
! free_buff(buffheader_T *buf)
  {
      buffblock_T	*p, *np;
  
***************
*** 155,163 ****
   * K_SPECIAL and CSI in the returned string are escaped.
   */
      static char_u *
! get_buffcont(buffer, dozero)
!     buffheader_T	*buffer;
!     int			dozero;	    /* count == zero is not an error */
  {
      long_u	    count = 0;
      char_u	    *p = NULL;
--- 154,162 ----
   * K_SPECIAL and CSI in the returned string are escaped.
   */
      static char_u *
! get_buffcont(
!     buffheader_T	*buffer,
!     int			dozero)	    /* count == zero is not an error */
  {
      long_u	    count = 0;
      char_u	    *p = NULL;
***************
*** 186,192 ****
   * K_SPECIAL and CSI in the returned string are escaped.
   */
      char_u *
! get_recorded()
  {
      char_u	*p;
      size_t	len;
--- 185,191 ----
   * K_SPECIAL and CSI in the returned string are escaped.
   */
      char_u *
! get_recorded(void)
  {
      char_u	*p;
      size_t	len;
***************
*** 220,226 ****
   * K_SPECIAL and CSI in the returned string are escaped.
   */
      char_u *
! get_inserted()
  {
      return get_buffcont(&redobuff, FALSE);
  }
--- 219,225 ----
   * K_SPECIAL and CSI in the returned string are escaped.
   */
      char_u *
! get_inserted(void)
  {
      return get_buffcont(&redobuff, FALSE);
  }
***************
*** 230,239 ****
   * K_SPECIAL and CSI should have been escaped already.
   */
      static void
! add_buff(buf, s, slen)
!     buffheader_T	*buf;
!     char_u		*s;
!     long		slen;	/* length of "s" or -1 */
  {
      buffblock_T *p;
      long_u	    len;
--- 229,238 ----
   * K_SPECIAL and CSI should have been escaped already.
   */
      static void
! add_buff(
!     buffheader_T	*buf,
!     char_u		*s,
!     long		slen)	/* length of "s" or -1 */
  {
      buffblock_T *p;
      long_u	    len;
***************
*** 289,297 ****
   * Add number "n" to buffer "buf".
   */
      static void
! add_num_buff(buf, n)
!     buffheader_T *buf;
!     long	      n;
  {
      char_u	number[32];
  
--- 288,294 ----
   * Add number "n" to buffer "buf".
   */
      static void
! add_num_buff(buffheader_T *buf, long n)
  {
      char_u	number[32];
  
***************
*** 304,312 ****
   * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
   */
      static void
! add_char_buff(buf, c)
!     buffheader_T	*buf;
!     int			c;
  {
  #ifdef FEAT_MBYTE
      char_u	bytes[MB_MAXBYTES + 1];
--- 301,307 ----
   * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
   */
      static void
! add_char_buff(buffheader_T *buf, int c)
  {
  #ifdef FEAT_MBYTE
      char_u	bytes[MB_MAXBYTES + 1];
***************
*** 368,375 ****
   * No translation is done K_SPECIAL and CSI are escaped.
   */
      static int
! read_readbuffers(advance)
!     int		advance;
  {
      int c;
  
--- 363,369 ----
   * No translation is done K_SPECIAL and CSI are escaped.
   */
      static int
! read_readbuffers(int advance)
  {
      int c;
  
***************
*** 380,388 ****
  }
  
      static int
! read_readbuf(buf, advance)
!     buffheader_T    *buf;
!     int		    advance;
  {
      char_u	c;
      buffblock_T	*curr;
--- 374,380 ----
  }
  
      static int
! read_readbuf(buffheader_T *buf, int advance)
  {
      char_u	c;
      buffblock_T	*curr;
***************
*** 409,415 ****
   * Prepare the read buffers for reading (if they contain something).
   */
      static void
! start_stuff()
  {
      if (readbuf1.bh_first.b_next != NULL)
      {
--- 401,407 ----
   * Prepare the read buffers for reading (if they contain something).
   */
      static void
! start_stuff(void)
  {
      if (readbuf1.bh_first.b_next != NULL)
      {
***************
*** 427,433 ****
   * Return TRUE if the stuff buffer is empty.
   */
      int
! stuff_empty()
  {
      return (readbuf1.bh_first.b_next == NULL
  	 && readbuf2.bh_first.b_next == NULL);
--- 419,425 ----
   * Return TRUE if the stuff buffer is empty.
   */
      int
! stuff_empty(void)
  {
      return (readbuf1.bh_first.b_next == NULL
  	 && readbuf2.bh_first.b_next == NULL);
***************
*** 438,444 ****
   * redbuf2.
   */
      int
! readbuf1_empty()
  {
      return (readbuf1.bh_first.b_next == NULL);
  }
--- 430,436 ----
   * redbuf2.
   */
      int
! readbuf1_empty(void)
  {
      return (readbuf1.bh_first.b_next == NULL);
  }
***************
*** 447,454 ****
   * Set a typeahead character that won't be flushed.
   */
      void
! typeahead_noflush(c)
!     int		c;
  {
      typeahead_char = c;
  }
--- 439,445 ----
   * Set a typeahead character that won't be flushed.
   */
      void
! typeahead_noflush(int c)
  {
      typeahead_char = c;
  }
***************
*** 459,466 ****
   * flush all typeahead characters (used when interrupted by a CTRL-C).
   */
      void
! flush_buffers(flush_typeahead)
!     int flush_typeahead;
  {
      init_typebuf();
  
--- 450,456 ----
   * flush all typeahead characters (used when interrupted by a CTRL-C).
   */
      void
! flush_buffers(int flush_typeahead)
  {
      init_typebuf();
  
***************
*** 497,503 ****
   * This is used for the CTRL-O <.> command in insert mode.
   */
      void
! ResetRedobuff()
  {
      if (!block_redo)
      {
--- 487,493 ----
   * This is used for the CTRL-O <.> command in insert mode.
   */
      void
! ResetRedobuff(void)
  {
      if (!block_redo)
      {
***************
*** 512,518 ****
   * buffer.
   */
      void
! CancelRedo()
  {
      if (!block_redo)
      {
--- 502,508 ----
   * buffer.
   */
      void
! CancelRedo(void)
  {
      if (!block_redo)
      {
***************
*** 533,539 ****
  static int save_level = 0;
  
      void
! saveRedobuff()
  {
      char_u	*s;
  
--- 523,529 ----
  static int save_level = 0;
  
      void
! saveRedobuff(void)
  {
      char_u	*s;
  
***************
*** 559,565 ****
   * Used after executing autocommands and user functions.
   */
      void
! restoreRedobuff()
  {
      if (--save_level == 0)
      {
--- 549,555 ----
   * Used after executing autocommands and user functions.
   */
      void
! restoreRedobuff(void)
  {
      if (--save_level == 0)
      {
***************
*** 576,583 ****
   * K_SPECIAL and CSI should already have been escaped.
   */
      void
! AppendToRedobuff(s)
!     char_u	   *s;
  {
      if (!block_redo)
  	add_buff(&redobuff, s, -1L);
--- 566,572 ----
   * K_SPECIAL and CSI should already have been escaped.
   */
      void
! AppendToRedobuff(char_u *s)
  {
      if (!block_redo)
  	add_buff(&redobuff, s, -1L);
***************
*** 588,596 ****
   * K_SPECIAL and CSI are escaped as well.
   */
      void
! AppendToRedobuffLit(str, len)
!     char_u	*str;
!     int		len;	    /* length of "str" or -1 for up to the NUL */
  {
      char_u	*s = str;
      int		c;
--- 577,585 ----
   * K_SPECIAL and CSI are escaped as well.
   */
      void
! AppendToRedobuffLit(
!     char_u	*str,
!     int		len)	    /* length of "str" or -1 for up to the NUL */
  {
      char_u	*s = str;
      int		c;
***************
*** 649,656 ****
   * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
   */
      void
! AppendCharToRedobuff(c)
!     int		   c;
  {
      if (!block_redo)
  	add_char_buff(&redobuff, c);
--- 638,644 ----
   * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
   */
      void
! AppendCharToRedobuff(int c)
  {
      if (!block_redo)
  	add_char_buff(&redobuff, c);
***************
*** 660,667 ****
   * Append a number to the redo buffer.
   */
      void
! AppendNumberToRedobuff(n)
!     long	    n;
  {
      if (!block_redo)
  	add_num_buff(&redobuff, n);
--- 648,654 ----
   * Append a number to the redo buffer.
   */
      void
! AppendNumberToRedobuff(long n)
  {
      if (!block_redo)
  	add_num_buff(&redobuff, n);
***************
*** 672,679 ****
   * CSI and K_SPECIAL must already have been escaped.
   */
      void
! stuffReadbuff(s)
!     char_u	*s;
  {
      add_buff(&readbuf1, s, -1L);
  }
--- 659,665 ----
   * CSI and K_SPECIAL must already have been escaped.
   */
      void
! stuffReadbuff(char_u *s)
  {
      add_buff(&readbuf1, s, -1L);
  }
***************
*** 683,698 ****
   * CSI and K_SPECIAL must already have been escaped.
   */
      void
! stuffRedoReadbuff(s)
!     char_u	*s;
  {
      add_buff(&readbuf2, s, -1L);
  }
  
      void
! stuffReadbuffLen(s, len)
!     char_u	*s;
!     long	len;
  {
      add_buff(&readbuf1, s, len);
  }
--- 669,681 ----
   * CSI and K_SPECIAL must already have been escaped.
   */
      void
! stuffRedoReadbuff(char_u *s)
  {
      add_buff(&readbuf2, s, -1L);
  }
  
      void
! stuffReadbuffLen(char_u *s, long len)
  {
      add_buff(&readbuf1, s, len);
  }
***************
*** 704,711 ****
   * Change CR, LF and ESC into a space.
   */
      void
! stuffReadbuffSpec(s)
!     char_u	*s;
  {
      int c;
  
--- 687,693 ----
   * Change CR, LF and ESC into a space.
   */
      void
! stuffReadbuffSpec(char_u *s)
  {
      int c;
  
***************
*** 737,744 ****
   * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
   */
      void
! stuffcharReadbuff(c)
!     int		   c;
  {
      add_char_buff(&readbuf1, c);
  }
--- 719,725 ----
   * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
   */
      void
! stuffcharReadbuff(int c)
  {
      add_char_buff(&readbuf1, c);
  }
***************
*** 747,754 ****
   * Append a number to the stuff buffer.
   */
      void
! stuffnumReadbuff(n)
!     long    n;
  {
      add_num_buff(&readbuf1, n);
  }
--- 728,734 ----
   * Append a number to the stuff buffer.
   */
      void
! stuffnumReadbuff(long n)
  {
      add_num_buff(&readbuf1, n);
  }
***************
*** 762,770 ****
   * If old is TRUE, use old_redobuff instead of redobuff.
   */
      static int
! read_redo(init, old_redo)
!     int		init;
!     int		old_redo;
  {
      static buffblock_T	*bp;
      static char_u	*p;
--- 742,748 ----
   * If old is TRUE, use old_redobuff instead of redobuff.
   */
      static int
! read_redo(int init, int old_redo)
  {
      static buffblock_T	*bp;
      static char_u	*p;
***************
*** 837,844 ****
   * The escaped K_SPECIAL and CSI are copied without translation.
   */
      static void
! copy_redo(old_redo)
!     int	    old_redo;
  {
      int	    c;
  
--- 815,821 ----
   * The escaped K_SPECIAL and CSI are copied without translation.
   */
      static void
! copy_redo(int old_redo)
  {
      int	    c;
  
***************
*** 856,864 ****
   * return FAIL for failure, OK otherwise
   */
      int
! start_redo(count, old_redo)
!     long    count;
!     int	    old_redo;
  {
      int	    c;
  
--- 833,839 ----
   * return FAIL for failure, OK otherwise
   */
      int
! start_redo(long count, int old_redo)
  {
      int	    c;
  
***************
*** 911,917 ****
   * return FAIL for failure, OK otherwise
   */
      int
! start_redo_ins()
  {
      int	    c;
  
--- 886,892 ----
   * return FAIL for failure, OK otherwise
   */
      int
! start_redo_ins(void)
  {
      int	    c;
  
***************
*** 937,943 ****
  }
  
      void
! stop_redo_ins()
  {
      block_redo = FALSE;
  }
--- 912,918 ----
  }
  
      void
! stop_redo_ins(void)
  {
      block_redo = FALSE;
  }
***************
*** 948,954 ****
   * be impossible to type anything.
   */
      static void
! init_typebuf()
  {
      if (typebuf.tb_buf == NULL)
      {
--- 923,929 ----
   * be impossible to type anything.
   */
      static void
! init_typebuf(void)
  {
      if (typebuf.tb_buf == NULL)
      {
***************
*** 981,992 ****
   * return FAIL for failure, OK otherwise
   */
      int
! ins_typebuf(str, noremap, offset, nottyped, silent)
!     char_u	*str;
!     int		noremap;
!     int		offset;
!     int		nottyped;
!     int		silent;
  {
      char_u	*s1, *s2;
      int		newlen;
--- 956,967 ----
   * return FAIL for failure, OK otherwise
   */
      int
! ins_typebuf(
!     char_u	*str,
!     int		noremap,
!     int		offset,
!     int		nottyped,
!     int		silent)
  {
      char_u	*s1, *s2;
      int		newlen;
***************
*** 1114,1121 ****
   * the char.
   */
      void
! ins_char_typebuf(c)
!     int	    c;
  {
  #ifdef FEAT_MBYTE
      char_u	buf[MB_MAXBYTES + 1];
--- 1089,1095 ----
   * the char.
   */
      void
! ins_char_typebuf(int c)
  {
  #ifdef FEAT_MBYTE
      char_u	buf[MB_MAXBYTES + 1];
***************
*** 1151,1158 ****
   * that was just added.
   */
      int
! typebuf_changed(tb_change_cnt)
!     int		tb_change_cnt;	/* old value of typebuf.tb_change_cnt */
  {
      return (tb_change_cnt != 0 && (typebuf.tb_change_cnt != tb_change_cnt
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
--- 1125,1132 ----
   * that was just added.
   */
      int
! typebuf_changed(
!     int		tb_change_cnt)	/* old value of typebuf.tb_change_cnt */
  {
      return (tb_change_cnt != 0 && (typebuf.tb_change_cnt != tb_change_cnt
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
***************
*** 1166,1172 ****
   * not been typed (result from a mapping or come from ":normal").
   */
      int
! typebuf_typed()
  {
      return typebuf.tb_maplen == 0;
  }
--- 1140,1146 ----
   * not been typed (result from a mapping or come from ":normal").
   */
      int
! typebuf_typed(void)
  {
      return typebuf.tb_maplen == 0;
  }
***************
*** 1175,1181 ****
   * Return the number of characters that are mapped (or not typed).
   */
      int
! typebuf_maplen()
  {
      return typebuf.tb_maplen;
  }
--- 1149,1155 ----
   * Return the number of characters that are mapped (or not typed).
   */
      int
! typebuf_maplen(void)
  {
      return typebuf.tb_maplen;
  }
***************
*** 1184,1192 ****
   * remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]
   */
      void
! del_typebuf(len, offset)
!     int	len;
!     int	offset;
  {
      int	    i;
  
--- 1158,1164 ----
   * remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]
   */
      void
! del_typebuf(int len, int offset)
  {
      int	    i;
  
***************
*** 1264,1272 ****
   * If recording is on put the character in the recordbuffer.
   */
      static void
! gotchars(chars, len)
!     char_u	*chars;
!     int		len;
  {
      char_u	*s = chars;
      int		c;
--- 1236,1242 ----
   * If recording is on put the character in the recordbuffer.
   */
      static void
! gotchars(char_u *chars, int len)
  {
      char_u	*s = chars;
      int		c;
***************
*** 1311,1317 ****
   * - When no_u_sync is non-zero.
   */
      static void
! may_sync_undo()
  {
      if ((!(State & (INSERT + CMDLINE)) || arrow_used)
  					       && scriptin[curscript] == NULL)
--- 1281,1287 ----
   * - When no_u_sync is non-zero.
   */
      static void
! may_sync_undo(void)
  {
      if ((!(State & (INSERT + CMDLINE)) || arrow_used)
  					       && scriptin[curscript] == NULL)
***************
*** 1323,1329 ****
   * Returns FAIL when out of memory.
   */
      int
! alloc_typebuf()
  {
      typebuf.tb_buf = alloc(TYPELEN_INIT);
      typebuf.tb_noremap = alloc(TYPELEN_INIT);
--- 1293,1299 ----
   * Returns FAIL when out of memory.
   */
      int
! alloc_typebuf(void)
  {
      typebuf.tb_buf = alloc(TYPELEN_INIT);
      typebuf.tb_noremap = alloc(TYPELEN_INIT);
***************
*** 1347,1353 ****
   * Free the buffers of "typebuf".
   */
      void
! free_typebuf()
  {
      if (typebuf.tb_buf == typebuf_init)
  	EMSG2(_(e_intern2), "Free typebuf 1");
--- 1317,1323 ----
   * Free the buffers of "typebuf".
   */
      void
! free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
  	EMSG2(_(e_intern2), "Free typebuf 1");
***************
*** 1366,1372 ****
  static typebuf_T saved_typebuf[NSCRIPT];
  
      int
! save_typebuf()
  {
      init_typebuf();
      saved_typebuf[curscript] = typebuf;
--- 1336,1342 ----
  static typebuf_T saved_typebuf[NSCRIPT];
  
      int
! save_typebuf(void)
  {
      init_typebuf();
      saved_typebuf[curscript] = typebuf;
***************
*** 1392,1399 ****
   * Save all three kinds of typeahead, so that the user must type at a prompt.
   */
      void
! save_typeahead(tp)
!     tasave_T	*tp;
  {
      tp->save_typebuf = typebuf;
      tp->typebuf_valid = (alloc_typebuf() == OK);
--- 1362,1368 ----
   * Save all three kinds of typeahead, so that the user must type at a prompt.
   */
      void
! save_typeahead(tasave_T *tp)
  {
      tp->save_typebuf = typebuf;
      tp->typebuf_valid = (alloc_typebuf() == OK);
***************
*** 1418,1425 ****
   * The allocated memory is freed, can only be called once!
   */
      void
! restore_typeahead(tp)
!     tasave_T	*tp;
  {
      if (tp->typebuf_valid)
      {
--- 1387,1393 ----
   * The allocated memory is freed, can only be called once!
   */
      void
! restore_typeahead(tasave_T *tp)
  {
      if (tp->typebuf_valid)
      {
***************
*** 1444,1452 ****
   * Open a new script file for the ":source!" command.
   */
      void
! openscript(name, directly)
!     char_u	*name;
!     int		directly;	/* when TRUE execute directly */
  {
      if (curscript + 1 == NSCRIPT)
      {
--- 1412,1420 ----
   * Open a new script file for the ":source!" command.
   */
      void
! openscript(
!     char_u	*name,
!     int		directly)	/* when TRUE execute directly */
  {
      if (curscript + 1 == NSCRIPT)
      {
***************
*** 1517,1523 ****
   * Close the currently active input script.
   */
      static void
! closescript()
  {
      free_typebuf();
      typebuf = saved_typebuf[curscript];
--- 1485,1491 ----
   * Close the currently active input script.
   */
      static void
! closescript(void)
  {
      free_typebuf();
      typebuf = saved_typebuf[curscript];
***************
*** 1530,1536 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! close_all_scripts()
  {
      while (scriptin[0] != NULL)
  	closescript();
--- 1498,1504 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! close_all_scripts(void)
  {
      while (scriptin[0] != NULL)
  	closescript();
***************
*** 1542,1548 ****
   * Return TRUE when reading keys from a script file.
   */
      int
! using_script()
  {
      return scriptin[curscript] != NULL;
  }
--- 1510,1516 ----
   * Return TRUE when reading keys from a script file.
   */
      int
! using_script(void)
  {
      return scriptin[curscript] != NULL;
  }
***************
*** 1553,1559 ****
   * waiting 'updatetime' for a character to arrive.
   */
      void
! before_blocking()
  {
      updatescript(0);
  #ifdef FEAT_EVAL
--- 1521,1527 ----
   * waiting 'updatetime' for a character to arrive.
   */
      void
! before_blocking(void)
  {
      updatescript(0);
  #ifdef FEAT_EVAL
***************
*** 1570,1577 ****
   * characters reaches 'updatecount' and 'updatecount' is non-zero.
   */
      void
! updatescript(c)
!     int c;
  {
      static int	    count = 0;
  
--- 1538,1544 ----
   * characters reaches 'updatecount' and 'updatecount' is non-zero.
   */
      void
! updatescript(int c)
  {
      static int	    count = 0;
  
***************
*** 1594,1600 ****
   * Returns the modifiers in the global "mod_mask".
   */
      int
! vgetc()
  {
      int		c, c2;
  #ifdef FEAT_MBYTE
--- 1561,1567 ----
   * Returns the modifiers in the global "mod_mask".
   */
      int
! vgetc(void)
  {
      int		c, c2;
  #ifdef FEAT_MBYTE
***************
*** 1839,1845 ****
   * directly from the user (ignoring typeahead).
   */
      int
! safe_vgetc()
  {
      int	c;
  
--- 1806,1812 ----
   * directly from the user (ignoring typeahead).
   */
      int
! safe_vgetc(void)
  {
      int	c;
  
***************
*** 1854,1860 ****
   * Also ignore scrollbar events.
   */
      int
! plain_vgetc()
  {
      int c;
  
--- 1821,1827 ----
   * Also ignore scrollbar events.
   */
      int
! plain_vgetc(void)
  {
      int c;
  
***************
*** 1871,1877 ****
   * character is not valid!.
   */
      int
! vpeekc()
  {
      if (old_char != -1)
  	return old_char;
--- 1838,1844 ----
   * character is not valid!.
   */
      int
! vpeekc(void)
  {
      if (old_char != -1)
  	return old_char;
***************
*** 1884,1890 ****
   * codes.
   */
      int
! vpeekc_nomap()
  {
      int		c;
  
--- 1851,1857 ----
   * codes.
   */
      int
! vpeekc_nomap(void)
  {
      int		c;
  
***************
*** 1904,1910 ****
   * buffer, it must be an ESC that is recognized as the start of a key code.
   */
      int
! vpeekc_any()
  {
      int		c;
  
--- 1871,1877 ----
   * buffer, it must be an ESC that is recognized as the start of a key code.
   */
      int
! vpeekc_any(void)
  {
      int		c;
  
***************
*** 1920,1926 ****
   * Return TRUE if a character is available, FALSE otherwise.
   */
      int
! char_avail()
  {
      int	    retval;
  
--- 1887,1893 ----
   * Return TRUE if a character is available, FALSE otherwise.
   */
      int
! char_avail(void)
  {
      int	    retval;
  
***************
*** 1930,1938 ****
      return (retval != NUL);
  }
  
      void
! vungetc(c)	/* unget one character (can only be done once!) */
!     int		c;
  {
      old_char = c;
      old_mod_mask = mod_mask;
--- 1897,1907 ----
      return (retval != NUL);
  }
  
+ /*
+  * unget one character (can only be done once!)
+  */
      void
! vungetc(int c)
  {
      old_char = c;
      old_mod_mask = mod_mask;
***************
*** 1966,1973 ****
   * K_SPECIAL and CSI may be escaped, need to get two more bytes then.
   */
      static int
! vgetorpeek(advance)
!     int	    advance;
  {
      int		c, c1;
      int		keylen;
--- 1935,1941 ----
   * K_SPECIAL and CSI may be escaped, need to get two more bytes then.
   */
      static int
! vgetorpeek(int advance)
  {
      int		c, c1;
      int		keylen;
***************
*** 2988,2998 ****
   *  Return -1 when end of input script reached.
   */
      int
! inchar(buf, maxlen, wait_time, tb_change_cnt)
!     char_u	*buf;
!     int		maxlen;
!     long	wait_time;	    /* milli seconds */
!     int		tb_change_cnt;
  {
      int		len = 0;	    /* init for GCC */
      int		retesc = FALSE;	    /* return ESC with gotint */
--- 2956,2966 ----
   *  Return -1 when end of input script reached.
   */
      int
! inchar(
!     char_u	*buf,
!     int		maxlen,
!     long	wait_time,	    /* milli seconds */
!     int		tb_change_cnt)
  {
      int		len = 0;	    /* init for GCC */
      int		retesc = FALSE;	    /* return ESC with gotint */
***************
*** 3114,3123 ****
   * Returns the new length.
   */
      int
! fix_input_buffer(buf, len, script)
!     char_u	*buf;
!     int		len;
!     int		script;		/* TRUE when reading from a script */
  {
      int		i;
      char_u	*p = buf;
--- 3082,3091 ----
   * Returns the new length.
   */
      int
! fix_input_buffer(
!     char_u	*buf,
!     int		len,
!     int		script)		/* TRUE when reading from a script */
  {
      int		i;
      char_u	*p = buf;
***************
*** 3182,3188 ****
   * waiting for input to arrive.
   */
      int
! input_available()
  {
      return (!vim_is_input_buf_empty()
  # if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
--- 3150,3156 ----
   * waiting for input to arrive.
   */
      int
! input_available(void)
  {
      return (!vim_is_input_buf_empty()
  # if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
***************
*** 3231,3241 ****
   *	  5 for entry not unique
   */
      int
! do_map(maptype, arg, mode, abbrev)
!     int		maptype;
!     char_u	*arg;
!     int		mode;
!     int		abbrev;		/* not a mapping but an abbreviation */
  {
      char_u	*keys;
      mapblock_T	*mp, **mpp;
--- 3199,3209 ----
   *	  5 for entry not unique
   */
      int
! do_map(
!     int		maptype,
!     char_u	*arg,
!     int		mode,
!     int		abbrev)		/* not a mapping but an abbreviation */
  {
      char_u	*keys;
      mapblock_T	*mp, **mpp;
***************
*** 3810,3817 ****
   * "mpp" is a pointer to the m_next field of the PREVIOUS entry!
   */
      static void
! map_free(mpp)
!     mapblock_T	**mpp;
  {
      mapblock_T	*mp;
  
--- 3778,3784 ----
   * "mpp" is a pointer to the m_next field of the PREVIOUS entry!
   */
      static void
! map_free(mapblock_T **mpp)
  {
      mapblock_T	*mp;
  
***************
*** 3827,3833 ****
   * Initialize maphash[] for first use.
   */
      static void
! validate_maphash()
  {
      if (!maphash_valid)
      {
--- 3794,3800 ----
   * Initialize maphash[] for first use.
   */
      static void
! validate_maphash(void)
  {
      if (!maphash_valid)
      {
***************
*** 3840,3848 ****
   * Get the mapping mode from the command name.
   */
      int
! get_map_mode(cmdp, forceit)
!     char_u	**cmdp;
!     int		forceit;
  {
      char_u	*p;
      int		modec;
--- 3807,3813 ----
   * Get the mapping mode from the command name.
   */
      int
! get_map_mode(char_u **cmdp, int forceit)
  {
      char_u	*p;
      int		modec;
***************
*** 3884,3894 ****
   * 'abbr' should be FALSE for mappings, TRUE for abbreviations.
   */
      void
! map_clear(cmdp, arg, forceit, abbr)
!     char_u	*cmdp;
!     char_u	*arg UNUSED;
!     int		forceit;
!     int		abbr;
  {
      int		mode;
  #ifdef FEAT_LOCALMAP
--- 3849,3859 ----
   * 'abbr' should be FALSE for mappings, TRUE for abbreviations.
   */
      void
! map_clear(
!     char_u	*cmdp,
!     char_u	*arg UNUSED,
!     int		forceit,
!     int		abbr)
  {
      int		mode;
  #ifdef FEAT_LOCALMAP
***************
*** 3916,3926 ****
   * Clear all mappings in "mode".
   */
      void
! map_clear_int(buf, mode, local, abbr)
!     buf_T	*buf UNUSED;	/* buffer for local mappings */
!     int		mode;		/* mode in which to delete */
!     int		local UNUSED;	/* TRUE for buffer-local mappings */
!     int		abbr;		/* TRUE for abbreviations */
  {
      mapblock_T	*mp, **mpp;
      int		hash;
--- 3881,3891 ----
   * Clear all mappings in "mode".
   */
      void
! map_clear_int(
!     buf_T	*buf UNUSED,	/* buffer for local mappings */
!     int		mode,		/* mode in which to delete */
!     int		local UNUSED,	/* TRUE for buffer-local mappings */
!     int		abbr)		/* TRUE for abbreviations */
  {
      mapblock_T	*mp, **mpp;
      int		hash;
***************
*** 3993,4000 ****
   * Returns NULL when out of memory.
   */
      char_u *
! map_mode_to_chars(mode)
!     int mode;
  {
      garray_T    mapmode;
  
--- 3958,3964 ----
   * Returns NULL when out of memory.
   */
      char_u *
! map_mode_to_chars(int mode)
  {
      garray_T    mapmode;
  
***************
*** 4033,4041 ****
  }
  
      static void
! showmap(mp, local)
!     mapblock_T	*mp;
!     int		local;	    /* TRUE for buffer-local map */
  {
      int		len = 1;
      char_u	*mapchars;
--- 3997,4005 ----
  }
  
      static void
! showmap(
!     mapblock_T	*mp,
!     int		local)	    /* TRUE for buffer-local map */
  {
      int		len = 1;
      char_u	*mapchars;
***************
*** 4108,4117 ****
   * Also checks mappings local to the current buffer.
   */
      int
! map_to_exists(str, modechars, abbr)
!     char_u	*str;
!     char_u	*modechars;
!     int		abbr;
  {
      int		mode = 0;
      char_u	*rhs;
--- 4072,4078 ----
   * Also checks mappings local to the current buffer.
   */
      int
! map_to_exists(char_u *str, char_u *modechars, int abbr)
  {
      int		mode = 0;
      char_u	*rhs;
***************
*** 4149,4158 ****
   * Also checks mappings local to the current buffer.
   */
      int
! map_to_exists_mode(rhs, mode, abbr)
!     char_u	*rhs;
!     int		mode;
!     int		abbr;
  {
      mapblock_T	*mp;
      int		hash;
--- 4110,4116 ----
   * Also checks mappings local to the current buffer.
   */
      int
! map_to_exists_mode(char_u *rhs, int mode, int abbr)
  {
      mapblock_T	*mp;
      int		hash;
***************
*** 4216,4229 ****
   * or abbreviation names.
   */
      char_u *
! set_context_in_map_cmd(xp, cmd, arg, forceit, isabbrev, isunmap, cmdidx)
!     expand_T	*xp;
!     char_u	*cmd;
!     char_u	*arg;
!     int		forceit;	/* TRUE if '!' given */
!     int		isabbrev;	/* TRUE if abbreviation */
!     int		isunmap;	/* TRUE if unmap/unabbrev command */
!     cmdidx_T	cmdidx;
  {
      if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)
  	xp->xp_context = EXPAND_NOTHING;
--- 4174,4187 ----
   * or abbreviation names.
   */
      char_u *
! set_context_in_map_cmd(
!     expand_T	*xp,
!     char_u	*cmd,
!     char_u	*arg,
!     int		forceit,	/* TRUE if '!' given */
!     int		isabbrev,	/* TRUE if abbreviation */
!     int		isunmap,	/* TRUE if unmap/unabbrev command */
!     cmdidx_T	cmdidx)
  {
      if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)
  	xp->xp_context = EXPAND_NOTHING;
***************
*** 4293,4302 ****
   * Return OK if matches found, FAIL otherwise.
   */
      int
! ExpandMappings(regmatch, num_file, file)
!     regmatch_T	*regmatch;
!     int		*num_file;
!     char_u	***file;
  {
      mapblock_T	*mp;
      int		hash;
--- 4251,4260 ----
   * Return OK if matches found, FAIL otherwise.
   */
      int
! ExpandMappings(
!     regmatch_T	*regmatch,
!     int		*num_file,
!     char_u	***file)
  {
      mapblock_T	*mp;
      int		hash;
***************
*** 4441,4451 ****
   * return TRUE if there is an abbreviation, FALSE if not
   */
      int
! check_abbr(c, ptr, col, mincol)
!     int		c;
!     char_u	*ptr;
!     int		col;
!     int		mincol;
  {
      int		len;
      int		scol;		/* starting column of the abbr. */
--- 4399,4409 ----
   * return TRUE if there is an abbreviation, FALSE if not
   */
      int
! check_abbr(
!     int		c,
!     char_u	*ptr,
!     int		col,
!     int		mincol)
  {
      int		len;
      int		scol;		/* starting column of the abbr. */
***************
*** 4651,4659 ****
   * special characters.
   */
      static char_u *
! eval_map_expr(str, c)
!     char_u	*str;
!     int		c;	    /* NUL or typed character for abbreviation */
  {
      char_u	*res;
      char_u	*p;
--- 4609,4617 ----
   * special characters.
   */
      static char_u *
! eval_map_expr(
!     char_u	*str,
!     int		c)	    /* NUL or typed character for abbreviation */
  {
      char_u	*res;
      char_u	*p;
***************
*** 4715,4722 ****
   * Returns NULL when out of memory.
   */
      char_u *
! vim_strsave_escape_csi(p)
!     char_u *p;
  {
      char_u	*res;
      char_u	*s, *d;
--- 4673,4680 ----
   * Returns NULL when out of memory.
   */
      char_u *
! vim_strsave_escape_csi(
!     char_u *p)
  {
      char_u	*res;
      char_u	*s, *d;
***************
*** 4765,4772 ****
   * vim_strsave_escape_csi().  Works in-place.
   */
      void
! vim_unescape_csi(p)
!     char_u *p;
  {
      char_u	*s = p, *d = p;
  
--- 4723,4729 ----
   * vim_strsave_escape_csi().  Works in-place.
   */
      void
! vim_unescape_csi(char_u *p)
  {
      char_u	*s = p, *d = p;
  
***************
*** 4794,4802 ****
   * Return FAIL on error, OK otherwise.
   */
      int
! makemap(fd, buf)
!     FILE	*fd;
!     buf_T	*buf;	    /* buffer for local mappings or NULL */
  {
      mapblock_T	*mp;
      char_u	c1, c2, c3;
--- 4751,4759 ----
   * Return FAIL on error, OK otherwise.
   */
      int
! makemap(
!     FILE	*fd,
!     buf_T	*buf)	    /* buffer for local mappings or NULL */
  {
      mapblock_T	*mp;
      char_u	c1, c2, c3;
***************
*** 5007,5016 ****
   * return FAIL for failure, OK otherwise
   */
      int
! put_escstr(fd, strstart, what)
!     FILE	*fd;
!     char_u	*strstart;
!     int		what;
  {
      char_u	*str = strstart;
      int		c;
--- 4964,4970 ----
   * return FAIL for failure, OK otherwise
   */
      int
! put_escstr(FILE *fd, char_u *strstart, int what)
  {
      char_u	*str = strstart;
      int		c;
***************
*** 5123,5129 ****
   * Used after ":set term=xxx".
   */
      void
! check_map_keycodes()
  {
      mapblock_T	*mp;
      char_u	*p;
--- 5077,5083 ----
   * Used after ":set term=xxx".
   */
      void
! check_map_keycodes(void)
  {
      mapblock_T	*mp;
      char_u	*p;
***************
*** 5215,5228 ****
   * NULL when no mapping found.
   */
      char_u *
! check_map(keys, mode, exact, ign_mod, abbr, mp_ptr, local_ptr)
!     char_u	*keys;
!     int		mode;
!     int		exact;		/* require exact match */
!     int		ign_mod;	/* ignore preceding modifier */
!     int		abbr;		/* do abbreviations */
!     mapblock_T	**mp_ptr;	/* return: pointer to mapblock or NULL */
!     int		*local_ptr;	/* return: buffer-local mapping or NULL */
  {
      int		hash;
      int		len, minlen;
--- 5169,5182 ----
   * NULL when no mapping found.
   */
      char_u *
! check_map(
!     char_u	*keys,
!     int		mode,
!     int		exact,		/* require exact match */
!     int		ign_mod,	/* ignore preceding modifier */
!     int		abbr,		/* do abbreviations */
!     mapblock_T	**mp_ptr,	/* return: pointer to mapblock or NULL */
!     int		*local_ptr)	/* return: buffer-local mapping or NULL */
  {
      int		hash;
      int		len, minlen;
***************
*** 5378,5384 ****
   * Set up default mappings.
   */
      void
! init_mappings()
  {
  #if defined(MSDOS) || defined(MSWIN) ||defined(MACOS)
      int		i;
--- 5332,5338 ----
   * Set up default mappings.
   */
      void
! init_mappings(void)
  {
  #if defined(MSDOS) || defined(MSWIN) ||defined(MACOS)
      int		i;
***************
*** 5395,5403 ****
   * Need to put string in allocated memory, because do_map() will modify it.
   */
      void
! add_map(map, mode)
!     char_u	*map;
!     int		mode;
  {
      char_u	*s;
      char_u	*cpo_save = p_cpo;
--- 5349,5355 ----
   * Need to put string in allocated memory, because do_map() will modify it.
   */
      void
! add_map(char_u *map, int mode)
  {
      char_u	*s;
      char_u	*cpo_save = p_cpo;
*** ../vim-7.4.1206/src/gui_at_fs.c	2016-01-29 22:13:26.047781524 +0100
--- src/gui_at_fs.c	2016-01-30 16:23:39.140185168 +0100
***************
*** 240,247 ****
  static int SFchdir(char *path);
  
      static int
! SFchdir(path)
!     char	*path;
  {
      int		result;
  
--- 240,246 ----
  static int SFchdir(char *path);
  
      static int
! SFchdir(char *path)
  {
      int		result;
  
***************
*** 260,267 ****
  static void SFfree(int i);
  
      static void
! SFfree(i)
!     int	i;
  {
      SFDir	*dir;
      int		j;
--- 259,265 ----
  static void SFfree(int i);
  
      static void
! SFfree(int i)
  {
      SFDir	*dir;
      int		j;
***************
*** 284,292 ****
  static void SFstrdup(char **s1, char *s2);
  
      static void
! SFstrdup(s1, s2)
!     char	**s1;
!     char	*s2;
  {
      *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
  }
--- 282,288 ----
  static void SFstrdup(char **s1, char *s2);
  
      static void
! SFstrdup(char **s1, char *s2)
  {
      *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
  }
***************
*** 294,301 ****
  static void SFunreadableDir(SFDir *dir);
  
      static void
! SFunreadableDir(dir)
!     SFDir	*dir;
  {
      char	*cannotOpen = _("<cannot open> ");
  
--- 290,296 ----
  static void SFunreadableDir(SFDir *dir);
  
      static void
! SFunreadableDir(SFDir *dir)
  {
      char	*cannotOpen = _("<cannot open> ");
  
***************
*** 310,318 ****
  static void SFreplaceText(SFDir *dir, char *str);
  
      static void
! SFreplaceText(dir, str)
!     SFDir	*dir;
!     char	*str;
  {
      int	len;
  
--- 305,311 ----
  static void SFreplaceText(SFDir *dir, char *str);
  
      static void
! SFreplaceText(SFDir *dir, char *str)
  {
      int	len;
  
***************
*** 333,340 ****
  static void SFexpand(char *str);
  
      static void
! SFexpand(str)
!     char	*str;
  {
      int		len;
      int		cmp;
--- 326,332 ----
  static void SFexpand(char *str);
  
      static void
! SFexpand(char *str)
  {
      int		len;
      int		cmp;
***************
*** 390,398 ****
  static int SFfindFile(SFDir *dir, char *str);
  
      static int
! SFfindFile(dir, str)
!     SFDir	*dir;
!     char	*str;
  {
      int		i, last, max;
      char	*name, save;
--- 382,388 ----
  static int SFfindFile(SFDir *dir, char *str);
  
      static int
! SFfindFile(SFDir *dir, char *str)
  {
      int		i, last, max;
      char	*name, save;
***************
*** 491,497 ****
  static void SFunselect(void);
  
      static void
! SFunselect()
  {
      SFDir	*dir;
  
--- 481,487 ----
  static void SFunselect(void);
  
      static void
! SFunselect(void)
  {
      SFDir	*dir;
  
***************
*** 505,512 ****
  static int SFcompareLogins(const void *p, const void *q);
  
      static int
! SFcompareLogins(p, q)
!     const void *p, *q;
  {
      return strcmp(((SFLogin *)p)->name, ((SFLogin *)q)->name);
  }
--- 495,501 ----
  static int SFcompareLogins(const void *p, const void *q);
  
      static int
! SFcompareLogins(const void *p, *q)
  {
      return strcmp(((SFLogin *)p)->name, ((SFLogin *)q)->name);
  }
***************
*** 514,520 ****
  static void SFgetHomeDirs(void);
  
      static void
! SFgetHomeDirs()
  {
      struct	passwd	*pw;
      int		Alloc;
--- 503,509 ----
  static void SFgetHomeDirs(void);
  
      static void
! SFgetHomeDirs(void)
  {
      struct	passwd	*pw;
      int		Alloc;
***************
*** 582,589 ****
  static int SFfindHomeDir(char *begin, char *end);
  
      static int
! SFfindHomeDir(begin, end)
!     char	*begin, *end;
  {
      char	save;
      char	*theRest;
--- 571,577 ----
  static int SFfindHomeDir(char *begin, char *end);
  
      static int
! SFfindHomeDir(char *begin, *end)
  {
      char	save;
      char	*theRest;
***************
*** 613,619 ****
  }
  
      static void
! SFupdatePath()
  {
      static int	Alloc;
      static int	wasTwiddle = 0;
--- 601,607 ----
  }
  
      static void
! SFupdatePath(void)
  {
      static int	Alloc;
      static int	wasTwiddle = 0;
***************
*** 807,814 ****
  
  #ifdef XtNinternational
      static int
! WcsLen(p)
!     wchar_t *p;
  {
      int i = 0;
      while (*p++ != 0)
--- 795,801 ----
  
  #ifdef XtNinternational
      static int
! WcsLen(wchar_t *p)
  {
      int i = 0;
      while (*p++ != 0)
***************
*** 818,825 ****
  #endif
  
      static void
! SFsetText(path)
!     char	*path;
  {
      XawTextBlock	text;
  
--- 805,811 ----
  #endif
  
      static void
! SFsetText(char *path)
  {
      XawTextBlock	text;
  
***************
*** 852,870 ****
  }
  
      static void
! SFbuttonPressList(w, n, event)
!     Widget		w UNUSED;
!     int			n UNUSED;
!     XButtonPressedEvent	*event UNUSED;
  {
      SFbuttonPressed = 1;
  }
  
      static void
! SFbuttonReleaseList(w, n, event)
!     Widget		 w;
!     int			 n;
!     XButtonReleasedEvent *event;
  {
      SFDir	*dir;
  
--- 838,856 ----
  }
  
      static void
! SFbuttonPressList(
!     Widget		w UNUSED,
!     int			n UNUSED,
!     XButtonPressedEvent	*event UNUSED)
  {
      SFbuttonPressed = 1;
  }
  
      static void
! SFbuttonReleaseList(
!     Widget		 w,
!     int			 n,
!     XButtonReleasedEvent *event)
  {
      SFDir	*dir;
  
***************
*** 885,893 ****
  static int SFcheckDir(int n, SFDir *dir);
  
      static int
! SFcheckDir(n, dir)
!     int		n;
!     SFDir		*dir;
  {
      struct stat	statBuf;
      int		i;
--- 871,877 ----
  static int SFcheckDir(int n, SFDir *dir);
  
      static int
! SFcheckDir(int n, SFDir *dir)
  {
      struct stat	statBuf;
      int		i;
***************
*** 951,958 ****
  static int SFcheckFiles(SFDir *dir);
  
      static int
! SFcheckFiles(dir)
! 	SFDir	*dir;
  {
      int		from, to;
      int		result;
--- 935,941 ----
  static int SFcheckFiles(SFDir *dir);
  
      static int
! SFcheckFiles(SFDir *dir)
  {
      int		from, to;
      int		result;
***************
*** 988,996 ****
  }
  
      static void
! SFdirModTimer(cl, id)
!     XtPointer		cl UNUSED;
!     XtIntervalId	*id UNUSED;
  {
      static int		n = -1;
      static int		f = 0;
--- 971,977 ----
  }
  
      static void
! SFdirModTimer(XtPointer cl UNUSED, XtIntervalId *id UNUSED)
  {
      static int		n = -1;
      static int		f = 0;
***************
*** 1036,1043 ****
  /* Return a single character describing what kind of file STATBUF is.  */
  
      static char
! SFstatChar(statBuf)
!     struct stat *statBuf;
  {
      if (S_ISDIR (statBuf->st_mode))
  	return '/';
--- 1017,1023 ----
  /* Return a single character describing what kind of file STATBUF is.  */
  
      static char
! SFstatChar(struct stat *statBuf)
  {
      if (S_ISDIR (statBuf->st_mode))
  	return '/';
***************
*** 1100,1106 ****
  static void SFinitFont(void);
  
      static void
! SFinitFont()
  {
      TextData	*data;
  #ifdef FEAT_XFONTSET
--- 1080,1086 ----
  static void SFinitFont(void);
  
      static void
! SFinitFont(void)
  {
      TextData	*data;
  #ifdef FEAT_XFONTSET
***************
*** 1151,1157 ****
  static void SFcreateGC(void);
  
      static void
! SFcreateGC()
  {
      XGCValues	gcValues;
      XRectangle	rectangles[1];
--- 1131,1137 ----
  static void SFcreateGC(void);
  
      static void
! SFcreateGC(void)
  {
      XGCValues	gcValues;
      XRectangle	rectangles[1];
***************
*** 1209,1217 ****
  }
  
      static void
! SFclearList(n, doScroll)
!     int	n;
!     int	doScroll;
  {
      SFDir	*dir;
  
--- 1189,1195 ----
  }
  
      static void
! SFclearList(int n, int doScroll)
  {
      SFDir	*dir;
  
***************
*** 1286,1294 ****
  static void SFdeleteEntry(SFDir *dir, SFEntry *entry);
  
      static void
! SFdeleteEntry(dir, entry)
!     SFDir	*dir;
!     SFEntry	*entry;
  {
      SFEntry	*e;
      SFEntry	*end;
--- 1264,1270 ----
  static void SFdeleteEntry(SFDir *dir, SFEntry *entry);
  
      static void
! SFdeleteEntry(SFDir *dir, SFEntry *entry)
  {
      SFEntry	*e;
      SFEntry	*end;
***************
*** 1340,1349 ****
  static void SFwriteStatChar(char *name, int last, struct stat *statBuf);
  
      static void
! SFwriteStatChar(name, last, statBuf)
!     char	*name;
!     int		last;
!     struct stat	*statBuf;
  {
      name[last] = SFstatChar(statBuf);
  }
--- 1316,1325 ----
  static void SFwriteStatChar(char *name, int last, struct stat *statBuf);
  
      static void
! SFwriteStatChar(
!     char	*name,
!     int		last,
!     struct stat	*statBuf)
  {
      name[last] = SFstatChar(statBuf);
  }
***************
*** 1351,1359 ****
  static int SFstatAndCheck(SFDir *dir, SFEntry *entry);
  
      static int
! SFstatAndCheck(dir, entry)
!     SFDir	*dir;
!     SFEntry	*entry;
  {
      struct stat	statBuf;
      char	save;
--- 1327,1333 ----
  static int SFstatAndCheck(SFDir *dir, SFEntry *entry);
  
      static int
! SFstatAndCheck(SFDir *dir, SFEntry *entry)
  {
      struct stat	statBuf;
      char	save;
***************
*** 1414,1424 ****
  
  
      static void
! SFdrawStrings(w, dir, from, to)
!     Window	w;
!     SFDir	*dir;
!     int		from;
!     int		to;
  {
      int		i;
      SFEntry	*entry;
--- 1388,1398 ----
  
  
      static void
! SFdrawStrings(
!     Window	w,
!     SFDir	*dir,
!     int		from,
!     int		to)
  {
      int		i;
      SFEntry	*entry;
***************
*** 1501,1509 ****
  }
  
      static void
! SFdrawList(n, doScroll)
!     int	n;
!     int	doScroll;
  {
      SFDir	*dir;
      Window	w;
--- 1475,1481 ----
  }
  
      static void
! SFdrawList(int n, int doScroll)
  {
      SFDir	*dir;
      Window	w;
***************
*** 1539,1546 ****
  }
  
      static void
! SFdrawLists(doScroll)
!     int	doScroll;
  {
      int	i;
  
--- 1511,1517 ----
  }
  
      static void
! SFdrawLists(int doScroll)
  {
      int	i;
  
***************
*** 1549,1556 ****
  }
  
      static void
! SFinvertEntry(n)
!     int		n;
  {
      XFillRectangle(
  	    SFdisplay,
--- 1520,1526 ----
  }
  
      static void
! SFinvertEntry(int n)
  {
      XFillRectangle(
  	    SFdisplay,
***************
*** 1565,1571 ****
  static unsigned long SFscrollTimerInterval(void);
  
      static unsigned long
! SFscrollTimerInterval()
  {
      static int	maxVal = 200;
      static int	varyDist = 50;
--- 1535,1541 ----
  static unsigned long SFscrollTimerInterval(void);
  
      static unsigned long
! SFscrollTimerInterval(void)
  {
      static int	maxVal = 200;
      static int	varyDist = 50;
***************
*** 1594,1602 ****
  static void SFscrollTimer(XtPointer p, XtIntervalId *id);
  
      static void
! SFscrollTimer(p, id)
!     XtPointer		p;
!     XtIntervalId	*id UNUSED;
  {
      SFDir	*dir;
      int		save;
--- 1564,1570 ----
  static void SFscrollTimer(XtPointer p, XtIntervalId *id);
  
      static void
! SFscrollTimer(XtPointer p, XtIntervalId *id UNUSED)
  {
      SFDir	*dir;
      int		save;
***************
*** 1646,1654 ****
  }
  
      static int
! SFnewInvertEntry(n, event)
!     int			n;
!     XMotionEvent	*event;
  {
      int			x, y;
      int			nw;
--- 1614,1620 ----
  }
  
      static int
! SFnewInvertEntry(int n, XMotionEvent *event)
  {
      int			x, y;
      int			nw;
***************
*** 1693,1702 ****
  }
  
      static void
! SFenterList(w, n, event)
!     Widget		w UNUSED;
!     int			n;
!     XEnterWindowEvent	*event;
  {
      int			nw;
  
--- 1659,1665 ----
  }
  
      static void
! SFenterList(Widget w UNUSED, int n, XEnterWindowEvent *event)
  {
      int			nw;
  
***************
*** 1716,1725 ****
  }
  
      static void
! SFleaveList(w, n, event)
!     Widget	w UNUSED;
!     int		n;
!     XEvent	*event UNUSED;
  {
      if (SFcurrentInvert[n] != -1)
      {
--- 1679,1685 ----
  }
  
      static void
! SFleaveList(Widget w UNUSED, int n, XEvent *event UNUSED)
  {
      if (SFcurrentInvert[n] != -1)
      {
***************
*** 1729,1738 ****
  }
  
      static void
! SFmotionList(w, n, event)
!     Widget		w UNUSED;
!     int			n;
!     XMotionEvent	*event;
  {
      int		nw;
  
--- 1689,1695 ----
  }
  
      static void
! SFmotionList(Widget w UNUSED, int n, XMotionEvent *event)
  {
      int		nw;
  
***************
*** 1749,1758 ****
  }
  
      static void
! SFvFloatSliderMovedCallback(w, n, fnew)
!     Widget	w;
!     XtPointer	n;
!     XtPointer	fnew;
  {
      int		nw;
  
--- 1706,1712 ----
  }
  
      static void
! SFvFloatSliderMovedCallback(Widget w, XtPointer n, XtPointer fnew)
  {
      int		nw;
  
***************
*** 1761,1770 ****
  }
  
      static void
! SFvSliderMovedCallback(w, n, nw)
!     Widget	w UNUSED;
!     int		n;
!     int		nw;
  {
      int		old;
      Window	win;
--- 1715,1721 ----
  }
  
      static void
! SFvSliderMovedCallback(Widget w UNUSED, int n, int nw)
  {
      int		old;
      Window	win;
***************
*** 1846,1855 ****
  }
  
      static void
! SFvAreaSelectedCallback(w, n, pnew)
!     Widget	w;
!     XtPointer	n;
!     XtPointer	pnew;
  {
      SFDir	*dir;
      int		nw = (int)(long)pnew;
--- 1797,1803 ----
  }
  
      static void
! SFvAreaSelectedCallback(Widget w, XtPointer n, XtPointer pnew)
  {
      SFDir	*dir;
      int		nw = (int)(long)pnew;
***************
*** 1906,1915 ****
  }
  
      static void
! SFhSliderMovedCallback(w, n, nw)
!     Widget	w UNUSED;
!     XtPointer	n;
!     XtPointer	nw;
  {
      SFDir	*dir;
      int	save;
--- 1854,1860 ----
  }
  
      static void
! SFhSliderMovedCallback(Widget w UNUSED, XtPointer n, XtPointer nw)
  {
      SFDir	*dir;
      int	save;
***************
*** 1924,1933 ****
  }
  
      static void
! SFhAreaSelectedCallback(w, n, pnew)
!     Widget	w;
!     XtPointer	n;
!     XtPointer	pnew;
  {
      SFDir	*dir;
      int		nw = (int)(long)pnew;
--- 1869,1875 ----
  }
  
      static void
! SFhAreaSelectedCallback(Widget w, XtPointer n, XtPointer pnew)
  {
      SFDir	*dir;
      int		nw = (int)(long)pnew;
***************
*** 1984,1993 ****
  }
  
      static void
! SFpathSliderMovedCallback(w, client_data, nw)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
!     XtPointer	nw;
  {
      SFDir		*dir;
      int			n;
--- 1926,1935 ----
  }
  
      static void
! SFpathSliderMovedCallback(
!     Widget	w UNUSED,
!     XtPointer	client_data UNUSED,
!     XtPointer	nw)
  {
      SFDir		*dir;
      int			n;
***************
*** 2020,2029 ****
  }
  
      static void
! SFpathAreaSelectedCallback(w, client_data, pnew)
!     Widget	w;
!     XtPointer	client_data UNUSED;
!     XtPointer	pnew;
  {
      int		nw = (int)(long)pnew;
      float	f;
--- 1962,1971 ----
  }
  
      static void
! SFpathAreaSelectedCallback(
!     Widget	w,
!     XtPointer	client_data UNUSED,
!     XtPointer	pnew)
  {
      int		nw = (int)(long)pnew;
      float	f;
***************
*** 2071,2077 ****
  }
  
      static Boolean
! SFworkProc()
  {
      SFDir	*dir;
      SFEntry	*entry;
--- 2013,2019 ----
  }
  
      static Boolean
! SFworkProc(void)
  {
      SFDir	*dir;
      SFEntry	*entry;
***************
*** 2100,2115 ****
  /***************** Dir.c */
  
      static int
! SFcompareEntries(p, q)
!     const void	*p;
!     const void	*q;
  {
!     return strcmp(((SFEntry *)p)->real, ((SFEntry *)q)->real);
  }
  
      static int
! SFgetDir(dir)
!     SFDir	*dir;
  {
      SFEntry		*result = NULL;
      int			Alloc = 0;
--- 2042,2055 ----
  /***************** Dir.c */
  
      static int
! SFcompareEntries(const void *p, const void *q)
  {
!  return strcmp(((SFEntry *)p)->real, ((SFEntry *)q)->real);
  }
  
      static int
! SFgetDir(
!     SFDir	*dir)
  {
      SFEntry		*result = NULL;
      int			Alloc = 0;
***************
*** 2194,2204 ****
  static void SFexposeList(Widget w, XtPointer n, XEvent *event, Boolean *cont);
  
      static void
! SFexposeList(w, n, event, cont)
!     Widget	w UNUSED;
!     XtPointer	n;
!     XEvent	*event;
!     Boolean	*cont UNUSED;
  {
      if ((event->type == NoExpose) || event->xexpose.count)
  	return;
--- 2134,2144 ----
  static void SFexposeList(Widget w, XtPointer n, XEvent *event, Boolean *cont);
  
      static void
! SFexposeList(
!     Widget	w UNUSED,
!     XtPointer	n,
!     XEvent	*event,
!     Boolean	*cont UNUSED)
  {
      if ((event->type == NoExpose) || event->xexpose.count)
  	return;
***************
*** 2209,2219 ****
  static void SFmodVerifyCallback(Widget w, XtPointer client_data, XEvent *event, Boolean *cont);
  
      static void
! SFmodVerifyCallback(w, client_data, event, cont)
!     Widget		w UNUSED;
!     XtPointer		client_data UNUSED;
!     XEvent		*event;
!     Boolean		*cont UNUSED;
  {
      char	buf[2];
  
--- 2149,2159 ----
  static void SFmodVerifyCallback(Widget w, XtPointer client_data, XEvent *event, Boolean *cont);
  
      static void
! SFmodVerifyCallback(
!     Widget		w UNUSED,
!     XtPointer		client_data UNUSED,
!     XEvent		*event,
!     Boolean		*cont UNUSED)
  {
      char	buf[2];
  
***************
*** 2227,2236 ****
  static void SFokCallback(Widget w, XtPointer cl, XtPointer cd);
  
      static void
! SFokCallback(w, cl, cd)
!     Widget	w UNUSED;
!     XtPointer	cl UNUSED;
!     XtPointer	cd UNUSED;
  {
      SFstatus = SEL_FILE_OK;
  }
--- 2167,2173 ----
  static void SFokCallback(Widget w, XtPointer cl, XtPointer cd);
  
      static void
! SFokCallback(Widget w UNUSED, XtPointer cl UNUSED, XtPointer cd UNUSED)
  {
      SFstatus = SEL_FILE_OK;
  }
***************
*** 2244,2253 ****
  static void SFcancelCallback(Widget w, XtPointer cl, XtPointer cd);
  
      static void
! SFcancelCallback(w, cl, cd)
!     Widget	w UNUSED;
!     XtPointer	cl UNUSED;
!     XtPointer	cd UNUSED;
  {
      SFstatus = SEL_FILE_CANCEL;
  }
--- 2181,2187 ----
  static void SFcancelCallback(Widget w, XtPointer cl, XtPointer cd);
  
      static void
! SFcancelCallback(Widget w UNUSED, XtPointer cl UNUSED, XtPointer cd UNUSED)
  {
      SFstatus = SEL_FILE_CANCEL;
  }
***************
*** 2261,2271 ****
  static void SFdismissAction(Widget w, XEvent *event, String *params, Cardinal *num_params);
  
      static void
! SFdismissAction(w, event, params, num_params)
!     Widget	w UNUSED;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      if (event->type == ClientMessage
  	    && (Atom)event->xclient.data.l[0] != SFwmDeleteWindow)
--- 2195,2205 ----
  static void SFdismissAction(Widget w, XEvent *event, String *params, Cardinal *num_params);
  
      static void
! SFdismissAction(
!     Widget	w UNUSED,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      if (event->type == ClientMessage
  	    && (Atom)event->xclient.data.l[0] != SFwmDeleteWindow)
***************
*** 2284,2294 ****
  };
  
      static void
! SFsetColors(bg, fg, scroll_bg, scroll_fg)
!     guicolor_T	bg;
!     guicolor_T	fg;
!     guicolor_T	scroll_bg;
!     guicolor_T	scroll_fg;
  {
      if (selFileForm)
      {
--- 2218,2228 ----
  };
  
      static void
! SFsetColors(
!     guicolor_T	bg,
!     guicolor_T	fg,
!     guicolor_T	scroll_bg,
!     guicolor_T	scroll_fg)
  {
      if (selFileForm)
      {
***************
*** 2366,2376 ****
  }
  
      static void
! SFcreateWidgets(toplevel, prompt, ok, cancel)
!     Widget	toplevel;
!     char	*prompt;
!     char	*ok;
!     char	*cancel;
  {
      Cardinal	n;
      int		listWidth, listHeight;
--- 2300,2310 ----
  }
  
      static void
! SFcreateWidgets(
!     Widget	toplevel,
!     char	*prompt,
!     char	*ok,
!     char	*cancel)
  {
      Cardinal	n;
      int		listWidth, listHeight;
***************
*** 2686,2692 ****
  }
  
      static void
! SFtextChanged()
  {
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
      if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
--- 2620,2626 ----
  }
  
      static void
! SFtextChanged(void)
  {
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
      if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
***************
*** 2730,2736 ****
  }
  
      static char *
! SFgetText()
  {
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
      char *buf;
--- 2664,2670 ----
  }
  
      static char *
! SFgetText(void)
  {
  #if defined(FEAT_XFONTSET) && defined(XtNinternational)
      char *buf;
***************
*** 2756,2762 ****
  }
  
      static void
! SFprepareToReturn()
  {
      SFstatus = SEL_FILE_NULL;
      XtRemoveGrab(selFile);
--- 2690,2696 ----
  }
  
      static void
! SFprepareToReturn(void)
  {
      SFstatus = SEL_FILE_NULL;
      XtRemoveGrab(selFile);
***************
*** 2770,2783 ****
  }
  
      char *
! vim_SelFile(toplevel, prompt, init_path, show_entry, x, y, fg, bg, scroll_fg, scroll_bg)
!     Widget	toplevel;
!     char	*prompt;
!     char	*init_path;
!     int		(*show_entry)();
!     int		x, y;
!     guicolor_T	fg, bg;
!     guicolor_T	scroll_fg, scroll_bg; /* The "Scrollbar" group colors */
  {
      static int	firstTime = 1;
      XEvent	event;
--- 2704,2717 ----
  }
  
      char *
! vim_SelFile(
!     Widget	toplevel,
!     char	*prompt,
!     char	*init_path,
!     int		(*show_entry)(),
!     int		x, y,
!     guicolor_T	fg, bg,
!     guicolor_T	scroll_fg, scroll_bg) /* The "Scrollbar" group colors */
  {
      static int	firstTime = 1;
      XEvent	event;
*** ../vim-7.4.1206/src/gui_athena.c	2016-01-29 22:13:26.047781524 +0100
--- src/gui_athena.c	2016-01-30 16:25:52.366796189 +0100
***************
*** 87,95 ****
   * left or middle mouse button.
   */
      static void
! gui_athena_scroll_cb_jump(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data, call_data;
  {
      scrollbar_T *sb, *sb_info;
      long	value;
--- 87,95 ----
   * left or middle mouse button.
   */
      static void
! gui_athena_scroll_cb_jump(
!     Widget	w UNUSED,
!     XtPointer	client_data, call_data)
  {
      scrollbar_T *sb, *sb_info;
      long	value;
***************
*** 122,130 ****
   * right mouse buttons.
   */
      static void
! gui_athena_scroll_cb_scroll(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data, call_data;
  {
      scrollbar_T *sb, *sb_info;
      long	value;
--- 122,130 ----
   * right mouse buttons.
   */
      static void
! gui_athena_scroll_cb_scroll(
!     Widget	w UNUSED,
!     XtPointer	client_data, call_data)
  {
      scrollbar_T *sb, *sb_info;
      long	value;
***************
*** 228,234 ****
   * Create all the Athena widgets necessary.
   */
      void
! gui_x11_create_widgets()
  {
      /*
       * We don't have any borders handled internally by the textArea to worry
--- 228,234 ----
   * Create all the Athena widgets necessary.
   */
      void
! gui_x11_create_widgets(void)
  {
      /*
       * We don't have any borders handled internally by the textArea to worry
***************
*** 325,332 ****
   * Calculates the Pixmap based on the size of the current menu font.
   */
      static Pixmap
! gui_athena_create_pullright_pixmap(w)
!     Widget  w;
  {
      Pixmap  retval;
  #ifdef FONTSET_ALWAYS
--- 325,331 ----
   * Calculates the Pixmap based on the size of the current menu font.
   */
      static Pixmap
! gui_athena_create_pullright_pixmap(Widget w)
  {
      Pixmap  retval;
  #ifdef FONTSET_ALWAYS
***************
*** 425,431 ****
   * Called when the GUI is not going to start after all.
   */
      void
! gui_x11_destroy_widgets()
  {
      textArea = NULL;
  #ifdef FEAT_MENU
--- 424,430 ----
   * Called when the GUI is not going to start after all.
   */
      void
! gui_x11_destroy_widgets(void)
  {
      textArea = NULL;
  #ifdef FEAT_MENU
***************
*** 450,458 ****
   * Return in "sen".
   */
      static void
! get_toolbar_pixmap(menu, sen)
!     vimmenu_T	*menu;
!     Pixmap	*sen;
  {
      char_u	buf[MAXPATHL];		/* buffer storing expanded pathname */
      char	**xpm = NULL;		/* xpm array */
--- 449,455 ----
   * Return in "sen".
   */
      static void
! get_toolbar_pixmap(vimmenu_T *menu, Pixmap *sen)
  {
      char_u	buf[MAXPATHL];		/* buffer storing expanded pathname */
      char	**xpm = NULL;		/* xpm array */
***************
*** 492,501 ****
   * insensitive Pixmap too.
   */
      static void
! createXpmImages(path, xpm, sen)
!     char_u	*path;
!     char	**xpm;
!     Pixmap	*sen;
  {
      Window	rootWindow;
      XpmAttributes attrs;
--- 489,495 ----
   * insensitive Pixmap too.
   */
      static void
! createXpmImages(char_u *path, char **xpm, Pixmap *sen)
  {
      Window	rootWindow;
      XpmAttributes attrs;
***************
*** 566,576 ****
  }
  
      void
! gui_mch_set_toolbar_pos(x, y, w, h)
!     int	    x;
!     int	    y;
!     int	    w;
!     int	    h;
  {
      Dimension	border;
      int		height;
--- 560,570 ----
  }
  
      void
! gui_mch_set_toolbar_pos(
!     int	    x,
!     int	    y,
!     int	    w,
!     int	    h)
  {
      Dimension	border;
      int		height;
***************
*** 595,605 ****
  #endif
  
      void
! gui_mch_set_text_area_pos(x, y, w, h)
!     int	    x;
!     int	    y;
!     int	    w;
!     int	    h;
  {
      XtUnmanageChild(textArea);
      XtVaSetValues(textArea,
--- 589,599 ----
  #endif
  
      void
! gui_mch_set_text_area_pos(
!     int	    x,
!     int	    y,
!     int	    w,
!     int	    h)
  {
      XtUnmanageChild(textArea);
      XtVaSetValues(textArea,
***************
*** 622,628 ****
   * input go to the editor window, not the button
   */
      static void
! gui_mch_reset_focus()
  {
      XtSetKeyboardFocus(vimForm, textArea);
  }
--- 616,622 ----
   * input go to the editor window, not the button
   */
      static void
! gui_mch_reset_focus(void)
  {
      XtSetKeyboardFocus(vimForm, textArea);
  }
***************
*** 630,636 ****
  
  
      void
! gui_x11_set_back_color()
  {
      if (textArea != NULL)
  	XtVaSetValues(textArea,
--- 624,630 ----
  
  
      void
! gui_x11_set_back_color(void)
  {
      if (textArea != NULL)
  	XtVaSetValues(textArea,
***************
*** 652,659 ****
  static Boolean	gui_athena_menu_has_submenus(Widget, Widget);
  
      void
! gui_mch_enable_menu(flag)
!     int	    flag;
  {
      if (flag)
      {
--- 646,652 ----
  static Boolean	gui_athena_menu_has_submenus(Widget, Widget);
  
      void
! gui_mch_enable_menu(int flag)
  {
      if (flag)
      {
***************
*** 685,695 ****
  }
  
      void
! gui_mch_set_menu_pos(x, y, w, h)
!     int	    x;
!     int	    y;
!     int	    w;
!     int	    h;
  {
      Dimension	border;
      int		height;
--- 678,688 ----
  }
  
      void
! gui_mch_set_menu_pos(
!     int	    x,
!     int	    y,
!     int	    w,
!     int	    h)
  {
      Dimension	border;
      int		height;
***************
*** 717,724 ****
   *				    numChildren (end of children).
   */
      static Cardinal
! athena_calculate_ins_pos(widget)
!     Widget	widget;
  {
      /* Assume that if the parent of the vimmenu_T is NULL, then we can get
       * to this menu by traversing "next", starting at "root_menu".
--- 710,716 ----
   *				    numChildren (end of children).
   */
      static Cardinal
! athena_calculate_ins_pos(Widget widget)
  {
      /* Assume that if the parent of the vimmenu_T is NULL, then we can get
       * to this menu by traversing "next", starting at "root_menu".
***************
*** 764,772 ****
  }
  
      void
! gui_mch_add_menu(menu, idx)
!     vimmenu_T	*menu;
!     int		idx UNUSED;
  {
      char_u	*pullright_name;
      Dimension	height, space, border;
--- 756,762 ----
  }
  
      void
! gui_mch_add_menu(vimmenu_T *menu, int idx UNUSED)
  {
      char_u	*pullright_name;
      Dimension	height, space, border;
***************
*** 884,892 ****
   * Ignore widget "ignore" in the pane.
   */
      static Boolean
! gui_athena_menu_has_submenus(id, ignore)
!     Widget	id;
!     Widget	ignore;
  {
      WidgetList	children;
      Cardinal	num_children;
--- 874,880 ----
   * Ignore widget "ignore" in the pane.
   */
      static Boolean
! gui_athena_menu_has_submenus(Widget id, Widget ignore)
  {
      WidgetList	children;
      Cardinal	num_children;
***************
*** 906,913 ****
  }
  
      static void
! gui_athena_menu_font(id)
!     Widget	id;
  {
  #ifdef FONTSET_ALWAYS
      if (gui.menu_fontset != NOFONTSET)
--- 894,900 ----
  }
  
      static void
! gui_athena_menu_font(Widget id)
  {
  #ifdef FONTSET_ALWAYS
      if (gui.menu_fontset != NOFONTSET)
***************
*** 954,960 ****
  
  
      void
! gui_mch_new_menu_font()
  {
      Pixmap oldpuller = None;
  
--- 941,947 ----
  
  
      void
! gui_mch_new_menu_font(void)
  {
      Pixmap oldpuller = None;
  
***************
*** 1031,1037 ****
  
  #if defined(FEAT_BEVAL) || defined(PROTO)
      void
! gui_mch_new_tooltip_font()
  {
  #  ifdef FEAT_TOOLBAR
      vimmenu_T   *menu;
--- 1018,1024 ----
  
  #if defined(FEAT_BEVAL) || defined(PROTO)
      void
! gui_mch_new_tooltip_font(void)
  {
  #  ifdef FEAT_TOOLBAR
      vimmenu_T   *menu;
***************
*** 1046,1052 ****
  }
  
      void
! gui_mch_new_tooltip_colors()
  {
  # ifdef FEAT_TOOLBAR
      vimmenu_T   *menu;
--- 1033,1039 ----
  }
  
      void
! gui_mch_new_tooltip_colors(void)
  {
  # ifdef FEAT_TOOLBAR
      vimmenu_T   *menu;
***************
*** 1062,1070 ****
  #endif
  
      static void
! gui_mch_submenu_change(menu, colors)
!     vimmenu_T	*menu;
!     int		colors;		/* TRUE for colors, FALSE for font */
  {
      vimmenu_T	*mp;
  
--- 1049,1057 ----
  #endif
  
      static void
! gui_mch_submenu_change(
!     vimmenu_T	*menu,
!     int		colors)		/* TRUE for colors, FALSE for font */
  {
      vimmenu_T	*mp;
  
***************
*** 1141,1148 ****
   * Replace '.' by '_', can't include '.' in the submenu name.
   */
      static char_u *
! make_pull_name(name)
!     char_u * name;
  {
      char_u  *pname;
      char_u  *p;
--- 1128,1134 ----
   * Replace '.' by '_', can't include '.' in the submenu name.
   */
      static char_u *
! make_pull_name(char_u * name)
  {
      char_u  *pname;
      char_u  *p;
***************
*** 1158,1166 ****
  }
  
      void
! gui_mch_add_menu_item(menu, idx)
!     vimmenu_T	*menu;
!     int		idx UNUSED;
  {
      vimmenu_T	*parent = menu->parent;
  
--- 1144,1150 ----
  }
  
      void
! gui_mch_add_menu_item(vimmenu_T *menu, int idx UNUSED)
  {
      vimmenu_T	*parent = menu->parent;
  
***************
*** 1404,1410 ****
  
  
      int
! gui_mch_compute_toolbar_height()
  {
      Dimension	height;		    /* total Toolbar height */
      Dimension	whgt;		    /* height of each widget */
--- 1388,1394 ----
  
  
      int
! gui_mch_compute_toolbar_height(void)
  {
      Dimension	height;		    /* total Toolbar height */
      Dimension	whgt;		    /* height of each widget */
***************
*** 1439,1450 ****
  }
  
      void
! gui_mch_get_toolbar_colors(bgp, fgp, bsp, tsp, hsp)
!     Pixel	*bgp;
!     Pixel	*fgp;
!     Pixel       *bsp;
!     Pixel	*tsp;
!     Pixel	*hsp;
  {
      XtVaGetValues(toolBar, XtNbackground, bgp, XtNborderColor, fgp, NULL);
      *bsp = *bgp;
--- 1423,1434 ----
  }
  
      void
! gui_mch_get_toolbar_colors(
!     Pixel	*bgp,
!     Pixel	*fgp,
!     Pixel       *bsp,
!     Pixel	*tsp,
!     Pixel	*hsp)
  {
      XtVaGetValues(toolBar, XtNbackground, bgp, XtNborderColor, fgp, NULL);
      *bsp = *bgp;
***************
*** 1455,1468 ****
  
  
      void
! gui_mch_toggle_tearoffs(enable)
!     int		enable UNUSED;
  {
      /* no tearoff menus */
  }
  
      void
! gui_mch_new_menu_colors()
  {
      if (menuBar == (Widget)0)
  	return;
--- 1439,1451 ----
  
  
      void
! gui_mch_toggle_tearoffs(int enable UNUSED)
  {
      /* no tearoff menus */
  }
  
      void
! gui_mch_new_menu_colors(void)
  {
      if (menuBar == (Widget)0)
  	return;
***************
*** 1480,1487 ****
   * Destroy the machine specific menu widget.
   */
      void
! gui_mch_destroy_menu(menu)
!     vimmenu_T *menu;
  {
      Widget	parent;
  
--- 1463,1469 ----
   * Destroy the machine specific menu widget.
   */
      void
! gui_mch_destroy_menu(vimmenu_T *menu)
  {
      Widget	parent;
  
***************
*** 1626,1634 ****
  }
  
      static void
! gui_athena_menu_timeout(client_data, id)
!     XtPointer	    client_data;
!     XtIntervalId    *id UNUSED;
  {
      Widget  w = (Widget)client_data;
      Widget  popup;
--- 1608,1616 ----
  }
  
      static void
! gui_athena_menu_timeout(
!     XtPointer	    client_data,
!     XtIntervalId    *id UNUSED)
  {
      Widget  w = (Widget)client_data;
      Widget  popup;
***************
*** 1658,1667 ****
   * This is called when XtPopup() is called.
   */
      static void
! gui_athena_popup_callback(w, client_data, call_data)
!     Widget	w;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
      vimmenu_T	*menu = (vimmenu_T *)client_data;
--- 1640,1649 ----
   * This is called when XtPopup() is called.
   */
      static void
! gui_athena_popup_callback(
!     Widget	w,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
      vimmenu_T	*menu = (vimmenu_T *)client_data;
***************
*** 1690,1700 ****
  }
  
      static void
! gui_athena_popdown_submenus_action(w, event, args, nargs)
!     Widget	w;
!     XEvent	*event;
!     String	*args;
!     Cardinal	*nargs;
  {
      WidgetList	children;
      Cardinal	num_children;
--- 1672,1682 ----
  }
  
      static void
! gui_athena_popdown_submenus_action(
!     Widget	w,
!     XEvent	*event,
!     String	*args,
!     Cardinal	*nargs)
  {
      WidgetList	children;
      Cardinal	num_children;
***************
*** 1719,1726 ****
  
  /* Used to determine if the given widget has a submenu that can be popped up. */
      static Boolean
! has_submenu(widget)
!     Widget  widget;
  {
      if ((widget != NULL) && XtIsSubclass(widget,smeBSBObjectClass))
      {
--- 1701,1707 ----
  
  /* Used to determine if the given widget has a submenu that can be popped up. */
      static Boolean
! has_submenu(Widget widget)
  {
      if ((widget != NULL) && XtIsSubclass(widget,smeBSBObjectClass))
      {
***************
*** 1734,1744 ****
  }
  
      static void
! gui_athena_delayed_arm_action(w, event, args, nargs)
!     Widget	w;
!     XEvent	*event;
!     String	*args;
!     Cardinal	*nargs;
  {
      Dimension	width, height;
  
--- 1715,1725 ----
  }
  
      static void
! gui_athena_delayed_arm_action(
!     Widget	w,
!     XEvent	*event,
!     String	*args,
!     Cardinal	*nargs)
  {
      Dimension	width, height;
  
***************
*** 1778,1785 ****
  }
  
      static Widget
! get_popup_entry(w)
!     Widget  w;
  {
      Widget	menuw;
  
--- 1759,1765 ----
  }
  
      static Widget
! get_popup_entry(Widget w)
  {
      Widget	menuw;
  
***************
*** 1794,1801 ****
   * that is to be popped up.
   */
      static Widget
! submenu_widget(widget)
!     Widget  widget;
  {
      /* Precondition: has_submenu(widget) == True
       *	    XtIsSubclass(XtParent(widget),simpleMenuWidgetClass) == True
--- 1774,1780 ----
   * that is to be popped up.
   */
      static Widget
! submenu_widget(Widget widget)
  {
      /* Precondition: has_submenu(widget) == True
       *	    XtIsSubclass(XtParent(widget),simpleMenuWidgetClass) == True
***************
*** 1814,1821 ****
  }
  
      void
! gui_mch_show_popupmenu(menu)
!     vimmenu_T *menu;
  {
      int		rootx, rooty, winx, winy;
      Window	root, child;
--- 1793,1799 ----
  }
  
      void
! gui_mch_show_popupmenu(vimmenu_T *menu)
  {
      int		rootx, rooty, winx, winy;
      Window	root, child;
***************
*** 1850,1856 ****
   * Set the menu and scrollbar colors to their default values.
   */
      void
! gui_mch_def_colors()
  {
      /*
       * Get the colors ourselves.  Using the automatic conversion doesn't
--- 1828,1834 ----
   * Set the menu and scrollbar colors to their default values.
   */
      void
! gui_mch_def_colors(void)
  {
      /*
       * Get the colors ourselves.  Using the automatic conversion doesn't
***************
*** 1875,1885 ****
   */
  
      void
! gui_mch_set_scrollbar_thumb(sb, val, size, max)
!     scrollbar_T	*sb;
!     long	val;
!     long	size;
!     long	max;
  {
      double	v, s;
  
--- 1853,1863 ----
   */
  
      void
! gui_mch_set_scrollbar_thumb(
!     scrollbar_T	*sb,
!     long	val,
!     long	size,
!     long	max)
  {
      double	v, s;
  
***************
*** 1911,1922 ****
  }
  
      void
! gui_mch_set_scrollbar_pos(sb, x, y, w, h)
!     scrollbar_T *sb;
!     int		x;
!     int		y;
!     int		w;
!     int		h;
  {
      if (sb->id == (Widget)0)
  	return;
--- 1889,1900 ----
  }
  
      void
! gui_mch_set_scrollbar_pos(
!     scrollbar_T *sb,
!     int		x,
!     int		y,
!     int		w,
!     int		h)
  {
      if (sb->id == (Widget)0)
  	return;
***************
*** 1932,1940 ****
  }
  
      void
! gui_mch_enable_scrollbar(sb, flag)
!     scrollbar_T	*sb;
!     int		flag;
  {
      if (sb->id != (Widget)0)
      {
--- 1910,1916 ----
  }
  
      void
! gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)
  {
      if (sb->id != (Widget)0)
      {
***************
*** 1946,1954 ****
  }
  
      void
! gui_mch_create_scrollbar(sb, orient)
!     scrollbar_T *sb;
!     int		orient;	/* SBAR_VERT or SBAR_HORIZ */
  {
      sb->id = XtVaCreateWidget("scrollBar",
  #ifdef FEAT_GUI_NEXTAW
--- 1922,1930 ----
  }
  
      void
! gui_mch_create_scrollbar(
!     scrollbar_T *sb,
!     int		orient)	/* SBAR_VERT or SBAR_HORIZ */
  {
      sb->id = XtVaCreateWidget("scrollBar",
  #ifdef FEAT_GUI_NEXTAW
***************
*** 1984,1991 ****
  
  #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
! gui_mch_destroy_scrollbar(sb)
!     scrollbar_T *sb;
  {
      if (sb->id != (Widget)0)
  	XtDestroyWidget(sb->id);
--- 1960,1966 ----
  
  #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
! gui_mch_destroy_scrollbar(scrollbar_T *sb)
  {
      if (sb->id != (Widget)0)
  	XtDestroyWidget(sb->id);
***************
*** 1993,2000 ****
  #endif
  
      void
! gui_mch_set_scrollbar_colors(sb)
!     scrollbar_T *sb;
  {
      if (sb->id != (Widget)0)
  	XtVaSetValues(sb->id,
--- 1968,1974 ----
  #endif
  
      void
! gui_mch_set_scrollbar_colors(scrollbar_T *sb)
  {
      if (sb->id != (Widget)0)
  	XtVaSetValues(sb->id,
***************
*** 2011,2017 ****
   * Miscellaneous stuff:
   */
      Window
! gui_x11_get_wid()
  {
      return XtWindow(textArea);
  }
--- 1985,1991 ----
   * Miscellaneous stuff:
   */
      Window
! gui_x11_get_wid(void)
  {
      return XtWindow(textArea);
  }
***************
*** 2022,2034 ****
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
      char_u *
! gui_mch_browse(saving, title, dflt, ext, initdir, filter)
!     int		saving UNUSED;	/* select file to write */
!     char_u	*title;		/* title for the window */
!     char_u	*dflt;		/* default name */
!     char_u	*ext UNUSED;	/* extension added */
!     char_u	*initdir;	/* initial directory, NULL for current dir */
!     char_u	*filter UNUSED;	/* file name filter */
  {
      Position x, y;
      char_u	dirbuf[MAXPATHL];
--- 1996,2008 ----
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
      char_u *
! gui_mch_browse(
!     int		saving UNUSED,	/* select file to write */
!     char_u	*title,		/* title for the window */
!     char_u	*dflt,		/* default name */
!     char_u	*ext UNUSED,	/* extension added */
!     char_u	*initdir,	/* initial directory, NULL for current dir */
!     char_u	*filter UNUSED)	/* file name filter */
  {
      Position x, y;
      char_u	dirbuf[MAXPATHL];
***************
*** 2075,2085 ****
   * hitting the "OK" button, ESC like "Cancel".
   */
      static void
! keyhit_callback(w, client_data, event, cont)
!     Widget		w UNUSED;
!     XtPointer		client_data UNUSED;
!     XEvent		*event;
!     Boolean		*cont UNUSED;
  {
      char	buf[2];
  
--- 2049,2059 ----
   * hitting the "OK" button, ESC like "Cancel".
   */
      static void
! keyhit_callback(
!     Widget		w UNUSED,
!     XtPointer		client_data UNUSED,
!     XEvent		*event,
!     Boolean		*cont UNUSED)
  {
      char	buf[2];
  
***************
*** 2093,2102 ****
  }
  
      static void
! butproc(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      dialogStatus = (int)(long)client_data + 1;
  }
--- 2067,2076 ----
  }
  
      static void
! butproc(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      dialogStatus = (int)(long)client_data + 1;
  }
***************
*** 2105,2115 ****
   * Function called when dialog window closed.
   */
      static void
! dialog_wm_handler(w, client_data, event, dum)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
!     XEvent	*event;
!     Boolean	*dum UNUSED;
  {
      if (event->type == ClientMessage
  	    && (Atom)((XClientMessageEvent *)event)->data.l[0] == dialogatom)
--- 2079,2089 ----
   * Function called when dialog window closed.
   */
      static void
! dialog_wm_handler(
!     Widget	w UNUSED,
!     XtPointer	client_data UNUSED,
!     XEvent	*event,
!     Boolean	*dum UNUSED)
  {
      if (event->type == ClientMessage
  	    && (Atom)((XClientMessageEvent *)event)->data.l[0] == dialogatom)
***************
*** 2117,2130 ****
  }
  
      int
! gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield, ex_cmd)
!     int		type UNUSED;
!     char_u	*title;
!     char_u	*message;
!     char_u	*buttons;
!     int		dfltbutton UNUSED;
!     char_u	*textfield;
!     int		ex_cmd UNUSED;
  {
      char_u		*buts;
      char_u		*p, *next;
--- 2091,2104 ----
  }
  
      int
! gui_mch_dialog(
!     int		type UNUSED,
!     char_u	*title,
!     char_u	*message,
!     char_u	*buttons,
!     int		dfltbutton UNUSED,
!     char_u	*textfield,
!     int		ex_cmd UNUSED)
  {
      char_u		*buts;
      char_u		*p, *next;
***************
*** 2305,2312 ****
   * Set the colors of Widget "id" to the menu colors.
   */
      static void
! gui_athena_menu_colors(id)
!     Widget  id;
  {
      if (gui.menu_bg_pixel != INVALCOLOR)
  	XtVaSetValues(id, XtNbackground, gui.menu_bg_pixel, NULL);
--- 2279,2285 ----
   * Set the colors of Widget "id" to the menu colors.
   */
      static void
! gui_athena_menu_colors(Widget id)
  {
      if (gui.menu_bg_pixel != INVALCOLOR)
  	XtVaSetValues(id, XtNbackground, gui.menu_bg_pixel, NULL);
***************
*** 2319,2326 ****
   * Set the colors of Widget "id" to the scroll colors.
   */
      static void
! gui_athena_scroll_colors(id)
!     Widget  id;
  {
      if (gui.scroll_bg_pixel != INVALCOLOR)
  	XtVaSetValues(id, XtNbackground, gui.scroll_bg_pixel, NULL);
--- 2292,2298 ----
   * Set the colors of Widget "id" to the scroll colors.
   */
      static void
! gui_athena_scroll_colors(Widget id)
  {
      if (gui.scroll_bg_pixel != INVALCOLOR)
  	XtVaSetValues(id, XtNbackground, gui.scroll_bg_pixel, NULL);
*** ../vim-7.4.1206/src/gui_at_sb.c	2016-01-29 23:23:01.711780688 +0100
--- src/gui_at_sb.c	2016-01-30 16:28:09.421367515 +0100
***************
*** 222,228 ****
  #define PAGE_REPEAT	250
  
      static void
! ClassInitialize()
  {
      XawInitializeWidgetSet();
      XtAddConverter( XtRString, XtROrientation, XmuCvtStringToOrientation,
--- 222,228 ----
  #define PAGE_REPEAT	250
  
      static void
! ClassInitialize(void)
  {
      XawInitializeWidgetSet();
      XtAddConverter( XtRString, XtROrientation, XmuCvtStringToOrientation,
***************
*** 232,242 ****
  #define MARGIN(sbw) (sbw)->scrollbar.thickness + (sbw)->scrollbar.shadow_width
  
      static void
! FillArea(sbw, top, bottom, fill, draw_shadow)
!     ScrollbarWidget	sbw;
!     Position		top, bottom;
!     int			fill;
!     int			draw_shadow;
  {
      int tlen = bottom - top;	/* length of thumb in pixels */
      int sw, margin, floor;
--- 232,242 ----
  #define MARGIN(sbw) (sbw)->scrollbar.thickness + (sbw)->scrollbar.shadow_width
  
      static void
! FillArea(
!     ScrollbarWidget	sbw,
!     Position		top, bottom,
!     int			fill,
!     int			draw_shadow)
  {
      int tlen = bottom - top;	/* length of thumb in pixels */
      int sw, margin, floor;
***************
*** 340,347 ****
   */
  
      static void
! PaintThumb(sbw)
!     ScrollbarWidget sbw;
  {
      Position	    oldtop, oldbot, newtop, newbot;
      Dimension	    margin, tzl;
--- 340,346 ----
   */
  
      static void
! PaintThumb(ScrollbarWidget sbw)
  {
      Position	    oldtop, oldbot, newtop, newbot;
      Dimension	    margin, tzl;
***************
*** 374,381 ****
  }
  
      static void
! PaintArrows(sbw)
!     ScrollbarWidget sbw;
  {
      XPoint	point[6];
      Dimension	thickness = sbw->scrollbar.thickness - 1;
--- 373,379 ----
  }
  
      static void
! PaintArrows(ScrollbarWidget sbw)
  {
      XPoint	point[6];
      Dimension	thickness = sbw->scrollbar.thickness - 1;
***************
*** 454,461 ****
  }
  
      static void
! Destroy(w)
!     Widget w;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      if (sbw->scrollbar.timer_id != (XtIntervalId) 0)
--- 452,458 ----
  }
  
      static void
! Destroy(Widget w)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      if (sbw->scrollbar.timer_id != (XtIntervalId) 0)
***************
*** 466,473 ****
  }
  
      static void
! CreateGC(w)
!     Widget w;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) w;
      XGCValues		gcValues;
--- 463,469 ----
  }
  
      static void
! CreateGC(Widget w)
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) w;
      XGCValues		gcValues;
***************
*** 505,512 ****
  }
  
      static void
! SetDimensions(sbw)
!     ScrollbarWidget sbw;
  {
      if (sbw->scrollbar.orientation == XtorientVertical)
      {
--- 501,507 ----
  }
  
      static void
! SetDimensions(ScrollbarWidget sbw)
  {
      if (sbw->scrollbar.orientation == XtorientVertical)
      {
***************
*** 521,531 ****
  }
  
      static void
! Initialize(request, new, args, num_args)
!     Widget	request UNUSED;	/* what the client asked for */
!     Widget	new;		/* what we're going to give him */
!     ArgList	args UNUSED;
!     Cardinal	*num_args UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) new;
  
--- 516,526 ----
  }
  
      static void
! Initialize(
!     Widget	request UNUSED,	/* what the client asked for */
!     Widget	new,		/* what we're going to give him */
!     ArgList	args UNUSED,
!     Cardinal	*num_args UNUSED)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) new;
  
***************
*** 549,558 ****
  }
  
      static void
! Realize(w, valueMask, attributes)
!     Widget w;
!     Mask *valueMask;
!     XSetWindowAttributes *attributes;
  {
      /* The Simple widget actually stuffs the value in the valuemask. */
      (*vim_scrollbarWidgetClass->core_class.superclass->core_class.realize)
--- 544,553 ----
  }
  
      static void
! Realize(
!     Widget w,
!     Mask *valueMask,
!     XSetWindowAttributes *attributes)
  {
      /* The Simple widget actually stuffs the value in the valuemask. */
      (*vim_scrollbarWidgetClass->core_class.superclass->core_class.realize)
***************
*** 560,571 ****
  }
  
      static Boolean
! SetValues(current, request, desired, args, num_args)
!     Widget  current;	    /* what I am */
!     Widget  request UNUSED; /* what he wants me to be */
!     Widget  desired;	    /* what I will become */
!     ArgList args UNUSED;
!     Cardinal *num_args UNUSED;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) current;
      ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
--- 555,566 ----
  }
  
      static Boolean
! SetValues(
!     Widget  current,	    /* what I am */
!     Widget  request UNUSED, /* what he wants me to be */
!     Widget  desired,	    /* what I will become */
!     ArgList args UNUSED,
!     Cardinal *num_args UNUSED)
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) current;
      ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
***************
*** 601,608 ****
  }
  
      static void
! Resize(w)
!     Widget w;
  {
      /* ForgetGravity has taken care of background, but thumb may
       * have to move as a result of the new size. */
--- 596,602 ----
  }
  
      static void
! Resize(Widget w)
  {
      /* ForgetGravity has taken care of background, but thumb may
       * have to move as a result of the new size. */
***************
*** 612,621 ****
  
  
      static void
! Redisplay(w, event, region)
!     Widget w;
!     XEvent *event;
!     Region region;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      int x, y;
--- 606,612 ----
  
  
      static void
! Redisplay(Widget w, XEvent *event, Region region)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      int x, y;
***************
*** 650,657 ****
  
  
      static Boolean
! CompareEvents(oldEvent, newEvent)
!     XEvent *oldEvent, *newEvent;
  {
  #define Check(field) if (newEvent->field != oldEvent->field) return False;
  
--- 641,647 ----
  
  
      static Boolean
! CompareEvents(XEvent *oldEvent, *newEvent)
  {
  #define Check(field) if (newEvent->field != oldEvent->field) return False;
  
***************
*** 693,702 ****
  };
  
      static Bool
! PeekNotifyEvent(dpy, event, args)
!     Display *dpy;
!     XEvent *event;
!     char *args;
  {
      struct EventData *eventData = (struct EventData*)args;
  
--- 683,689 ----
  };
  
      static Bool
! PeekNotifyEvent(Display *dpy, XEvent *event, char *args)
  {
      struct EventData *eventData = (struct EventData*)args;
  
***************
*** 706,714 ****
  
  
      static Boolean
! LookAhead(w, event)
!     Widget w;
!     XEvent *event;
  {
      XEvent newEvent;
      struct EventData eventData;
--- 693,699 ----
  
  
      static Boolean
! LookAhead(Widget w, XEvent *event)
  {
      XEvent newEvent;
      struct EventData eventData;
***************
*** 726,735 ****
  
  
      static void
! ExtractPosition(event, x, y, state)
!     XEvent	    *event;
!     Position	    *x, *y;	/* RETURN */
!     unsigned int    *state;	/* RETURN */
  {
      switch (event->type)
      {
--- 711,720 ----
  
  
      static void
! ExtractPosition(
!     XEvent	    *event,
!     Position	    *x, *y,	/* RETURN */
!     unsigned int    *state)	/* RETURN */
  {
      switch (event->type)
      {
***************
*** 768,778 ****
  }
  
      static void
! HandleThumb(w, event, params, num_params)
!     Widget w;
!     XEvent *event;
!     String *params;
!     Cardinal *num_params;
  {
      Position x, y, loc;
      ScrollbarWidget sbw = (ScrollbarWidget) w;
--- 753,763 ----
  }
  
      static void
! HandleThumb(
!     Widget w,
!     XEvent *event,
!     String *params,
!     Cardinal *num_params)
  {
      Position x, y, loc;
      ScrollbarWidget sbw = (ScrollbarWidget) w;
***************
*** 791,799 ****
  }
  
      static void
! RepeatNotify(client_data, idp)
!     XtPointer client_data;
!     XtIntervalId *idp UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) client_data;
      int		    call_data;
--- 776,782 ----
  }
  
      static void
! RepeatNotify(XtPointer client_data, XtIntervalId *idp UNUSED)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) client_data;
      int		    call_data;
***************
*** 833,889 ****
   * Same as above, but for floating numbers.
   */
      static float
! FloatInRange(num, small, big)
!     float num, small, big;
  {
      return (num < small) ? small : ((num > big) ? big : num);
  }
  
      static void
! ScrollOneLineUp(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, -ONE_LINE_DATA);
  }
  
      static void
! ScrollOneLineDown(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, ONE_LINE_DATA);
  }
  
      static void
! ScrollPageDown(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, ONE_PAGE_DATA);
  }
  
      static void
! ScrollPageUp(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollSome(w, event, -ONE_PAGE_DATA);
  }
  
      static void
! ScrollSome(w, event, call_data)
!     Widget	w;
!     XEvent	*event;
!     int		call_data;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) w;
  
--- 816,871 ----
   * Same as above, but for floating numbers.
   */
      static float
! FloatInRange(float num, small, big)
  {
      return (num < small) ? small : ((num > big) ? big : num);
  }
  
      static void
! ScrollOneLineUp(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollSome(w, event, -ONE_LINE_DATA);
  }
  
      static void
! ScrollOneLineDown(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollSome(w, event, ONE_LINE_DATA);
  }
  
      static void
! ScrollPageDown(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollSome(w, event, ONE_PAGE_DATA);
  }
  
      static void
! ScrollPageUp(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollSome(w, event, -ONE_PAGE_DATA);
  }
  
      static void
! ScrollSome(
!     Widget	w,
!     XEvent	*event,
!     int		call_data)
  {
      ScrollbarWidget	sbw = (ScrollbarWidget) w;
  
***************
*** 898,908 ****
  }
  
      static void
! NotifyScroll(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      Position	    x, y, loc;
--- 880,890 ----
  }
  
      static void
! NotifyScroll(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      Position	    x, y, loc;
***************
*** 987,997 ****
  }
  
      static void
! EndScroll(w, event, params, num_params)
!     Widget w;
!     XEvent *event UNUSED;
!     String *params UNUSED;
!     Cardinal *num_params UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
  
--- 969,979 ----
  }
  
      static void
! EndScroll(
!     Widget w,
!     XEvent *event UNUSED,
!     String *params UNUSED,
!     Cardinal *num_params UNUSED)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
  
***************
*** 1002,1010 ****
  }
  
      static float
! FractionLoc(sbw, x, y)
!     ScrollbarWidget sbw;
!     int x, y;
  {
      int	    margin;
      float   height, width;
--- 984,990 ----
  }
  
      static float
! FractionLoc(ScrollbarWidget sbw, int x, y)
  {
      int	    margin;
      float   height, width;
***************
*** 1018,1028 ****
  }
  
      static void
! MoveThumb(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollbarWidget	sbw = (ScrollbarWidget)w;
      Position		x, y;
--- 998,1008 ----
  }
  
      static void
! MoveThumb(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollbarWidget	sbw = (ScrollbarWidget)w;
      Position		x, y;
***************
*** 1063,1073 ****
  
  
      static void
! NotifyThumb(w, event, params, num_params)
!     Widget	w;
!     XEvent	*event;
!     String	*params UNUSED;
!     Cardinal	*num_params UNUSED;
  {
      ScrollbarWidget sbw = (ScrollbarWidget)w;
      /* Use a union to avoid a warning for the weird conversion from float to
--- 1043,1053 ----
  
  
      static void
! NotifyThumb(
!     Widget	w,
!     XEvent	*event,
!     String	*params UNUSED,
!     Cardinal	*num_params UNUSED)
  {
      ScrollbarWidget sbw = (ScrollbarWidget)w;
      /* Use a union to avoid a warning for the weird conversion from float to
***************
*** 1089,1096 ****
  }
  
      static void
! AllocTopShadowGC(w)
!     Widget w;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      XtGCMask	    valuemask;
--- 1069,1075 ----
  }
  
      static void
! AllocTopShadowGC(Widget w)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      XtGCMask	    valuemask;
***************
*** 1102,1109 ****
  }
  
      static void
! AllocBotShadowGC(w)
!     Widget w;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      XtGCMask	    valuemask;
--- 1081,1087 ----
  }
  
      static void
! AllocBotShadowGC(Widget w)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
      XtGCMask	    valuemask;
***************
*** 1115,1125 ****
  }
  
      static void
! _Xaw3dDrawShadows(gw, event, region, out)
!     Widget  gw;
!     XEvent  *event UNUSED;
!     Region  region;
!     int	    out;
  {
      XPoint  pt[6];
      ScrollbarWidget sbw = (ScrollbarWidget) gw;
--- 1093,1103 ----
  }
  
      static void
! _Xaw3dDrawShadows(
!     Widget  gw,
!     XEvent  *event UNUSED,
!     Region  region,
!     int	    out)
  {
      XPoint  pt[6];
      ScrollbarWidget sbw = (ScrollbarWidget) gw;
***************
*** 1187,1195 ****
   * Set the scroll bar to the given location.
   */
      void
! vim_XawScrollbarSetThumb(w, top, shown, max)
!     Widget w;
!     double top, shown, max;
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
  
--- 1165,1171 ----
   * Set the scroll bar to the given location.
   */
      void
! vim_XawScrollbarSetThumb(Widget w, double top, shown, max)
  {
      ScrollbarWidget sbw = (ScrollbarWidget) w;
  
*** ../vim-7.4.1206/src/gui_beval.c	2016-01-29 23:20:35.301308246 +0100
--- src/gui_beval.c	2016-01-30 16:29:15.312680727 +0100
***************
*** 16,24 ****
   * Common code, invoked when the mouse is resting for a moment.
   */
      void
! general_beval_cb(beval, state)
!     BalloonEval *beval;
!     int		state UNUSED;
  {
  #ifdef FEAT_EVAL
      win_T	*wp;
--- 16,22 ----
   * Common code, invoked when the mouse is resting for a moment.
   */
      void
! general_beval_cb(BalloonEval *beval, int state UNUSED)
  {
  #ifdef FEAT_EVAL
      win_T	*wp;
***************
*** 192,202 ****
   * Returns a pointer to the resulting object (NULL when out of memory).
   */
      BalloonEval *
! gui_mch_create_beval_area(target, mesg, mesgCB, clientData)
!     void	*target;
!     char_u	*mesg;
!     void	(*mesgCB)(BalloonEval *, int);
!     void	*clientData;
  {
  #ifndef FEAT_GUI_GTK
      char	*display_name;	    /* get from gui.dpy */
--- 190,200 ----
   * Returns a pointer to the resulting object (NULL when out of memory).
   */
      BalloonEval *
! gui_mch_create_beval_area(
!     void	*target,
!     char_u	*mesg,
!     void	(*mesgCB)(BalloonEval *, int),
!     void	*clientData)
  {
  #ifndef FEAT_GUI_GTK
      char	*display_name;	    /* get from gui.dpy */
***************
*** 262,269 ****
   * Destroy a balloon-eval and free its associated memory.
   */
      void
! gui_mch_destroy_beval_area(beval)
!     BalloonEval	*beval;
  {
      cancelBalloon(beval);
      removeEventHandler(beval);
--- 260,266 ----
   * Destroy a balloon-eval and free its associated memory.
   */
      void
! gui_mch_destroy_beval_area(BalloonEval *beval)
  {
      cancelBalloon(beval);
      removeEventHandler(beval);
***************
*** 278,293 ****
  #endif
  
      void
! gui_mch_enable_beval_area(beval)
!     BalloonEval	*beval;
  {
      if (beval != NULL)
  	addEventHandler(beval->target, beval);
  }
  
      void
! gui_mch_disable_beval_area(beval)
!     BalloonEval	*beval;
  {
      if (beval != NULL)
  	removeEventHandler(beval);
--- 275,288 ----
  #endif
  
      void
! gui_mch_enable_beval_area(BalloonEval *beval)
  {
      if (beval != NULL)
  	addEventHandler(beval->target, beval);
  }
  
      void
! gui_mch_disable_beval_area(BalloonEval *beval)
  {
      if (beval != NULL)
  	removeEventHandler(beval);
***************
*** 301,307 ****
   * Assumption: Only one tooltip can be shown at a time.
   */
      BalloonEval *
! gui_mch_currently_showing_beval()
  {
      return current_beval;
  }
--- 296,302 ----
   * Assumption: Only one tooltip can be shown at a time.
   */
      BalloonEval *
! gui_mch_currently_showing_beval(void)
  {
      return current_beval;
  }
***************
*** 317,329 ****
   * Returns OK or FAIL.
   */
      int
! get_beval_info(beval, getword, winp, lnump, textp, colp)
!     BalloonEval	*beval;
!     int		getword;
!     win_T	**winp;
!     linenr_T	*lnump;
!     char_u	**textp;
!     int		*colp;
  {
      win_T	*wp;
      int		row, col;
--- 312,324 ----
   * Returns OK or FAIL.
   */
      int
! get_beval_info(
!     BalloonEval	*beval,
!     int		getword,
!     win_T	**winp,
!     linenr_T	*lnump,
!     char_u	**textp,
!     int		*colp)
  {
      win_T	*wp;
      int		row, col;
***************
*** 427,435 ****
   * Show a balloon with "mesg".
   */
      void
! gui_mch_post_balloon(beval, mesg)
!     BalloonEval	*beval;
!     char_u	*mesg;
  {
      beval->msg = mesg;
      if (mesg != NULL)
--- 422,428 ----
   * Show a balloon with "mesg".
   */
      void
! gui_mch_post_balloon(BalloonEval *beval, char_u *mesg)
  {
      beval->msg = mesg;
      if (mesg != NULL)
***************
*** 446,453 ****
   * Hide the given balloon.
   */
      void
! gui_mch_unpost_balloon(beval)
!     BalloonEval	*beval;
  {
      undrawBalloon(beval);
  }
--- 439,445 ----
   * Hide the given balloon.
   */
      void
! gui_mch_unpost_balloon(BalloonEval *beval)
  {
      undrawBalloon(beval);
  }
***************
*** 687,695 ****
  #else /* !FEAT_GUI_GTK */
  
      static void
! addEventHandler(target, beval)
!     Widget	target;
!     BalloonEval	*beval;
  {
      XtAddEventHandler(target,
  			PointerMotionMask | EnterWindowMask |
--- 679,685 ----
  #else /* !FEAT_GUI_GTK */
  
      static void
! addEventHandler(Widget target, BalloonEval *beval)
  {
      XtAddEventHandler(target,
  			PointerMotionMask | EnterWindowMask |
***************
*** 700,707 ****
  }
  
      static void
! removeEventHandler(beval)
!     BalloonEval	*beval;
  {
      XtRemoveEventHandler(beval->target,
  			PointerMotionMask | EnterWindowMask |
--- 690,696 ----
  }
  
      static void
! removeEventHandler(BalloonEval *beval)
  {
      XtRemoveEventHandler(beval->target,
  			PointerMotionMask | EnterWindowMask |
***************
*** 716,726 ****
   * The X event handler. All it does is call the real event handler.
   */
      static void
! pointerEventEH(w, client_data, event, unused)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XEvent	*event;
!     Boolean	*unused UNUSED;
  {
      BalloonEval *beval = (BalloonEval *)client_data;
      pointerEvent(beval, event);
--- 705,715 ----
   * The X event handler. All it does is call the real event handler.
   */
      static void
! pointerEventEH(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XEvent	*event,
!     Boolean	*unused UNUSED)
  {
      BalloonEval *beval = (BalloonEval *)client_data;
      pointerEvent(beval, event);
***************
*** 733,741 ****
   */
  
      static void
! pointerEvent(beval, event)
!     BalloonEval	*beval;
!     XEvent	*event;
  {
      Position	distance;	    /* a measure of how much the pointer moved */
      Position	delta;		    /* used to compute distance */
--- 722,728 ----
   */
  
      static void
! pointerEvent(BalloonEval *beval, XEvent *event)
  {
      Position	distance;	    /* a measure of how much the pointer moved */
      Position	delta;		    /* used to compute distance */
***************
*** 866,874 ****
  }
  
      static void
! timerRoutine(dx, id)
!     XtPointer	    dx;
!     XtIntervalId    *id UNUSED;
  {
      BalloonEval *beval = (BalloonEval *)dx;
  
--- 853,859 ----
  }
  
      static void
! timerRoutine(XtPointer dx, XtIntervalId *id UNUSED)
  {
      BalloonEval *beval = (BalloonEval *)dx;
  
***************
*** 885,892 ****
  #endif /* !FEAT_GUI_GTK */
  
      static void
! requestBalloon(beval)
!     BalloonEval	*beval;
  {
      if (beval->showState != ShS_PENDING)
      {
--- 870,876 ----
  #endif /* !FEAT_GUI_GTK */
  
      static void
! requestBalloon(BalloonEval *beval)
  {
      if (beval->showState != ShS_PENDING)
      {
***************
*** 1177,1184 ****
   * Draw a balloon.
   */
      static void
! drawBalloon(beval)
!     BalloonEval	*beval;
  {
      Dimension	w;
      Dimension	h;
--- 1161,1167 ----
   * Draw a balloon.
   */
      static void
! drawBalloon(BalloonEval *beval)
  {
      Dimension	w;
      Dimension	h;
***************
*** 1281,1288 ****
   * Undraw a balloon.
   */
      static void
! undrawBalloon(beval)
!     BalloonEval *beval;
  {
      if (beval->balloonShell != (Widget)0)
  	XtPopdown(beval->balloonShell);
--- 1264,1270 ----
   * Undraw a balloon.
   */
      static void
! undrawBalloon(BalloonEval *beval)
  {
      if (beval->balloonShell != (Widget)0)
  	XtPopdown(beval->balloonShell);
***************
*** 1292,1299 ****
  }
  
      static void
! cancelBalloon(beval)
!     BalloonEval	*beval;
  {
      if (beval->showState == ShS_SHOWING
  	    || beval->showState == ShS_UPDATE_PENDING)
--- 1274,1280 ----
  }
  
      static void
! cancelBalloon(BalloonEval *beval)
  {
      if (beval->showState == ShS_SHOWING
  	    || beval->showState == ShS_UPDATE_PENDING)
***************
*** 1309,1316 ****
  
  
      static void
! createBalloonEvalWindow(beval)
!     BalloonEval	*beval;
  {
      Arg		args[12];
      int		n;
--- 1290,1296 ----
  
  
      static void
! createBalloonEvalWindow(BalloonEval *beval)
  {
      Arg		args[12];
      int		n;
*** ../vim-7.4.1206/src/gui.c	2016-01-29 22:13:26.047781524 +0100
--- src/gui.c	2016-01-30 16:32:40.218545287 +0100
***************
*** 73,79 ****
   * recursive call.
   */
      void
! gui_start()
  {
      char_u	*old_term;
      static int	recursive = 0;
--- 73,79 ----
   * recursive call.
   */
      void
! gui_start(void)
  {
      char_u	*old_term;
      static int	recursive = 0;
***************
*** 152,158 ****
   * full_screen will be set to TRUE again by a successful termcapinit().
   */
      static void
! gui_attempt_start()
  {
      static int recursive = 0;
  
--- 152,158 ----
   * full_screen will be set to TRUE again by a successful termcapinit().
   */
      static void
! gui_attempt_start(void)
  {
      static int recursive = 0;
  
***************
*** 204,210 ****
   * and the child will return.
   */
      static void
! gui_do_fork()
  {
      int		pipefd[2];	/* pipe between parent and child */
      int		pipe_error;
--- 204,210 ----
   * and the child will return.
   */
      static void
! gui_do_fork(void)
  {
      int		pipefd[2];	/* pipe between parent and child */
      int		pipe_error;
***************
*** 345,353 ****
   * Call this when vim starts up, whether or not the GUI is started
   */
      void
! gui_prepare(argc, argv)
!     int	    *argc;
!     char    **argv;
  {
      gui.in_use = FALSE;		    /* No GUI yet (maybe later) */
      gui.starting = FALSE;	    /* No GUI yet (maybe later) */
--- 345,351 ----
   * Call this when vim starts up, whether or not the GUI is started
   */
      void
! gui_prepare(int *argc, char **argv)
  {
      gui.in_use = FALSE;		    /* No GUI yet (maybe later) */
      gui.starting = FALSE;	    /* No GUI yet (maybe later) */
***************
*** 361,367 ****
   * Returns FAIL or OK.
   */
      int
! gui_init_check()
  {
      static int result = MAYBE;
  
--- 359,365 ----
   * Returns FAIL or OK.
   */
      int
! gui_init_check(void)
  {
      static int result = MAYBE;
  
***************
*** 461,467 ****
   * This is the call which starts the GUI.
   */
      void
! gui_init()
  {
      win_T	*wp;
      static int	recursive = 0;
--- 459,465 ----
   * This is the call which starts the GUI.
   */
      void
! gui_init(void)
  {
      win_T	*wp;
      static int	recursive = 0;
***************
*** 789,796 ****
  
  
      void
! gui_exit(rc)
!     int		rc;
  {
      /* don't free the fonts, it leads to a BUS error
       * richard@whitequeen.com Jul 99 */
--- 787,793 ----
  
  
      void
! gui_exit(int rc)
  {
      /* don't free the fonts, it leads to a BUS error
       * richard@whitequeen.com Jul 99 */
***************
*** 809,815 ****
   * When this function returns, Vim should NOT exit!
   */
      void
! gui_shell_closed()
  {
      cmdmod_T	    save_cmdmod;
  
--- 806,812 ----
   * When this function returns, Vim should NOT exit!
   */
      void
! gui_shell_closed(void)
  {
      cmdmod_T	    save_cmdmod;
  
***************
*** 843,851 ****
   * the fonts are unchanged.
   */
      int
! gui_init_font(font_list, fontset)
!     char_u	*font_list;
!     int		fontset UNUSED;
  {
  #define FONTLEN 320
      char_u	font_name[FONTLEN];
--- 840,846 ----
   * the fonts are unchanged.
   */
      int
! gui_init_font(char_u *font_list, int fontset UNUSED)
  {
  #define FONTLEN 320
      char_u	font_name[FONTLEN];
***************
*** 926,933 ****
   * Try setting 'guifontwide' to a font twice as wide as "name".
   */
      static void
! set_guifontwide(name)
!     char_u	*name;
  {
      int		i = 0;
      char_u	wide_name[FONTLEN + 10]; /* room for 2 * width and '*' */
--- 921,927 ----
   * Try setting 'guifontwide' to a font twice as wide as "name".
   */
      static void
! set_guifontwide(char_u *name)
  {
      int		i = 0;
      char_u	wide_name[FONTLEN + 10]; /* room for 2 * width and '*' */
***************
*** 976,982 ****
   * Return FAIL for an invalid font name.
   */
      int
! gui_get_wide_font()
  {
      GuiFont	font = NOFONT;
      char_u	font_name[FONTLEN];
--- 970,976 ----
   * Return FAIL for an invalid font name.
   */
      int
! gui_get_wide_font(void)
  {
      GuiFont	font = NOFONT;
      char_u	font_name[FONTLEN];
***************
*** 1024,1032 ****
  #endif
  
      void
! gui_set_cursor(row, col)
!     int	    row;
!     int	    col;
  {
      gui.row = row;
      gui.col = col;
--- 1018,1024 ----
  #endif
  
      void
! gui_set_cursor(int row, int col)
  {
      gui.row = row;
      gui.col = col;
***************
*** 1036,1042 ****
   * gui_check_pos - check if the cursor is on the screen.
   */
      static void
! gui_check_pos()
  {
      if (gui.row >= screen_Rows)
  	gui.row = screen_Rows - 1;
--- 1028,1034 ----
   * gui_check_pos - check if the cursor is on the screen.
   */
      static void
! gui_check_pos(void)
  {
      if (gui.row >= screen_Rows)
  	gui.row = screen_Rows - 1;
***************
*** 1052,1060 ****
   * otherwise this goes wrong.  May need to call out_flush() first.
   */
      void
! gui_update_cursor(force, clear_selection)
!     int		force;		/* when TRUE, update even when not moved */
!     int		clear_selection;/* clear selection under cursor */
  {
      int		cur_width = 0;
      int		cur_height = 0;
--- 1044,1052 ----
   * otherwise this goes wrong.  May need to call out_flush() first.
   */
      void
! gui_update_cursor(
!     int		force,		/* when TRUE, update even when not moved */
!     int		clear_selection)/* clear selection under cursor */
  {
      int		cur_width = 0;
      int		cur_height = 0;
***************
*** 1301,1307 ****
  
  #if defined(FEAT_MENU) || defined(PROTO)
      void
! gui_position_menu()
  {
  # if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
      if (gui.menu_is_active && gui.in_use)
--- 1293,1299 ----
  
  #if defined(FEAT_MENU) || defined(PROTO)
      void
! gui_position_menu(void)
  {
  # if !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)
      if (gui.menu_is_active && gui.in_use)
***************
*** 1315,1322 ****
   * scrollbars are NOT handled here.  See gui_update_scrollbars().
   */
      static void
! gui_position_components(total_width)
!     int	    total_width UNUSED;
  {
      int	    text_area_x;
      int	    text_area_y;
--- 1307,1313 ----
   * scrollbars are NOT handled here.  See gui_update_scrollbars().
   */
      static void
! gui_position_components(int total_width UNUSED)
  {
      int	    text_area_x;
      int	    text_area_y;
***************
*** 1388,1394 ****
   * Get the width of the widgets and decorations to the side of the text area.
   */
      int
! gui_get_base_width()
  {
      int	    base_width;
  
--- 1379,1385 ----
   * Get the width of the widgets and decorations to the side of the text area.
   */
      int
! gui_get_base_width(void)
  {
      int	    base_width;
  
***************
*** 1404,1410 ****
   * Get the height of the widgets and decorations above and below the text area.
   */
      int
! gui_get_base_height()
  {
      int	    base_height;
  
--- 1395,1401 ----
   * Get the height of the widgets and decorations above and below the text area.
   */
      int
! gui_get_base_height(void)
  {
      int	    base_height;
  
***************
*** 1449,1457 ****
   * the new width and height of the shell in pixels.
   */
      void
! gui_resize_shell(pixel_width, pixel_height)
!     int		pixel_width;
!     int		pixel_height;
  {
      static int	busy = FALSE;
  
--- 1440,1446 ----
   * the new width and height of the shell in pixels.
   */
      void
! gui_resize_shell(int pixel_width, int pixel_height)
  {
      static int	busy = FALSE;
  
***************
*** 1520,1526 ****
   * Check if gui_resize_shell() must be called.
   */
      void
! gui_may_resize_shell()
  {
      int		h, w;
  
--- 1509,1515 ----
   * Check if gui_resize_shell() must be called.
   */
      void
! gui_may_resize_shell(void)
  {
      int		h, w;
  
***************
*** 1537,1543 ****
  }
  
      int
! gui_get_shellsize()
  {
      Rows = gui.num_rows;
      Columns = gui.num_cols;
--- 1526,1532 ----
  }
  
      int
! gui_get_shellsize(void)
  {
      Rows = gui.num_rows;
      Columns = gui.num_cols;
***************
*** 1550,1559 ****
   * on the screen.
   */
      void
! gui_set_shellsize(mustset, fit_to_display, direction)
!     int		mustset UNUSED;		/* set by the user */
!     int		fit_to_display;
!     int		direction;		/* RESIZE_HOR, RESIZE_VER */
  {
      int		base_width;
      int		base_height;
--- 1539,1548 ----
   * on the screen.
   */
      void
! gui_set_shellsize(
!     int		mustset UNUSED,		/* set by the user */
!     int		fit_to_display,
!     int		direction)		/* RESIZE_HOR, RESIZE_VER */
  {
      int		base_width;
      int		base_height;
***************
*** 1676,1682 ****
   * Called when Rows and/or Columns has changed.
   */
      void
! gui_new_shellsize()
  {
      gui_reset_scroll_region();
  }
--- 1665,1671 ----
   * Called when Rows and/or Columns has changed.
   */
      void
! gui_new_shellsize(void)
  {
      gui_reset_scroll_region();
  }
***************
*** 1685,1691 ****
   * Make scroll region cover whole screen.
   */
      void
! gui_reset_scroll_region()
  {
      gui.scroll_region_top = 0;
      gui.scroll_region_bot = gui.num_rows - 1;
--- 1674,1680 ----
   * Make scroll region cover whole screen.
   */
      void
! gui_reset_scroll_region(void)
  {
      gui.scroll_region_top = 0;
      gui.scroll_region_bot = gui.num_rows - 1;
***************
*** 1694,1701 ****
  }
  
      void
! gui_start_highlight(mask)
!     int	    mask;
  {
      if (mask > HL_ALL)		    /* highlight code */
  	gui.highlight_mask = mask;
--- 1683,1689 ----
  }
  
      void
! gui_start_highlight(int mask)
  {
      if (mask > HL_ALL)		    /* highlight code */
  	gui.highlight_mask = mask;
***************
*** 1704,1711 ****
  }
  
      void
! gui_stop_highlight(mask)
!     int	    mask;
  {
      if (mask > HL_ALL)		    /* highlight code */
  	gui.highlight_mask = HL_NORMAL;
--- 1692,1698 ----
  }
  
      void
! gui_stop_highlight(int mask)
  {
      if (mask > HL_ALL)		    /* highlight code */
  	gui.highlight_mask = HL_NORMAL;
***************
*** 1718,1728 ****
   * (row2, col2) inclusive.
   */
      void
! gui_clear_block(row1, col1, row2, col2)
!     int	    row1;
!     int	    col1;
!     int	    row2;
!     int	    col2;
  {
      /* Clear the selection if we are about to write over it */
      clip_may_clear_selection(row1, row2);
--- 1705,1715 ----
   * (row2, col2) inclusive.
   */
      void
! gui_clear_block(
!     int	    row1,
!     int	    col1,
!     int	    row2,
!     int	    col2)
  {
      /* Clear the selection if we are about to write over it */
      clip_may_clear_selection(row1, row2);
***************
*** 1740,1754 ****
   * output buffer before calling gui_update_cursor().
   */
      void
! gui_update_cursor_later()
  {
!     OUT_STR(IF_EB("\033|s", ESC_STR "|s"));
  }
  
      void
! gui_write(s, len)
!     char_u	*s;
!     int		len;
  {
      char_u	*p;
      int		arg1 = 0, arg2 = 0;
--- 1727,1741 ----
   * output buffer before calling gui_update_cursor().
   */
      void
! gui_update_cursor_later(void)
  {
!  OUT_STR(IF_EB("\033|s", ESC_STR "|s"));
  }
  
      void
! gui_write(
!     char_u	*s,
!     int		len)
  {
      char_u	*p;
      int		arg1 = 0, arg2 = 0;
***************
*** 1977,1983 ****
   * gui_can_update_cursor() afterwards.
   */
      void
! gui_dont_update_cursor()
  {
      if (gui.in_use)
      {
--- 1964,1970 ----
   * gui_can_update_cursor() afterwards.
   */
      void
! gui_dont_update_cursor(void)
  {
      if (gui.in_use)
      {
***************
*** 1988,1994 ****
  }
  
      void
! gui_can_update_cursor()
  {
      can_update_cursor = TRUE;
      /* No need to update the cursor right now, there is always more output
--- 1975,1981 ----
  }
  
      void
! gui_can_update_cursor(void)
  {
      can_update_cursor = TRUE;
      /* No need to update the cursor right now, there is always more output
***************
*** 1996,2004 ****
  }
  
      static void
! gui_outstr(s, len)
!     char_u  *s;
!     int	    len;
  {
      int	    this_len;
  #ifdef FEAT_MBYTE
--- 1983,1989 ----
  }
  
      static void
! gui_outstr(char_u *s, int len)
  {
      int	    this_len;
  #ifdef FEAT_MBYTE
***************
*** 2060,2070 ****
   * Returns FAIL or OK, just like gui_outstr_nowrap().
   */
      static int
! gui_screenchar(off, flags, fg, bg, back)
!     int		off;	    /* Offset from start of screen */
!     int		flags;
!     guicolor_T	fg, bg;	    /* colors for cursor */
!     int		back;	    /* backup this many chars when using bold trick */
  {
  #ifdef FEAT_MBYTE
      char_u	buf[MB_MAXBYTES + 1];
--- 2045,2056 ----
   * Returns FAIL or OK, just like gui_outstr_nowrap().
   */
      static int
! gui_screenchar(
!     int		off,	    /* Offset from start of screen */
!     int		flags,
!     guicolor_T	fg,	    /* colors for cursor */
!     guicolor_T	bg,	    /* colors for cursor */
!     int		back)	    /* backup this many chars when using bold trick */
  {
  #ifdef FEAT_MBYTE
      char_u	buf[MB_MAXBYTES + 1];
***************
*** 2101,2112 ****
   * as possible to work nicely.  It's a lot faster as well.
   */
      static int
! gui_screenstr(off, len, flags, fg, bg, back)
!     int		off;	    /* Offset from start of screen */
!     int		len;	    /* string length in screen cells */
!     int		flags;
!     guicolor_T	fg, bg;	    /* colors for cursor */
!     int		back;	    /* backup this many chars when using bold trick */
  {
      char_u  *buf;
      int	    outlen = 0;
--- 2087,2099 ----
   * as possible to work nicely.  It's a lot faster as well.
   */
      static int
! gui_screenstr(
!     int		off,	    /* Offset from start of screen */
!     int		len,	    /* string length in screen cells */
!     int		flags,
!     guicolor_T	fg,	    /* colors for cursor */
!     guicolor_T	bg,	    /* colors for cursor */
!     int		back)	    /* backup this many chars when using bold trick */
  {
      char_u  *buf;
      int	    outlen = 0;
***************
*** 2184,2195 ****
   * FAIL (the caller should start drawing "back" chars back).
   */
      int
! gui_outstr_nowrap(s, len, flags, fg, bg, back)
!     char_u	*s;
!     int		len;
!     int		flags;
!     guicolor_T	fg, bg;	    /* colors for cursor */
!     int		back;	    /* backup this many chars when using bold trick */
  {
      long_u	highlight_mask;
      long_u	hl_mask_todo;
--- 2171,2183 ----
   * FAIL (the caller should start drawing "back" chars back).
   */
      int
! gui_outstr_nowrap(
!     char_u	*s,
!     int		len,
!     int		flags,
!     guicolor_T	fg,	    /* colors for cursor */
!     guicolor_T	bg,	    /* colors for cursor */
!     int		back)	    /* backup this many chars when using bold trick */
  {
      long_u	highlight_mask;
      long_u	hl_mask_todo;
***************
*** 2576,2582 ****
   * position.  The character just before it too, for when it was in bold.
   */
      void
! gui_undraw_cursor()
  {
      if (gui.cursor_is_valid)
      {
--- 2564,2570 ----
   * position.  The character just before it too, for when it was in bold.
   */
      void
! gui_undraw_cursor(void)
  {
      if (gui.cursor_is_valid)
      {
***************
*** 2617,2627 ****
  }
  
      void
! gui_redraw(x, y, w, h)
!     int		x;
!     int		y;
!     int		w;
!     int		h;
  {
      int		row1, col1, row2, col2;
  
--- 2605,2615 ----
  }
  
      void
! gui_redraw(
!     int		x,
!     int		y,
!     int		w,
!     int		h)
  {
      int		row1, col1, row2, col2;
  
***************
*** 2650,2661 ****
   * different attributes (may have to be redrawn too).
   */
      int
! gui_redraw_block(row1, col1, row2, col2, flags)
!     int		row1;
!     int		col1;
!     int		row2;
!     int		col2;
!     int		flags;	/* flags for gui_outstr_nowrap() */
  {
      int		old_row, old_col;
      long_u	old_hl_mask;
--- 2638,2649 ----
   * different attributes (may have to be redrawn too).
   */
      int
! gui_redraw_block(
!     int		row1,
!     int		col1,
!     int		row2,
!     int		col2,
!     int		flags)	/* flags for gui_outstr_nowrap() */
  {
      int		old_row, old_col;
      long_u	old_hl_mask;
***************
*** 2814,2822 ****
  }
  
      static void
! gui_delete_lines(row, count)
!     int	    row;
!     int	    count;
  {
      if (count <= 0)
  	return;
--- 2802,2808 ----
  }
  
      static void
! gui_delete_lines(int row, int count)
  {
      if (count <= 0)
  	return;
***************
*** 2844,2852 ****
  }
  
      static void
! gui_insert_lines(row, count)
!     int	    row;
!     int	    count;
  {
      if (count <= 0)
  	return;
--- 2830,2836 ----
  }
  
      static void
! gui_insert_lines(int row, int count)
  {
      if (count <= 0)
  	return;
***************
*** 2880,2887 ****
   * or FAIL otherwise.
   */
      int
! gui_wait_for_chars(wtime)
!     long    wtime;
  {
      int	    retval;
  
--- 2864,2870 ----
   * or FAIL otherwise.
   */
      int
! gui_wait_for_chars(long wtime)
  {
      int	    retval;
  
***************
*** 2956,2965 ****
   * Fill p[4] with mouse coordinates encoded for check_termcode().
   */
      static void
! fill_mouse_coord(p, col, row)
!     char_u	*p;
!     int		col;
!     int		row;
  {
      p[0] = (char_u)(col / 128 + ' ' + 1);
      p[1] = (char_u)(col % 128 + ' ' + 1);
--- 2939,2945 ----
   * Fill p[4] with mouse coordinates encoded for check_termcode().
   */
      static void
! fill_mouse_coord(char_u *p, int col, int row)
  {
      p[0] = (char_u)(col / 128 + ' ' + 1);
      p[1] = (char_u)(col % 128 + ' ' + 1);
***************
*** 2984,2995 ****
   * character.
   */
      void
! gui_send_mouse_event(button, x, y, repeated_click, modifiers)
!     int	    button;
!     int	    x;
!     int	    y;
!     int	    repeated_click;
!     int_u   modifiers;
  {
      static int	    prev_row = 0, prev_col = 0;
      static int	    prev_button = -1;
--- 2964,2975 ----
   * character.
   */
      void
! gui_send_mouse_event(
!     int	    button,
!     int	    x,
!     int	    y,
!     int	    repeated_click,
!     int_u   modifiers)
  {
      static int	    prev_row = 0, prev_col = 0;
      static int	    prev_button = -1;
***************
*** 3299,3308 ****
   * returns column in "*colp" and row as return value;
   */
      int
! gui_xy2colrow(x, y, colp)
!     int		x;
!     int		y;
!     int		*colp;
  {
      int		col = check_col(X_2_COL(x));
      int		row = check_row(Y_2_ROW(y));
--- 3279,3285 ----
   * returns column in "*colp" and row as return value;
   */
      int
! gui_xy2colrow(int x, int y, int *colp)
  {
      int		col = check_col(X_2_COL(x));
      int		row = check_row(Y_2_ROW(y));
***************
*** 3320,3327 ****
   * Callback function for when a menu entry has been selected.
   */
      void
! gui_menu_cb(menu)
!     vimmenu_T *menu;
  {
      char_u  bytes[sizeof(long_u)];
  
--- 3297,3303 ----
   * Callback function for when a menu entry has been selected.
   */
      void
! gui_menu_cb(vimmenu_T *menu)
  {
      char_u  bytes[sizeof(long_u)];
  
***************
*** 3346,3353 ****
   * in p_go.
   */
      void
! gui_init_which_components(oldval)
!     char_u	*oldval UNUSED;
  {
  #ifdef FEAT_MENU
      static int	prev_menu_is_active = -1;
--- 3322,3328 ----
   * in p_go.
   */
      void
! gui_init_which_components(char_u *oldval UNUSED)
  {
  #ifdef FEAT_MENU
      static int	prev_menu_is_active = -1;
***************
*** 3599,3605 ****
   * It may still be hidden if 'showtabline' is zero.
   */
      int
! gui_use_tabline()
  {
      return gui.in_use && vim_strchr(p_go, GO_TABLINE) != NULL;
  }
--- 3574,3580 ----
   * It may still be hidden if 'showtabline' is zero.
   */
      int
! gui_use_tabline(void)
  {
      return gui.in_use && vim_strchr(p_go, GO_TABLINE) != NULL;
  }
***************
*** 3609,3615 ****
   * This uses 'showtabline'.
   */
      static int
! gui_has_tabline()
  {
      if (!gui_use_tabline()
  	    || p_stal == 0
--- 3584,3590 ----
   * This uses 'showtabline'.
   */
      static int
! gui_has_tabline(void)
  {
      if (!gui_use_tabline()
  	    || p_stal == 0
***************
*** 3623,3629 ****
   * This may display/undisplay the tabline and update the labels.
   */
      void
! gui_update_tabline()
  {
      int	    showit = gui_has_tabline();
      int	    shown = gui_mch_showing_tabline();
--- 3598,3604 ----
   * This may display/undisplay the tabline and update the labels.
   */
      void
! gui_update_tabline(void)
  {
      int	    showit = gui_has_tabline();
      int	    shown = gui_mch_showing_tabline();
***************
*** 3651,3659 ****
   * Get the label or tooltip for tab page "tp" into NameBuff[].
   */
      void
! get_tabline_label(tp, tooltip)
!     tabpage_T	*tp;
!     int		tooltip;	/* TRUE: get tooltip */
  {
      int		modified = FALSE;
      char_u	buf[40];
--- 3626,3634 ----
   * Get the label or tooltip for tab page "tp" into NameBuff[].
   */
      void
! get_tabline_label(
!     tabpage_T	*tp,
!     int		tooltip)	/* TRUE: get tooltip */
  {
      int		modified = FALSE;
      char_u	buf[40];
***************
*** 3744,3751 ****
   * that tab page or the cmdline window is open.
   */
      int
! send_tabline_event(nr)
!     int	    nr;
  {
      char_u string[3];
  
--- 3719,3725 ----
   * that tab page or the cmdline window is open.
   */
      int
! send_tabline_event(int nr)
  {
      char_u string[3];
  
***************
*** 3777,3785 ****
   * Send a tabline menu event
   */
      void
! send_tabline_menu_event(tabidx, event)
!     int	    tabidx;
!     int	    event;
  {
      char_u	    string[3];
  
--- 3751,3757 ----
   * Send a tabline menu event
   */
      void
! send_tabline_menu_event(int tabidx, int event)
  {
      char_u	    string[3];
  
***************
*** 3807,3813 ****
   * Remove all scrollbars.  Used before switching to another tab page.
   */
      void
! gui_remove_scrollbars()
  {
      int	    i;
      win_T   *wp;
--- 3779,3785 ----
   * Remove all scrollbars.  Used before switching to another tab page.
   */
      void
! gui_remove_scrollbars(void)
  {
      int	    i;
      win_T   *wp;
***************
*** 3829,3838 ****
  #endif
  
      void
! gui_create_scrollbar(sb, type, wp)
!     scrollbar_T	*sb;
!     int		type;
!     win_T	*wp;
  {
      static int	sbar_ident = 0;
  
--- 3801,3807 ----
  #endif
  
      void
! gui_create_scrollbar(scrollbar_T *sb, int type, win_T *wp)
  {
      static int	sbar_ident = 0;
  
***************
*** 3858,3865 ****
   * Find the scrollbar with the given index.
   */
      scrollbar_T *
! gui_find_scrollbar(ident)
!     long	ident;
  {
      win_T	*wp;
  
--- 3827,3833 ----
   * Find the scrollbar with the given index.
   */
      scrollbar_T *
! gui_find_scrollbar(long ident)
  {
      win_T	*wp;
  
***************
*** 3891,3900 ****
   * are still characters to be processed.
   */
      void
! gui_drag_scrollbar(sb, value, still_dragging)
!     scrollbar_T	*sb;
!     long	value;
!     int		still_dragging;
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
--- 3859,3865 ----
   * are still characters to be processed.
   */
      void
! gui_drag_scrollbar(scrollbar_T *sb, long value, int still_dragging)
  {
  #ifdef FEAT_WINDOWS
      win_T	*wp;
***************
*** 4112,4118 ****
   * Called when something in the window layout has changed.
   */
      void
! gui_may_update_scrollbars()
  {
      if (gui.in_use && starting == 0)
      {
--- 4077,4083 ----
   * Called when something in the window layout has changed.
   */
      void
! gui_may_update_scrollbars(void)
  {
      if (gui.in_use && starting == 0)
      {
***************
*** 4125,4132 ****
  #endif
  
      void
! gui_update_scrollbars(force)
!     int		force;	    /* Force all scrollbars to get updated */
  {
      win_T	*wp;
      scrollbar_T	*sb;
--- 4090,4097 ----
  #endif
  
      void
! gui_update_scrollbars(
!     int		force)	    /* Force all scrollbars to get updated */
  {
      win_T	*wp;
      scrollbar_T	*sb;
***************
*** 4340,4349 ****
   * sometimes.
   */
      static void
! gui_do_scrollbar(wp, which, enable)
!     win_T	*wp;
!     int		which;	    /* SBAR_LEFT or SBAR_RIGHT */
!     int		enable;	    /* TRUE to enable scrollbar */
  {
  #ifdef FEAT_VERTSPLIT
      int		midcol = curwin->w_wincol + curwin->w_width / 2;
--- 4305,4314 ----
   * sometimes.
   */
      static void
! gui_do_scrollbar(
!     win_T	*wp,
!     int		which,	    /* SBAR_LEFT or SBAR_RIGHT */
!     int		enable)	    /* TRUE to enable scrollbar */
  {
  #ifdef FEAT_VERTSPLIT
      int		midcol = curwin->w_wincol + curwin->w_width / 2;
***************
*** 4386,4392 ****
   * or FALSE otherwise.
   */
      int
! gui_do_scroll()
  {
      win_T	*wp, *save_wp;
      int		i;
--- 4351,4357 ----
   * or FALSE otherwise.
   */
      int
! gui_do_scroll(void)
  {
      win_T	*wp, *save_wp;
      int		i;
***************
*** 4498,4505 ****
   * Return length of line "lnum" for horizontal scrolling.
   */
      static colnr_T
! scroll_line_len(lnum)
!     linenr_T	lnum;
  {
      char_u	*p;
      colnr_T	col;
--- 4463,4469 ----
   * Return length of line "lnum" for horizontal scrolling.
   */
      static colnr_T
! scroll_line_len(linenr_T lnum)
  {
      char_u	*p;
      colnr_T	col;
***************
*** 4528,4534 ****
   * by setting 'h' in "guioptions") then the current line number is returned.
   */
      static linenr_T
! gui_find_longest_lnum()
  {
      linenr_T ret = 0;
  
--- 4492,4498 ----
   * by setting 'h' in "guioptions") then the current line number is returned.
   */
      static linenr_T
! gui_find_longest_lnum(void)
  {
      linenr_T ret = 0;
  
***************
*** 4569,4576 ****
  }
  
      static void
! gui_update_horiz_scrollbar(force)
!     int		force;
  {
      long	value, size, max;	/* need 32 bit ints here */
  
--- 4533,4539 ----
  }
  
      static void
! gui_update_horiz_scrollbar(int force)
  {
      long	value, size, max;	/* need 32 bit ints here */
  
***************
*** 4662,4670 ****
   * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.
   */
      int
! gui_do_horiz_scroll(leftcol, compute_longest_lnum)
!     long_u	leftcol;
!     int		compute_longest_lnum;
  {
      /* no wrapping, no scrolling */
      if (curwin->w_p_wrap)
--- 4625,4631 ----
   * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.
   */
      int
! gui_do_horiz_scroll(long_u leftcol, int compute_longest_lnum)
  {
      /* no wrapping, no scrolling */
      if (curwin->w_p_wrap)
***************
*** 4702,4708 ****
   * Check that none of the colors are the same as the background color
   */
      void
! gui_check_colors()
  {
      if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
      {
--- 4663,4669 ----
   * Check that none of the colors are the same as the background color
   */
      void
! gui_check_colors(void)
  {
      if (gui.norm_pixel == gui.back_pixel || gui.norm_pixel == INVALCOLOR)
      {
***************
*** 4713,4728 ****
  }
  
      static void
! gui_set_fg_color(name)
!     char_u	*name;
  {
      gui.norm_pixel = gui_get_color(name);
      hl_set_fg_color_name(vim_strsave(name));
  }
  
      static void
! gui_set_bg_color(name)
!     char_u	*name;
  {
      gui.back_pixel = gui_get_color(name);
      hl_set_bg_color_name(vim_strsave(name));
--- 4674,4687 ----
  }
  
      static void
! gui_set_fg_color(char_u *name)
  {
      gui.norm_pixel = gui_get_color(name);
      hl_set_fg_color_name(vim_strsave(name));
  }
  
      static void
! gui_set_bg_color(char_u *name)
  {
      gui.back_pixel = gui_get_color(name);
      hl_set_bg_color_name(vim_strsave(name));
***************
*** 4733,4740 ****
   * Returns INVALCOLOR and gives an error message when failed.
   */
      guicolor_T
! gui_get_color(name)
!     char_u	*name;
  {
      guicolor_T	t;
  
--- 4692,4698 ----
   * Returns INVALCOLOR and gives an error message when failed.
   */
      guicolor_T
! gui_get_color(char_u *name)
  {
      guicolor_T	t;
  
***************
*** 4755,4762 ****
   * Return the grey value of a color (range 0-255).
   */
      int
! gui_get_lightness(pixel)
!     guicolor_T	pixel;
  {
      long_u	rgb = gui_mch_get_rgb(pixel);
  
--- 4713,4719 ----
   * Return the grey value of a color (range 0-255).
   */
      int
! gui_get_lightness(guicolor_T pixel)
  {
      long_u	rgb = gui_mch_get_rgb(pixel);
  
***************
*** 4767,4773 ****
  
  #if defined(FEAT_GUI_X11) || defined(PROTO)
      void
! gui_new_scrollbar_colors()
  {
      win_T	*wp;
  
--- 4724,4730 ----
  
  #if defined(FEAT_GUI_X11) || defined(PROTO)
      void
! gui_new_scrollbar_colors(void)
  {
      win_T	*wp;
  
***************
*** 4788,4795 ****
   * Call this when focus has changed.
   */
      void
! gui_focus_change(in_focus)
!     int		in_focus;
  {
  /*
   * Skip this code to avoid drawing the cursor when debugging and switching
--- 4745,4751 ----
   * Call this when focus has changed.
   */
      void
! gui_focus_change(int in_focus)
  {
  /*
   * Skip this code to avoid drawing the cursor when debugging and switching
***************
*** 4823,4831 ****
   * Called when the mouse moved (but not when dragging).
   */
      void
! gui_mouse_moved(x, y)
!     int		x;
!     int		y;
  {
      win_T	*wp;
      char_u	st[8];
--- 4779,4785 ----
   * Called when the mouse moved (but not when dragging).
   */
      void
! gui_mouse_moved(int x, int y)
  {
      win_T	*wp;
      char_u	st[8];
***************
*** 4902,4908 ****
   * Called when mouse should be moved to window with focus.
   */
      void
! gui_mouse_correct()
  {
      int		x, y;
      win_T	*wp = NULL;
--- 4856,4862 ----
   * Called when mouse should be moved to window with focus.
   */
      void
! gui_mouse_correct(void)
  {
      int		x, y;
      win_T	*wp = NULL;
***************
*** 4935,4943 ****
   * Find window where the mouse pointer "y" coordinate is in.
   */
      static win_T *
! xy2win(x, y)
!     int		x UNUSED;
!     int		y UNUSED;
  {
  #ifdef FEAT_WINDOWS
      int		row;
--- 4889,4895 ----
   * Find window where the mouse pointer "y" coordinate is in.
   */
      static win_T *
! xy2win(int x UNUSED, int y UNUSED)
  {
  #ifdef FEAT_WINDOWS
      int		row;
***************
*** 4981,4988 ****
   * File names may be given to redefine the args list.
   */
      void
! ex_gui(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
  
--- 4933,4939 ----
   * File names may be given to redefine the args list.
   */
      void
! ex_gui(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
  
***************
*** 5023,5031 ****
   * Callback function for do_in_runtimepath().
   */
      static void
! gfp_setname(fname, cookie)
!     char_u	*fname;
!     void	*cookie;
  {
      char_u	*gfp_buffer = cookie;
  
--- 4974,4980 ----
   * Callback function for do_in_runtimepath().
   */
      static void
! gfp_setname(char_u *fname, void *cookie)
  {
      char_u	*gfp_buffer = cookie;
  
***************
*** 5040,5049 ****
   * Return FAIL for failure and OK if buffer[MAXPATHL] contains the result.
   */
      int
! gui_find_bitmap(name, buffer, ext)
!     char_u	*name;
!     char_u	*buffer;
!     char	*ext;
  {
      if (STRLEN(name) > MAXPATHL - 14)
  	return FAIL;
--- 4989,4995 ----
   * Return FAIL for failure and OK if buffer[MAXPATHL] contains the result.
   */
      int
! gui_find_bitmap(char_u *name, char_u *buffer, char *ext)
  {
      if (STRLEN(name) > MAXPATHL - 14)
  	return FAIL;
***************
*** 5063,5072 ****
   * contains "name".
   */
      void
! gui_find_iconfile(name, buffer, ext)
!     char_u	*name;
!     char_u	*buffer;
!     char	*ext;
  {
      char_u	buf[MAXPATHL + 1];
  
--- 5009,5015 ----
   * contains "name".
   */
      void
! gui_find_iconfile(char_u *name, char_u *buffer, char *ext)
  {
      char_u	buf[MAXPATHL + 1];
  
***************
*** 5079,5085 ****
  
  #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(PROTO)
      void
! display_errors()
  {
      char_u	*p;
  
--- 5022,5028 ----
  
  #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11) || defined(PROTO)
      void
! display_errors(void)
  {
      char_u	*p;
  
***************
*** 5111,5117 ****
   * allow typing on stdin.
   */
      int
! no_console_input()
  {
      return ((!gui.in_use || gui.starting)
  # ifndef NO_CONSOLE
--- 5054,5060 ----
   * allow typing on stdin.
   */
      int
! no_console_input(void)
  {
      return ((!gui.in_use || gui.starting)
  # ifndef NO_CONSOLE
***************
*** 5128,5134 ****
   * Update the current window and the screen.
   */
      void
! gui_update_screen()
  {
  #ifdef FEAT_CONCEAL
      linenr_T	conceal_old_cursor_line = 0;
--- 5071,5077 ----
   * Update the current window and the screen.
   */
      void
! gui_update_screen(void)
  {
  #ifdef FEAT_CONCEAL
      linenr_T	conceal_old_cursor_line = 0;
***************
*** 5199,5208 ****
   * Returns an allocated string.
   */
      char_u *
! get_find_dialog_text(arg, wwordp, mcasep)
!     char_u	*arg;
!     int		*wwordp;	/* return: TRUE if \< \> found */
!     int		*mcasep;	/* return: TRUE if \C found */
  {
      char_u	*text;
  
--- 5142,5151 ----
   * Returns an allocated string.
   */
      char_u *
! get_find_dialog_text(
!     char_u	*arg,
!     int		*wwordp,	/* return: TRUE if \< \> found */
!     int		*mcasep)	/* return: TRUE if \C found */
  {
      char_u	*text;
  
***************
*** 5260,5269 ****
   * Concatenate "text" to grow array "gap", escaping "what" with a backslash.
   */
      static void
! concat_esc(gap, text, what)
!     garray_T	*gap;
!     char_u	*text;
!     int		what;
  {
      while (*text != NUL)
      {
--- 5203,5209 ----
   * Concatenate "text" to grow array "gap", escaping "what" with a backslash.
   */
      static void
! concat_esc(garray_T *gap, char_u *text, int what)
  {
      while (*text != NUL)
      {
***************
*** 5289,5299 ****
   * Return TRUE when something was added to the input buffer.
   */
      int
! gui_do_findrepl(flags, find_text, repl_text, down)
!     int		flags;		/* one of FRD_REPLACE, FRD_FINDNEXT, etc. */
!     char_u	*find_text;
!     char_u	*repl_text;
!     int		down;		/* Search downwards. */
  {
      garray_T	ga;
      int		i;
--- 5229,5239 ----
   * Return TRUE when something was added to the input buffer.
   */
      int
! gui_do_findrepl(
!     int		flags,		/* one of FRD_REPLACE, FRD_FINDNEXT, etc. */
!     char_u	*find_text,
!     char_u	*repl_text,
!     int		down)		/* Search downwards. */
  {
      garray_T	ga;
      int		i;
***************
*** 5422,5430 ****
   * Jump to the window at specified point (x, y).
   */
      static void
! gui_wingoto_xy(x, y)
!     int x;
!     int y;
  {
      int		row = Y_2_ROW(y);
      int		col = X_2_COL(x);
--- 5362,5368 ----
   * Jump to the window at specified point (x, y).
   */
      static void
! gui_wingoto_xy(int x, int y)
  {
      int		row = Y_2_ROW(y);
      int		col = X_2_COL(x);
***************
*** 5446,5457 ****
   * fnames after call this function.
   */
      void
! gui_handle_drop(x, y, modifiers, fnames, count)
!     int		x UNUSED;
!     int		y UNUSED;
!     int_u	modifiers;
!     char_u	**fnames;
!     int		count;
  {
      int		i;
      char_u	*p;
--- 5384,5395 ----
   * fnames after call this function.
   */
      void
! gui_handle_drop(
!     int		x UNUSED,
!     int		y UNUSED,
!     int_u	modifiers,
!     char_u	**fnames,
!     int		count)
  {
      int		i;
      char_u	*p;
*** ../vim-7.4.1206/src/gui_gtk.c	2015-12-29 18:52:33.344054429 +0100
--- src/gui_gtk.c	2016-01-30 16:33:04.158295825 +0100
***************
*** 1988,1995 ****
   * ":helpfind"
   */
      void
! ex_helpfind(eap)
!     exarg_T	*eap UNUSED;
  {
      /* This will fail when menus are not loaded.  Well, it's only for
       * backwards compatibility anyway. */
--- 1988,1994 ----
   * ":helpfind"
   */
      void
! ex_helpfind(exarg_T *eap UNUSED)
  {
      /* This will fail when menus are not loaded.  Well, it's only for
       * backwards compatibility anyway. */
*** ../vim-7.4.1206/src/gui_gtk_x11.c	2016-01-19 17:47:19.774767193 +0100
--- src/gui_gtk_x11.c	2016-01-30 16:33:39.509927460 +0100
***************
*** 571,577 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! gui_mch_free_all()
  {
      vim_free(gui_argv);
  #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
--- 571,577 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! gui_mch_free_all(void)
  {
      vim_free(gui_argv);
  #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
***************
*** 2224,2233 ****
   * GTK tells us that XSMP needs attention
   */
      static gboolean
! local_xsmp_handle_requests(source, condition, data)
!     GIOChannel		*source UNUSED;
!     GIOCondition	condition;
!     gpointer		data;
  {
      if (condition == G_IO_IN)
      {
--- 2224,2233 ----
   * GTK tells us that XSMP needs attention
   */
      static gboolean
! local_xsmp_handle_requests(
!     GIOChannel		*source UNUSED,
!     GIOCondition	condition,
!     gpointer		data)
  {
      if (condition == G_IO_IN)
      {
***************
*** 3070,3077 ****
   * Set the current tab to "nr".  First tab is 1.
   */
      void
! gui_mch_set_curtab(nr)
!     int		nr;
  {
      if (gui.tabline == NULL)
  	return;
--- 3070,3076 ----
   * Set the current tab to "nr".  First tab is 1.
   */
      void
! gui_mch_set_curtab(int nr)
  {
      if (gui.tabline == NULL)
  	return;
***************
*** 3944,3950 ****
   * Return TRUE if the main window is maximized.
   */
      int
! gui_mch_maximized()
  {
      return (gui.mainwin != NULL && gui.mainwin->window != NULL
  	    && (gdk_window_get_state(gui.mainwin->window)
--- 3943,3949 ----
   * Return TRUE if the main window is maximized.
   */
      int
! gui_mch_maximized(void)
  {
      return (gui.mainwin != NULL && gui.mainwin->window != NULL
  	    && (gdk_window_get_state(gui.mainwin->window)
***************
*** 3955,3961 ****
   * Unmaximize the main window
   */
      void
! gui_mch_unmaximize()
  {
      if (gui.mainwin != NULL)
  	gtk_window_unmaximize(GTK_WINDOW(gui.mainwin));
--- 3954,3960 ----
   * Unmaximize the main window
   */
      void
! gui_mch_unmaximize(void)
  {
      if (gui.mainwin != NULL)
  	gtk_window_unmaximize(GTK_WINDOW(gui.mainwin));
***************
*** 3966,3972 ****
   * new Rows and Columns.  This is like resizing the window.
   */
      void
! gui_mch_newfont()
  {
      int w, h;
  
--- 3965,3971 ----
   * new Rows and Columns.  This is like resizing the window.
   */
      void
! gui_mch_newfont(void)
  {
      int w, h;
  
*** ../vim-7.4.1206/src/gui_mac.c	2015-06-09 19:14:18.773373964 +0200
--- src/gui_mac.c	2016-01-30 16:34:07.757633123 +0100
***************
*** 2607,2614 ****
   * the menu that we should display
   */
      void
! gui_mac_handle_contextual_menu(event)
!     EventRecord *event;
  {
  /*
   *  Clone PopUp to use menu
--- 2607,2613 ----
   * the menu that we should display
   */
      void
! gui_mac_handle_contextual_menu(EventRecord *event)
  {
  /*
   *  Clone PopUp to use menu
***************
*** 3697,3704 ****
   * If a font is not going to be used, free its structure.
   */
      void
! gui_mch_free_font(font)
!     GuiFont	font;
  {
      /*
       * Free font when "font" is not 0.
--- 3696,3702 ----
   * If a font is not going to be used, free its structure.
   */
      void
! gui_mch_free_font(GuiFont font)
  {
      /*
       * Free font when "font" is not 0.
***************
*** 6897,6904 ****
   * Set the current tab to "nr".  First tab is 1.
   */
      void
! gui_mch_set_curtab(nr)
!     int		nr;
  {
      DataBrowserItemID item = nr;
      SetDataBrowserSelectedItems(dataBrowser, 1, &item, kDataBrowserItemsAssign);
--- 6895,6901 ----
   * Set the current tab to "nr".  First tab is 1.
   */
      void
! gui_mch_set_curtab(int nr)
  {
      DataBrowserItemID item = nr;
      SetDataBrowserSelectedItems(dataBrowser, 1, &item, kDataBrowserItemsAssign);
*** ../vim-7.4.1206/src/gui_motif.c	2016-01-30 13:53:30.189407662 +0100
--- src/gui_motif.c	2016-01-30 16:38:04.163170672 +0100
***************
*** 118,126 ****
   */
  
      static void
! scroll_cb(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data, call_data;
  {
      scrollbar_T *sb;
      long	value;
--- 118,124 ----
   */
  
      static void
! scroll_cb(Widget w UNUSED, XtPointer client_data, call_data)
  {
      scrollbar_T *sb;
      long	value;
***************
*** 136,145 ****
  
  #ifdef FEAT_GUI_TABLINE
      static void
! tabline_cb(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
!     XtPointer	call_data;
  {
      XmNotebookCallbackStruct *nptr;
  
--- 134,143 ----
  
  #ifdef FEAT_GUI_TABLINE
      static void
! tabline_cb(
!     Widget	w UNUSED,
!     XtPointer	client_data UNUSED,
!     XtPointer	call_data)
  {
      XmNotebookCallbackStruct *nptr;
  
***************
*** 149,158 ****
  }
  
      static void
! tabline_button_cb(w, client_data, call_data)
!     Widget	w;
!     XtPointer	client_data UNUSED;
!     XtPointer	call_data UNUSED;
  {
      int		cmd, tab_idx;
  
--- 147,156 ----
  }
  
      static void
! tabline_button_cb(
!     Widget	w,
!     XtPointer	client_data UNUSED,
!     XtPointer	call_data UNUSED)
  {
      int		cmd, tab_idx;
  
***************
*** 166,174 ****
   * Tabline single mouse click timeout handler
   */
      static void
! motif_tabline_timer_cb (timed_out, interval_id)
!     XtPointer		timed_out;
!     XtIntervalId	*interval_id UNUSED;
  {
      *((int *)timed_out) = TRUE;
  }
--- 164,172 ----
   * Tabline single mouse click timeout handler
   */
      static void
! motif_tabline_timer_cb (
!     XtPointer		timed_out,
!     XtIntervalId	*interval_id UNUSED)
  {
      *((int *)timed_out) = TRUE;
  }
***************
*** 177,185 ****
   * check if the tabline tab scroller is clicked
   */
      static int
! tabline_scroller_clicked(scroller_name, event)
!     char		*scroller_name;
!     XButtonPressedEvent *event;
  {
      Widget	tab_scroll_w;
      Position	pos_x, pos_y;
--- 175,183 ----
   * check if the tabline tab scroller is clicked
   */
      static int
! tabline_scroller_clicked(
!     char		*scroller_name,
!     XButtonPressedEvent *event)
  {
      Widget	tab_scroll_w;
      Position	pos_x, pos_y;
***************
*** 202,212 ****
  }
  
      static void
! tabline_menu_cb(w, closure, e, continue_dispatch)
!     Widget	w;
!     XtPointer	closure UNUSED;
!     XEvent	*e;
!     Boolean	*continue_dispatch UNUSED;
  {
      Widget			tab_w;
      XButtonPressedEvent		*event;
--- 200,210 ----
  }
  
      static void
! tabline_menu_cb(
!     Widget	w,
!     XtPointer	closure UNUSED,
!     XEvent	*e,
!     Boolean	*continue_dispatch UNUSED)
  {
      Widget			tab_w;
      XButtonPressedEvent		*event;
***************
*** 275,283 ****
  }
  
      static void
! tabline_balloon_cb(beval, state)
!     BalloonEval	*beval;
!     int		state UNUSED;
  {
      int		nr;
      tabpage_T	*tp;
--- 273,279 ----
  }
  
      static void
! tabline_balloon_cb(BalloonEval *beval, int state UNUSED)
  {
      int		nr;
      tabpage_T	*tp;
***************
*** 313,322 ****
  static void label_expose(Widget _w, XEvent *_event, Region _region);
  
      static void
! label_expose(_w, _event, _region)
!     Widget	_w;
!     XEvent	*_event;
!     Region	_region;
  {
      GC		    insensitiveGC;
      XmLabelWidget   lw = (XmLabelWidget)_w;
--- 309,315 ----
  static void label_expose(Widget _w, XEvent *_event, Region _region);
  
      static void
! label_expose(Widget _w, XEvent *_event, Region _region)
  {
      GC		    insensitiveGC;
      XmLabelWidget   lw = (XmLabelWidget)_w;
***************
*** 396,402 ****
   * Create all the motif widgets necessary.
   */
      void
! gui_x11_create_widgets()
  {
  #ifdef FEAT_GUI_TABLINE
      Widget	button, scroller;
--- 389,395 ----
   * Create all the motif widgets necessary.
   */
      void
! gui_x11_create_widgets(void)
  {
  #ifdef FEAT_GUI_TABLINE
      Widget	button, scroller;
***************
*** 633,639 ****
   * Called when the GUI is not going to start after all.
   */
      void
! gui_x11_destroy_widgets()
  {
      textArea = NULL;
  #ifdef FEAT_MENU
--- 626,632 ----
   * Called when the GUI is not going to start after all.
   */
      void
! gui_x11_destroy_widgets(void)
  {
      textArea = NULL;
  #ifdef FEAT_MENU
***************
*** 642,652 ****
  }
  
      void
! gui_mch_set_text_area_pos(x, y, w, h)
!     int	    x UNUSED;
!     int	    y UNUSED;
!     int	    w UNUSED;
!     int	    h UNUSED;
  {
  #ifdef FEAT_TOOLBAR
      /* Give keyboard focus to the textArea instead of the toolbar. */
--- 635,645 ----
  }
  
      void
! gui_mch_set_text_area_pos(
!     int	    x UNUSED,
!     int	    y UNUSED,
!     int	    w UNUSED,
!     int	    h UNUSED)
  {
  #ifdef FEAT_TOOLBAR
      /* Give keyboard focus to the textArea instead of the toolbar. */
***************
*** 655,661 ****
  }
  
      void
! gui_x11_set_back_color()
  {
      if (textArea != NULL)
  #if (XmVersion >= 1002)
--- 648,654 ----
  }
  
      void
! gui_x11_set_back_color(void)
  {
      if (textArea != NULL)
  #if (XmVersion >= 1002)
***************
*** 672,679 ****
   * well.
   */
      void
! manage_centered(dialog_child)
!     Widget dialog_child;
  {
      Widget shell = XtParent(dialog_child);
      Window root, child;
--- 665,671 ----
   * well.
   */
      void
! manage_centered(Widget dialog_child)
  {
      Widget shell = XtParent(dialog_child);
      Window root, child;
***************
*** 731,738 ****
   * Encapsulate the way an XmFontList is created.
   */
      XmFontList
! gui_motif_create_fontlist(font)
!     XFontStruct    *font;
  {
      XmFontList font_list;
  
--- 723,729 ----
   * Encapsulate the way an XmFontList is created.
   */
      XmFontList
! gui_motif_create_fontlist(XFontStruct *font)
  {
      XmFontList font_list;
  
***************
*** 753,760 ****
  
  # if ((XmVersion > 1001) && defined(FEAT_XFONTSET)) || defined(PROTO)
      XmFontList
! gui_motif_fontset2fontlist(fontset)
!     XFontSet	*fontset;
  {
      XmFontList font_list;
  
--- 744,750 ----
  
  # if ((XmVersion > 1001) && defined(FEAT_XFONTSET)) || defined(PROTO)
      XmFontList
! gui_motif_fontset2fontlist(XFontSet *fontset)
  {
      XmFontList font_list;
  
***************
*** 788,795 ****
  static int menu_enabled = TRUE;
  
      void
! gui_mch_enable_menu(flag)
!     int	    flag;
  {
      if (flag)
      {
--- 778,784 ----
  static int menu_enabled = TRUE;
  
      void
! gui_mch_enable_menu(int flag)
  {
      if (flag)
      {
***************
*** 900,907 ****
   * Enable or disable mnemonics for the toplevel menus.
   */
      void
! gui_motif_set_mnemonics(enable)
!     int		enable;
  {
      /*
       * Don't enable menu mnemonics when the menu bar is disabled, LessTif
--- 889,895 ----
   * Enable or disable mnemonics for the toplevel menus.
   */
      void
! gui_motif_set_mnemonics(int enable)
  {
      /*
       * Don't enable menu mnemonics when the menu bar is disabled, LessTif
***************
*** 913,920 ****
  }
  
      static void
! do_set_mnemonics(enable)
!     int		enable;
  {
      vimmenu_T	*menu;
  
--- 901,907 ----
  }
  
      static void
! do_set_mnemonics(int enable)
  {
      vimmenu_T	*menu;
  
***************
*** 926,934 ****
  }
  
      void
! gui_mch_add_menu(menu, idx)
!     vimmenu_T	*menu;
!     int		idx;
  {
      XmString	label;
      Widget	shell;
--- 913,919 ----
  }
  
      void
! gui_mch_add_menu(vimmenu_T *menu, int idx)
  {
      XmString	label;
      Widget	shell;
***************
*** 1036,1043 ****
   * Add mnemonic and accelerator text to a menu button.
   */
      static void
! gui_motif_add_actext(menu)
!     vimmenu_T	*menu;
  {
      XmString	label;
  
--- 1021,1027 ----
   * Add mnemonic and accelerator text to a menu button.
   */
      static void
! gui_motif_add_actext(vimmenu_T *menu)
  {
      XmString	label;
  
***************
*** 1053,1060 ****
  }
  
      void
! gui_mch_toggle_tearoffs(enable)
!     int		enable;
  {
  #if (XmVersion >= 1002)
      if (enable)
--- 1037,1043 ----
  }
  
      void
! gui_mch_toggle_tearoffs(int enable)
  {
  #if (XmVersion >= 1002)
      if (enable)
***************
*** 1072,1079 ****
   * tearoff widget.
   */
      static void
! toggle_tearoff(wid)
!     Widget	wid;
  {
      Widget	w;
  
--- 1055,1061 ----
   * tearoff widget.
   */
      static void
! toggle_tearoff(Widget wid)
  {
      Widget	w;
  
***************
*** 1084,1091 ****
  }
  
      static void
! gui_mch_recurse_tearoffs(menu)
!     vimmenu_T	*menu;
  {
      while (menu != NULL)
      {
--- 1066,1072 ----
  }
  
      static void
! gui_mch_recurse_tearoffs(vimmenu_T *menu)
  {
      while (menu != NULL)
      {
***************
*** 1101,1107 ****
  #endif
  
      int
! gui_mch_text_area_extra_height()
  {
      Dimension	shadowHeight;
  
--- 1082,1088 ----
  #endif
  
      int
! gui_mch_text_area_extra_height(void)
  {
      Dimension	shadowHeight;
  
***************
*** 1115,1122 ****
   * there are several rows, and/or some characters extend higher or lower.
   */
      void
! gui_mch_compute_menu_height(id)
!     Widget	id;		    /* can be NULL when deleting menu */
  {
      Dimension	y, maxy;
      Dimension	margin, shadow;
--- 1096,1103 ----
   * there are several rows, and/or some characters extend higher or lower.
   */
      void
! gui_mch_compute_menu_height(
!     Widget	id)		    /* can be NULL when deleting menu */
  {
      Dimension	y, maxy;
      Dimension	margin, shadow;
***************
*** 1200,1207 ****
   * Read an Xpm file.  Return OK or FAIL.
   */
      static int
! check_xpm(path)
!     char_u	*path;
  {
      XpmAttributes attrs;
      int		status;
--- 1181,1187 ----
   * Read an Xpm file.  Return OK or FAIL.
   */
      static int
! check_xpm(char_u *path)
  {
      XpmAttributes attrs;
      int		status;
***************
*** 1229,1237 ****
   * Return a blank pixmap if it fails.
   */
      static char **
! get_toolbar_pixmap(menu, fname)
!     vimmenu_T	*menu;
!     char	**fname;
  {
      char_u	buf[MAXPATHL];		/* buffer storing expanded pathname */
      char	**xpm = NULL;		/* xpm array */
--- 1209,1215 ----
   * Return a blank pixmap if it fails.
   */
      static char **
! get_toolbar_pixmap(vimmenu_T *menu, char **fname)
  {
      char_u	buf[MAXPATHL];		/* buffer storing expanded pathname */
      char	**xpm = NULL;		/* xpm array */
***************
*** 1272,1281 ****
   * Add arguments for the toolbar pixmap to a menu item.
   */
      static int
! add_pixmap_args(menu, args, n)
!     vimmenu_T	*menu;
!     Arg		*args;
!     int		n;
  {
      vim_free(menu->xpm_fname);
      menu->xpm = get_toolbar_pixmap(menu, &menu->xpm_fname);
--- 1250,1256 ----
   * Add arguments for the toolbar pixmap to a menu item.
   */
      static int
! add_pixmap_args(vimmenu_T *menu, Arg *args, int n)
  {
      vim_free(menu->xpm_fname);
      menu->xpm = get_toolbar_pixmap(menu, &menu->xpm_fname);
***************
*** 1297,1305 ****
  #endif /* FEAT_TOOLBAR */
  
      void
! gui_mch_add_menu_item(menu, idx)
!     vimmenu_T	*menu;
!     int		idx;
  {
      XmString	label;
      vimmenu_T	*parent = menu->parent;
--- 1272,1278 ----
  #endif /* FEAT_TOOLBAR */
  
      void
! gui_mch_add_menu_item(vimmenu_T *menu, int idx)
  {
      XmString	label;
      vimmenu_T	*parent = menu->parent;
***************
*** 1457,1464 ****
   * there exists a popup menu but it isn't managed.
   */
      void
! gui_motif_update_mousemodel(menu)
!     vimmenu_T	*menu;
  {
      int		idx = 0;
  
--- 1430,1436 ----
   * there exists a popup menu but it isn't managed.
   */
      void
! gui_motif_update_mousemodel(vimmenu_T *menu)
  {
      int		idx = 0;
  
***************
*** 1500,1506 ****
  #endif
  
      void
! gui_mch_new_menu_colors()
  {
      if (menuBar == (Widget)0)
  	return;
--- 1472,1478 ----
  #endif
  
      void
! gui_mch_new_menu_colors(void)
  {
      if (menuBar == (Widget)0)
  	return;
***************
*** 1514,1520 ****
  }
  
      void
! gui_mch_new_menu_font()
  {
      if (menuBar == (Widget)0)
  	return;
--- 1486,1492 ----
  }
  
      void
! gui_mch_new_menu_font(void)
  {
      if (menuBar == (Widget)0)
  	return;
***************
*** 1539,1545 ****
  
  #if defined(FEAT_BEVAL) || defined(PROTO)
      void
! gui_mch_new_tooltip_font()
  {
  # ifdef FEAT_TOOLBAR
      vimmenu_T   *menu;
--- 1511,1517 ----
  
  #if defined(FEAT_BEVAL) || defined(PROTO)
      void
! gui_mch_new_tooltip_font(void)
  {
  # ifdef FEAT_TOOLBAR
      vimmenu_T   *menu;
***************
*** 1554,1560 ****
  }
  
      void
! gui_mch_new_tooltip_colors()
  {
  # ifdef FEAT_TOOLBAR
      vimmenu_T   *toolbar;
--- 1526,1532 ----
  }
  
      void
! gui_mch_new_tooltip_colors(void)
  {
  # ifdef FEAT_TOOLBAR
      vimmenu_T   *toolbar;
***************
*** 1570,1578 ****
  #endif
  
      static void
! submenu_change(menu, colors)
!     vimmenu_T	*menu;
!     int		colors;		/* TRUE for colors, FALSE for font */
  {
      vimmenu_T	*mp;
  
--- 1542,1550 ----
  #endif
  
      static void
! submenu_change(
!     vimmenu_T	*menu,
!     int		colors)		/* TRUE for colors, FALSE for font */
  {
      vimmenu_T	*mp;
  
***************
*** 1650,1657 ****
   * Destroy the machine specific menu widget.
   */
      void
! gui_mch_destroy_menu(menu)
!     vimmenu_T	*menu;
  {
      /* Please be sure to destroy the parent widget first (i.e. menu->id).
       * On the other hand, problems have been reported that the submenu must be
--- 1622,1628 ----
   * Destroy the machine specific menu widget.
   */
      void
! gui_mch_destroy_menu(vimmenu_T *menu)
  {
      /* Please be sure to destroy the parent widget first (i.e. menu->id).
       * On the other hand, problems have been reported that the submenu must be
***************
*** 1708,1715 ****
  }
  
      void
! gui_mch_show_popupmenu(menu)
!     vimmenu_T *menu UNUSED;
  {
  #ifdef MOTIF_POPUP
      XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
--- 1679,1685 ----
  }
  
      void
! gui_mch_show_popupmenu(vimmenu_T *menu UNUSED)
  {
  #ifdef MOTIF_POPUP
      XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
***************
*** 1723,1729 ****
   * Set the menu and scrollbar colors to their default values.
   */
      void
! gui_mch_def_colors()
  {
      if (gui.in_use)
      {
--- 1693,1699 ----
   * Set the menu and scrollbar colors to their default values.
   */
      void
! gui_mch_def_colors(void)
  {
      if (gui.in_use)
      {
***************
*** 1748,1758 ****
   */
  
      void
! gui_mch_set_scrollbar_thumb(sb, val, size, max)
!     scrollbar_T *sb;
!     long	val;
!     long	size;
!     long	max;
  {
      if (sb->id != (Widget)0)
  	XtVaSetValues(sb->id,
--- 1718,1728 ----
   */
  
      void
! gui_mch_set_scrollbar_thumb(
!     scrollbar_T *sb,
!     long	val,
!     long	size,
!     long	max)
  {
      if (sb->id != (Widget)0)
  	XtVaSetValues(sb->id,
***************
*** 1764,1775 ****
  }
  
      void
! gui_mch_set_scrollbar_pos(sb, x, y, w, h)
!     scrollbar_T *sb;
!     int		x;
!     int		y;
!     int		w;
!     int		h;
  {
      if (sb->id != (Widget)0)
      {
--- 1734,1745 ----
  }
  
      void
! gui_mch_set_scrollbar_pos(
!     scrollbar_T *sb,
!     int		x,
!     int		y,
!     int		w,
!     int		h)
  {
      if (sb->id != (Widget)0)
      {
***************
*** 1798,1806 ****
  }
  
      void
! gui_mch_enable_scrollbar(sb, flag)
!     scrollbar_T *sb;
!     int		flag;
  {
      Arg		args[16];
      int		n;
--- 1768,1774 ----
  }
  
      void
! gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)
  {
      Arg		args[16];
      int		n;
***************
*** 1855,1863 ****
  }
  
      void
! gui_mch_create_scrollbar(sb, orient)
!     scrollbar_T *sb;
!     int		orient;	/* SBAR_VERT or SBAR_HORIZ */
  {
      Arg		args[16];
      int		n;
--- 1823,1831 ----
  }
  
      void
! gui_mch_create_scrollbar(
!     scrollbar_T *sb,
!     int		orient)	/* SBAR_VERT or SBAR_HORIZ */
  {
      Arg		args[16];
      int		n;
***************
*** 1913,1920 ****
  
  #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
! gui_mch_destroy_scrollbar(sb)
!     scrollbar_T *sb;
  {
      if (sb->id != (Widget)0)
  	XtDestroyWidget(sb->id);
--- 1881,1887 ----
  
  #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
! gui_mch_destroy_scrollbar(scrollbar_T *sb)
  {
      if (sb->id != (Widget)0)
  	XtDestroyWidget(sb->id);
***************
*** 1922,1929 ****
  #endif
  
      void
! gui_mch_set_scrollbar_colors(sb)
!     scrollbar_T *sb;
  {
      if (sb->id != (Widget)0)
      {
--- 1889,1895 ----
  #endif
  
      void
! gui_mch_set_scrollbar_colors(scrollbar_T *sb)
  {
      if (sb->id != (Widget)0)
      {
***************
*** 1957,1963 ****
   */
  
      Window
! gui_x11_get_wid()
  {
      return(XtWindow(textArea));
  }
--- 1923,1929 ----
   */
  
      Window
! gui_x11_get_wid(void)
  {
      return(XtWindow(textArea));
  }
***************
*** 2130,2137 ****
   * Use the 'guifont' or 'guifontset' as a fontlist for a dialog widget.
   */
      static void
! set_fontlist(id)
!     Widget id;
  {
      XmFontList fl;
  
--- 2096,2102 ----
   * Use the 'guifont' or 'guifontset' as a fontlist for a dialog widget.
   */
      static void
! set_fontlist(Widget id)
  {
      XmFontList fl;
  
***************
*** 2211,2221 ****
   */
  static void set_predefined_label(Widget parent, String name, char *new_label);
  
! static void
! set_predefined_label(parent, name, new_label)
!     Widget  parent;
!     String  name;
!     char    *new_label;
  {
      XmString	str;
      Widget	w;
--- 2176,2183 ----
   */
  static void set_predefined_label(Widget parent, String name, char *new_label);
  
!     static void
! set_predefined_label(Widget parent, String name, char *new_label)
  {
      XmString	str;
      Widget	w;
***************
*** 2258,2267 ****
      gui_motif_menu_fontlist(w);
  }
  
! static void
! set_predefined_fontlist(parent, name)
!     Widget parent;
!     String name;
  {
      Widget w;
      w = XtNameToWidget(parent, name);
--- 2220,2227 ----
      gui_motif_menu_fontlist(w);
  }
  
!     static void
! set_predefined_fontlist(Widget parent, String name)
  {
      Widget w;
      w = XtNameToWidget(parent, name);
***************
*** 2277,2289 ****
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
      char_u *
! gui_mch_browse(saving, title, dflt, ext, initdir, filter)
!     int		saving UNUSED;	/* select file to write */
!     char_u	*title;		/* title for the window */
!     char_u	*dflt;		/* default name */
!     char_u	*ext UNUSED;	/* not used (extension added) */
!     char_u	*initdir;	/* initial directory, NULL for current dir */
!     char_u	*filter;	/* file name filter */
  {
      char_u	dirbuf[MAXPATHL];
      char_u	dfltbuf[MAXPATHL];
--- 2237,2249 ----
   * Returns the selected name in allocated memory, or NULL for Cancel.
   */
      char_u *
! gui_mch_browse(
!     int		saving UNUSED,	/* select file to write */
!     char_u	*title,		/* title for the window */
!     char_u	*dflt,		/* default name */
!     char_u	*ext UNUSED,	/* not used (extension added) */
!     char_u	*initdir,	/* initial directory, NULL for current dir */
!     char_u	*filter)	/* file name filter */
  {
      char_u	dirbuf[MAXPATHL];
      char_u	dfltbuf[MAXPATHL];
***************
*** 2402,2411 ****
   * Process callback from Dialog cancel actions.
   */
      static void
! DialogCancelCB(w, client_data, call_data)
!     Widget	w UNUSED;		/*  widget id		*/
!     XtPointer	client_data UNUSED;	/*  data from application   */
!     XtPointer	call_data UNUSED;	/*  data from widget class  */
  {
      if (browse_fname != NULL)
      {
--- 2362,2371 ----
   * Process callback from Dialog cancel actions.
   */
      static void
! DialogCancelCB(
!     Widget	w UNUSED,		/*  widget id		*/
!     XtPointer	client_data UNUSED,	/*  data from application   */
!     XtPointer	call_data UNUSED)	/*  data from widget class  */
  {
      if (browse_fname != NULL)
      {
***************
*** 2419,2428 ****
   * Process callback from Dialog actions.
   */
      static void
! DialogAcceptCB(w, client_data, call_data)
!     Widget	w UNUSED;		/*  widget id		*/
!     XtPointer	client_data UNUSED;	/*  data from application   */
!     XtPointer	call_data;		/*  data from widget class  */
  {
      XmFileSelectionBoxCallbackStruct *fcb;
  
--- 2379,2388 ----
   * Process callback from Dialog actions.
   */
      static void
! DialogAcceptCB(
!     Widget	w UNUSED,		/*  widget id		*/
!     XtPointer	client_data UNUSED,	/*  data from application   */
!     XtPointer	call_data)		/*  data from widget class  */
  {
      XmFileSelectionBoxCallbackStruct *fcb;
  
***************
*** 2454,2464 ****
   * hitting the "OK" button, ESC like "Cancel".
   */
      static void
! keyhit_callback(w, client_data, event, cont)
!     Widget		w;
!     XtPointer		client_data UNUSED;
!     XEvent		*event;
!     Boolean		*cont UNUSED;
  {
      char	buf[2];
      KeySym	key_sym;
--- 2414,2424 ----
   * hitting the "OK" button, ESC like "Cancel".
   */
      static void
! keyhit_callback(
!     Widget		w,
!     XtPointer		client_data UNUSED,
!     XEvent		*event,
!     Boolean		*cont UNUSED)
  {
      char	buf[2];
      KeySym	key_sym;
***************
*** 2476,2485 ****
  }
  
      static void
! butproc(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      dialogStatus = (int)(long)client_data + 1;
  }
--- 2436,2445 ----
  }
  
      static void
! butproc(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      dialogStatus = (int)(long)client_data + 1;
  }
***************
*** 2489,2500 ****
  static Widget create_pixmap_label(Widget parent, String name, char **data, ArgList args, Cardinal arg);
  
      static Widget
! create_pixmap_label(parent, name, data, args, arg)
!     Widget	parent;
!     String	name;
!     char	**data;
!     ArgList	args;
!     Cardinal	arg;
  {
      Widget		label;
      Display		*dsp;
--- 2449,2460 ----
  static Widget create_pixmap_label(Widget parent, String name, char **data, ArgList args, Cardinal arg);
  
      static Widget
! create_pixmap_label(
!     Widget	parent,
!     String	name,
!     char	**data,
!     ArgList	args,
!     Cardinal	arg)
  {
      Widget		label;
      Display		*dsp;
***************
*** 2552,2565 ****
  #endif
  
      int
! gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield, ex_cmd)
!     int		type UNUSED;
!     char_u	*title;
!     char_u	*message;
!     char_u	*button_names;
!     int		dfltbutton;
!     char_u	*textfield;		/* buffer of size IOSIZE */
!     int		ex_cmd UNUSED;
  {
      char_u		*buts;
      char_u		*p, *next;
--- 2512,2525 ----
  #endif
  
      int
! gui_mch_dialog(
!     int		type UNUSED,
!     char_u	*title,
!     char_u	*message,
!     char_u	*button_names,
!     int		dfltbutton,
!     char_u	*textfield,		/* buffer of size IOSIZE */
!     int		ex_cmd UNUSED)
  {
      char_u		*buts;
      char_u		*p, *next;
***************
*** 2927,2933 ****
  #if defined(FEAT_FOOTER) || defined(PROTO)
  
      static int
! gui_mch_compute_footer_height()
  {
      Dimension	height;		    /* total Toolbar height */
      Dimension	top;		    /* XmNmarginTop */
--- 2887,2893 ----
  #if defined(FEAT_FOOTER) || defined(PROTO)
  
      static int
! gui_mch_compute_footer_height(void)
  {
      Dimension	height;		    /* total Toolbar height */
      Dimension	top;		    /* XmNmarginTop */
***************
*** 2945,2952 ****
  }
  
      void
! gui_mch_enable_footer(showit)
!     int		showit;
  {
      if (showit)
      {
--- 2905,2911 ----
  }
  
      void
! gui_mch_enable_footer(int showit)
  {
      if (showit)
      {
***************
*** 2962,2969 ****
  }
  
      void
! gui_mch_set_footer(s)
!     char_u	*s;
  {
      XmString	xms;
  
--- 2921,2927 ----
  }
  
      void
! gui_mch_set_footer(char_u *s)
  {
      XmString	xms;
  
***************
*** 3135,3148 ****
   * input go to the editor window, not the button
   */
      static void
! reset_focus()
  {
      if (textArea != NULL)
  	XmProcessTraversal(textArea, XmTRAVERSE_CURRENT);
  }
  
      int
! gui_mch_compute_toolbar_height()
  {
      Dimension	borders;
      Dimension	height;		    /* total Toolbar height */
--- 3093,3106 ----
   * input go to the editor window, not the button
   */
      static void
! reset_focus(void)
  {
      if (textArea != NULL)
  	XmProcessTraversal(textArea, XmTRAVERSE_CURRENT);
  }
  
      int
! gui_mch_compute_toolbar_height(void)
  {
      Dimension	borders;
      Dimension	height;		    /* total Toolbar height */
***************
*** 3189,3200 ****
  }
  
      void
! motif_get_toolbar_colors(bgp, fgp, bsp, tsp, hsp)
!     Pixel       *bgp;
!     Pixel       *fgp;
!     Pixel       *bsp;
!     Pixel       *tsp;
!     Pixel       *hsp;
  {
      XtVaGetValues(toolBar,
  	    XmNbackground, bgp,
--- 3147,3158 ----
  }
  
      void
! motif_get_toolbar_colors(
!     Pixel       *bgp,
!     Pixel       *fgp,
!     Pixel       *bsp,
!     Pixel       *tsp,
!     Pixel       *hsp)
  {
      XtVaGetValues(toolBar,
  	    XmNbackground, bgp,
***************
*** 3212,3222 ****
   * get implemented and the user will have a choice.
   */
      static void
! toolbarbutton_enter_cb(w, client_data, event, cont)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XEvent	*event UNUSED;
!     Boolean	*cont UNUSED;
  {
      vimmenu_T	*menu = (vimmenu_T *) client_data;
  
--- 3170,3180 ----
   * get implemented and the user will have a choice.
   */
      static void
! toolbarbutton_enter_cb(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XEvent	*event UNUSED,
!     Boolean	*cont UNUSED)
  {
      vimmenu_T	*menu = (vimmenu_T *) client_data;
  
***************
*** 3228,3238 ****
  }
  
      static void
! toolbarbutton_leave_cb(w, client_data, event, cont)
!     Widget	w UNUSED;
!     XtPointer	client_data UNUSED;
!     XEvent	*event UNUSED;
!     Boolean	*cont UNUSED;
  {
      gui_mch_set_footer((char_u *) "");
  }
--- 3186,3196 ----
  }
  
      static void
! toolbarbutton_leave_cb(
!     Widget	w UNUSED,
!     XtPointer	client_data UNUSED,
!     XEvent	*event UNUSED,
!     Boolean	*cont UNUSED)
  {
      gui_mch_set_footer((char_u *) "");
  }
***************
*** 3413,3420 ****
   * Set the current tab to "nr".  First tab is 1.
   */
      void
! gui_mch_set_curtab(nr)
!     int		nr;
  {
      int		currentpage;
  
--- 3371,3377 ----
   * Set the current tab to "nr".  First tab is 1.
   */
      void
! gui_mch_set_curtab(int nr)
  {
      int		currentpage;
  
***************
*** 3431,3438 ****
   * Set the colors of Widget "id" to the menu colors.
   */
      static void
! gui_motif_menu_colors(id)
!     Widget  id;
  {
      if (gui.menu_bg_pixel != INVALCOLOR)
  #if (XmVersion >= 1002)
--- 3388,3394 ----
   * Set the colors of Widget "id" to the menu colors.
   */
      static void
! gui_motif_menu_colors(Widget id)
  {
      if (gui.menu_bg_pixel != INVALCOLOR)
  #if (XmVersion >= 1002)
***************
*** 3448,3455 ****
   * Set the colors of Widget "id" to the scrollbar colors.
   */
      static void
! gui_motif_scroll_colors(id)
!     Widget  id;
  {
      if (gui.scroll_bg_pixel != INVALCOLOR)
  #if (XmVersion >= 1002)
--- 3404,3410 ----
   * Set the colors of Widget "id" to the scrollbar colors.
   */
      static void
! gui_motif_scroll_colors(Widget id)
  {
      if (gui.scroll_bg_pixel != INVALCOLOR)
  #if (XmVersion >= 1002)
***************
*** 3465,3472 ****
   * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
   */
      void
! gui_motif_menu_fontlist(id)
!     Widget  id UNUSED;
  {
  #ifdef FEAT_MENU
  #ifdef FONTSET_ALWAYS
--- 3420,3426 ----
   * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
   */
      void
! gui_motif_menu_fontlist(Widget id UNUSED)
  {
  #ifdef FEAT_MENU
  #ifdef FONTSET_ALWAYS
***************
*** 3548,3557 ****
  static void find_replace_dialog_create(char_u *entry_text, int do_replace);
  
      static void
! find_replace_destroy_callback(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
--- 3502,3511 ----
  static void find_replace_dialog_create(char_u *entry_text, int do_replace);
  
      static void
! find_replace_destroy_callback(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
***************
*** 3561,3570 ****
  }
  
      static void
! find_replace_dismiss_callback(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
--- 3515,3524 ----
  }
  
      static void
! find_replace_dismiss_callback(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      SharedFindReplace *cd = (SharedFindReplace *)client_data;
  
***************
*** 3573,3591 ****
  }
  
      static void
! entry_activate_callback(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
  }
  
      static void
! find_replace_callback(w, client_data, call_data)
!     Widget	w UNUSED;
!     XtPointer	client_data;
!     XtPointer	call_data UNUSED;
  {
      long_u	flags = (long_u)client_data;
      char	*find_text, *repl_text;
--- 3527,3545 ----
  }
  
      static void
! entry_activate_callback(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
  }
  
      static void
! find_replace_callback(
!     Widget	w UNUSED,
!     XtPointer	client_data,
!     XtPointer	call_data UNUSED)
  {
      long_u	flags = (long_u)client_data;
      char	*find_text, *repl_text;
***************
*** 3636,3645 ****
  }
  
      static void
! find_replace_keypress(w, frdp, event)
!     Widget		w UNUSED;
!     SharedFindReplace	*frdp;
!     XKeyEvent		*event;
  {
      KeySym keysym;
  
--- 3590,3599 ----
  }
  
      static void
! find_replace_keypress(
!     Widget		w UNUSED,
!     SharedFindReplace	*frdp,
!     XKeyEvent		*event)
  {
      KeySym keysym;
  
***************
*** 3654,3662 ****
  }
  
      static void
! set_label(w, label)
!     Widget w;
!     char *label;
  {
      XmString	str;
      char_u	*p, *next;
--- 3608,3614 ----
  }
  
      static void
! set_label(Widget w, char *label)
  {
      XmString	str;
      char_u	*p, *next;
***************
*** 3696,3704 ****
  }
  
      static void
! find_replace_dialog_create(arg, do_replace)
!     char_u	*arg;
!     int		do_replace;
  {
      SharedFindReplace	*frdp;
      Widget		separator;
--- 3648,3654 ----
  }
  
      static void
! find_replace_dialog_create(char_u *arg, int do_replace)
  {
      SharedFindReplace	*frdp;
      Widget		separator;
***************
*** 4050,4057 ****
  }
  
     void
! gui_mch_find_dialog(eap)
!     exarg_T	*eap;
  {
      if (!gui.in_use)
  	return;
--- 4000,4006 ----
  }
  
     void
! gui_mch_find_dialog(exarg_T *eap)
  {
      if (!gui.in_use)
  	return;
***************
*** 4061,4068 ****
  
  
      void
! gui_mch_replace_dialog(eap)
!     exarg_T	*eap;
  {
      if (!gui.in_use)
  	return;
--- 4010,4016 ----
  
  
      void
! gui_mch_replace_dialog(exarg_T *eap)
  {
      if (!gui.in_use)
  	return;
*** ../vim-7.4.1206/src/version.c	2016-01-30 15:52:42.579439439 +0100
--- src/version.c	2016-01-30 15:53:36.034885637 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1207,
  /**/

-- 
From "know your smileys":
 :----}  You lie like Pinocchio

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
