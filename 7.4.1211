To: vim_dev@googlegroups.com
Subject: Patch 7.4.1211
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1211
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/misc1.c, src/misc2.c, src/move.c, src/netbeans.c,
            src/normal.c, src/ops.c, src/option.c


*** ../vim-7.4.1210/src/misc1.c	2016-01-29 22:36:41.233047606 +0100
--- src/misc1.c	2016-01-30 19:01:39.433638558 +0100
***************
*** 30,36 ****
   * Count the size (in window cells) of the indent in the current line.
   */
      int
! get_indent()
  {
      return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);
  }
--- 30,36 ----
   * Count the size (in window cells) of the indent in the current line.
   */
      int
! get_indent(void)
  {
      return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);
  }
***************
*** 39,46 ****
   * Count the size (in window cells) of the indent in line "lnum".
   */
      int
! get_indent_lnum(lnum)
!     linenr_T	lnum;
  {
      return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);
  }
--- 39,45 ----
   * Count the size (in window cells) of the indent in line "lnum".
   */
      int
! get_indent_lnum(linenr_T lnum)
  {
      return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);
  }
***************
*** 51,59 ****
   * "buf".
   */
      int
! get_indent_buf(buf, lnum)
!     buf_T	*buf;
!     linenr_T	lnum;
  {
      return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);
  }
--- 50,56 ----
   * "buf".
   */
      int
! get_indent_buf(buf_T *buf, linenr_T lnum)
  {
      return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);
  }
***************
*** 64,73 ****
   * 'tabstop' at "ts"
   */
      int
! get_indent_str(ptr, ts, list)
!     char_u	*ptr;
!     int		ts;
!     int		list; /* if TRUE, count only screen size for tabs */
  {
      int		count = 0;
  
--- 61,70 ----
   * 'tabstop' at "ts"
   */
      int
! get_indent_str(
!     char_u	*ptr,
!     int		ts,
!     int		list) /* if TRUE, count only screen size for tabs */
  {
      int		count = 0;
  
***************
*** 101,109 ****
   * Returns TRUE if the line was changed.
   */
      int
! set_indent(size, flags)
!     int		size;		    /* measured in spaces */
!     int		flags;
  {
      char_u	*p;
      char_u	*newline;
--- 98,106 ----
   * Returns TRUE if the line was changed.
   */
      int
! set_indent(
!     int		size,		    /* measured in spaces */
!     int		flags)
  {
      char_u	*p;
      char_u	*newline;
***************
*** 338,346 ****
   * Returns TRUE if the line was changed.
   */
      static int
! copy_indent(size, src)
!     int		size;
!     char_u	*src;
  {
      char_u	*p = NULL;
      char_u	*line = NULL;
--- 335,341 ----
   * Returns TRUE if the line was changed.
   */
      static int
! copy_indent(int size, char_u *src)
  {
      char_u	*p = NULL;
      char_u	*line = NULL;
***************
*** 442,449 ****
   * Since a pattern is used it can actually handle more than numbers.
   */
      int
! get_number_indent(lnum)
!     linenr_T	lnum;
  {
      colnr_T	col;
      pos_T	pos;
--- 437,443 ----
   * Since a pattern is used it can actually handle more than numbers.
   */
      int
! get_number_indent(linenr_T lnum)
  {
      colnr_T	col;
      pos_T	pos;
***************
*** 491,499 ****
   * necessarily always the current one.
   */
      int
! get_breakindent_win(wp, line)
!     win_T	*wp;
!     char_u	*line; /* start of the line */
  {
      static int	    prev_indent = 0;  /* cached indent value */
      static long	    prev_ts     = 0L; /* cached tabstop value */
--- 485,493 ----
   * necessarily always the current one.
   */
      int
! get_breakindent_win(
!     win_T	*wp,
!     char_u	*line) /* start of the line */
  {
      static int	    prev_indent = 0;  /* cached indent value */
      static long	    prev_ts     = 0L; /* cached tabstop value */
***************
*** 547,554 ****
   * Return TRUE if the string "line" starts with a word from 'cinwords'.
   */
      static int
! cin_is_cinword(line)
!     char_u	*line;
  {
      char_u	*cinw;
      char_u	*cinw_buf;
--- 541,547 ----
   * Return TRUE if the string "line" starts with a word from 'cinwords'.
   */
      static int
! cin_is_cinword(char_u *line)
  {
      char_u	*cinw;
      char_u	*cinw_buf;
***************
*** 598,607 ****
   * Return TRUE for success, FALSE for failure
   */
      int
! open_line(dir, flags, second_line_indent)
!     int		dir;		/* FORWARD or BACKWARD */
!     int		flags;
!     int		second_line_indent;
  {
      char_u	*saved_line;		/* copy of the original line */
      char_u	*next_line = NULL;	/* copy of the next line */
--- 591,600 ----
   * Return TRUE for success, FALSE for failure
   */
      int
! open_line(
!     int		dir,		/* FORWARD or BACKWARD */
!     int		flags,
!     int		second_line_indent)
  {
      char_u	*saved_line;		/* copy of the original line */
      char_u	*next_line = NULL;	/* copy of the next line */
***************
*** 1662,1672 ****
   * length.
   */
      int
! get_leader_len(line, flags, backward, include_space)
!     char_u	*line;
!     char_u	**flags;
!     int		backward;
!     int		include_space;
  {
      int		i, j;
      int		result;
--- 1655,1665 ----
   * length.
   */
      int
! get_leader_len(
!     char_u	*line,
!     char_u	**flags,
!     int		backward,
!     int		include_space)
  {
      int		i, j;
      int		result;
***************
*** 1807,1815 ****
   * recognized comment leader.
   */
      int
! get_last_leader_offset(line, flags)
!     char_u	*line;
!     char_u	**flags;
  {
      int		result = -1;
      int		i, j;
--- 1800,1806 ----
   * recognized comment leader.
   */
      int
! get_last_leader_offset(char_u *line, char_u **flags)
  {
      int		result = -1;
      int		i, j;
***************
*** 1950,1966 ****
   * Return the number of window lines occupied by buffer line "lnum".
   */
      int
! plines(lnum)
!     linenr_T	lnum;
  {
      return plines_win(curwin, lnum, TRUE);
  }
  
      int
! plines_win(wp, lnum, winheight)
!     win_T	*wp;
!     linenr_T	lnum;
!     int		winheight;	/* when TRUE limit to window height */
  {
  #if defined(FEAT_DIFF) || defined(PROTO)
      /* Check for filler lines above this buffer line.  When folded the result
--- 1941,1956 ----
   * Return the number of window lines occupied by buffer line "lnum".
   */
      int
! plines(linenr_T lnum)
  {
      return plines_win(curwin, lnum, TRUE);
  }
  
      int
! plines_win(
!     win_T	*wp,
!     linenr_T	lnum,
!     int		winheight)	/* when TRUE limit to window height */
  {
  #if defined(FEAT_DIFF) || defined(PROTO)
      /* Check for filler lines above this buffer line.  When folded the result
***************
*** 1969,1985 ****
  }
  
      int
! plines_nofill(lnum)
!     linenr_T	lnum;
  {
      return plines_win_nofill(curwin, lnum, TRUE);
  }
  
      int
! plines_win_nofill(wp, lnum, winheight)
!     win_T	*wp;
!     linenr_T	lnum;
!     int		winheight;	/* when TRUE limit to window height */
  {
  #endif
      int		lines;
--- 1959,1974 ----
  }
  
      int
! plines_nofill(linenr_T lnum)
  {
      return plines_win_nofill(curwin, lnum, TRUE);
  }
  
      int
! plines_win_nofill(
!     win_T	*wp,
!     linenr_T	lnum,
!     int		winheight)	/* when TRUE limit to window height */
  {
  #endif
      int		lines;
***************
*** 2010,2018 ****
   * "wp".  Does not care about folding, 'wrap' or 'diff'.
   */
      int
! plines_win_nofold(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      char_u	*s;
      long	col;
--- 1999,2005 ----
   * "wp".  Does not care about folding, 'wrap' or 'diff'.
   */
      int
! plines_win_nofold(win_T *wp, linenr_T lnum)
  {
      char_u	*s;
      long	col;
***************
*** 2048,2057 ****
   * used from the start of the line to the given column number.
   */
      int
! plines_win_col(wp, lnum, column)
!     win_T	*wp;
!     linenr_T	lnum;
!     long	column;
  {
      long	col;
      char_u	*s;
--- 2035,2041 ----
   * used from the start of the line to the given column number.
   */
      int
! plines_win_col(win_T *wp, linenr_T lnum, long column)
  {
      long	col;
      char_u	*s;
***************
*** 2106,2114 ****
  }
  
      int
! plines_m_win(wp, first, last)
!     win_T	*wp;
!     linenr_T	first, last;
  {
      int		count = 0;
  
--- 2090,2096 ----
  }
  
      int
! plines_m_win(win_T *wp, linenr_T first, linenr_T last)
  {
      int		count = 0;
  
***************
*** 2146,2153 ****
   * Handles Replace mode and multi-byte characters.
   */
      void
! ins_bytes(p)
!     char_u	*p;
  {
      ins_bytes_len(p, (int)STRLEN(p));
  }
--- 2128,2134 ----
   * Handles Replace mode and multi-byte characters.
   */
      void
! ins_bytes(char_u *p)
  {
      ins_bytes_len(p, (int)STRLEN(p));
  }
***************
*** 2160,2168 ****
   * Handles Replace mode and multi-byte characters.
   */
      void
! ins_bytes_len(p, len)
!     char_u	*p;
!     int		len;
  {
      int		i;
  # ifdef FEAT_MBYTE
--- 2141,2147 ----
   * Handles Replace mode and multi-byte characters.
   */
      void
! ins_bytes_len(char_u *p, int len)
  {
      int		i;
  # ifdef FEAT_MBYTE
***************
*** 2193,2200 ****
   * convert bytes to a character.
   */
      void
! ins_char(c)
!     int		c;
  {
  #if defined(FEAT_MBYTE) || defined(PROTO)
      char_u	buf[MB_MAXBYTES + 1];
--- 2172,2178 ----
   * convert bytes to a character.
   */
      void
! ins_char(int c)
  {
  #if defined(FEAT_MBYTE) || defined(PROTO)
      char_u	buf[MB_MAXBYTES + 1];
***************
*** 2211,2219 ****
  }
  
      void
! ins_char_bytes(buf, charlen)
!     char_u	*buf;
!     int		charlen;
  {
      int		c = buf[0];
  #endif
--- 2189,2195 ----
  }
  
      void
! ins_char_bytes(char_u *buf, int charlen)
  {
      int		c = buf[0];
  #endif
***************
*** 2398,2405 ****
   * Caller must have prepared for undo.
   */
      void
! ins_str(s)
!     char_u	*s;
  {
      char_u	*oldp, *newp;
      int		newlen = (int)STRLEN(s);
--- 2374,2380 ----
   * Caller must have prepared for undo.
   */
      void
! ins_str(char_u *s)
  {
      char_u	*oldp, *newp;
      int		newlen = (int)STRLEN(s);
***************
*** 2436,2443 ****
   * return FAIL for failure, OK otherwise
   */
      int
! del_char(fixpos)
!     int		fixpos;
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
--- 2411,2417 ----
   * return FAIL for failure, OK otherwise
   */
      int
! del_char(int fixpos)
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
***************
*** 2457,2465 ****
   * Like del_bytes(), but delete characters instead of bytes.
   */
      int
! del_chars(count, fixpos)
!     long	count;
!     int		fixpos;
  {
      long	bytes = 0;
      long	i;
--- 2431,2437 ----
   * Like del_bytes(), but delete characters instead of bytes.
   */
      int
! del_chars(long count, int fixpos)
  {
      long	bytes = 0;
      long	i;
***************
*** 2485,2494 ****
   * return FAIL for failure, OK otherwise
   */
      int
! del_bytes(count, fixpos_arg, use_delcombine)
!     long	count;
!     int		fixpos_arg;
!     int		use_delcombine UNUSED;	    /* 'delcombine' option applies */
  {
      char_u	*oldp, *newp;
      colnr_T	oldlen;
--- 2457,2466 ----
   * return FAIL for failure, OK otherwise
   */
      int
! del_bytes(
!     long	count,
!     int		fixpos_arg,
!     int		use_delcombine UNUSED)	    /* 'delcombine' option applies */
  {
      char_u	*oldp, *newp;
      colnr_T	oldlen;
***************
*** 2602,2609 ****
   * return FAIL for failure, OK otherwise
   */
      int
! truncate_line(fixpos)
!     int		fixpos;	    /* if TRUE fix the cursor position when done */
  {
      char_u	*newp;
      linenr_T	lnum = curwin->w_cursor.lnum;
--- 2574,2581 ----
   * return FAIL for failure, OK otherwise
   */
      int
! truncate_line(
!     int		fixpos)	    /* if TRUE fix the cursor position when done */
  {
      char_u	*newp;
      linenr_T	lnum = curwin->w_cursor.lnum;
***************
*** 2636,2644 ****
   * Saves the lines for undo first if "undo" is TRUE.
   */
      void
! del_lines(nlines, undo)
!     long	nlines;		/* number of lines to delete */
!     int		undo;		/* if TRUE, prepare for undo */
  {
      long	n;
      linenr_T	first = curwin->w_cursor.lnum;
--- 2608,2616 ----
   * Saves the lines for undo first if "undo" is TRUE.
   */
      void
! del_lines(
!     long	nlines,		/* number of lines to delete */
!     int		undo)		/* if TRUE, prepare for undo */
  {
      long	n;
      linenr_T	first = curwin->w_cursor.lnum;
***************
*** 2673,2680 ****
  }
  
      int
! gchar_pos(pos)
!     pos_T *pos;
  {
      char_u	*ptr = ml_get_pos(pos);
  
--- 2645,2651 ----
  }
  
      int
! gchar_pos(pos_T *pos)
  {
      char_u	*ptr = ml_get_pos(pos);
  
***************
*** 2686,2692 ****
  }
  
      int
! gchar_cursor()
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
--- 2657,2663 ----
  }
  
      int
! gchar_cursor(void)
  {
  #ifdef FEAT_MBYTE
      if (has_mbyte)
***************
*** 2700,2707 ****
   * It is directly written into the block.
   */
      void
! pchar_cursor(c)
!     int c;
  {
      *(ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE)
  						  + curwin->w_cursor.col) = c;
--- 2671,2677 ----
   * It is directly written into the block.
   */
      void
! pchar_cursor(int c)
  {
      *(ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE)
  						  + curwin->w_cursor.col) = c;
***************
*** 2714,2721 ****
   *		    the line.
   */
      int
! inindent(extra)
!     int	    extra;
  {
      char_u	*ptr;
      colnr_T	col;
--- 2684,2690 ----
   *		    the line.
   */
      int
! inindent(int extra)
  {
      char_u	*ptr;
      colnr_T	col;
***************
*** 2732,2739 ****
   * Skip to next part of an option argument: Skip space and comma.
   */
      char_u *
! skip_to_option_part(p)
!     char_u  *p;
  {
      if (*p == ',')
  	++p;
--- 2701,2707 ----
   * Skip to next part of an option argument: Skip space and comma.
   */
      char_u *
! skip_to_option_part(char_u *p)
  {
      if (*p == ',')
  	++p;
***************
*** 2751,2757 ****
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! changed()
  {
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
      /* The text of the preediting area is inserted, but this doesn't
--- 2719,2725 ----
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! changed(void)
  {
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
      /* The text of the preediting area is inserted, but this doesn't
***************
*** 2806,2812 ****
   * Internal part of changed(), no user interaction.
   */
      void
! changed_int()
  {
      curbuf->b_changed = TRUE;
      ml_setflags(curbuf);
--- 2774,2780 ----
   * Internal part of changed(), no user interaction.
   */
      void
! changed_int(void)
  {
      curbuf->b_changed = TRUE;
      ml_setflags(curbuf);
***************
*** 2831,2839 ****
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! changed_bytes(lnum, col)
!     linenr_T	lnum;
!     colnr_T	col;
  {
      changedOneline(curbuf, lnum);
      changed_common(lnum, col, lnum + 1, 0L);
--- 2799,2805 ----
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! changed_bytes(linenr_T lnum, colnr_T col)
  {
      changedOneline(curbuf, lnum);
      changed_common(lnum, col, lnum + 1, 0L);
***************
*** 2858,2866 ****
  }
  
      static void
! changedOneline(buf, lnum)
!     buf_T	*buf;
!     linenr_T	lnum;
  {
      if (buf->b_mod_set)
      {
--- 2824,2830 ----
  }
  
      static void
! changedOneline(buf_T *buf, linenr_T lnum)
  {
      if (buf->b_mod_set)
      {
***************
*** 2886,2894 ****
   * Takes care of marking the buffer to be redrawn and sets the changed flag.
   */
      void
! appended_lines(lnum, count)
!     linenr_T	lnum;
!     long	count;
  {
      changed_lines(lnum + 1, 0, lnum + 1, count);
  }
--- 2850,2856 ----
   * Takes care of marking the buffer to be redrawn and sets the changed flag.
   */
      void
! appended_lines(linenr_T lnum, long count)
  {
      changed_lines(lnum + 1, 0, lnum + 1, count);
  }
***************
*** 2897,2905 ****
   * Like appended_lines(), but adjust marks first.
   */
      void
! appended_lines_mark(lnum, count)
!     linenr_T	lnum;
!     long	count;
  {
      mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);
      changed_lines(lnum + 1, 0, lnum + 1, count);
--- 2859,2865 ----
   * Like appended_lines(), but adjust marks first.
   */
      void
! appended_lines_mark(linenr_T lnum, long count)
  {
      mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);
      changed_lines(lnum + 1, 0, lnum + 1, count);
***************
*** 2911,2919 ****
   * Takes care of marking the buffer to be redrawn and sets the changed flag.
   */
      void
! deleted_lines(lnum, count)
!     linenr_T	lnum;
!     long	count;
  {
      changed_lines(lnum, 0, lnum + count, -count);
  }
--- 2871,2877 ----
   * Takes care of marking the buffer to be redrawn and sets the changed flag.
   */
      void
! deleted_lines(linenr_T lnum, long count)
  {
      changed_lines(lnum, 0, lnum + count, -count);
  }
***************
*** 2924,2932 ****
   * be triggered to display the cursor.
   */
      void
! deleted_lines_mark(lnum, count)
!     linenr_T	lnum;
!     long	count;
  {
      mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count);
      changed_lines(lnum, 0, lnum + count, -count);
--- 2882,2888 ----
   * be triggered to display the cursor.
   */
      void
! deleted_lines_mark(linenr_T lnum, long count)
  {
      mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count);
      changed_lines(lnum, 0, lnum + count, -count);
***************
*** 2945,2955 ****
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! changed_lines(lnum, col, lnume, xtra)
!     linenr_T	lnum;	    /* first line with change */
!     colnr_T	col;	    /* column in first line with change */
!     linenr_T	lnume;	    /* line below last changed line */
!     long	xtra;	    /* number of extra lines (negative when deleting) */
  {
      changed_lines_buf(curbuf, lnum, lnume, xtra);
  
--- 2901,2911 ----
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! changed_lines(
!     linenr_T	lnum,	    /* first line with change */
!     colnr_T	col,	    /* column in first line with change */
!     linenr_T	lnume,	    /* line below last changed line */
!     long	xtra)	    /* number of extra lines (negative when deleting) */
  {
      changed_lines_buf(curbuf, lnum, lnume, xtra);
  
***************
*** 2978,2988 ****
  }
  
      static void
! changed_lines_buf(buf, lnum, lnume, xtra)
!     buf_T	*buf;
!     linenr_T	lnum;	    /* first line with change */
!     linenr_T	lnume;	    /* line below last changed line */
!     long	xtra;	    /* number of extra lines (negative when deleting) */
  {
      if (buf->b_mod_set)
      {
--- 2934,2944 ----
  }
  
      static void
! changed_lines_buf(
!     buf_T	*buf,
!     linenr_T	lnum,	    /* first line with change */
!     linenr_T	lnume,	    /* line below last changed line */
!     long	xtra)	    /* number of extra lines (negative when deleting) */
  {
      if (buf->b_mod_set)
      {
***************
*** 3016,3026 ****
   * Careful: may trigger autocommands that reload the buffer.
   */
      static void
! changed_common(lnum, col, lnume, xtra)
!     linenr_T	lnum;
!     colnr_T	col;
!     linenr_T	lnume;
!     long	xtra;
  {
      win_T	*wp;
  #ifdef FEAT_WINDOWS
--- 2972,2982 ----
   * Careful: may trigger autocommands that reload the buffer.
   */
      static void
! changed_common(
!     linenr_T	lnum,
!     colnr_T	col,
!     linenr_T	lnume,
!     long	xtra)
  {
      win_T	*wp;
  #ifdef FEAT_WINDOWS
***************
*** 3217,3225 ****
   * unchanged() is called when the changed flag must be reset for buffer 'buf'
   */
      void
! unchanged(buf, ff)
!     buf_T	*buf;
!     int		ff;	/* also reset 'fileformat' */
  {
      if (buf->b_changed || (ff && file_ff_differs(buf, FALSE)))
      {
--- 3173,3181 ----
   * unchanged() is called when the changed flag must be reset for buffer 'buf'
   */
      void
! unchanged(
!     buf_T	*buf,
!     int		ff)	/* also reset 'fileformat' */
  {
      if (buf->b_changed || (ff && file_ff_differs(buf, FALSE)))
      {
***************
*** 3247,3254 ****
   *		 need to be updated
   */
      void
! check_status(buf)
!     buf_T	*buf;
  {
      win_T	*wp;
  
--- 3203,3209 ----
   *		 need to be updated
   */
      void
! check_status(buf_T *buf)
  {
      win_T	*wp;
  
***************
*** 3271,3278 ****
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! change_warning(col)
!     int	    col;		/* column for message; non-zero when in insert
  				   mode and 'showmode' is on */
  {
      static char *w_readonly = N_("W10: Warning: Changing a readonly file");
--- 3226,3233 ----
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! change_warning(
!     int	    col)		/* column for message; non-zero when in insert
  				   mode and 'showmode' is on */
  {
      static char *w_readonly = N_("W10: Warning: Changing a readonly file");
***************
*** 3327,3335 ****
   * return the 'y' or 'n'
   */
      int
! ask_yesno(str, direct)
!     char_u  *str;
!     int	    direct;
  {
      int	    r = ' ';
      int	    save_State = State;
--- 3282,3288 ----
   * return the 'y' or 'n'
   */
      int
! ask_yesno(char_u *str, int direct)
  {
      int	    r = ' ';
      int	    save_State = State;
***************
*** 3376,3383 ****
   * Return TRUE if "c" is a mouse key.
   */
      int
! is_mouse_key(c)
!     int c;
  {
      return c == K_LEFTMOUSE
  	|| c == K_LEFTMOUSE_NM
--- 3329,3335 ----
   * Return TRUE if "c" is a mouse key.
   */
      int
! is_mouse_key(int c)
  {
      return c == K_LEFTMOUSE
  	|| c == K_LEFTMOUSE_NM
***************
*** 3412,3418 ****
   * Translates the interrupt character for unix to ESC.
   */
      int
! get_keystroke()
  {
      char_u	*buf = NULL;
      int		buflen = 150;
--- 3364,3370 ----
   * Translates the interrupt character for unix to ESC.
   */
      int
! get_keystroke(void)
  {
      char_u	*buf = NULL;
      int		buflen = 150;
***************
*** 3536,3544 ****
   * When "mouse_used" is not NULL allow using the mouse.
   */
      int
! get_number(colon, mouse_used)
!     int	    colon;			/* allow colon to abort */
!     int	    *mouse_used;
  {
      int	n = 0;
      int	c;
--- 3488,3496 ----
   * When "mouse_used" is not NULL allow using the mouse.
   */
      int
! get_number(
!     int	    colon,			/* allow colon to abort */
!     int	    *mouse_used)
  {
      int	n = 0;
      int	c;
***************
*** 3607,3614 ****
   * the line number.
   */
      int
! prompt_for_number(mouse_used)
!     int		*mouse_used;
  {
      int		i;
      int		save_cmdline_row;
--- 3559,3565 ----
   * the line number.
   */
      int
! prompt_for_number(int *mouse_used)
  {
      int		i;
      int		save_cmdline_row;
***************
*** 3645,3652 ****
  }
  
      void
! msgmore(n)
!     long n;
  {
      long pn;
  
--- 3596,3602 ----
  }
  
      void
! msgmore(long n)
  {
      long pn;
  
***************
*** 3699,3705 ****
   * flush map and typeahead buffers and give a warning for an error
   */
      void
! beep_flush()
  {
      if (emsg_silent == 0)
      {
--- 3649,3655 ----
   * flush map and typeahead buffers and give a warning for an error
   */
      void
! beep_flush(void)
  {
      if (emsg_silent == 0)
      {
***************
*** 3712,3719 ****
   * Give a warning for an error.
   */
      void
! vim_beep(val)
!     unsigned val; /* one of the BO_ values, e.g., BO_OPER */
  {
      if (emsg_silent == 0)
      {
--- 3662,3669 ----
   * Give a warning for an error.
   */
      void
! vim_beep(
!     unsigned val) /* one of the BO_ values, e.g., BO_OPER */
  {
      if (emsg_silent == 0)
      {
***************
*** 3772,3778 ****
  static char_u	*homedir = NULL;
  
      void
! init_homedir()
  {
      char_u  *var;
  
--- 3722,3728 ----
  static char_u	*homedir = NULL;
  
      void
! init_homedir(void)
  {
      char_u  *var;
  
***************
*** 3891,3904 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_homedir()
  {
      vim_free(homedir);
  }
  
  # ifdef FEAT_CMDL_COMPL
      void
! free_users()
  {
      ga_clear_strings(&ga_users);
  }
--- 3841,3854 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_homedir(void)
  {
      vim_free(homedir);
  }
  
  # ifdef FEAT_CMDL_COMPL
      void
! free_users(void)
  {
      ga_clear_strings(&ga_users);
  }
***************
*** 3911,3918 ****
   * again soon.
   */
      char_u *
! expand_env_save(src)
!     char_u	*src;
  {
      return expand_env_save_opt(src, FALSE);
  }
--- 3861,3867 ----
   * again soon.
   */
      char_u *
! expand_env_save(char_u *src)
  {
      return expand_env_save_opt(src, FALSE);
  }
***************
*** 3922,3930 ****
   * expand "~" at the start.
   */
      char_u *
! expand_env_save_opt(src, one)
!     char_u	*src;
!     int		one;
  {
      char_u	*p;
  
--- 3871,3877 ----
   * expand "~" at the start.
   */
      char_u *
! expand_env_save_opt(char_u *src, int one)
  {
      char_u	*p;
  
***************
*** 3941,3962 ****
   * If anything fails no expansion is done and dst equals src.
   */
      void
! expand_env(src, dst, dstlen)
!     char_u	*src;		/* input string e.g. "$HOME/vim.hlp" */
!     char_u	*dst;		/* where to put the result */
!     int		dstlen;		/* maximum length of the result */
  {
      expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);
  }
  
      void
! expand_env_esc(srcp, dst, dstlen, esc, one, startstr)
!     char_u	*srcp;		/* input string e.g. "$HOME/vim.hlp" */
!     char_u	*dst;		/* where to put the result */
!     int		dstlen;		/* maximum length of the result */
!     int		esc;		/* escape spaces in expanded variables */
!     int		one;		/* "srcp" is one file name */
!     char_u	*startstr;	/* start again after this (can be NULL) */
  {
      char_u	*src;
      char_u	*tail;
--- 3888,3909 ----
   * If anything fails no expansion is done and dst equals src.
   */
      void
! expand_env(
!     char_u	*src,		/* input string e.g. "$HOME/vim.hlp" */
!     char_u	*dst,		/* where to put the result */
!     int		dstlen)		/* maximum length of the result */
  {
      expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);
  }
  
      void
! expand_env_esc(
!     char_u	*srcp,		/* input string e.g. "$HOME/vim.hlp" */
!     char_u	*dst,		/* where to put the result */
!     int		dstlen,		/* maximum length of the result */
!     int		esc,		/* escape spaces in expanded variables */
!     int		one,		/* "srcp" is one file name */
!     char_u	*startstr)	/* start again after this (can be NULL) */
  {
      char_u	*src;
      char_u	*tail;
***************
*** 4241,4249 ****
   * initialized to FALSE by the caller.
   */
      char_u *
! vim_getenv(name, mustfree)
!     char_u	*name;
!     int		*mustfree;
  {
      char_u	*p;
      char_u	*pend;
--- 4188,4194 ----
   * initialized to FALSE by the caller.
   */
      char_u *
! vim_getenv(char_u *name, int *mustfree)
  {
      char_u	*p;
      char_u	*pend;
***************
*** 4469,4476 ****
   * Return NULL if not, return its name in allocated memory otherwise.
   */
      static char_u *
! vim_version_dir(vimdir)
!     char_u	*vimdir;
  {
      char_u	*p;
  
--- 4414,4420 ----
   * Return NULL if not, return its name in allocated memory otherwise.
   */
      static char_u *
! vim_version_dir(char_u *vimdir)
  {
      char_u	*p;
  
***************
*** 4492,4501 ****
   * the length of "name/".  Otherwise return "pend".
   */
      static char_u *
! remove_tail(p, pend, name)
!     char_u	*p;
!     char_u	*pend;
!     char_u	*name;
  {
      int		len = (int)STRLEN(name) + 1;
      char_u	*newend = pend - len;
--- 4436,4442 ----
   * the length of "name/".  Otherwise return "pend".
   */
      static char_u *
! remove_tail(char_u *p, char_u *pend, char_u *name)
  {
      int		len = (int)STRLEN(name) + 1;
      char_u	*newend = pend - len;
***************
*** 4511,4519 ****
   * Our portable version of setenv.
   */
      void
! vim_setenv(name, val)
!     char_u	*name;
!     char_u	*val;
  {
  #ifdef HAVE_SETENV
      mch_setenv((char *)name, (char *)val, 1);
--- 4452,4458 ----
   * Our portable version of setenv.
   */
      void
! vim_setenv(char_u *name, char_u *val)
  {
  #ifdef HAVE_SETENV
      mch_setenv((char *)name, (char *)val, 1);
***************
*** 4554,4562 ****
   * Function given to ExpandGeneric() to obtain an environment variable name.
   */
      char_u *
! get_env_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
  # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
      /*
--- 4493,4501 ----
   * Function given to ExpandGeneric() to obtain an environment variable name.
   */
      char_u *
! get_env_name(
!     expand_T	*xp UNUSED,
!     int		idx)
  {
  # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
      /*
***************
*** 4593,4599 ****
   * Done only once and then cached.
   */
      static void
! init_users()
  {
      static int	lazy_init_done = FALSE;
  
--- 4532,4538 ----
   * Done only once and then cached.
   */
      static void
! init_users(void)
  {
      static int	lazy_init_done = FALSE;
  
***************
*** 4629,4637 ****
   * Function given to ExpandGeneric() to obtain an user names.
   */
      char_u*
! get_users(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      init_users();
      if (idx < ga_users.ga_len)
--- 4568,4574 ----
   * Function given to ExpandGeneric() to obtain an user names.
   */
      char_u*
! get_users(expand_T *xp UNUSED, int idx)
  {
      init_users();
      if (idx < ga_users.ga_len)
***************
*** 4645,4652 ****
   * 1 if name partially matches the beginning of a user name.
   * 2 is name fully matches a user name.
   */
! int match_user(name)
!     char_u* name;
  {
      int i;
      int n = (int)STRLEN(name);
--- 4582,4588 ----
   * 1 if name partially matches the beginning of a user name.
   * 2 is name fully matches a user name.
   */
! int match_user(char_u* name)
  {
      int i;
      int n = (int)STRLEN(name);
***************
*** 4670,4681 ****
   * If anything fails (except when out of space) dst equals src.
   */
      void
! home_replace(buf, src, dst, dstlen, one)
!     buf_T	*buf;	/* when not NULL, check for help files */
!     char_u	*src;	/* input file name */
!     char_u	*dst;	/* where to put the result */
!     int		dstlen;	/* maximum length of the result */
!     int		one;	/* if TRUE, only replace one file name, include
  			   spaces and commas in the file name. */
  {
      size_t	dirlen = 0, envlen = 0;
--- 4606,4617 ----
   * If anything fails (except when out of space) dst equals src.
   */
      void
! home_replace(
!     buf_T	*buf,	/* when not NULL, check for help files */
!     char_u	*src,	/* input file name */
!     char_u	*dst,	/* where to put the result */
!     int		dstlen,	/* maximum length of the result */
!     int		one)	/* if TRUE, only replace one file name, include
  			   spaces and commas in the file name. */
  {
      size_t	dirlen = 0, envlen = 0;
***************
*** 4794,4802 ****
   * When something fails, NULL is returned.
   */
      char_u  *
! home_replace_save(buf, src)
!     buf_T	*buf;	/* when not NULL, check for help files */
!     char_u	*src;	/* input file name */
  {
      char_u	*dst;
      unsigned	len;
--- 4730,4738 ----
   * When something fails, NULL is returned.
   */
      char_u  *
! home_replace_save(
!     buf_T	*buf,	/* when not NULL, check for help files */
!     char_u	*src)	/* input file name */
  {
      char_u	*dst;
      unsigned	len;
***************
*** 4820,4828 ****
   * For the first name environment variables are expanded
   */
      int
! fullpathcmp(s1, s2, checkname)
!     char_u *s1, *s2;
!     int	    checkname;		/* when both don't exist, check file names */
  {
  #ifdef UNIX
      char_u	    exp1[MAXPATHL];
--- 4756,4765 ----
   * For the first name environment variables are expanded
   */
      int
! fullpathcmp(
!     char_u *s1,
!     char_u *s2,
!     int	    checkname)		/* when both don't exist, check file names */
  {
  #ifdef UNIX
      char_u	    exp1[MAXPATHL];
***************
*** 4896,4903 ****
   * Fail safe: never returns NULL.
   */
      char_u *
! gettail(fname)
!     char_u *fname;
  {
      char_u  *p1, *p2;
  
--- 4833,4839 ----
   * Fail safe: never returns NULL.
   */
      char_u *
! gettail(char_u *fname)
  {
      char_u  *p1, *p2;
  
***************
*** 4922,4929 ****
   *	 ^	       ^	     ^	      ^
   */
      static char_u *
! gettail_dir(fname)
!     char_u *fname;
  {
      char_u	*dir_end = fname;
      char_u	*next_dir_end = fname;
--- 4858,4864 ----
   *	 ^	       ^	     ^	      ^
   */
      static char_u *
! gettail_dir(char_u *fname)
  {
      char_u	*dir_end = fname;
      char_u	*next_dir_end = fname;
***************
*** 4958,4965 ****
   * Always returns a valid pointer.
   */
      char_u *
! gettail_sep(fname)
!     char_u	*fname;
  {
      char_u	*p;
      char_u	*t;
--- 4893,4899 ----
   * Always returns a valid pointer.
   */
      char_u *
! gettail_sep(char_u *fname)
  {
      char_u	*p;
      char_u	*t;
***************
*** 4979,4986 ****
   * get the next path component (just after the next path separator).
   */
      char_u *
! getnextcomp(fname)
!     char_u *fname;
  {
      while (*fname && !vim_ispathsep(*fname))
  	mb_ptr_adv(fname);
--- 4913,4919 ----
   * get the next path component (just after the next path separator).
   */
      char_u *
! getnextcomp(char_u *fname)
  {
      while (*fname && !vim_ispathsep(*fname))
  	mb_ptr_adv(fname);
***************
*** 4995,5002 ****
   * If there is no head, path is returned.
   */
      char_u *
! get_past_head(path)
!     char_u  *path;
  {
      char_u  *retval;
  
--- 4928,4934 ----
   * If there is no head, path is returned.
   */
      char_u *
! get_past_head(char_u *path)
  {
      char_u  *retval;
  
***************
*** 5028,5035 ****
   * Note that for MS-Windows this includes the colon.
   */
      int
! vim_ispathsep(c)
!     int c;
  {
  #ifdef UNIX
      return (c == '/');	    /* UNIX has ':' inside file names */
--- 4960,4966 ----
   * Note that for MS-Windows this includes the colon.
   */
      int
! vim_ispathsep(int c)
  {
  #ifdef UNIX
      return (c == '/');	    /* UNIX has ':' inside file names */
***************
*** 5052,5059 ****
   * Like vim_ispathsep(c), but exclude the colon for MS-Windows.
   */
      int
! vim_ispathsep_nocolon(c)
!     int c;
  {
      return vim_ispathsep(c)
  #ifdef BACKSLASH_IN_FILENAME
--- 4983,4989 ----
   * Like vim_ispathsep(c), but exclude the colon for MS-Windows.
   */
      int
! vim_ispathsep_nocolon(int c)
  {
      return vim_ispathsep(c)
  #ifdef BACKSLASH_IN_FILENAME
***************
*** 5067,5074 ****
   * return TRUE if 'c' is a path list separator.
   */
      int
! vim_ispathlistsep(c)
!     int c;
  {
  #ifdef UNIX
      return (c == ':');
--- 4997,5003 ----
   * return TRUE if 'c' is a path list separator.
   */
      int
! vim_ispathlistsep(int c)
  {
  #ifdef UNIX
      return (c == ':');
***************
*** 5085,5092 ****
   * It's done in-place.
   */
      void
! shorten_dir(str)
!     char_u *str;
  {
      char_u	*tail, *s, *d;
      int		skip = FALSE;
--- 5014,5020 ----
   * It's done in-place.
   */
      void
! shorten_dir(char_u *str)
  {
      char_u	*tail, *s, *d;
      int		skip = FALSE;
***************
*** 5131,5138 ****
   * "fname" must be writable!.
   */
      int
! dir_of_file_exists(fname)
!     char_u	*fname;
  {
      char_u	*p;
      int		c;
--- 5059,5065 ----
   * "fname" must be writable!.
   */
      int
! dir_of_file_exists(char_u *fname)
  {
      char_u	*p;
      int		c;
***************
*** 5153,5160 ****
   * and deal with 'fileignorecase'.
   */
      int
! vim_fnamecmp(x, y)
!     char_u	*x, *y;
  {
  #ifdef BACKSLASH_IN_FILENAME
      return vim_fnamencmp(x, y, MAXPATHL);
--- 5080,5086 ----
   * and deal with 'fileignorecase'.
   */
      int
! vim_fnamecmp(char_u *x, char_u *y)
  {
  #ifdef BACKSLASH_IN_FILENAME
      return vim_fnamencmp(x, y, MAXPATHL);
***************
*** 5166,5174 ****
  }
  
      int
! vim_fnamencmp(x, y, len)
!     char_u	*x, *y;
!     size_t	len;
  {
  #ifdef BACKSLASH_IN_FILENAME
      char_u	*px = x;
--- 5092,5098 ----
  }
  
      int
! vim_fnamencmp(char_u *x, char_u *y, size_t len)
  {
  #ifdef BACKSLASH_IN_FILENAME
      char_u	*px = x;
***************
*** 5204,5213 ****
   * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.
   */
      char_u  *
! concat_fnames(fname1, fname2, sep)
!     char_u  *fname1;
!     char_u  *fname2;
!     int	    sep;
  {
      char_u  *dest;
  
--- 5128,5134 ----
   * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.
   */
      char_u  *
! concat_fnames(char_u *fname1, char_u *fname2, int sep)
  {
      char_u  *dest;
  
***************
*** 5227,5235 ****
   * Returns NULL when out of memory.
   */
      char_u  *
! concat_str(str1, str2)
!     char_u  *str1;
!     char_u  *str2;
  {
      char_u  *dest;
      size_t  l = STRLEN(str1);
--- 5148,5154 ----
   * Returns NULL when out of memory.
   */
      char_u  *
! concat_str(char_u *str1, char_u *str2)
  {
      char_u  *dest;
      size_t  l = STRLEN(str1);
***************
*** 5248,5255 ****
   * separator.
   */
      void
! add_pathsep(p)
!     char_u	*p;
  {
      if (*p != NUL && !after_pathsep(p, p + STRLEN(p)))
  	STRCAT(p, PATHSEPSTR);
--- 5167,5173 ----
   * separator.
   */
      void
! add_pathsep(char_u *p)
  {
      if (*p != NUL && !after_pathsep(p, p + STRLEN(p)))
  	STRCAT(p, PATHSEPSTR);
***************
*** 5260,5268 ****
   * Returns NULL when out of memory.
   */
      char_u  *
! FullName_save(fname, force)
!     char_u	*fname;
!     int		force;		/* force expansion, even when it already looks
  				 * like a full path name */
  {
      char_u	*buf;
--- 5178,5186 ----
   * Returns NULL when out of memory.
   */
      char_u  *
! FullName_save(
!     char_u	*fname,
!     int		force)		/* force expansion, even when it already looks
  				 * like a full path name */
  {
      char_u	*buf;
***************
*** 5296,5309 ****
   * Return NULL when not inside a comment.
   */
      static pos_T *
! ind_find_start_comment()	    /* XXX */
  {
      return find_start_comment(curbuf->b_ind_maxcomment);
  }
  
      pos_T *
! find_start_comment(ind_maxcomment)	    /* XXX */
!     int		ind_maxcomment;
  {
      pos_T	*pos;
      char_u	*line;
--- 5214,5226 ----
   * Return NULL when not inside a comment.
   */
      static pos_T *
! ind_find_start_comment(void)	    /* XXX */
  {
      return find_start_comment(curbuf->b_ind_maxcomment);
  }
  
      pos_T *
! find_start_comment(int ind_maxcomment)	/* XXX */
  {
      pos_T	*pos;
      char_u	*line;
***************
*** 5343,5349 ****
   * "CORS" -> Comment Or Raw String
   */
      static pos_T *
! ind_find_start_CORS()	    /* XXX */
  {
      static pos_T comment_pos_copy;
      pos_T	*comment_pos;
--- 5260,5266 ----
   * "CORS" -> Comment Or Raw String
   */
      static pos_T *
! ind_find_start_CORS(void)	    /* XXX */
  {
      static pos_T comment_pos_copy;
      pos_T	*comment_pos;
***************
*** 5372,5379 ****
   * Return NULL when not inside a raw string.
   */
      static pos_T *
! find_start_rawstring(ind_maxcomment)	    /* XXX */
!     int		ind_maxcomment;
  {
      pos_T	*pos;
      char_u	*line;
--- 5289,5295 ----
   * Return NULL when not inside a raw string.
   */
      static pos_T *
! find_start_rawstring(int ind_maxcomment)	/* XXX */
  {
      pos_T	*pos;
      char_u	*line;
***************
*** 5410,5417 ****
   * If there is no string or character, return argument unmodified.
   */
      static char_u *
! skip_string(p)
!     char_u  *p;
  {
      int	    i;
  
--- 5326,5332 ----
   * If there is no string or character, return argument unmodified.
   */
      static char_u *
! skip_string(char_u *p)
  {
      int	    i;
  
***************
*** 5484,5490 ****
   * Do C or expression indenting on the current line.
   */
      void
! do_c_expr_indent()
  {
  # ifdef FEAT_EVAL
      if (*curbuf->b_p_inde != NUL)
--- 5399,5405 ----
   * Do C or expression indenting on the current line.
   */
      void
! do_c_expr_indent(void)
  {
  # ifdef FEAT_EVAL
      if (*curbuf->b_p_inde != NUL)
***************
*** 5551,5558 ****
   * Also skip over Perl/shell comments if desired.
   */
      static char_u *
! cin_skipcomment(s)
!     char_u	*s;
  {
      while (*s)
      {
--- 5466,5472 ----
   * Also skip over Perl/shell comments if desired.
   */
      static char_u *
! cin_skipcomment(char_u *s)
  {
      while (*s)
      {
***************
*** 5592,5599 ****
   * not considered code.
   */
      static int
! cin_nocode(s)
!     char_u	*s;
  {
      return *cin_skipcomment(s) == NUL;
  }
--- 5506,5512 ----
   * not considered code.
   */
      static int
! cin_nocode(char_u *s)
  {
      return *cin_skipcomment(s) == NUL;
  }
***************
*** 5602,5608 ****
   * Check previous lines for a "//" line comment, skipping over blank lines.
   */
      static pos_T *
! find_line_comment() /* XXX */
  {
      static pos_T pos;
      char_u	 *line;
--- 5515,5521 ----
   * Check previous lines for a "//" line comment, skipping over blank lines.
   */
      static pos_T *
! find_line_comment(void) /* XXX */
  {
      static pos_T pos;
      char_u	 *line;
***************
*** 5628,5635 ****
   * Return TRUE if "text" starts with "key:".
   */
      static int
! cin_has_js_key(text)
!     char_u *text;
  {
      char_u *s = skipwhite(text);
      int	    quote = -1;
--- 5541,5547 ----
   * Return TRUE if "text" starts with "key:".
   */
      static int
! cin_has_js_key(char_u *text)
  {
      char_u *s = skipwhite(text);
      int	    quote = -1;
***************
*** 5659,5666 ****
   * "*s" must point to the start of the label, if there is one.
   */
      static int
! cin_islabel_skip(s)
!     char_u	**s;
  {
      if (!vim_isIDc(**s))	    /* need at least one ID character */
  	return FALSE;
--- 5571,5577 ----
   * "*s" must point to the start of the label, if there is one.
   */
      static int
! cin_islabel_skip(char_u **s)
  {
      if (!vim_isIDc(**s))	    /* need at least one ID character */
  	return FALSE;
***************
*** 5679,5685 ****
   * Note: curwin->w_cursor must be where we are looking for the label.
   */
      int
! cin_islabel()		/* XXX */
  {
      char_u	*s;
  
--- 5590,5596 ----
   * Note: curwin->w_cursor must be where we are looking for the label.
   */
      int
! cin_islabel(void)		/* XXX */
  {
      char_u	*s;
  
***************
*** 5784,5792 ****
   * Recognize a switch label: "case .*:" or "default:".
   */
       int
! cin_iscase(s, strict)
!     char_u *s;
!     int strict; /* Allow relaxed check of case statement for JS */
  {
      s = cin_skipcomment(s);
      if (cin_starts_with(s, "case"))
--- 5695,5703 ----
   * Recognize a switch label: "case .*:" or "default:".
   */
       int
! cin_iscase(
!     char_u *s,
!     int strict) /* Allow relaxed check of case statement for JS */
  {
      s = cin_skipcomment(s);
      if (cin_starts_with(s, "case"))
***************
*** 5826,5833 ****
   * Recognize a "default" switch label.
   */
      static int
! cin_isdefault(s)
!     char_u  *s;
  {
      return (STRNCMP(s, "default", 7) == 0
  	    && *(s = cin_skipcomment(s + 7)) == ':'
--- 5737,5743 ----
   * Recognize a "default" switch label.
   */
      static int
! cin_isdefault(char_u *s)
  {
      return (STRNCMP(s, "default", 7) == 0
  	    && *(s = cin_skipcomment(s + 7)) == ':'
***************
*** 5838,5845 ****
   * Recognize a "public/private/protected" scope declaration label.
   */
      int
! cin_isscopedecl(s)
!     char_u	*s;
  {
      int		i;
  
--- 5748,5754 ----
   * Recognize a "public/private/protected" scope declaration label.
   */
      int
! cin_isscopedecl(char_u *s)
  {
      int		i;
  
***************
*** 5862,5869 ****
   * Recognize a "namespace" scope declaration.
   */
      static int
! cin_is_cpp_namespace(s)
!     char_u	*s;
  {
      char_u	*p;
      int		has_name = FALSE;
--- 5771,5777 ----
   * Recognize a "namespace" scope declaration.
   */
      static int
! cin_is_cpp_namespace(char_u *s)
  {
      char_u	*p;
      int		has_name = FALSE;
***************
*** 5906,5913 ****
   *		       ^
   */
      static char_u *
! after_label(l)
!     char_u  *l;
  {
      for ( ; *l; ++l)
      {
--- 5814,5820 ----
   *		       ^
   */
      static char_u *
! after_label(char_u *l)
  {
      for ( ; *l; ++l)
      {
***************
*** 5934,5941 ****
   * Return 0 if there is nothing after the label.
   */
      static int
! get_indent_nolabel(lnum)		/* XXX */
!     linenr_T	lnum;
  {
      char_u	*l;
      pos_T	fp;
--- 5841,5847 ----
   * Return 0 if there is nothing after the label.
   */
      static int
! get_indent_nolabel (linenr_T lnum)	/* XXX */
  {
      char_u	*l;
      pos_T	fp;
***************
*** 5960,5968 ****
   *		^
   */
      static int
! skip_label(lnum, pp)
!     linenr_T	lnum;
!     char_u	**pp;
  {
      char_u	*l;
      int		amount;
--- 5866,5872 ----
   *		^
   */
      static int
! skip_label(linenr_T lnum, char_u **pp)
  {
      char_u	*l;
      int		amount;
***************
*** 5998,6004 ****
   * Returns zero when it doesn't look like a declaration.
   */
      static int
! cin_first_id_amount()
  {
      char_u	*line, *p, *s;
      int		len;
--- 5902,5908 ----
   * Returns zero when it doesn't look like a declaration.
   */
      static int
! cin_first_id_amount(void)
  {
      char_u	*line, *p, *s;
      int		len;
***************
*** 6049,6056 ****
   *	       here";
   */
      static int
! cin_get_equal_amount(lnum)
!     linenr_T	lnum;
  {
      char_u	*line;
      char_u	*s;
--- 5953,5959 ----
   *	       here";
   */
      static int
! cin_get_equal_amount(linenr_T lnum)
  {
      char_u	*line;
      char_u	*s;
***************
*** 6092,6099 ****
   * Recognize a preprocessor statement: Any line that starts with '#'.
   */
      static int
! cin_ispreproc(s)
!     char_u *s;
  {
      if (*skipwhite(s) == '#')
  	return TRUE;
--- 5995,6001 ----
   * Recognize a preprocessor statement: Any line that starts with '#'.
   */
      static int
! cin_ispreproc(char_u *s)
  {
      if (*skipwhite(s) == '#')
  	return TRUE;
***************
*** 6106,6114 ****
   * start and return the line in "*pp".
   */
      static int
! cin_ispreproc_cont(pp, lnump)
!     char_u	**pp;
!     linenr_T	*lnump;
  {
      char_u	*line = *pp;
      linenr_T	lnum = *lnump;
--- 6008,6014 ----
   * start and return the line in "*pp".
   */
      static int
! cin_ispreproc_cont(char_u **pp, linenr_T *lnump)
  {
      char_u	*line = *pp;
      linenr_T	lnum = *lnump;
***************
*** 6138,6145 ****
   * Recognize the start of a C or C++ comment.
   */
      static int
! cin_iscomment(p)
!     char_u  *p;
  {
      return (p[0] == '/' && (p[1] == '*' || p[1] == '/'));
  }
--- 6038,6044 ----
   * Recognize the start of a C or C++ comment.
   */
      static int
! cin_iscomment(char_u *p)
  {
      return (p[0] == '/' && (p[1] == '*' || p[1] == '/'));
  }
***************
*** 6148,6155 ****
   * Recognize the start of a "//" comment.
   */
      static int
! cin_islinecomment(p)
!     char_u *p;
  {
      return (p[0] == '/' && p[1] == '/');
  }
--- 6047,6053 ----
   * Recognize the start of a "//" comment.
   */
      static int
! cin_islinecomment(char_u *p)
  {
      return (p[0] == '/' && p[1] == '/');
  }
***************
*** 6164,6173 ****
   * both apply in order to determine initializations).
   */
      static int
! cin_isterminated(s, incl_open, incl_comma)
!     char_u	*s;
!     int		incl_open;	/* include '{' at the end as terminator */
!     int		incl_comma;	/* recognize a trailing comma */
  {
      char_u	found_start = 0;
      unsigned	n_open = 0;
--- 6062,6071 ----
   * both apply in order to determine initializations).
   */
      static int
! cin_isterminated(
!     char_u	*s,
!     int		incl_open,	/* include '{' at the end as terminator */
!     int		incl_comma)	/* recognize a trailing comma */
  {
      char_u	found_start = 0;
      unsigned	n_open = 0;
***************
*** 6216,6225 ****
   * "min_lnum" is the line before which we will not be looking.
   */
      static int
! cin_isfuncdecl(sp, first_lnum, min_lnum)
!     char_u	**sp;
!     linenr_T	first_lnum;
!     linenr_T	min_lnum;
  {
      char_u	*s;
      linenr_T	lnum = first_lnum;
--- 6114,6123 ----
   * "min_lnum" is the line before which we will not be looking.
   */
      static int
! cin_isfuncdecl(
!     char_u	**sp,
!     linenr_T	first_lnum,
!     linenr_T	min_lnum)
  {
      char_u	*s;
      linenr_T	lnum = first_lnum;
***************
*** 6326,6340 ****
  }
  
      static int
! cin_isif(p)
!     char_u  *p;
  {
!     return (STRNCMP(p, "if", 2) == 0 && !vim_isIDc(p[2]));
  }
  
      static int
! cin_iselse(p)
!     char_u  *p;
  {
      if (*p == '}')	    /* accept "} else" */
  	p = cin_skipcomment(p + 1);
--- 6224,6237 ----
  }
  
      static int
! cin_isif(char_u *p)
  {
!  return (STRNCMP(p, "if", 2) == 0 && !vim_isIDc(p[2]));
  }
  
      static int
! cin_iselse(
!     char_u  *p)
  {
      if (*p == '}')	    /* accept "} else" */
  	p = cin_skipcomment(p + 1);
***************
*** 6342,6349 ****
  }
  
      static int
! cin_isdo(p)
!     char_u  *p;
  {
      return (STRNCMP(p, "do", 2) == 0 && !vim_isIDc(p[2]));
  }
--- 6239,6245 ----
  }
  
      static int
! cin_isdo(char_u *p)
  {
      return (STRNCMP(p, "do", 2) == 0 && !vim_isIDc(p[2]));
  }
***************
*** 6354,6362 ****
   * ')' and ';'. The condition may be spread over several lines.
   */
      static int
! cin_iswhileofdo(p, lnum)	    /* XXX */
!     char_u	*p;
!     linenr_T	lnum;
  {
      pos_T	cursor_save;
      pos_T	*trypos;
--- 6250,6256 ----
   * ')' and ';'. The condition may be spread over several lines.
   */
      static int
! cin_iswhileofdo (char_u *p, linenr_T lnum)	/* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
***************
*** 6392,6400 ****
   * string was found.
   */
      static int
! cin_is_if_for_while_before_offset(line, poffset)
!     char_u *line;
!     int    *poffset;
  {
      int offset = *poffset;
  
--- 6286,6292 ----
   * string was found.
   */
      static int
! cin_is_if_for_while_before_offset(char_u *line, int *poffset)
  {
      int offset = *poffset;
  
***************
*** 6440,6447 ****
   * Adjust the cursor to the line with "while".
   */
      static int
! cin_iswhileofdo_end(terminated)
!     int	    terminated;
  {
      char_u	*line;
      char_u	*p;
--- 6332,6338 ----
   * Adjust the cursor to the line with "while".
   */
      static int
! cin_iswhileofdo_end(int terminated)
  {
      char_u	*line;
      char_u	*p;
***************
*** 6490,6497 ****
  }
  
      static int
! cin_isbreak(p)
!     char_u  *p;
  {
      return (STRNCMP(p, "break", 5) == 0 && !vim_isIDc(p[5]));
  }
--- 6381,6387 ----
  }
  
      static int
! cin_isbreak(char_u *p)
  {
      return (STRNCMP(p, "break", 5) == 0 && !vim_isIDc(p[5]));
  }
***************
*** 6510,6517 ****
   * This is a lot of guessing.  Watch out for "cond ? func() : foo".
   */
      static int
! cin_is_cpp_baseclass(cached)
!     cpp_baseclass_cache_T *cached; /* input and output */
  {
      lpos_T	*pos = &cached->lpos;	    /* find position */
      char_u	*s;
--- 6400,6407 ----
   * This is a lot of guessing.  Watch out for "cond ? func() : foo".
   */
      static int
! cin_is_cpp_baseclass(
!     cpp_baseclass_cache_T *cached) /* input and output */
  {
      lpos_T	*pos = &cached->lpos;	    /* find position */
      char_u	*s;
***************
*** 6672,6679 ****
  }
  
      static int
! get_baseclass_amount(col)
!     int		col;
  {
      int		amount;
      colnr_T	vcol;
--- 6562,6568 ----
  }
  
      static int
! get_baseclass_amount(int col)
  {
      int		amount;
      colnr_T	vcol;
***************
*** 6705,6714 ****
   * Ignore "ignore" after "find" if it's not NULL.
   */
      static int
! cin_ends_in(s, find, ignore)
!     char_u	*s;
!     char_u	*find;
!     char_u	*ignore;
  {
      char_u	*p = s;
      char_u	*r;
--- 6594,6600 ----
   * Ignore "ignore" after "find" if it's not NULL.
   */
      static int
! cin_ends_in(char_u *s, char_u *find, char_u *ignore)
  {
      char_u	*p = s;
      char_u	*r;
***************
*** 6735,6743 ****
   * Return TRUE when "s" starts with "word" and then a non-ID character.
   */
      static int
! cin_starts_with(s, word)
!     char_u *s;
!     char *word;
  {
      int l = (int)STRLEN(word);
  
--- 6621,6627 ----
   * Return TRUE when "s" starts with "word" and then a non-ID character.
   */
      static int
! cin_starts_with(char_u *s, char *word)
  {
      int l = (int)STRLEN(word);
  
***************
*** 6749,6756 ****
   * Return the column found.
   */
      static int
! cin_skip2pos(trypos)
!     pos_T	*trypos;
  {
      char_u	*line;
      char_u	*p;
--- 6633,6639 ----
   * Return the column found.
   */
      static int
! cin_skip2pos(pos_T *trypos)
  {
      char_u	*line;
      char_u	*p;
***************
*** 6779,6785 ****
  /* }	    */
  
      static pos_T *
! find_start_brace()	    /* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
--- 6662,6668 ----
  /* }	    */
  
      static pos_T *
! find_start_brace(void)	    /* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
***************
*** 6809,6824 ****
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren(ind_maxparen)	    /* XXX */
!     int		ind_maxparen;
  {
!     return find_match_char('(', ind_maxparen);
  }
  
      static pos_T *
! find_match_char(c, ind_maxparen)	    /* XXX */
!     int		c;
!     int		ind_maxparen;
  {
      pos_T	cursor_save;
      pos_T	*trypos;
--- 6692,6704 ----
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren(int ind_maxparen)	/* XXX */
  {
!  return find_match_char('(', ind_maxparen);
  }
  
      static pos_T *
! find_match_char (int c, int ind_maxparen)	/* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
***************
*** 6872,6879 ****
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren_after_brace(ind_maxparen)	    /* XXX */
!     int		ind_maxparen;
  {
      pos_T	*trypos = find_match_paren(ind_maxparen);
  
--- 6752,6758 ----
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren_after_brace (int ind_maxparen)	    /* XXX */
  {
      pos_T	*trypos = find_match_paren(ind_maxparen);
  
***************
*** 6899,6906 ****
   * looking a few lines further.
   */
      static int
! corr_ind_maxparen(startpos)
!     pos_T	*startpos;
  {
      long	n = (long)startpos->lnum - (long)curwin->w_cursor.lnum;
  
--- 6778,6784 ----
   * looking a few lines further.
   */
      static int
! corr_ind_maxparen(pos_T *startpos)
  {
      long	n = (long)startpos->lnum - (long)curwin->w_cursor.lnum;
  
***************
*** 6914,6922 ****
   * line "l".  "l" must point to the start of the line.
   */
      static int
! find_last_paren(l, start, end)
!     char_u	*l;
!     int		start, end;
  {
      int		i;
      int		retval = FALSE;
--- 6792,6798 ----
   * line "l".  "l" must point to the start of the line.
   */
      static int
! find_last_paren(char_u *l, int start, int end)
  {
      int		i;
      int		retval = FALSE;
***************
*** 6949,6956 ****
   * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.
   */
      void
! parse_cino(buf)
!     buf_T	*buf;
  {
      char_u	*p;
      char_u	*l;
--- 6825,6831 ----
   * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.
   */
      void
! parse_cino(buf_T *buf)
  {
      char_u	*p;
      char_u	*l;
***************
*** 7169,7175 ****
   * Return -1 if the indent should be left alone (inside a raw string).
   */
      int
! get_c_indent()
  {
      pos_T	cur_curpos;
      int		amount;
--- 7044,7050 ----
   * Return -1 if the indent should be left alone (inside a raw string).
   */
      int
! get_c_indent(void)
  {
      pos_T	cur_curpos;
      int		amount;
***************
*** 9172,9180 ****
  }
  
      static int
! find_match(lookfor, ourscope)
!     int		lookfor;
!     linenr_T	ourscope;
  {
      char_u	*look;
      pos_T	*theirscope;
--- 9047,9053 ----
  }
  
      static int
! find_match(int lookfor, linenr_T ourscope)
  {
      char_u	*look;
      pos_T	*theirscope;
***************
*** 9290,9296 ****
   * Get indent level from 'indentexpr'.
   */
      int
! get_expr_indent()
  {
      int		indent;
      pos_T	save_pos;
--- 9163,9169 ----
   * Get indent level from 'indentexpr'.
   */
      int
! get_expr_indent(void)
  {
      int		indent;
      pos_T	save_pos;
***************
*** 9340,9347 ****
  static int lisp_match(char_u *p);
  
      static int
! lisp_match(p)
!     char_u	*p;
  {
      char_u	buf[LSIZE];
      int		len;
--- 9213,9219 ----
  static int lisp_match(char_u *p);
  
      static int
! lisp_match(char_u *p)
  {
      char_u	buf[LSIZE];
      int		len;
***************
*** 9374,9380 ****
   * I tried to fix the first two issues.
   */
      int
! get_lisp_indent()
  {
      pos_T	*pos, realpos, paren;
      int		amount;
--- 9246,9252 ----
   * I tried to fix the first two issues.
   */
      int
! get_lisp_indent(void)
  {
      pos_T	*pos, realpos, paren;
      int		amount;
***************
*** 9560,9566 ****
  #endif /* FEAT_LISP */
  
      void
! prepare_to_exit()
  {
  #if defined(SIGHUP) && defined(SIG_IGN)
      /* Ignore SIGHUP, because a dropped connection causes a read error, which
--- 9432,9438 ----
  #endif /* FEAT_LISP */
  
      void
! prepare_to_exit(void)
  {
  #if defined(SIGHUP) && defined(SIG_IGN)
      /* Ignore SIGHUP, because a dropped connection causes a read error, which
***************
*** 9600,9606 ****
   * functions, such as allocating memory.
   */
      void
! preserve_exit()
  {
      buf_T	*buf;
  
--- 9472,9478 ----
   * functions, such as allocating memory.
   */
      void
! preserve_exit(void)
  {
      buf_T	*buf;
  
***************
*** 9639,9646 ****
   * return TRUE if "fname" exists.
   */
      int
! vim_fexists(fname)
!     char_u  *fname;
  {
      struct stat st;
  
--- 9511,9517 ----
   * return TRUE if "fname" exists.
   */
      int
! vim_fexists(char_u *fname)
  {
      struct stat st;
  
***************
*** 9667,9673 ****
  static int	breakcheck_count = 0;
  
      void
! line_breakcheck()
  {
      if (++breakcheck_count >= BREAKCHECK_SKIP)
      {
--- 9538,9544 ----
  static int	breakcheck_count = 0;
  
      void
! line_breakcheck(void)
  {
      if (++breakcheck_count >= BREAKCHECK_SKIP)
      {
***************
*** 9680,9686 ****
   * Like line_breakcheck() but check 10 times less often.
   */
      void
! fast_breakcheck()
  {
      if (++breakcheck_count >= BREAKCHECK_SKIP * 10)
      {
--- 9551,9557 ----
   * Like line_breakcheck() but check 10 times less often.
   */
      void
! fast_breakcheck(void)
  {
      if (++breakcheck_count >= BREAKCHECK_SKIP * 10)
      {
***************
*** 9695,9705 ****
   * Returns OK or FAIL.
   */
      int
! expand_wildcards_eval(pat, num_file, file, flags)
!     char_u	 **pat;		/* pointer to input pattern */
!     int		  *num_file;	/* resulting number of files */
!     char_u	***file;	/* array of resulting files */
!     int		   flags;	/* EW_DIR, etc. */
  {
      int		ret = FAIL;
      char_u	*eval_pat = NULL;
--- 9566,9576 ----
   * Returns OK or FAIL.
   */
      int
! expand_wildcards_eval(
!     char_u	 **pat,		/* pointer to input pattern */
!     int		  *num_file,	/* resulting number of files */
!     char_u	***file,	/* array of resulting files */
!     int		   flags)	/* EW_DIR, etc. */
  {
      int		ret = FAIL;
      char_u	*eval_pat = NULL;
***************
*** 9735,9746 ****
   * Returns OK or FAIL.  When FAIL then "num_files" won't be set.
   */
      int
! expand_wildcards(num_pat, pat, num_files, files, flags)
!     int		   num_pat;	/* number of input patterns */
!     char_u	 **pat;		/* array of input patterns */
!     int		  *num_files;	/* resulting number of files */
!     char_u	***files;	/* array of resulting files */
!     int		   flags;	/* EW_DIR, etc. */
  {
      int		retval;
      int		i, j;
--- 9606,9617 ----
   * Returns OK or FAIL.  When FAIL then "num_files" won't be set.
   */
      int
! expand_wildcards(
!     int		   num_pat,	/* number of input patterns */
!     char_u	 **pat,		/* array of input patterns */
!     int		  *num_files,	/* resulting number of files */
!     char_u	***files,	/* array of resulting files */
!     int		   flags)	/* EW_DIR, etc. */
  {
      int		retval;
      int		i, j;
***************
*** 9821,9828 ****
   * Return TRUE if "fname" matches with an entry in 'suffixes'.
   */
      int
! match_suffix(fname)
!     char_u	*fname;
  {
      int		fnamelen, setsuflen;
      char_u	*setsuf;
--- 9692,9698 ----
   * Return TRUE if "fname" matches with an entry in 'suffixes'.
   */
      int
! match_suffix(char_u *fname)
  {
      int		fnamelen, setsuflen;
      char_u	*setsuf;
***************
*** 10219,10226 ****
  static int	pstrcmp(const void *, const void *);
  
      static int
! pstrcmp(a, b)
!     const void *a, *b;
  {
      return (pathcmp(*(char **)a, *(char **)b, -1));
  }
--- 10089,10095 ----
  static int	pstrcmp(const void *, const void *);
  
      static int
! pstrcmp(const void *a, const void *b)
  {
      return (pathcmp(*(char **)a, *(char **)b, -1));
  }
***************
*** 10234,10245 ****
   * NOTE: much of this is identical to dos_expandpath(), keep in sync!
   */
      int
! unix_expandpath(gap, path, wildoff, flags, didstar)
!     garray_T	*gap;
!     char_u	*path;
!     int		wildoff;
!     int		flags;		/* EW_* flags */
!     int		didstar;	/* expanded "**" once already */
  {
      char_u	*buf;
      char_u	*path_end;
--- 10103,10114 ----
   * NOTE: much of this is identical to dos_expandpath(), keep in sync!
   */
      int
! unix_expandpath(
!     garray_T	*gap,
!     char_u	*path,
!     int		wildoff,
!     int		flags,		/* EW_* flags */
!     int		didstar)	/* expanded "**" once already */
  {
      char_u	*buf;
      char_u	*path_end;
***************
*** 10462,10470 ****
   * Returns FAIL is "*psep" ends up at the beginning of "path".
   */
      static int
! find_previous_pathsep(path, psep)
!     char_u *path;
!     char_u **psep;
  {
      /* skip the current separator */
      if (*psep > path && vim_ispathsep(**psep))
--- 10331,10337 ----
   * Returns FAIL is "*psep" ends up at the beginning of "path".
   */
      static int
! find_previous_pathsep(char_u *path, char_u **psep)
  {
      /* skip the current separator */
      if (*psep > path && vim_ispathsep(**psep))
***************
*** 10486,10495 ****
   * "maybe_unique" is the end portion of "((char_u **)gap->ga_data)[i]".
   */
      static int
! is_unique(maybe_unique, gap, i)
!     char_u	*maybe_unique;
!     garray_T	*gap;
!     int		i;
  {
      int	    j;
      int	    candidate_len;
--- 10353,10359 ----
   * "maybe_unique" is the end portion of "((char_u **)gap->ga_data)[i]".
   */
      static int
! is_unique(char_u *maybe_unique, garray_T *gap, int i)
  {
      int	    j;
      int	    candidate_len;
***************
*** 10526,10534 ****
   * expanding each into their equivalent path(s).
   */
      static void
! expand_path_option(curdir, gap)
!     char_u	*curdir;
!     garray_T	*gap;
  {
      char_u	*path_option = *curbuf->b_p_path == NUL
  						  ? p_path : curbuf->b_p_path;
--- 10390,10396 ----
   * expanding each into their equivalent path(s).
   */
      static void
! expand_path_option(char_u *curdir, garray_T *gap)
  {
      char_u	*path_option = *curbuf->b_p_path == NUL
  						  ? p_path : curbuf->b_p_path;
***************
*** 10608,10616 ****
   * returns:		 ^this
   */
      static char_u *
! get_path_cutoff(fname, gap)
!     char_u *fname;
!     garray_T *gap;
  {
      int	    i;
      int	    maxlen = 0;
--- 10470,10476 ----
   * returns:		 ^this
   */
      static char_u *
! get_path_cutoff(char_u *fname, garray_T *gap)
  {
      int	    i;
      int	    maxlen = 0;
***************
*** 10648,10656 ****
   * that matches the pattern. Beware, this is at least O(n^2) wrt "gap->ga_len".
   */
      static void
! uniquefy_paths(gap, pattern)
!     garray_T	*gap;
!     char_u	*pattern;
  {
      int		i;
      int		len;
--- 10508,10514 ----
   * that matches the pattern. Beware, this is at least O(n^2) wrt "gap->ga_len".
   */
      static void
! uniquefy_paths(garray_T *gap, char_u *pattern)
  {
      int		i;
      int		len;
***************
*** 10816,10825 ****
   * Returns the total number of matches.
   */
      static int
! expand_in_path(gap, pattern, flags)
!     garray_T	*gap;
!     char_u	*pattern;
!     int		flags;		/* EW_* flags */
  {
      char_u	*curdir;
      garray_T	path_ga;
--- 10674,10683 ----
   * Returns the total number of matches.
   */
      static int
! expand_in_path(
!     garray_T	*gap,
!     char_u	*pattern,
!     int		flags)		/* EW_* flags */
  {
      char_u	*curdir;
      garray_T	path_ga;
***************
*** 10853,10860 ****
   * list of file names in allocated memory.
   */
      void
! remove_duplicates(gap)
!     garray_T	*gap;
  {
      int	    i;
      int	    j;
--- 10711,10717 ----
   * list of file names in allocated memory.
   */
      void
! remove_duplicates(garray_T *gap)
  {
      int	    i;
      int	    j;
***************
*** 10879,10886 ****
   * Allowing for escaping.
   */
      static int
! has_env_var(p)
!     char_u *p;
  {
      for ( ; *p; mb_ptr_adv(p))
      {
--- 10736,10742 ----
   * Allowing for escaping.
   */
      static int
! has_env_var(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
***************
*** 10906,10913 ****
   * Allowing for escaping.
   */
      static int
! has_special_wildchar(p)
!     char_u  *p;
  {
      for ( ; *p; mb_ptr_adv(p))
      {
--- 10762,10768 ----
   * Allowing for escaping.
   */
      static int
! has_special_wildchar(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
***************
*** 10932,10943 ****
   * matches, "file" to the array of matches.  Call FreeWild() later.
   */
      int
! gen_expand_wildcards(num_pat, pat, num_file, file, flags)
!     int		num_pat;	/* number of input patterns */
!     char_u	**pat;		/* array of input patterns */
!     int		*num_file;	/* resulting number of files */
!     char_u	***file;	/* array of resulting files */
!     int		flags;		/* EW_* flags */
  {
      int			i;
      garray_T		ga;
--- 10787,10798 ----
   * matches, "file" to the array of matches.  Call FreeWild() later.
   */
      int
! gen_expand_wildcards(
!     int		num_pat,	/* number of input patterns */
!     char_u	**pat,		/* array of input patterns */
!     int		*num_file,	/* resulting number of files */
!     char_u	***file,	/* array of resulting files */
!     int		flags)		/* EW_* flags */
  {
      int			i;
      garray_T		ga;
***************
*** 11096,11103 ****
   * Return TRUE if we can expand this backtick thing here.
   */
      static int
! vim_backtick(p)
!     char_u	*p;
  {
      return (*p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`');
  }
--- 10951,10957 ----
   * Return TRUE if we can expand this backtick thing here.
   */
      static int
! vim_backtick(char_u *p)
  {
      return (*p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`');
  }
***************
*** 11108,11117 ****
   * Returns number of file names found, -1 if an error is encountered.
   */
      static int
! expand_backtick(gap, pat, flags)
!     garray_T	*gap;
!     char_u	*pat;
!     int		flags;	/* EW_* flags */
  {
      char_u	*p;
      char_u	*cmd;
--- 10962,10971 ----
   * Returns number of file names found, -1 if an error is encountered.
   */
      static int
! expand_backtick(
!     garray_T	*gap,
!     char_u	*pat,
!     int		flags)	/* EW_* flags */
  {
      char_u	*p;
      char_u	*cmd;
***************
*** 11171,11180 ****
   * EW_ALLLINKS	add symlink also when the referred file does not exist
   */
      void
! addfile(gap, f, flags)
!     garray_T	*gap;
!     char_u	*f;	/* filename */
!     int		flags;
  {
      char_u	*p;
      int		isdir;
--- 11025,11034 ----
   * EW_ALLLINKS	add symlink also when the referred file does not exist
   */
      void
! addfile(
!     garray_T	*gap,
!     char_u	*f,	/* filename */
!     int		flags)
  {
      char_u	*p;
      int		isdir;
***************
*** 11240,11250 ****
   * Returns an allocated string, or NULL for error.
   */
      char_u *
! get_cmd_output(cmd, infile, flags, ret_len)
!     char_u	*cmd;
!     char_u	*infile;	/* optional input file name */
!     int		flags;		/* can be SHELL_SILENT */
!     int		*ret_len;
  {
      char_u	*tempname;
      char_u	*command;
--- 11094,11104 ----
   * Returns an allocated string, or NULL for error.
   */
      char_u *
! get_cmd_output(
!     char_u	*cmd,
!     char_u	*infile,	/* optional input file name */
!     int		flags,		/* can be SHELL_SILENT */
!     int		*ret_len)
  {
      char_u	*tempname;
      char_u	*command;
***************
*** 11337,11345 ****
   * functions.
   */
      void
! FreeWild(count, files)
!     int	    count;
!     char_u  **files;
  {
      if (count <= 0 || files == NULL)
  	return;
--- 11191,11197 ----
   * functions.
   */
      void
! FreeWild(int count, char_u **files)
  {
      if (count <= 0 || files == NULL)
  	return;
***************
*** 11362,11368 ****
   * Don't do this when inside a ":normal" command.
   */
      int
! goto_im()
  {
      return (p_im && stuff_empty() && typebuf_typed());
  }
--- 11214,11220 ----
   * Don't do this when inside a ":normal" command.
   */
      int
! goto_im(void)
  {
      return (p_im && stuff_empty() && typebuf_typed());
  }
***************
*** 11376,11382 ****
   * But don't do that for Windows, it's common to have a space in the path.
   */
      char_u *
! get_isolated_shell_name()
  {
      char_u *p;
  
--- 11228,11234 ----
   * But don't do that for Windows, it's common to have a space in the path.
   */
      char_u *
! get_isolated_shell_name(void)
  {
      char_u *p;
  
*** ../vim-7.4.1210/src/misc2.c	2016-01-29 22:36:41.233047606 +0100
--- src/misc2.c	2016-01-30 19:09:35.908685438 +0100
***************
*** 23,29 ****
   * Return TRUE if in the current mode we need to use virtual.
   */
      int
! virtual_active()
  {
      /* While an operator is being executed we return "virtual_op", because
       * VIsual_active has already been reset, thus we can't check for "block"
--- 23,29 ----
   * Return TRUE if in the current mode we need to use virtual.
   */
      int
! virtual_active(void)
  {
      /* While an operator is being executed we return "virtual_op", because
       * VIsual_active has already been reset, thus we can't check for "block"
***************
*** 39,45 ****
   * Get the screen position of the cursor.
   */
      int
! getviscol()
  {
      colnr_T	x;
  
--- 39,45 ----
   * Get the screen position of the cursor.
   */
      int
! getviscol(void)
  {
      colnr_T	x;
  
***************
*** 51,59 ****
   * Get the screen position of character col with a coladd in the cursor line.
   */
      int
! getviscol2(col, coladd)
!     colnr_T	col;
!     colnr_T	coladd;
  {
      colnr_T	x;
      pos_T	pos;
--- 51,57 ----
   * Get the screen position of character col with a coladd in the cursor line.
   */
      int
! getviscol2(colnr_T col, colnr_T coladd)
  {
      colnr_T	x;
      pos_T	pos;
***************
*** 71,78 ****
   * The caller must have saved the cursor line for undo!
   */
      int
! coladvance_force(wcol)
!     colnr_T wcol;
  {
      int rc = coladvance2(&curwin->w_cursor, TRUE, FALSE, wcol);
  
--- 69,75 ----
   * The caller must have saved the cursor line for undo!
   */
      int
! coladvance_force(colnr_T wcol)
  {
      int rc = coladvance2(&curwin->w_cursor, TRUE, FALSE, wcol);
  
***************
*** 98,105 ****
   * return OK if desired column is reached, FAIL if not
   */
      int
! coladvance(wcol)
!     colnr_T	wcol;
  {
      int rc = getvpos(&curwin->w_cursor, wcol);
  
--- 95,101 ----
   * return OK if desired column is reached, FAIL if not
   */
      int
! coladvance(colnr_T wcol)
  {
      int rc = getvpos(&curwin->w_cursor, wcol);
  
***************
*** 119,138 ****
   * return OK if desired column is reached, FAIL if not
   */
      int
! getvpos(pos, wcol)
!     pos_T   *pos;
!     colnr_T wcol;
  {
  #ifdef FEAT_VIRTUALEDIT
      return coladvance2(pos, FALSE, virtual_active(), wcol);
  }
  
      static int
! coladvance2(pos, addspaces, finetune, wcol)
!     pos_T	*pos;
!     int		addspaces;	/* change the text to achieve our goal? */
!     int		finetune;	/* change char offset for the exact column */
!     colnr_T	wcol;		/* column to move to */
  {
  #endif
      int		idx;
--- 115,132 ----
   * return OK if desired column is reached, FAIL if not
   */
      int
! getvpos(pos_T *pos, colnr_T wcol)
  {
  #ifdef FEAT_VIRTUALEDIT
      return coladvance2(pos, FALSE, virtual_active(), wcol);
  }
  
      static int
! coladvance2(
!     pos_T	*pos,
!     int		addspaces,	/* change the text to achieve our goal? */
!     int		finetune,	/* change char offset for the exact column */
!     colnr_T	wcol)		/* column to move to */
  {
  #endif
      int		idx;
***************
*** 341,347 ****
   * Increment the cursor position.  See inc() for return values.
   */
      int
! inc_cursor()
  {
      return inc(&curwin->w_cursor);
  }
--- 335,341 ----
   * Increment the cursor position.  See inc() for return values.
   */
      int
! inc_cursor(void)
  {
      return inc(&curwin->w_cursor);
  }
***************
*** 354,361 ****
   * Return 0 otherwise.
   */
      int
! inc(lp)
!     pos_T  *lp;
  {
      char_u  *p = ml_get_pos(lp);
  
--- 348,354 ----
   * Return 0 otherwise.
   */
      int
! inc(pos_T *lp)
  {
      char_u  *p = ml_get_pos(lp);
  
***************
*** 392,399 ****
   * incl(lp): same as inc(), but skip the NUL at the end of non-empty lines
   */
      int
! incl(lp)
!     pos_T    *lp;
  {
      int	    r;
  
--- 385,391 ----
   * incl(lp): same as inc(), but skip the NUL at the end of non-empty lines
   */
      int
! incl(pos_T *lp)
  {
      int	    r;
  
***************
*** 409,422 ****
   * Return 1 when crossing a line, -1 when at start of file, 0 otherwise.
   */
      int
! dec_cursor()
  {
!     return dec(&curwin->w_cursor);
  }
  
      int
! dec(lp)
!     pos_T  *lp;
  {
      char_u	*p;
  
--- 401,413 ----
   * Return 1 when crossing a line, -1 when at start of file, 0 otherwise.
   */
      int
! dec_cursor(void)
  {
!  return dec(&curwin->w_cursor);
  }
  
      int
! dec(pos_T *lp)
  {
      char_u	*p;
  
***************
*** 453,460 ****
   * decl(lp): same as dec(), but skip the NUL at the end of non-empty lines
   */
      int
! decl(lp)
!     pos_T    *lp;
  {
      int	    r;
  
--- 444,450 ----
   * decl(lp): same as dec(), but skip the NUL at the end of non-empty lines
   */
      int
! decl(pos_T *lp)
  {
      int	    r;
  
***************
*** 469,477 ****
   * can be visible, folded lines don't count.
   */
      linenr_T
! get_cursor_rel_lnum(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;		    /* line number to get the result for */
  {
      linenr_T	cursor = wp->w_cursor.lnum;
      linenr_T	retval = 0;
--- 459,467 ----
   * can be visible, folded lines don't count.
   */
      linenr_T
! get_cursor_rel_lnum(
!     win_T	*wp,
!     linenr_T	lnum)		    /* line number to get the result for */
  {
      linenr_T	cursor = wp->w_cursor.lnum;
      linenr_T	retval = 0;
***************
*** 518,524 ****
   * Make sure curwin->w_cursor.lnum is valid.
   */
      void
! check_cursor_lnum()
  {
      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
      {
--- 508,514 ----
   * Make sure curwin->w_cursor.lnum is valid.
   */
      void
! check_cursor_lnum(void)
  {
      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
      {
***************
*** 538,544 ****
   * Make sure curwin->w_cursor.col is valid.
   */
      void
! check_cursor_col()
  {
      check_cursor_col_win(curwin);
  }
--- 528,534 ----
   * Make sure curwin->w_cursor.col is valid.
   */
      void
! check_cursor_col(void)
  {
      check_cursor_col_win(curwin);
  }
***************
*** 547,554 ****
   * Make sure win->w_cursor.col is valid.
   */
      void
! check_cursor_col_win(win)
!     win_T *win;
  {
      colnr_T len;
  #ifdef FEAT_VIRTUALEDIT
--- 537,543 ----
   * Make sure win->w_cursor.col is valid.
   */
      void
! check_cursor_col_win(win_T *win)
  {
      colnr_T len;
  #ifdef FEAT_VIRTUALEDIT
***************
*** 606,612 ****
   * make sure curwin->w_cursor in on a valid character
   */
      void
! check_cursor()
  {
      check_cursor_lnum();
      check_cursor_col();
--- 595,601 ----
   * make sure curwin->w_cursor in on a valid character
   */
      void
! check_cursor(void)
  {
      check_cursor_lnum();
      check_cursor_col();
***************
*** 618,624 ****
   * Allow it when in Visual mode and 'selection' is not "old".
   */
      void
! adjust_cursor_col()
  {
      if (curwin->w_cursor.col > 0
  	    && (!VIsual_active || *p_sel == 'o')
--- 607,613 ----
   * Allow it when in Visual mode and 'selection' is not "old".
   */
      void
! adjust_cursor_col(void)
  {
      if (curwin->w_cursor.col > 0
  	    && (!VIsual_active || *p_sel == 'o')
***************
*** 632,638 ****
   * Return TRUE if the cursor was moved.
   */
      int
! leftcol_changed()
  {
      long	lastcol;
      colnr_T	s, e;
--- 621,627 ----
   * Return TRUE if the cursor was moved.
   */
      int
! leftcol_changed(void)
  {
      long	lastcol;
      colnr_T	s, e;
***************
*** 705,727 ****
  static void mem_pre_free(void **pp);
  
      static void
! mem_pre_alloc_s(sizep)
!     size_t *sizep;
  {
      *sizep += sizeof(size_t);
  }
  
      static void
! mem_pre_alloc_l(sizep)
!     long_u *sizep;
  {
      *sizep += sizeof(size_t);
  }
  
      static void
! mem_post_alloc(pp, size)
!     void **pp;
!     size_t size;
  {
      if (*pp == NULL)
  	return;
--- 694,714 ----
  static void mem_pre_free(void **pp);
  
      static void
! mem_pre_alloc_s(size_t *sizep)
  {
      *sizep += sizeof(size_t);
  }
  
      static void
! mem_pre_alloc_l(long_u *sizep)
  {
      *sizep += sizeof(size_t);
  }
  
      static void
! mem_post_alloc(
!     void **pp,
!     size_t size)
  {
      if (*pp == NULL)
  	return;
***************
*** 739,746 ****
  }
  
      static void
! mem_pre_free(pp)
!     void **pp;
  {
      long_u size;
  
--- 726,732 ----
  }
  
      static void
! mem_pre_free(void **pp)
  {
      long_u size;
  
***************
*** 758,764 ****
   * called on exit via atexit()
   */
      void
! vim_mem_profile_dump()
  {
      int i, j;
  
--- 744,750 ----
   * called on exit via atexit()
   */
      void
! vim_mem_profile_dump(void)
  {
      int i, j;
  
***************
*** 801,808 ****
  static int alloc_does_fail(long_u size);
  
      static int
! alloc_does_fail(size)
!     long_u size;
  {
      if (alloc_fail_countdown == 0)
      {
--- 787,793 ----
  static int alloc_does_fail(long_u size);
  
      static int
! alloc_does_fail(long_u size)
  {
      if (alloc_fail_countdown == 0)
      {
***************
*** 833,840 ****
   * Use lalloc for larger blocks.
   */
      char_u *
! alloc(size)
!     unsigned	    size;
  {
      return (lalloc((long_u)size, TRUE));
  }
--- 818,824 ----
   * Use lalloc for larger blocks.
   */
      char_u *
! alloc(unsigned size)
  {
      return (lalloc((long_u)size, TRUE));
  }
***************
*** 843,851 ****
   * alloc() with an ID for alloc_fail().
   */
      char_u *
! alloc_id(size, id)
!     unsigned	size;
!     alloc_id_T	id UNUSED;
  {
  #ifdef FEAT_EVAL
      if (alloc_fail_id == id && alloc_does_fail((long_u)size))
--- 827,833 ----
   * alloc() with an ID for alloc_fail().
   */
      char_u *
! alloc_id(unsigned size, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
      if (alloc_fail_id == id && alloc_does_fail((long_u)size))
***************
*** 858,865 ****
   * Allocate memory and set all bytes to zero.
   */
      char_u *
! alloc_clear(size)
!     unsigned	    size;
  {
      char_u *p;
  
--- 840,846 ----
   * Allocate memory and set all bytes to zero.
   */
      char_u *
! alloc_clear(unsigned size)
  {
      char_u *p;
  
***************
*** 873,880 ****
   * alloc() with check for maximum line length
   */
      char_u *
! alloc_check(size)
!     unsigned	    size;
  {
  #if !defined(UNIX) && !defined(__EMX__)
      if (sizeof(int) == 2 && size > 0x7fff)
--- 854,860 ----
   * alloc() with check for maximum line length
   */
      char_u *
! alloc_check(unsigned size)
  {
  #if !defined(UNIX) && !defined(__EMX__)
      if (sizeof(int) == 2 && size > 0x7fff)
***************
*** 892,900 ****
   * Allocate memory like lalloc() and set all bytes to zero.
   */
      char_u *
! lalloc_clear(size, message)
!     long_u	size;
!     int		message;
  {
      char_u *p;
  
--- 872,878 ----
   * Allocate memory like lalloc() and set all bytes to zero.
   */
      char_u *
! lalloc_clear(long_u size, int message)
  {
      char_u *p;
  
***************
*** 909,917 ****
   * This is used often, KEEP IT FAST!
   */
      char_u *
! lalloc(size, message)
!     long_u	size;
!     int		message;
  {
      char_u	*p;		    /* pointer to new storage space */
      static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
--- 887,893 ----
   * This is used often, KEEP IT FAST!
   */
      char_u *
! lalloc(long_u size, int message)
  {
      char_u	*p;		    /* pointer to new storage space */
      static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
***************
*** 1006,1015 ****
   * lalloc() with an ID for alloc_fail().
   */
      char_u *
! lalloc_id(size, message, id)
!     long_u	size;
!     int		message;
!     alloc_id_T	id UNUSED;
  {
  #ifdef FEAT_EVAL
      if (alloc_fail_id == id && alloc_does_fail(size))
--- 982,988 ----
   * lalloc() with an ID for alloc_fail().
   */
      char_u *
! lalloc_id(long_u size, int message, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
      if (alloc_fail_id == id && alloc_does_fail(size))
***************
*** 1023,1031 ****
   * realloc() with memory profiling.
   */
      void *
! mem_realloc(ptr, size)
!     void *ptr;
!     size_t size;
  {
      void *p;
  
--- 996,1002 ----
   * realloc() with memory profiling.
   */
      void *
! mem_realloc(void *ptr, size_t size)
  {
      void *p;
  
***************
*** 1045,1052 ****
  * Did_outofmem_msg is reset when a character is read.
  */
      void
! do_outofmem_msg(size)
!     long_u	size;
  {
      if (!did_outofmem_msg)
      {
--- 1016,1022 ----
  * Did_outofmem_msg is reset when a character is read.
  */
      void
! do_outofmem_msg(long_u size)
  {
      if (!did_outofmem_msg)
      {
***************
*** 1075,1081 ****
   * Some things can't be freed, esp. things local to a library function.
   */
      void
! free_all_mem()
  {
      buf_T	*buf, *nextbuf;
      static int	entered = FALSE;
--- 1045,1051 ----
   * Some things can't be freed, esp. things local to a library function.
   */
      void
! free_all_mem(void)
  {
      buf_T	*buf, *nextbuf;
      static int	entered = FALSE;
***************
*** 1283,1290 ****
   * Copy "string" into newly allocated memory.
   */
      char_u *
! vim_strsave(string)
!     char_u	*string;
  {
      char_u	*p;
      unsigned	len;
--- 1253,1259 ----
   * Copy "string" into newly allocated memory.
   */
      char_u *
! vim_strsave(char_u *string)
  {
      char_u	*p;
      unsigned	len;
***************
*** 1303,1311 ****
   * shorter.
   */
      char_u *
! vim_strnsave(string, len)
!     char_u	*string;
!     int		len;
  {
      char_u	*p;
  
--- 1272,1278 ----
   * shorter.
   */
      char_u *
! vim_strnsave(char_u *string, int len)
  {
      char_u	*p;
  
***************
*** 1323,1331 ****
   * by a backslash.
   */
      char_u *
! vim_strsave_escaped(string, esc_chars)
!     char_u	*string;
!     char_u	*esc_chars;
  {
      return vim_strsave_escaped_ext(string, esc_chars, '\\', FALSE);
  }
--- 1290,1296 ----
   * by a backslash.
   */
      char_u *
! vim_strsave_escaped(char_u *string, char_u *esc_chars)
  {
      return vim_strsave_escaped_ext(string, esc_chars, '\\', FALSE);
  }
***************
*** 1336,1346 ****
   * Escape the characters with "cc".
   */
      char_u *
! vim_strsave_escaped_ext(string, esc_chars, cc, bsl)
!     char_u	*string;
!     char_u	*esc_chars;
!     int		cc;
!     int		bsl;
  {
      char_u	*p;
      char_u	*p2;
--- 1301,1311 ----
   * Escape the characters with "cc".
   */
      char_u *
! vim_strsave_escaped_ext(
!     char_u	*string,
!     char_u	*esc_chars,
!     int		cc,
!     int		bsl)
  {
      char_u	*p;
      char_u	*p2;
***************
*** 1397,1403 ****
   * Return TRUE when 'shell' has "csh" in the tail.
   */
      int
! csh_like_shell()
  {
      return (strstr((char *)gettail(p_sh), "csh") != NULL);
  }
--- 1362,1368 ----
   * Return TRUE when 'shell' has "csh" in the tail.
   */
      int
! csh_like_shell(void)
  {
      return (strstr((char *)gettail(p_sh), "csh") != NULL);
  }
***************
*** 1413,1422 ****
   * Returns the result in allocated memory, NULL if we have run out.
   */
      char_u *
! vim_strsave_shellescape(string, do_special, do_newline)
!     char_u	*string;
!     int		do_special;
!     int		do_newline;
  {
      unsigned	length;
      char_u	*p;
--- 1378,1384 ----
   * Returns the result in allocated memory, NULL if we have run out.
   */
      char_u *
! vim_strsave_shellescape(char_u *string, int do_special, int do_newline)
  {
      unsigned	length;
      char_u	*p;
***************
*** 1535,1542 ****
   * This uses ASCII lower-to-upper case translation, language independent.
   */
      char_u *
! vim_strsave_up(string)
!     char_u	*string;
  {
      char_u *p1;
  
--- 1497,1503 ----
   * This uses ASCII lower-to-upper case translation, language independent.
   */
      char_u *
! vim_strsave_up(char_u *string)
  {
      char_u *p1;
  
***************
*** 1550,1558 ****
   * This uses ASCII lower-to-upper case translation, language independent.
   */
      char_u *
! vim_strnsave_up(string, len)
!     char_u	*string;
!     int		len;
  {
      char_u *p1;
  
--- 1511,1517 ----
   * This uses ASCII lower-to-upper case translation, language independent.
   */
      char_u *
! vim_strnsave_up(char_u *string, int len)
  {
      char_u *p1;
  
***************
*** 1565,1572 ****
   * ASCII lower-to-upper case translation, language independent.
   */
      void
! vim_strup(p)
!     char_u	*p;
  {
      char_u  *p2;
      int	    c;
--- 1524,1531 ----
   * ASCII lower-to-upper case translation, language independent.
   */
      void
! vim_strup(
!     char_u	*p)
  {
      char_u  *p2;
      int	    c;
***************
*** 1590,1597 ****
   * Returns NULL when out of memory.
   */
      char_u *
! strup_save(orig)
!     char_u	*orig;
  {
      char_u	*p;
      char_u	*res;
--- 1549,1555 ----
   * Returns NULL when out of memory.
   */
      char_u *
! strup_save(char_u *orig)
  {
      char_u	*p;
      char_u	*res;
***************
*** 1650,1657 ****
   * delete spaces at the end of a string
   */
      void
! del_trailing_spaces(ptr)
!     char_u	*ptr;
  {
      char_u	*q;
  
--- 1608,1614 ----
   * delete spaces at the end of a string
   */
      void
! del_trailing_spaces(char_u *ptr)
  {
      char_u	*q;
  
***************
*** 1665,1674 ****
   * "to" must be "len + 1" long!
   */
      void
! vim_strncpy(to, from, len)
!     char_u	*to;
!     char_u	*from;
!     size_t	len;
  {
      STRNCPY(to, from, len);
      to[len] = NUL;
--- 1622,1628 ----
   * "to" must be "len + 1" long!
   */
      void
! vim_strncpy(char_u *to, char_u *from, size_t len)
  {
      STRNCPY(to, from, len);
      to[len] = NUL;
***************
*** 1679,1688 ****
   * always NUL terminated.
   */
      void
! vim_strcat(to, from, tosize)
!     char_u	*to;
!     char_u	*from;
!     size_t	tosize;
  {
      size_t tolen = STRLEN(to);
      size_t fromlen = STRLEN(from);
--- 1633,1639 ----
   * always NUL terminated.
   */
      void
! vim_strcat(char_u *to, char_u *from, size_t tosize)
  {
      size_t tolen = STRLEN(to);
      size_t fromlen = STRLEN(from);
***************
*** 1704,1714 ****
   * The length is returned.
   */
      int
! copy_option_part(option, buf, maxlen, sep_chars)
!     char_u	**option;
!     char_u	*buf;
!     int		maxlen;
!     char	*sep_chars;
  {
      int	    len = 0;
      char_u  *p = *option;
--- 1655,1665 ----
   * The length is returned.
   */
      int
! copy_option_part(
!     char_u	**option,
!     char_u	*buf,
!     int		maxlen,
!     char	*sep_chars)
  {
      int	    len = 0;
      char_u  *p = *option;
***************
*** 1743,1750 ****
   * signal that was caused by a crash in free().
   */
      void
! vim_free(x)
!     void *x;
  {
      if (x != NULL && !really_exiting)
      {
--- 1694,1700 ----
   * signal that was caused by a crash in free().
   */
      void
! vim_free(void *x)
  {
      if (x != NULL && !really_exiting)
      {
***************
*** 1757,1766 ****
  
  #ifndef HAVE_MEMSET
      void *
! vim_memset(ptr, c, size)
!     void    *ptr;
!     int	    c;
!     size_t  size;
  {
      char *p = ptr;
  
--- 1707,1713 ----
  
  #ifndef HAVE_MEMSET
      void *
! vim_memset(void *ptr, int c, size_t size)
  {
      char *p = ptr;
  
***************
*** 1776,1785 ****
   * Return non-zero otherwise.
   */
      int
! vim_memcmp(b1, b2, len)
!     void    *b1;
!     void    *b2;
!     size_t  len;
  {
      char_u  *p1 = (char_u *)b1, *p2 = (char_u *)b2;
  
--- 1723,1729 ----
   * Return non-zero otherwise.
   */
      int
! vim_memcmp(void *b1, void *b2, size_t len)
  {
      char_u  *p1 = (char_u *)b1, *p2 = (char_u *)b2;
  
***************
*** 1800,1808 ****
   * For systems that don't have a function that is guaranteed to do that (SYSV).
   */
      void
! mch_memmove(dst_arg, src_arg, len)
!     void    *src_arg, *dst_arg;
!     size_t  len;
  {
      /*
       * A void doesn't have a size, we use char pointers.
--- 1744,1750 ----
   * For systems that don't have a function that is guaranteed to do that (SYSV).
   */
      void
! mch_memmove(void *src_arg, *dst_arg, size_t len)
  {
      /*
       * A void doesn't have a size, we use char pointers.
***************
*** 1830,1838 ****
   * return 0 for match, < 0 for smaller, > 0 for bigger
   */
      int
! vim_stricmp(s1, s2)
!     char	*s1;
!     char	*s2;
  {
      int		i;
  
--- 1772,1778 ----
   * return 0 for match, < 0 for smaller, > 0 for bigger
   */
      int
! vim_stricmp(char *s1, char *s2)
  {
      int		i;
  
***************
*** 1857,1866 ****
   * return 0 for match, < 0 for smaller, > 0 for bigger
   */
      int
! vim_strnicmp(s1, s2, len)
!     char	*s1;
!     char	*s2;
!     size_t	len;
  {
      int		i;
  
--- 1797,1803 ----
   * return 0 for match, < 0 for smaller, > 0 for bigger
   */
      int
! vim_strnicmp(char *s1, char *s2, size_t len)
  {
      int		i;
  
***************
*** 1885,1893 ****
   * pointer to the NUL at the end of the string.
   */
      char_u  *
! vim_strchr(string, c)
!     char_u	*string;
!     int		c;
  {
      char_u	*p;
      int		b;
--- 1822,1828 ----
   * pointer to the NUL at the end of the string.
   */
      char_u  *
! vim_strchr(char_u *string, int c)
  {
      char_u	*p;
      int		b;
***************
*** 1946,1954 ****
   * pointer to the NUL at the end of the string.
   */
      char_u  *
! vim_strbyte(string, c)
!     char_u	*string;
!     int		c;
  {
      char_u	*p = string;
  
--- 1881,1887 ----
   * pointer to the NUL at the end of the string.
   */
      char_u  *
! vim_strbyte(char_u *string, int c)
  {
      char_u	*p = string;
  
***************
*** 1967,1975 ****
   * Does not handle multi-byte char for "c"!
   */
      char_u  *
! vim_strrchr(string, c)
!     char_u	*string;
!     int		c;
  {
      char_u	*retval = NULL;
      char_u	*p = string;
--- 1900,1906 ----
   * Does not handle multi-byte char for "c"!
   */
      char_u  *
! vim_strrchr(char_u *string, int c)
  {
      char_u	*retval = NULL;
      char_u	*p = string;
***************
*** 1993,2001 ****
  #   undef vim_strpbrk
  #  endif
      char_u *
! vim_strpbrk(s, charset)
!     char_u	*s;
!     char_u	*charset;
  {
      while (*s)
      {
--- 1924,1930 ----
  #   undef vim_strpbrk
  #  endif
      char_u *
! vim_strpbrk(char_u *s, char_u *charset)
  {
      while (*s)
      {
***************
*** 2013,2020 ****
   * can't handle characters above 128.
   */
      int
! vim_isspace(x)
!     int	    x;
  {
      return ((x >= 9 && x <= 13) || x == ' ');
  }
--- 1942,1948 ----
   * can't handle characters above 128.
   */
      int
! vim_isspace(int x)
  {
      return ((x >= 9 && x <= 13) || x == ' ');
  }
***************
*** 2027,2034 ****
   * Clear an allocated growing array.
   */
      void
! ga_clear(gap)
!     garray_T *gap;
  {
      vim_free(gap->ga_data);
      ga_init(gap);
--- 1955,1961 ----
   * Clear an allocated growing array.
   */
      void
! ga_clear(garray_T *gap)
  {
      vim_free(gap->ga_data);
      ga_init(gap);
***************
*** 2038,2045 ****
   * Clear a growing array that contains a list of strings.
   */
      void
! ga_clear_strings(gap)
!     garray_T *gap;
  {
      int		i;
  
--- 1965,1971 ----
   * Clear a growing array that contains a list of strings.
   */
      void
! ga_clear_strings(garray_T *gap)
  {
      int		i;
  
***************
*** 2053,2060 ****
   * ga_growsize!  Or use ga_init2().
   */
      void
! ga_init(gap)
!     garray_T *gap;
  {
      gap->ga_data = NULL;
      gap->ga_maxlen = 0;
--- 1979,1985 ----
   * ga_growsize!  Or use ga_init2().
   */
      void
! ga_init(garray_T *gap)
  {
      gap->ga_data = NULL;
      gap->ga_maxlen = 0;
***************
*** 2062,2071 ****
  }
  
      void
! ga_init2(gap, itemsize, growsize)
!     garray_T	*gap;
!     int		itemsize;
!     int		growsize;
  {
      ga_init(gap);
      gap->ga_itemsize = itemsize;
--- 1987,1993 ----
  }
  
      void
! ga_init2(garray_T *gap, int itemsize, int growsize)
  {
      ga_init(gap);
      gap->ga_itemsize = itemsize;
***************
*** 2077,2085 ****
   * Return FAIL for failure, OK otherwise.
   */
      int
! ga_grow(gap, n)
!     garray_T	*gap;
!     int		n;
  {
      size_t	old_len;
      size_t	new_len;
--- 1999,2005 ----
   * Return FAIL for failure, OK otherwise.
   */
      int
! ga_grow(garray_T *gap, int n)
  {
      size_t	old_len;
      size_t	new_len;
***************
*** 2108,2116 ****
   * Returns NULL when out of memory.
   */
      char_u *
! ga_concat_strings(gap, sep)
!     garray_T *gap;
!     char     *sep;
  {
      int		i;
      int		len = 0;
--- 2028,2034 ----
   * Returns NULL when out of memory.
   */
      char_u *
! ga_concat_strings(garray_T *gap, char *sep)
  {
      int		i;
      int		len = 0;
***************
*** 2166,2174 ****
   * Note: Does NOT copy the NUL at the end!
   */
      void
! ga_concat(gap, s)
!     garray_T	*gap;
!     char_u	*s;
  {
      int    len;
  
--- 2084,2090 ----
   * Note: Does NOT copy the NUL at the end!
   */
      void
! ga_concat(garray_T *gap, char_u *s)
  {
      int    len;
  
***************
*** 2186,2194 ****
   * Append one byte to a growarray which contains bytes.
   */
      void
! ga_append(gap, c)
!     garray_T	*gap;
!     int		c;
  {
      if (ga_grow(gap, 1) == OK)
      {
--- 2102,2108 ----
   * Append one byte to a growarray which contains bytes.
   */
      void
! ga_append(garray_T *gap, int c)
  {
      if (ga_grow(gap, 1) == OK)
      {
***************
*** 2203,2210 ****
   * Append the text in "gap" below the cursor line and clear "gap".
   */
      void
! append_ga_line(gap)
!     garray_T	*gap;
  {
      /* Remove trailing CR. */
      if (gap->ga_len > 0
--- 2117,2123 ----
   * Append the text in "gap" below the cursor line and clear "gap".
   */
      void
! append_ga_line(garray_T *gap)
  {
      /* Remove trailing CR. */
      if (gap->ga_len > 0
***************
*** 2560,2567 ****
   * modifier name ('S' for Shift, 'C' for Ctrl etc).
   */
      int
! name_to_mod_mask(c)
!     int	    c;
  {
      int	    i;
  
--- 2473,2479 ----
   * modifier name ('S' for Shift, 'C' for Ctrl etc).
   */
      int
! name_to_mod_mask(int c)
  {
      int	    i;
  
***************
*** 2577,2585 ****
   * modifiers specified.
   */
      int
! simplify_key(key, modifiers)
!     int	    key;
!     int	    *modifiers;
  {
      int	    i;
      int	    key0;
--- 2489,2495 ----
   * modifiers specified.
   */
      int
! simplify_key(int key, int *modifiers)
  {
      int	    i;
      int	    key0;
***************
*** 2612,2619 ****
   * Change <xHome> to <Home>, <xUp> to <Up>, etc.
   */
      int
! handle_x_keys(key)
!     int	    key;
  {
      switch (key)
      {
--- 2522,2528 ----
   * Change <xHome> to <Home>, <xUp> to <Up>, etc.
   */
      int
! handle_x_keys(int key)
  {
      switch (key)
      {
***************
*** 2642,2650 ****
   * modifiers are down.
   */
      char_u *
! get_special_key_name(c, modifiers)
!     int	    c;
!     int	    modifiers;
  {
      static char_u string[MAX_KEY_NAME_LEN + 1];
  
--- 2551,2557 ----
   * modifiers are down.
   */
      char_u *
! get_special_key_name(int c, int modifiers)
  {
      static char_u string[MAX_KEY_NAME_LEN + 1];
  
***************
*** 2762,2771 ****
   * dst[] must be big enough to hold the result (up to six characters)!
   */
      int
! trans_special(srcp, dst, keycode)
!     char_u	**srcp;
!     char_u	*dst;
!     int		keycode; /* prefer key code, e.g. K_DEL instead of DEL */
  {
      int		modifiers = 0;
      int		key;
--- 2669,2678 ----
   * dst[] must be big enough to hold the result (up to six characters)!
   */
      int
! trans_special(
!     char_u	**srcp,
!     char_u	*dst,
!     int		keycode) /* prefer key code, e.g. K_DEL instead of DEL */
  {
      int		modifiers = 0;
      int		key;
***************
*** 2807,2817 ****
   * returns 0 if there is no match.
   */
      int
! find_special_key(srcp, modp, keycode, keep_x_key)
!     char_u	**srcp;
!     int		*modp;
!     int		keycode;     /* prefer key code, e.g. K_DEL instead of DEL */
!     int		keep_x_key;  /* don't translate xHome to Home key */
  {
      char_u	*last_dash;
      char_u	*end_of_name;
--- 2714,2724 ----
   * returns 0 if there is no match.
   */
      int
! find_special_key(
!     char_u	**srcp,
!     int		*modp,
!     int		keycode,     /* prefer key code, e.g. K_DEL instead of DEL */
!     int		keep_x_key)  /* don't translate xHome to Home key */
  {
      char_u	*last_dash;
      char_u	*end_of_name;
***************
*** 2947,2955 ****
   * Changes "Shift-a" to 'A', "Alt-A" to 0xc0, etc.
   */
      int
! extract_modifiers(key, modp)
!     int	    key;
!     int	    *modp;
  {
      int	modifiers = *modp;
  
--- 2854,2860 ----
   * Changes "Shift-a" to 'A', "Alt-A" to 0xc0, etc.
   */
      int
! extract_modifiers(int key, int *modp)
  {
      int	modifiers = *modp;
  
***************
*** 3003,3010 ****
   * Return the index when found, -1 when not found.
   */
      int
! find_special_key_in_table(c)
!     int	    c;
  {
      int	    i;
  
--- 2908,2914 ----
   * Return the index when found, -1 when not found.
   */
      int
! find_special_key_in_table(int c)
  {
      int	    i;
  
***************
*** 3024,3031 ****
   * Return the key code, or 0 if not found.
   */
      int
! get_special_key_code(name)
!     char_u  *name;
  {
      char_u  *table_name;
      char_u  string[3];
--- 2928,2934 ----
   * Return the key code, or 0 if not found.
   */
      int
! get_special_key_code(char_u *name)
  {
      char_u  *table_name;
      char_u  string[3];
***************
*** 3057,3064 ****
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      char_u *
! get_key_name(i)
!     int	    i;
  {
      if (i >= (int)KEY_NAMES_TABLE_LEN)
  	return NULL;
--- 2960,2966 ----
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      char_u *
! get_key_name(int i)
  {
      if (i >= (int)KEY_NAMES_TABLE_LEN)
  	return NULL;
***************
*** 3072,3081 ****
   * arguments.  Return which button is down or was released.
   */
      int
! get_mouse_button(code, is_click, is_drag)
!     int	    code;
!     int	    *is_click;
!     int	    *is_drag;
  {
      int	    i;
  
--- 2974,2980 ----
   * arguments.  Return which button is down or was released.
   */
      int
! get_mouse_button(int code, int *is_click, int *is_drag)
  {
      int	    i;
  
***************
*** 3095,3104 ****
   * mouse was clicked, dragged or released.
   */
      int
! get_pseudo_mouse_code(button, is_click, is_drag)
!     int	    button;	/* eg MOUSE_LEFT */
!     int	    is_click;
!     int	    is_drag;
  {
      int	    i;
  
--- 2994,3003 ----
   * mouse was clicked, dragged or released.
   */
      int
! get_pseudo_mouse_code(
!     int	    button,	/* eg MOUSE_LEFT */
!     int	    is_click,
!     int	    is_drag)
  {
      int	    i;
  
***************
*** 3133,3140 ****
   * Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.
   */
      int
! get_fileformat(buf)
!     buf_T	*buf;
  {
      int		c = *buf->b_p_ff;
  
--- 3032,3038 ----
   * Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.
   */
      int
! get_fileformat(buf_T *buf)
  {
      int		c = *buf->b_p_ff;
  
***************
*** 3150,3158 ****
   * argument.
   */
      int
! get_fileformat_force(buf, eap)
!     buf_T	*buf;
!     exarg_T	*eap;	    /* can be NULL! */
  {
      int		c;
  
--- 3048,3056 ----
   * argument.
   */
      int
! get_fileformat_force(
!     buf_T	*buf,
!     exarg_T	*eap)	    /* can be NULL! */
  {
      int		c;
  
***************
*** 3178,3186 ****
   * Note: Does _not_ set global value of 'textmode'!
   */
      void
! set_fileformat(t, opt_flags)
!     int		t;
!     int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char	*p = NULL;
  
--- 3076,3084 ----
   * Note: Does _not_ set global value of 'textmode'!
   */
      void
! set_fileformat(
!     int		t,
!     int		opt_flags)	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char	*p = NULL;
  
***************
*** 3217,3223 ****
   * Return the default fileformat from 'fileformats'.
   */
      int
! default_fileformat()
  {
      switch (*p_ffs)
      {
--- 3115,3121 ----
   * Return the default fileformat from 'fileformats'.
   */
      int
! default_fileformat(void)
  {
      switch (*p_ffs)
      {
***************
*** 3231,3239 ****
   * Call shell.	Calls mch_call_shell, with 'shellxquote' added.
   */
      int
! call_shell(cmd, opt)
!     char_u	*cmd;
!     int		opt;
  {
      char_u	*ncmd;
      int		retval;
--- 3129,3135 ----
   * Call shell.	Calls mch_call_shell, with 'shellxquote' added.
   */
      int
! call_shell(char_u *cmd, int opt)
  {
      char_u	*ncmd;
      int		retval;
***************
*** 3329,3335 ****
   * NORMAL State with a condition.  This function returns the real State.
   */
      int
! get_real_state()
  {
      if (State & NORMAL)
      {
--- 3225,3231 ----
   * NORMAL State with a condition.  This function returns the real State.
   */
      int
! get_real_state(void)
  {
      if (State & NORMAL)
      {
***************
*** 3352,3360 ****
   * "b" must point to the start of the file name
   */
      int
! after_pathsep(b, p)
!     char_u	*b;
!     char_u	*p;
  {
      return p > b && vim_ispathsep(p[-1])
  			     && (!has_mbyte || (*mb_head_off)(b, p - 1) == 0);
--- 3248,3254 ----
   * "b" must point to the start of the file name
   */
      int
! after_pathsep(char_u *b, char_u *p)
  {
      return p > b && vim_ispathsep(p[-1])
  			     && (!has_mbyte || (*mb_head_off)(b, p - 1) == 0);
***************
*** 3366,3374 ****
   * "f1" may be a short name, "f2" must be a full path.
   */
      int
! same_directory(f1, f2)
!     char_u	*f1;
!     char_u	*f2;
  {
      char_u	ffname[MAXPATHL];
      char_u	*t1;
--- 3260,3266 ----
   * "f1" may be a short name, "f2" must be a full path.
   */
      int
! same_directory(char_u *f1, char_u *f2)
  {
      char_u	ffname[MAXPATHL];
      char_u	*t1;
***************
*** 3396,3403 ****
   * Return OK or FAIL.
   */
      int
! vim_chdirfile(fname)
!     char_u	*fname;
  {
      char_u	dir[MAXPATHL];
  
--- 3288,3294 ----
   * Return OK or FAIL.
   */
      int
! vim_chdirfile(char_u *fname)
  {
      char_u	dir[MAXPATHL];
  
***************
*** 3414,3421 ****
   * The Vim code assumes a trailing slash is only ignored for a directory.
   */
      int
! illegal_slash(name)
!     char *name;
  {
      if (name[0] == NUL)
  	return FALSE;	    /* no file name is not illegal */
--- 3305,3311 ----
   * The Vim code assumes a trailing slash is only ignored for a directory.
   */
      int
! illegal_slash(char *name)
  {
      if (name[0] == NUL)
  	return FALSE;	    /* no file name is not illegal */
***************
*** 3490,3497 ****
   * Returns error message for an illegal option, NULL otherwise.
   */
      char_u *
! parse_shape_opt(what)
!     int		what;
  {
      char_u	*modep;
      char_u	*colonp;
--- 3380,3386 ----
   * Returns error message for an illegal option, NULL otherwise.
   */
      char_u *
! parse_shape_opt(int what)
  {
      char_u	*modep;
      char_u	*colonp;
***************
*** 3737,3744 ****
   * When "mouse" is TRUE, consider indexes valid for the mouse pointer.
   */
      int
! get_shape_idx(mouse)
!     int	mouse;
  {
  #ifdef FEAT_MOUSESHAPE
      if (mouse && (State == HITRETURN || State == ASKMORE))
--- 3626,3632 ----
   * When "mouse" is TRUE, consider indexes valid for the mouse pointer.
   */
      int
! get_shape_idx(int mouse)
  {
  #ifdef FEAT_MOUSESHAPE
      if (mouse && (State == HITRETURN || State == ASKMORE))
***************
*** 3800,3807 ****
   * when the mouse moves off the status or command line).
   */
      void
! update_mouseshape(shape_idx)
!     int	shape_idx;
  {
      int new_mouse_shape;
  
--- 3688,3694 ----
   * when the mouse moves off the status or command line).
   */
      void
! update_mouseshape(int shape_idx)
  {
      int new_mouse_shape;
  
***************
*** 4060,4069 ****
  static void *ff_fn_search_context = NULL;
  
      char_u *
! vim_findfirst(path, filename, level)
!     char_u	*path;
!     char_u	*filename;
!     int		level;
  {
      ff_fn_search_context =
  	vim_findfile_init(path, filename, NULL, level, TRUE, FALSE,
--- 3947,3953 ----
  static void *ff_fn_search_context = NULL;
  
      char_u *
! vim_findfirst(char_u *path, char_u *filename, int level)
  {
      ff_fn_search_context =
  	vim_findfile_init(path, filename, NULL, level, TRUE, FALSE,
***************
*** 4075,4081 ****
  }
  
      char_u *
! vim_findnext()
  {
      char_u *ret = vim_findfile(ff_fn_search_context);
  
--- 3959,3965 ----
  }
  
      char_u *
! vim_findnext(void)
  {
      char_u *ret = vim_findfile(ff_fn_search_context);
  
***************
*** 4141,4157 ****
   * limited functionality then.
   */
      void *
! vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
! 					   search_ctx_arg, tagfile, rel_fname)
!     char_u	*path;
!     char_u	*filename;
!     char_u	*stopdirs UNUSED;
!     int		level;
!     int		free_visited;
!     int		find_what;
!     void	*search_ctx_arg;
!     int		tagfile;	/* expanding names of tags files */
!     char_u	*rel_fname;	/* file name to use for "." */
  {
  #ifdef FEAT_PATH_EXTRA
      char_u		*wc_part;
--- 4025,4040 ----
   * limited functionality then.
   */
      void *
! vim_findfile_init(
!     char_u	*path,
!     char_u	*filename,
!     char_u	*stopdirs UNUSED,
!     int		level,
!     int		free_visited,
!     int		find_what,
!     void	*search_ctx_arg,
!     int		tagfile,	/* expanding names of tags files */
!     char_u	*rel_fname)	/* file name to use for "." */
  {
  #ifdef FEAT_PATH_EXTRA
      char_u		*wc_part;
***************
*** 4491,4498 ****
   * Get the stopdir string.  Check that ';' is not escaped.
   */
      char_u *
! vim_findfile_stopdir(buf)
!     char_u	*buf;
  {
      char_u	*r_ptr = buf;
  
--- 4374,4380 ----
   * Get the stopdir string.  Check that ';' is not escaped.
   */
      char_u *
! vim_findfile_stopdir(char_u *buf)
  {
      char_u	*r_ptr = buf;
  
***************
*** 4522,4529 ****
   * Clean up the given search context. Can handle a NULL pointer.
   */
      void
! vim_findfile_cleanup(ctx)
!     void	*ctx;
  {
      if (ctx == NULL)
  	return;
--- 4404,4410 ----
   * Clean up the given search context. Can handle a NULL pointer.
   */
      void
! vim_findfile_cleanup(void *ctx)
  {
      if (ctx == NULL)
  	return;
***************
*** 4546,4553 ****
   * top of the list).
   */
      char_u *
! vim_findfile(search_ctx_arg)
!     void	*search_ctx_arg;
  {
      char_u	*file_path;
  #ifdef FEAT_PATH_EXTRA
--- 4427,4433 ----
   * top of the list).
   */
      char_u *
! vim_findfile(void *search_ctx_arg)
  {
      char_u	*file_path;
  #ifdef FEAT_PATH_EXTRA
***************
*** 4997,5004 ****
   * Can handle it if the passed search_context is NULL;
   */
      void
! vim_findfile_free_visited(search_ctx_arg)
!     void	*search_ctx_arg;
  {
      ff_search_ctx_T *search_ctx;
  
--- 4877,4883 ----
   * Can handle it if the passed search_context is NULL;
   */
      void
! vim_findfile_free_visited(void *search_ctx_arg)
  {
      ff_search_ctx_T *search_ctx;
  
***************
*** 5011,5018 ****
  }
  
      static void
! vim_findfile_free_visited_list(list_headp)
!     ff_visited_list_hdr_T	**list_headp;
  {
      ff_visited_list_hdr_T *vp;
  
--- 4890,4896 ----
  }
  
      static void
! vim_findfile_free_visited_list(ff_visited_list_hdr_T **list_headp)
  {
      ff_visited_list_hdr_T *vp;
  
***************
*** 5029,5036 ****
  }
  
      static void
! ff_free_visited_list(vl)
!     ff_visited_T *vl;
  {
      ff_visited_T *vp;
  
--- 4907,4913 ----
  }
  
      static void
! ff_free_visited_list(ff_visited_T *vl)
  {
      ff_visited_T *vp;
  
***************
*** 5051,5059 ****
   * allocates a new one.
   */
      static ff_visited_list_hdr_T*
! ff_get_visited_list(filename, list_headp)
!     char_u			*filename;
!     ff_visited_list_hdr_T	**list_headp;
  {
      ff_visited_list_hdr_T  *retptr = NULL;
  
--- 4928,4936 ----
   * allocates a new one.
   */
      static ff_visited_list_hdr_T*
! ff_get_visited_list(
!     char_u			*filename,
!     ff_visited_list_hdr_T	**list_headp)
  {
      ff_visited_list_hdr_T  *retptr = NULL;
  
***************
*** 5124,5132 ****
   *    '**\20' is equal to '**\24'
   */
      static int
! ff_wc_equal(s1, s2)
!     char_u	*s1;
!     char_u	*s2;
  {
      int		i, j;
      int		c1 = NUL;
--- 5001,5007 ----
   *    '**\20' is equal to '**\24'
   */
      static int
! ff_wc_equal(char_u *s1, char_u *s2)
  {
      int		i, j;
      int		c1 = NUL;
***************
*** 5168,5183 ****
   *	    never.
   */
      static int
! ff_check_visited(visited_list, fname
! #ifdef FEAT_PATH_EXTRA
! 	, wc_path
! #endif
! 	)
!     ff_visited_T	**visited_list;
!     char_u		*fname;
  #ifdef FEAT_PATH_EXTRA
!     char_u		*wc_path;
  #endif
  {
      ff_visited_T	*vp;
  #ifdef UNIX
--- 5043,5055 ----
   *	    never.
   */
      static int
! ff_check_visited(
!     ff_visited_T	**visited_list,
!     char_u		*fname
  #ifdef FEAT_PATH_EXTRA
!     , char_u		*wc_path
  #endif
+     )
  {
      ff_visited_T	*vp;
  #ifdef UNIX
***************
*** 5268,5284 ****
   * create stack element from given path pieces
   */
      static ff_stack_T *
! ff_create_stack_element(fix_part,
! #ifdef FEAT_PATH_EXTRA
! 	wc_part,
! #endif
! 	level, star_star_empty)
!     char_u	*fix_part;
  #ifdef FEAT_PATH_EXTRA
!     char_u	*wc_part;
  #endif
!     int		level;
!     int		star_star_empty;
  {
      ff_stack_T	*new;
  
--- 5140,5152 ----
   * create stack element from given path pieces
   */
      static ff_stack_T *
! ff_create_stack_element(
!     char_u	*fix_part,
  #ifdef FEAT_PATH_EXTRA
!     char_u	*wc_part,
  #endif
!     int		level,
!     int		star_star_empty)
  {
      ff_stack_T	*new;
  
***************
*** 5322,5330 ****
   * Push a dir on the directory stack.
   */
      static void
! ff_push(search_ctx, stack_ptr)
!     ff_search_ctx_T *search_ctx;
!     ff_stack_T	    *stack_ptr;
  {
      /* check for NULL pointer, not to return an error to the user, but
       * to prevent a crash */
--- 5190,5196 ----
   * Push a dir on the directory stack.
   */
      static void
! ff_push(ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr)
  {
      /* check for NULL pointer, not to return an error to the user, but
       * to prevent a crash */
***************
*** 5340,5347 ****
   * Returns NULL if stack is empty.
   */
      static ff_stack_T *
! ff_pop(search_ctx)
!     ff_search_ctx_T *search_ctx;
  {
      ff_stack_T  *sptr;
  
--- 5206,5212 ----
   * Returns NULL if stack is empty.
   */
      static ff_stack_T *
! ff_pop(ff_search_ctx_T *search_ctx)
  {
      ff_stack_T  *sptr;
  
***************
*** 5356,5363 ****
   * free the given stack element
   */
      static void
! ff_free_stack_element(stack_ptr)
!     ff_stack_T  *stack_ptr;
  {
      /* vim_free handles possible NULL pointers */
      vim_free(stack_ptr->ffs_fix_path);
--- 5221,5227 ----
   * free the given stack element
   */
      static void
! ff_free_stack_element(ff_stack_T *stack_ptr)
  {
      /* vim_free handles possible NULL pointers */
      vim_free(stack_ptr->ffs_fix_path);
***************
*** 5375,5382 ****
   * Clear the search context, but NOT the visited list.
   */
      static void
! ff_clear(search_ctx)
!     ff_search_ctx_T *search_ctx;
  {
      ff_stack_T   *sptr;
  
--- 5239,5245 ----
   * Clear the search context, but NOT the visited list.
   */
      static void
! ff_clear(ff_search_ctx_T *search_ctx)
  {
      ff_stack_T   *sptr;
  
***************
*** 5422,5431 ****
   * returns TRUE if yes else FALSE
   */
      static int
! ff_path_in_stoplist(path, path_len, stopdirs_v)
!     char_u	*path;
!     int		path_len;
!     char_u	**stopdirs_v;
  {
      int		i = 0;
  
--- 5285,5291 ----
   * returns TRUE if yes else FALSE
   */
      static int
! ff_path_in_stoplist(char_u *path, int path_len, char_u **stopdirs_v)
  {
      int		i = 0;
  
***************
*** 5486,5497 ****
   *
   */
      char_u *
! find_file_in_path(ptr, len, options, first, rel_fname)
!     char_u	*ptr;		/* file name */
!     int		len;		/* length of file name */
!     int		options;
!     int		first;		/* use count'th matching file name */
!     char_u	*rel_fname;	/* file name searching relative to */
  {
      return find_file_in_path_option(ptr, len, options, first,
  	    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,
--- 5346,5357 ----
   *
   */
      char_u *
! find_file_in_path(
!     char_u	*ptr,		/* file name */
!     int		len,		/* length of file name */
!     int		options,
!     int		first,		/* use count'th matching file name */
!     char_u	*rel_fname)	/* file name searching relative to */
  {
      return find_file_in_path_option(ptr, len, options, first,
  	    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,
***************
*** 5503,5509 ****
  
  #if defined(EXITFREE)
      static void
! free_findfile()
  {
      vim_free(ff_file_to_find);
      vim_findfile_cleanup(fdip_search_ctx);
--- 5363,5369 ----
  
  #if defined(EXITFREE)
      static void
! free_findfile(void)
  {
      vim_free(ff_file_to_find);
      vim_findfile_cleanup(fdip_search_ctx);
***************
*** 5522,5548 ****
   * Returns an allocated string for the file name.  NULL for error.
   */
      char_u *
! find_directory_in_path(ptr, len, options, rel_fname)
!     char_u	*ptr;		/* file name */
!     int		len;		/* length of file name */
!     int		options;
!     char_u	*rel_fname;	/* file name searching relative to */
  {
      return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,
  				       FINDFILE_DIR, rel_fname, (char_u *)"");
  }
  
      char_u *
! find_file_in_path_option(ptr, len, options, first, path_option,
! 			 find_what, rel_fname, suffixes)
!     char_u	*ptr;		/* file name */
!     int		len;		/* length of file name */
!     int		options;
!     int		first;		/* use count'th matching file name */
!     char_u	*path_option;	/* p_path or p_cdpath */
!     int		find_what;	/* FINDFILE_FILE, _DIR or _BOTH */
!     char_u	*rel_fname;	/* file name we are looking relative to. */
!     char_u	*suffixes;	/* list of suffixes, 'suffixesadd' option */
  {
      static char_u	*dir;
      static int		did_findfile_init = FALSE;
--- 5382,5407 ----
   * Returns an allocated string for the file name.  NULL for error.
   */
      char_u *
! find_directory_in_path(
!     char_u	*ptr,		/* file name */
!     int		len,		/* length of file name */
!     int		options,
!     char_u	*rel_fname)	/* file name searching relative to */
  {
      return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,
  				       FINDFILE_DIR, rel_fname, (char_u *)"");
  }
  
      char_u *
! find_file_in_path_option(
!     char_u	*ptr,		/* file name */
!     int		len,		/* length of file name */
!     int		options,
!     int		first,		/* use count'th matching file name */
!     char_u	*path_option,	/* p_path or p_cdpath */
!     int		find_what,	/* FINDFILE_FILE, _DIR or _BOTH */
!     char_u	*rel_fname,	/* file name we are looking relative to. */
!     char_u	*suffixes)	/* list of suffixes, 'suffixesadd' option */
  {
      static char_u	*dir;
      static int		did_findfile_init = FALSE;
***************
*** 5764,5771 ****
   * 'cdpath' for relative directory names, otherwise just mch_chdir().
   */
      int
! vim_chdir(new_dir)
!     char_u	*new_dir;
  {
  #ifndef FEAT_SEARCHPATH
      return mch_chdir((char *)new_dir);
--- 5623,5629 ----
   * 'cdpath' for relative directory names, otherwise just mch_chdir().
   */
      int
! vim_chdir(char_u *new_dir)
  {
  #ifndef FEAT_SEARCHPATH
      return mch_chdir((char *)new_dir);
***************
*** 5791,5799 ****
   * Returns OK or FAIL.
   */
      int
! get_user_name(buf, len)
!     char_u	*buf;
!     int		len;
  {
      if (username == NULL)
      {
--- 5649,5655 ----
   * Returns OK or FAIL.
   */
      int
! get_user_name(char_u *buf, int len)
  {
      if (username == NULL)
      {
***************
*** 5812,5822 ****
   * It's simple and slow.  From the K&R C book.
   */
      void
! qsort(base, elm_count, elm_size, cmp)
!     void	*base;
!     size_t	elm_count;
!     size_t	elm_size;
!     int (*cmp)(const void *, const void *);
  {
      char_u	*buf;
      char_u	*p1;
--- 5668,5678 ----
   * It's simple and slow.  From the K&R C book.
   */
      void
! qsort(
!     void	*base,
!     size_t	elm_count,
!     size_t	elm_size,
!     int (*cmp)(const void *, const void *))
  {
      char_u	*buf;
      char_u	*p1;
***************
*** 5860,5876 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      return STRCMP(*(char **)s1, *(char **)s2);
  }
  
      void
! sort_strings(files, count)
!     char_u	**files;
!     int		count;
  {
      qsort((void *)files, (size_t)count, sizeof(char_u *), sort_compare);
  }
--- 5716,5730 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sort_compare(const void *s1, const void *s2)
  {
      return STRCMP(*(char **)s1, *(char **)s2);
  }
  
      void
! sort_strings(
!     char_u	**files,
!     int		count)
  {
      qsort((void *)files, (size_t)count, sizeof(char_u *), sort_compare);
  }
***************
*** 5882,5890 ****
   * Return value like strcmp(p, q), but consider path separators.
   */
      int
! pathcmp(p, q, maxlen)
!     const char *p, *q;
!     int maxlen;
  {
      int		i, j;
      int		c1, c2;
--- 5736,5742 ----
   * Return value like strcmp(p, q), but consider path separators.
   */
      int
! pathcmp(const char *p, const char *q, int maxlen)
  {
      int		i, j;
      int		c1, c2;
***************
*** 5994,6001 ****
  static int  moreenv(void);	/* incr. size of env. */
  
      int
! putenv(string)
!     const char *string;
  {
      int	    i;
      char    *p;
--- 5846,5852 ----
  static int  moreenv(void);	/* incr. size of env. */
  
      int
! putenv(const char *string)
  {
      int	    i;
      char    *p;
***************
*** 6034,6041 ****
  }
  
      static int
! findenv(name)
!     char *name;
  {
      char    *namechar, *envchar;
      int	    i, found;
--- 5885,5891 ----
  }
  
      static int
! findenv(char *name)
  {
      char    *namechar, *envchar;
      int	    i, found;
***************
*** 6056,6062 ****
  }
  
      static int
! newenv()
  {
      char    **env, *elem;
      int	    i, esize;
--- 5906,5912 ----
  }
  
      static int
! newenv(void)
  {
      char    **env, *elem;
      int	    i, esize;
***************
*** 6091,6097 ****
  }
  
      static int
! moreenv()
  {
      int	    esize;
      char    **env;
--- 5941,5947 ----
  }
  
      static int
! moreenv(void)
  {
      int	    esize;
      char    **env;
***************
*** 6107,6114 ****
  
  # ifdef USE_VIMPTY_GETENV
      char_u *
! vimpty_getenv(string)
!     const char_u *string;
  {
      int i;
      char_u *p;
--- 5957,5963 ----
  
  # ifdef USE_VIMPTY_GETENV
      char_u *
! vimpty_getenv(const char_u *string)
  {
      int i;
      char_u *p;
***************
*** 6134,6141 ****
   * rights to write into.
   */
      int
! filewritable(fname)
!     char_u	*fname;
  {
      int		retval = 0;
  #if defined(UNIX) || defined(VMS)
--- 5983,5989 ----
   * rights to write into.
   */
      int
! filewritable(char_u *fname)
  {
      int		retval = 0;
  #if defined(UNIX) || defined(VMS)
***************
*** 6171,6178 ****
   * This is not in message.c to avoid a warning for prototypes.
   */
      int
! emsg3(s, a1, a2)
!     char_u *s, *a1, *a2;
  {
      if (emsg_not_now())
  	return TRUE;		/* no error messages at the moment */
--- 6019,6025 ----
   * This is not in message.c to avoid a warning for prototypes.
   */
      int
! emsg3(char_u *s, char_u *a1, char_u *a2)
  {
      if (emsg_not_now())
  	return TRUE;		/* no error messages at the moment */
***************
*** 6189,6197 ****
   * This is not in message.c to avoid a warning for prototypes.
   */
      int
! emsgn(s, n)
!     char_u	*s;
!     long	n;
  {
      if (emsg_not_now())
  	return TRUE;		/* no error messages at the moment */
--- 6036,6042 ----
   * This is not in message.c to avoid a warning for prototypes.
   */
      int
! emsgn(char_u *s, long n)
  {
      if (emsg_not_now())
  	return TRUE;		/* no error messages at the moment */
***************
*** 6204,6211 ****
   * Read 2 bytes from "fd" and turn them into an int, MSB first.
   */
      int
! get2c(fd)
!     FILE	*fd;
  {
      int		n;
  
--- 6049,6055 ----
   * Read 2 bytes from "fd" and turn them into an int, MSB first.
   */
      int
! get2c(FILE *fd)
  {
      int		n;
  
***************
*** 6218,6225 ****
   * Read 3 bytes from "fd" and turn them into an int, MSB first.
   */
      int
! get3c(fd)
!     FILE	*fd;
  {
      int		n;
  
--- 6062,6068 ----
   * Read 3 bytes from "fd" and turn them into an int, MSB first.
   */
      int
! get3c(FILE *fd)
  {
      int		n;
  
***************
*** 6233,6240 ****
   * Read 4 bytes from "fd" and turn them into an int, MSB first.
   */
      int
! get4c(fd)
!     FILE	*fd;
  {
      /* Use unsigned rather than int otherwise result is undefined
       * when left-shift sets the MSB. */
--- 6076,6082 ----
   * Read 4 bytes from "fd" and turn them into an int, MSB first.
   */
      int
! get4c(FILE *fd)
  {
      /* Use unsigned rather than int otherwise result is undefined
       * when left-shift sets the MSB. */
***************
*** 6251,6258 ****
   * Read 8 bytes from "fd" and turn them into a time_t, MSB first.
   */
      time_t
! get8ctime(fd)
!     FILE	*fd;
  {
      time_t	n = 0;
      int		i;
--- 6093,6099 ----
   * Read 8 bytes from "fd" and turn them into a time_t, MSB first.
   */
      time_t
! get8ctime(FILE *fd)
  {
      time_t	n = 0;
      int		i;
***************
*** 6267,6275 ****
   * Returns NULL when out of memory or unable to read that many bytes.
   */
      char_u *
! read_string(fd, cnt)
!     FILE	*fd;
!     int		cnt;
  {
      char_u	*str;
      int		i;
--- 6108,6114 ----
   * Returns NULL when out of memory or unable to read that many bytes.
   */
      char_u *
! read_string(FILE *fd, int cnt)
  {
      char_u	*str;
      int		i;
***************
*** 6299,6308 ****
   * Write a number to file "fd", MSB first, in "len" bytes.
   */
      int
! put_bytes(fd, nr, len)
!     FILE    *fd;
!     long_u  nr;
!     int	    len;
  {
      int	    i;
  
--- 6138,6144 ----
   * Write a number to file "fd", MSB first, in "len" bytes.
   */
      int
! put_bytes(FILE *fd, long_u nr, int len)
  {
      int	    i;
  
***************
*** 6325,6333 ****
   * Returns FAIL when the write failed.
   */
      int
! put_time(fd, the_time)
!     FILE	*fd;
!     time_t	the_time;
  {
      char_u	buf[8];
  
--- 6161,6167 ----
   * Returns FAIL when the write failed.
   */
      int
! put_time(FILE *fd, time_t the_time)
  {
      char_u	buf[8];
  
***************
*** 6339,6347 ****
   * Write time_t to "buf[8]".
   */
      void
! time_to_bytes(the_time, buf)
!     time_t	the_time;
!     char_u	*buf;
  {
      int		c;
      int		i;
--- 6173,6179 ----
   * Write time_t to "buf[8]".
   */
      void
! time_to_bytes(time_t the_time, char_u *buf)
  {
      int		c;
      int		i;
***************
*** 6387,6394 ****
   * When "s" is NULL FALSE is returned.
   */
      int
! has_non_ascii(s)
!     char_u	*s;
  {
      char_u	*p;
  
--- 6219,6225 ----
   * When "s" is NULL FALSE is returned.
   */
      int
! has_non_ascii(char_u *s)
  {
      char_u	*p;
  
***************
*** 6407,6413 ****
   * it is safe to do so.
   */
      void
! parse_queued_messages()
  {
  # ifdef FEAT_NETBEANS_INTG
      /* Process the queued netbeans messages. */
--- 6238,6244 ----
   * it is safe to do so.
   */
      void
! parse_queued_messages(void)
  {
  # ifdef FEAT_NETBEANS_INTG
      /* Process the queued netbeans messages. */
*** ../vim-7.4.1210/src/move.c	2016-01-29 22:36:41.233047606 +0100
--- src/move.c	2016-01-30 19:23:01.024310981 +0100
***************
*** 48,55 ****
   * wp->w_topline changed.
   */
      static void
! comp_botline(wp)
!     win_T	*wp;
  {
      int		n;
      linenr_T	lnum;
--- 48,54 ----
   * wp->w_topline changed.
   */
      static void
! comp_botline(win_T *wp)
  {
      int		n;
      linenr_T	lnum;
***************
*** 129,136 ****
   * set.
   */
      static void
! redraw_for_cursorline(wp)
!     win_T *wp;
  {
      if ((wp->w_p_rnu
  #ifdef FEAT_SYN_HL
--- 128,134 ----
   * set.
   */
      static void
! redraw_for_cursorline(win_T *wp)
  {
      if ((wp->w_p_rnu
  #ifdef FEAT_SYN_HL
***************
*** 150,156 ****
   * Used to update the screen before printing a message.
   */
      void
! update_topline_redraw()
  {
      update_topline();
      if (must_redraw)
--- 148,154 ----
   * Used to update the screen before printing a message.
   */
      void
! update_topline_redraw(void)
  {
      update_topline();
      if (must_redraw)
***************
*** 161,167 ****
   * Update curwin->w_topline to move the cursor onto the screen.
   */
      void
! update_topline()
  {
      long	line_count;
      int		halfheight;
--- 159,165 ----
   * Update curwin->w_topline to move the cursor onto the screen.
   */
      void
! update_topline(void)
  {
      long	line_count;
      int		halfheight;
***************
*** 420,426 ****
   * When 'scrolljump' is negative use it as a percentage of the window height.
   */
      static int
! scrolljump_value()
  {
      if (p_sj >= 0)
  	return (int)p_sj;
--- 418,424 ----
   * When 'scrolljump' is negative use it as a percentage of the window height.
   */
      static int
! scrolljump_value(void)
  {
      if (p_sj >= 0)
  	return (int)p_sj;
***************
*** 432,438 ****
   * current window.
   */
      static int
! check_top_offset()
  {
      lineoff_T	loff;
      int		n;
--- 430,436 ----
   * current window.
   */
      static int
! check_top_offset(void)
  {
      lineoff_T	loff;
      int		n;
***************
*** 470,476 ****
  }
  
      void
! update_curswant()
  {
      if (curwin->w_set_curswant)
      {
--- 468,474 ----
  }
  
      void
! update_curswant(void)
  {
      if (curwin->w_set_curswant)
      {
***************
*** 484,491 ****
   * Check if the cursor has moved.  Set the w_valid flag accordingly.
   */
      void
! check_cursor_moved(wp)
!     win_T	*wp;
  {
      if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)
      {
--- 482,488 ----
   * Check if the cursor has moved.  Set the w_valid flag accordingly.
   */
      void
! check_cursor_moved(win_T *wp)
  {
      if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)
      {
***************
*** 516,529 ****
   * be redrawn.  E.g, when changing the 'wrap' option or folding.
   */
      void
! changed_window_setting()
  {
      changed_window_setting_win(curwin);
  }
  
      void
! changed_window_setting_win(wp)
!     win_T	*wp;
  {
      wp->w_lines_valid = 0;
      changed_line_abv_curs_win(wp);
--- 513,525 ----
   * be redrawn.  E.g, when changing the 'wrap' option or folding.
   */
      void
! changed_window_setting(void)
  {
      changed_window_setting_win(curwin);
  }
  
      void
! changed_window_setting_win(win_T *wp)
  {
      wp->w_lines_valid = 0;
      changed_line_abv_curs_win(wp);
***************
*** 535,543 ****
   * Set wp->w_topline to a certain number.
   */
      void
! set_topline(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
  #ifdef FEAT_FOLDING
      /* go to first of folded lines */
--- 531,537 ----
   * Set wp->w_topline to a certain number.
   */
      void
! set_topline(win_T *wp, linenr_T lnum)
  {
  #ifdef FEAT_FOLDING
      /* go to first of folded lines */
***************
*** 563,577 ****
   * Need to take care of w_botline separately!
   */
      void
! changed_cline_bef_curs()
  {
      curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
  						|VALID_CHEIGHT|VALID_TOPLINE);
  }
  
      void
! changed_cline_bef_curs_win(wp)
!     win_T	*wp;
  {
      wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
  						|VALID_CHEIGHT|VALID_TOPLINE);
--- 557,570 ----
   * Need to take care of w_botline separately!
   */
      void
! changed_cline_bef_curs(void)
  {
      curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
  						|VALID_CHEIGHT|VALID_TOPLINE);
  }
  
      void
! changed_cline_bef_curs_win(win_T *wp)
  {
      wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
  						|VALID_CHEIGHT|VALID_TOPLINE);
***************
*** 583,597 ****
   * Need to take care of w_botline separately!
   */
      void
! changed_line_abv_curs()
  {
      curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW
  						|VALID_CHEIGHT|VALID_TOPLINE);
  }
  
      void
! changed_line_abv_curs_win(wp)
!     win_T	*wp;
  {
      wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW
  						|VALID_CHEIGHT|VALID_TOPLINE);
--- 576,589 ----
   * Need to take care of w_botline separately!
   */
      void
! changed_line_abv_curs(void)
  {
      curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW
  						|VALID_CHEIGHT|VALID_TOPLINE);
  }
  
      void
! changed_line_abv_curs_win(win_T *wp)
  {
      wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW
  						|VALID_CHEIGHT|VALID_TOPLINE);
***************
*** 601,607 ****
   * Make sure the value of curwin->w_botline is valid.
   */
      void
! validate_botline()
  {
      if (!(curwin->w_valid & VALID_BOTLINE))
  	comp_botline(curwin);
--- 593,599 ----
   * Make sure the value of curwin->w_botline is valid.
   */
      void
! validate_botline(void)
  {
      if (!(curwin->w_valid & VALID_BOTLINE))
  	comp_botline(curwin);
***************
*** 611,631 ****
   * Mark curwin->w_botline as invalid (because of some change in the buffer).
   */
      void
! invalidate_botline()
  {
      curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);
  }
  
      void
! invalidate_botline_win(wp)
!     win_T	*wp;
  {
      wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);
  }
  
      void
! approximate_botline_win(wp)
!     win_T	*wp;
  {
      wp->w_valid &= ~VALID_BOTLINE;
  }
--- 603,622 ----
   * Mark curwin->w_botline as invalid (because of some change in the buffer).
   */
      void
! invalidate_botline(void)
  {
      curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);
  }
  
      void
! invalidate_botline_win(win_T *wp)
  {
      wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);
  }
  
      void
! approximate_botline_win(
!     win_T	*wp)
  {
      wp->w_valid &= ~VALID_BOTLINE;
  }
***************
*** 634,640 ****
   * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.
   */
      int
! cursor_valid()
  {
      check_cursor_moved(curwin);
      return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==
--- 625,631 ----
   * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.
   */
      int
! cursor_valid(void)
  {
      check_cursor_moved(curwin);
      return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==
***************
*** 646,652 ****
   * w_topline must be valid, you may need to call update_topline() first!
   */
      void
! validate_cursor()
  {
      check_cursor_moved(curwin);
      if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))
--- 637,643 ----
   * w_topline must be valid, you may need to call update_topline() first!
   */
      void
! validate_cursor(void)
  {
      check_cursor_moved(curwin);
      if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))
***************
*** 658,664 ****
   * validate w_cline_row.
   */
      void
! validate_cline_row()
  {
      /*
       * First make sure that w_topline is valid (after moving the cursor).
--- 649,655 ----
   * validate w_cline_row.
   */
      void
! validate_cline_row(void)
  {
      /*
       * First make sure that w_topline is valid (after moving the cursor).
***************
*** 675,682 ****
   * of wp->w_topline.
   */
      static void
! curs_rows(wp)
!     win_T	*wp;
  {
      linenr_T	lnum;
      int		i;
--- 666,672 ----
   * of wp->w_topline.
   */
      static void
! curs_rows(win_T *wp)
  {
      linenr_T	lnum;
      int		i;
***************
*** 801,807 ****
   * Validate curwin->w_virtcol only.
   */
      void
! validate_virtcol()
  {
      validate_virtcol_win(curwin);
  }
--- 791,797 ----
   * Validate curwin->w_virtcol only.
   */
      void
! validate_virtcol(void)
  {
      validate_virtcol_win(curwin);
  }
***************
*** 810,817 ****
   * Validate wp->w_virtcol only.
   */
      void
! validate_virtcol_win(wp)
!     win_T	*wp;
  {
      check_cursor_moved(wp);
      if (!(wp->w_valid & VALID_VIRTCOL))
--- 800,806 ----
   * Validate wp->w_virtcol only.
   */
      void
! validate_virtcol_win(win_T *wp)
  {
      check_cursor_moved(wp);
      if (!(wp->w_valid & VALID_VIRTCOL))
***************
*** 833,839 ****
   * Validate curwin->w_cline_height only.
   */
      static void
! validate_cheight()
  {
      check_cursor_moved(curwin);
      if (!(curwin->w_valid & VALID_CHEIGHT))
--- 822,828 ----
   * Validate curwin->w_cline_height only.
   */
      static void
! validate_cheight(void)
  {
      check_cursor_moved(curwin);
      if (!(curwin->w_valid & VALID_CHEIGHT))
***************
*** 856,862 ****
   * Validate w_wcol and w_virtcol only.
   */
      void
! validate_cursor_col()
  {
      colnr_T off;
      colnr_T col;
--- 845,851 ----
   * Validate w_wcol and w_virtcol only.
   */
      void
! validate_cursor_col(void)
  {
      colnr_T off;
      colnr_T col;
***************
*** 891,898 ****
   * fold column and sign column (these don't move when scrolling horizontally).
   */
      int
! win_col_off(wp)
!     win_T	*wp;
  {
      return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)
  #ifdef FEAT_CMDWIN
--- 880,886 ----
   * fold column and sign column (these don't move when scrolling horizontally).
   */
      int
! win_col_off(win_T *wp)
  {
      return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)
  #ifdef FEAT_CMDWIN
***************
*** 913,919 ****
  }
  
      int
! curwin_col_off()
  {
      return win_col_off(curwin);
  }
--- 901,907 ----
  }
  
      int
! curwin_col_off(void)
  {
      return win_col_off(curwin);
  }
***************
*** 924,931 ****
   * 'cpoptions'.
   */
      int
! win_col_off2(wp)
!     win_T	*wp;
  {
      if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)
  	return number_width(wp) + 1;
--- 912,918 ----
   * 'cpoptions'.
   */
      int
! win_col_off2(win_T *wp)
  {
      if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)
  	return number_width(wp) + 1;
***************
*** 933,939 ****
  }
  
      int
! curwin_col_off2()
  {
      return win_col_off2(curwin);
  }
--- 920,926 ----
  }
  
      int
! curwin_col_off2(void)
  {
      return win_col_off2(curwin);
  }
***************
*** 944,951 ****
   * Also updates curwin->w_leftcol.
   */
      void
! curs_columns(may_scroll)
!     int		may_scroll;	/* when TRUE, may scroll horizontally */
  {
      int		diff;
      int		extra;		/* offset for first screen line */
--- 931,938 ----
   * Also updates curwin->w_leftcol.
   */
      void
! curs_columns(
!     int		may_scroll)	/* when TRUE, may scroll horizontally */
  {
      int		diff;
      int		extra;		/* offset for first screen line */
***************
*** 1207,1215 ****
   * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
   */
      void
! scrolldown(line_count, byfold)
!     long	line_count;
!     int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
  {
      long	done = 0;	/* total # of physical lines done */
      int		wrow;
--- 1194,1202 ----
   * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
   */
      void
! scrolldown(
!     long	line_count,
!     int		byfold UNUSED)	/* TRUE: count a closed fold as one line */
  {
      long	done = 0;	/* total # of physical lines done */
      int		wrow;
***************
*** 1314,1322 ****
   * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
   */
      void
! scrollup(line_count, byfold)
!     long	line_count;
!     int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
--- 1301,1309 ----
   * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
   */
      void
! scrollup(
!     long	line_count,
!     int		byfold UNUSED)	/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
***************
*** 1396,1404 ****
   * Don't end up with too many filler lines in the window.
   */
      void
! check_topfill(wp, down)
!     win_T	*wp;
!     int		down;	/* when TRUE scroll down when not enough space */
  {
      int		n;
  
--- 1383,1391 ----
   * Don't end up with too many filler lines in the window.
   */
      void
! check_topfill(
!     win_T	*wp,
!     int		down)	/* when TRUE scroll down when not enough space */
  {
      int		n;
  
***************
*** 1427,1433 ****
   * is still visible.
   */
      static void
! max_topfill()
  {
      int		n;
  
--- 1414,1420 ----
   * is still visible.
   */
      static void
! max_topfill(void)
  {
      int		n;
  
***************
*** 1449,1455 ****
   * cursor off the screen.
   */
      void
! scrolldown_clamp()
  {
      int		end_row;
  #ifdef FEAT_DIFF
--- 1436,1442 ----
   * cursor off the screen.
   */
      void
! scrolldown_clamp(void)
  {
      int		end_row;
  #ifdef FEAT_DIFF
***************
*** 1520,1526 ****
   * off the screen.
   */
      void
! scrollup_clamp()
  {
      int	    start_row;
  
--- 1507,1513 ----
   * off the screen.
   */
      void
! scrollup_clamp(void)
  {
      int	    start_row;
  
***************
*** 1579,1586 ****
   * Lines above the first one are incredibly high: MAXCOL.
   */
      static void
! topline_back(lp)
!     lineoff_T	*lp;
  {
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum))
--- 1566,1572 ----
   * Lines above the first one are incredibly high: MAXCOL.
   */
      static void
! topline_back(lineoff_T *lp)
  {
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum))
***************
*** 1616,1623 ****
   * Lines below the last one are incredibly high.
   */
      static void
! botline_forw(lp)
!     lineoff_T	*lp;
  {
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))
--- 1602,1608 ----
   * Lines below the last one are incredibly high.
   */
      static void
! botline_forw(lineoff_T *lp)
  {
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))
***************
*** 1655,1662 ****
   * When there are no filler lines nothing changes.
   */
      static void
! botline_topline(lp)
!     lineoff_T	*lp;
  {
      if (lp->fill > 0)
      {
--- 1640,1646 ----
   * When there are no filler lines nothing changes.
   */
      static void
! botline_topline(lineoff_T *lp)
  {
      if (lp->fill > 0)
      {
***************
*** 1671,1678 ****
   * When there are no filler lines nothing changes.
   */
      static void
! topline_botline(lp)
!     lineoff_T	*lp;
  {
      if (lp->fill > 0)
      {
--- 1655,1661 ----
   * When there are no filler lines nothing changes.
   */
      static void
! topline_botline(lineoff_T *lp)
  {
      if (lp->fill > 0)
      {
***************
*** 1688,1696 ****
   * If "always" is TRUE, always set topline (for "zt").
   */
      void
! scroll_cursor_top(min_scroll, always)
!     int		min_scroll;
!     int		always;
  {
      int		scrolled = 0;
      int		extra = 0;
--- 1671,1677 ----
   * If "always" is TRUE, always set topline (for "zt").
   */
      void
! scroll_cursor_top(int min_scroll, int always)
  {
      int		scrolled = 0;
      int		extra = 0;
***************
*** 1828,1836 ****
   * screen lines for text lines.
   */
      void
! set_empty_rows(wp, used)
!     win_T	*wp;
!     int		used;
  {
  #ifdef FEAT_DIFF
      wp->w_filler_rows = 0;
--- 1809,1815 ----
   * screen lines for text lines.
   */
      void
! set_empty_rows(win_T *wp, int used)
  {
  #ifdef FEAT_DIFF
      wp->w_filler_rows = 0;
***************
*** 1863,1871 ****
   * This is messy stuff!!!
   */
      void
! scroll_cursor_bot(min_scroll, set_topbot)
!     int		min_scroll;
!     int		set_topbot;
  {
      int		used;
      int		scrolled = 0;
--- 1842,1848 ----
   * This is messy stuff!!!
   */
      void
! scroll_cursor_bot(int min_scroll, int set_topbot)
  {
      int		used;
      int		scrolled = 0;
***************
*** 2086,2093 ****
   * If "atend" is TRUE, also put it halfway at the end of the file.
   */
      void
! scroll_cursor_halfway(atend)
!     int		atend;
  {
      int		above = 0;
      linenr_T	topline;
--- 2063,2069 ----
   * If "atend" is TRUE, also put it halfway at the end of the file.
   */
      void
! scroll_cursor_halfway(int atend)
  {
      int		above = 0;
      linenr_T	topline;
***************
*** 2171,2177 ****
   * When called topline must be valid!
   */
      void
! cursor_correct()
  {
      int		above = 0;	    /* screen lines above topline */
      linenr_T	topline;
--- 2147,2153 ----
   * When called topline must be valid!
   */
      void
! cursor_correct(void)
  {
      int		above = 0;	    /* screen lines above topline */
      linenr_T	topline;
***************
*** 2298,2306 ****
   * return FAIL for failure, OK otherwise
   */
      int
! onepage(dir, count)
!     int		dir;
!     long	count;
  {
      long	n;
      int		retval = OK;
--- 2274,2280 ----
   * return FAIL for failure, OK otherwise
   */
      int
! onepage(int dir, long count)
  {
      long	n;
      int		retval = OK;
***************
*** 2549,2557 ****
   *  l3				   etc.
   */
      static void
! get_scroll_overlap(lp, dir)
!     lineoff_T	*lp;
!     int		dir;
  {
      int		h1, h2, h3, h4;
      int		min_height = curwin->w_height - 2;
--- 2523,2529 ----
   *  l3				   etc.
   */
      static void
! get_scroll_overlap(lineoff_T *lp, int dir)
  {
      int		h1, h2, h3, h4;
      int		min_height = curwin->w_height - 2;
***************
*** 2611,2619 ****
   * Scroll 'scroll' lines up or down.
   */
      void
! halfpage(flag, Prenum)
!     int		flag;
!     linenr_T	Prenum;
  {
      long	scrolled = 0;
      int		i;
--- 2583,2589 ----
   * Scroll 'scroll' lines up or down.
   */
      void
! halfpage(int flag, linenr_T Prenum)
  {
      long	scrolled = 0;
      int		i;
***************
*** 2831,2837 ****
  
  #if defined(FEAT_CURSORBIND) || defined(PROTO)
      void
! do_check_cursorbind()
  {
      linenr_T	line = curwin->w_cursor.lnum;
      colnr_T	col = curwin->w_cursor.col;
--- 2801,2807 ----
  
  #if defined(FEAT_CURSORBIND) || defined(PROTO)
      void
! do_check_cursorbind(void)
  {
      linenr_T	line = curwin->w_cursor.lnum;
      colnr_T	col = curwin->w_cursor.col;
*** ../vim-7.4.1210/src/netbeans.c	2016-01-29 22:36:41.237047563 +0100
--- src/netbeans.c	2016-01-30 19:23:51.855782070 +0100
***************
*** 561,567 ****
   * Free netbeans resources.
   */
      static void
! nb_free()
  {
      keyQ_T *key_node = keyHead.next;
      nbbuf_T buf;
--- 561,567 ----
   * Free netbeans resources.
   */
      static void
! nb_free(void)
  {
      keyQ_T *key_node = keyHead.next;
      nbbuf_T buf;
***************
*** 2355,2376 ****
  }
  
      void
! ex_nbclose(eap)
!     exarg_T	*eap UNUSED;
  {
      netbeans_close();
  }
  
      void
! ex_nbkey(eap)
!     exarg_T	*eap;
  {
      (void)netbeans_keystring(eap->arg);
  }
  
      void
! ex_nbstart(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_GUI
  # if !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)  \
--- 2355,2374 ----
  }
  
      void
! ex_nbclose(exarg_T *eap UNUSED)
  {
      netbeans_close();
  }
  
      void
! ex_nbkey(exarg_T *eap)
  {
      (void)netbeans_keystring(eap->arg);
  }
  
      void
! ex_nbstart(
!     exarg_T	*eap)
  {
  #ifdef FEAT_GUI
  # if !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)  \
***************
*** 2572,2578 ****
   * before calling exit.
   */
      void
! netbeans_send_disconnect()
  {
      char buf[128];
  
--- 2570,2576 ----
   * before calling exit.
   */
      void
! netbeans_send_disconnect(void)
  {
      char buf[128];
  
***************
*** 3400,3407 ****
   * doesn't normally call readfile, we do our own.
   */
      static void
! print_read_msg(buf)
!     nbbuf_T	*buf;
  {
      int	    lnum = buf->bufp->b_ml.ml_line_count;
      off_t   nchars = buf->bufp->b_orig_size;
--- 3398,3404 ----
   * doesn't normally call readfile, we do our own.
   */
      static void
! print_read_msg(nbbuf_T *buf)
  {
      int	    lnum = buf->bufp->b_ml.ml_line_count;
      off_t   nchars = buf->bufp->b_orig_size;
***************
*** 3438,3446 ****
   * writing a file.
   */
      static void
! print_save_msg(buf, nchars)
!     nbbuf_T	*buf;
!     off_t	nchars;
  {
      char_u	c;
      char_u	*p;
--- 3435,3441 ----
   * writing a file.
   */
      static void
! print_save_msg(nbbuf_T *buf, off_t nchars)
  {
      char_u	c;
      char_u	*p;
*** ../vim-7.4.1210/src/normal.c	2016-01-29 22:36:41.237047563 +0100
--- src/normal.c	2016-01-30 19:29:34.216219980 +0100
***************
*** 452,460 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! nv_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      int		c1, c2;
  
--- 452,458 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! nv_compare(const void *s1, const void *s2)
  {
      int		c1, c2;
  
***************
*** 472,478 ****
   * Initialize the nv_cmd_idx[] table.
   */
      void
! init_normal_cmds()
  {
      int		i;
  
--- 470,476 ----
   * Initialize the nv_cmd_idx[] table.
   */
      void
! init_normal_cmds(void)
  {
      int		i;
  
***************
*** 495,502 ****
   * Returns -1 for invalid command.
   */
      static int
! find_command(cmdchar)
!     int		cmdchar;
  {
      int		i;
      int		idx;
--- 493,499 ----
   * Returns -1 for invalid command.
   */
      static int
! find_command(int cmdchar)
  {
      int		i;
      int		idx;
***************
*** 546,554 ****
   * Execute a command in Normal mode.
   */
      void
! normal_cmd(oap, toplevel)
!     oparg_T	*oap;
!     int		toplevel UNUSED;	/* TRUE when called from main() */
  {
      cmdarg_T	ca;			/* command arguments */
      int		c;
--- 543,551 ----
   * Execute a command in Normal mode.
   */
      void
! normal_cmd(
!     oparg_T	*oap,
!     int		toplevel UNUSED)	/* TRUE when called from main() */
  {
      cmdarg_T	ca;			/* command arguments */
      int		c;
***************
*** 1355,1363 ****
   * Set v:prevcount only when "set_prevcount" is TRUE.
   */
      static void
! set_vcount_ca(cap, set_prevcount)
!     cmdarg_T	*cap;
!     int		*set_prevcount;
  {
      long count = cap->count0;
  
--- 1352,1358 ----
   * Set v:prevcount only when "set_prevcount" is TRUE.
   */
      static void
! set_vcount_ca(cmdarg_T *cap, int *set_prevcount)
  {
      long count = cap->count0;
  
***************
*** 1373,1382 ****
   * Handle an operator after visual mode or when the movement is finished
   */
      void
! do_pending_operator(cap, old_col, gui_yank)
!     cmdarg_T	*cap;
!     int		old_col;
!     int		gui_yank;
  {
      oparg_T	*oap = cap->oap;
      pos_T	old_cursor;
--- 1368,1374 ----
   * Handle an operator after visual mode or when the movement is finished
   */
      void
! do_pending_operator(cmdarg_T *cap, int old_col, int gui_yank)
  {
      oparg_T	*oap = cap->oap;
      pos_T	old_cursor;
***************
*** 2164,2171 ****
   * Handle indent and format operators and visual mode ":".
   */
      static void
! op_colon(oap)
!     oparg_T	*oap;
  {
      stuffcharReadbuff(':');
      if (oap->is_VIsual)
--- 2156,2162 ----
   * Handle indent and format operators and visual mode ":".
   */
      static void
! op_colon(oparg_T *oap)
  {
      stuffcharReadbuff(':');
      if (oap->is_VIsual)
***************
*** 2225,2232 ****
   * Handle the "g@" operator: call 'operatorfunc'.
   */
      static void
! op_function(oap)
!     oparg_T	*oap UNUSED;
  {
  #ifdef FEAT_EVAL
      char_u	*(argv[1]);
--- 2216,2222 ----
   * Handle the "g@" operator: call 'operatorfunc'.
   */
      static void
! op_function(oparg_T *oap UNUSED)
  {
  #ifdef FEAT_EVAL
      char_u	*(argv[1]);
***************
*** 2307,2318 ****
   * Return TRUE if start_arrow() should be called for edit mode.
   */
      int
! do_mouse(oap, c, dir, count, fixindent)
!     oparg_T	*oap;		/* operator argument, can be NULL */
!     int		c;		/* K_LEFTMOUSE, etc */
!     int		dir;		/* Direction to 'put' if necessary */
!     long	count;
!     int		fixindent;	/* PUT_FIXINDENT if fixing indent necessary */
  {
      static int	do_always = FALSE;	/* ignore 'mouse' setting next time */
      static int	got_click = FALSE;	/* got a click some time back */
--- 2297,2308 ----
   * Return TRUE if start_arrow() should be called for edit mode.
   */
      int
! do_mouse(
!     oparg_T	*oap,		/* operator argument, can be NULL */
!     int		c,		/* K_LEFTMOUSE, etc */
!     int		dir,		/* Direction to 'put' if necessary */
!     long	count,
!     int		fixindent)	/* PUT_FIXINDENT if fixing indent necessary */
  {
      static int	do_always = FALSE;	/* ignore 'mouse' setting next time */
      static int	got_click = FALSE;	/* got a click some time back */
***************
*** 3175,3182 ****
   * Move "pos" back to the start of the word it's in.
   */
      static void
! find_start_of_word(pos)
!     pos_T	*pos;
  {
      char_u	*line;
      int		cclass;
--- 3165,3171 ----
   * Move "pos" back to the start of the word it's in.
   */
      static void
! find_start_of_word(pos_T *pos)
  {
      char_u	*line;
      int		cclass;
***************
*** 3202,3209 ****
   * When 'selection' is "exclusive", the position is just after the word.
   */
      static void
! find_end_of_word(pos)
!     pos_T	*pos;
  {
      char_u	*line;
      int		cclass;
--- 3191,3197 ----
   * When 'selection' is "exclusive", the position is just after the word.
   */
      static void
! find_end_of_word(pos_T *pos)
  {
      char_u	*line;
      int		cclass;
***************
*** 3243,3250 ****
   * >2: multi-byte word character.
   */
      static int
! get_mouse_class(p)
!     char_u	*p;
  {
      int		c;
  
--- 3231,3237 ----
   * >2: multi-byte word character.
   */
      static int
! get_mouse_class(char_u *p)
  {
      int		c;
  
***************
*** 3277,3283 ****
   * if not.
   */
      void
! check_visual_highlight()
  {
      static int	    did_check = FALSE;
  
--- 3264,3270 ----
   * if not.
   */
      void
! check_visual_highlight(void)
  {
      static int	    did_check = FALSE;
  
***************
*** 3295,3301 ****
   * do_pending_operator().
   */
      void
! end_visual_mode()
  {
  #ifdef FEAT_CLIPBOARD
      /*
--- 3282,3288 ----
   * do_pending_operator().
   */
      void
! end_visual_mode(void)
  {
  #ifdef FEAT_CLIPBOARD
      /*
***************
*** 3335,3341 ****
   * Reset VIsual_active and VIsual_reselect.
   */
      void
! reset_VIsual_and_resel()
  {
      if (VIsual_active)
      {
--- 3322,3328 ----
   * Reset VIsual_active and VIsual_reselect.
   */
      void
! reset_VIsual_and_resel(void)
  {
      if (VIsual_active)
      {
***************
*** 3349,3355 ****
   * Reset VIsual_active and VIsual_reselect if it's set.
   */
      void
! reset_VIsual()
  {
      if (VIsual_active)
      {
--- 3336,3342 ----
   * Reset VIsual_active and VIsual_reselect if it's set.
   */
      void
! reset_VIsual(void)
  {
      if (VIsual_active)
      {
***************
*** 3371,3381 ****
   * "bnp" points to a counter for square brackets.
   */
      static int
! find_is_eval_item(ptr, colp, bnp, dir)
!     char_u	*ptr;
!     int		*colp;
!     int		*bnp;
!     int		dir;
  {
      /* Accept everything inside []. */
      if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))
--- 3358,3368 ----
   * "bnp" points to a counter for square brackets.
   */
      static int
! find_is_eval_item(
!     char_u	*ptr,
!     int		*colp,
!     int		*bnp,
!     int		dir)
  {
      /* Accept everything inside []. */
      if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))
***************
*** 3424,3432 ****
   * string is not always NUL terminated.
   */
      int
! find_ident_under_cursor(string, find_type)
!     char_u	**string;
!     int		find_type;
  {
      return find_ident_at_pos(curwin, curwin->w_cursor.lnum,
  				     curwin->w_cursor.col, string, find_type);
--- 3411,3417 ----
   * string is not always NUL terminated.
   */
      int
! find_ident_under_cursor(char_u **string, int find_type)
  {
      return find_ident_at_pos(curwin, curwin->w_cursor.lnum,
  				     curwin->w_cursor.col, string, find_type);
***************
*** 3437,3448 ****
   * However: Uses 'iskeyword' from the current window!.
   */
      int
! find_ident_at_pos(wp, lnum, startcol, string, find_type)
!     win_T	*wp;
!     linenr_T	lnum;
!     colnr_T	startcol;
!     char_u	**string;
!     int		find_type;
  {
      char_u	*ptr;
      int		col = 0;	    /* init to shut up GCC */
--- 3422,3433 ----
   * However: Uses 'iskeyword' from the current window!.
   */
      int
! find_ident_at_pos(
!     win_T	*wp,
!     linenr_T	lnum,
!     colnr_T	startcol,
!     char_u	**string,
!     int		find_type)
  {
      char_u	*ptr;
      int		col = 0;	    /* init to shut up GCC */
***************
*** 3625,3632 ****
   * Prepare for redo of a normal command.
   */
      static void
! prep_redo_cmd(cap)
!     cmdarg_T  *cap;
  {
      prep_redo(cap->oap->regname, cap->count0,
  				     NUL, cap->cmdchar, NUL, NUL, cap->nchar);
--- 3610,3616 ----
   * Prepare for redo of a normal command.
   */
      static void
! prep_redo_cmd(cmdarg_T *cap)
  {
      prep_redo(cap->oap->regname, cap->count0,
  				     NUL, cap->cmdchar, NUL, NUL, cap->nchar);
***************
*** 3637,3650 ****
   * Note that only the last argument can be a multi-byte char.
   */
      static void
! prep_redo(regname, num, cmd1, cmd2, cmd3, cmd4, cmd5)
!     int	    regname;
!     long    num;
!     int	    cmd1;
!     int	    cmd2;
!     int	    cmd3;
!     int	    cmd4;
!     int	    cmd5;
  {
      ResetRedobuff();
      if (regname != 0)	/* yank from specified buffer */
--- 3621,3634 ----
   * Note that only the last argument can be a multi-byte char.
   */
      static void
! prep_redo(
!     int	    regname,
!     long    num,
!     int	    cmd1,
!     int	    cmd2,
!     int	    cmd3,
!     int	    cmd4,
!     int	    cmd5)
  {
      ResetRedobuff();
      if (regname != 0)	/* yank from specified buffer */
***************
*** 3673,3680 ****
   * return TRUE if operator was active
   */
      static int
! checkclearop(oap)
!     oparg_T	*oap;
  {
      if (oap->op_type == OP_NOP)
  	return FALSE;
--- 3657,3663 ----
   * return TRUE if operator was active
   */
      static int
! checkclearop(oparg_T *oap)
  {
      if (oap->op_type == OP_NOP)
  	return FALSE;
***************
*** 3688,3695 ****
   * Return TRUE if operator or Visual was active.
   */
      static int
! checkclearopq(oap)
!     oparg_T	*oap;
  {
      if (oap->op_type == OP_NOP && !VIsual_active)
  	return FALSE;
--- 3671,3677 ----
   * Return TRUE if operator or Visual was active.
   */
      static int
! checkclearopq(oparg_T *oap)
  {
      if (oap->op_type == OP_NOP && !VIsual_active)
  	return FALSE;
***************
*** 3698,3705 ****
  }
  
      static void
! clearop(oap)
!     oparg_T	*oap;
  {
      oap->op_type = OP_NOP;
      oap->regname = 0;
--- 3680,3686 ----
  }
  
      static void
! clearop(oparg_T *oap)
  {
      oap->op_type = OP_NOP;
      oap->regname = 0;
***************
*** 3708,3715 ****
  }
  
      static void
! clearopbeep(oap)
!     oparg_T	*oap;
  {
      clearop(oap);
      beep_flush();
--- 3689,3695 ----
  }
  
      static void
! clearopbeep(oparg_T *oap)
  {
      clearop(oap);
      beep_flush();
***************
*** 3719,3726 ****
   * Remove the shift modifier from a special key.
   */
      static void
! unshift_special(cap)
!     cmdarg_T	*cap;
  {
      switch (cap->cmdchar)
      {
--- 3699,3705 ----
   * Remove the shift modifier from a special key.
   */
      static void
! unshift_special(cmdarg_T *cap)
  {
      switch (cap->cmdchar)
      {
***************
*** 3739,3745 ****
   * command displayed.
   */
      static void
! may_clear_cmdline()
  {
      if (mode_displayed)
  	clear_cmdline = TRUE;   /* unshow visual mode later */
--- 3718,3724 ----
   * command displayed.
   */
      static void
! may_clear_cmdline(void)
  {
      if (mode_displayed)
  	clear_cmdline = TRUE;   /* unshow visual mode later */
***************
*** 3763,3769 ****
  static void display_showcmd(void);
  
      void
! clear_showcmd()
  {
      if (!p_sc)
  	return;
--- 3742,3748 ----
  static void display_showcmd(void);
  
      void
! clear_showcmd(void)
  {
      if (!p_sc)
  	return;
***************
*** 3870,3877 ****
   * Return TRUE if output has been written (and setcursor() has been called).
   */
      int
! add_to_showcmd(c)
!     int		c;
  {
      char_u	*p;
      int		old_len;
--- 3849,3855 ----
   * Return TRUE if output has been written (and setcursor() has been called).
   */
      int
! add_to_showcmd(int c)
  {
      char_u	*p;
      int		old_len;
***************
*** 3933,3940 ****
  }
  
      void
! add_to_showcmd_c(c)
!     int		c;
  {
      if (!add_to_showcmd(c))
  	setcursor();
--- 3911,3917 ----
  }
  
      void
! add_to_showcmd_c(int c)
  {
      if (!add_to_showcmd(c))
  	setcursor();
***************
*** 3944,3951 ****
   * Delete 'len' characters from the end of the shown command.
   */
      static void
! del_from_showcmd(len)
!     int	    len;
  {
      int	    old_len;
  
--- 3921,3927 ----
   * Delete 'len' characters from the end of the shown command.
   */
      static void
! del_from_showcmd(int len)
  {
      int	    old_len;
  
***************
*** 3966,3979 ****
   * something and there is a partial mapping.
   */
      void
! push_showcmd()
  {
      if (p_sc)
  	STRCPY(old_showcmd_buf, showcmd_buf);
  }
  
      void
! pop_showcmd()
  {
      if (!p_sc)
  	return;
--- 3942,3955 ----
   * something and there is a partial mapping.
   */
      void
! push_showcmd(void)
  {
      if (p_sc)
  	STRCPY(old_showcmd_buf, showcmd_buf);
  }
  
      void
! pop_showcmd(void)
  {
      if (!p_sc)
  	return;
***************
*** 3984,3990 ****
  }
  
      static void
! display_showcmd()
  {
      int	    len;
  
--- 3960,3966 ----
  }
  
      static void
! display_showcmd(void)
  {
      int	    len;
  
***************
*** 4016,4023 ****
   * scrolled.  Called from normal_cmd() and edit().
   */
      void
! do_check_scrollbind(check)
!     int		check;
  {
      static win_T	*old_curwin = NULL;
      static linenr_T	old_topline = 0;
--- 3992,3998 ----
   * scrolled.  Called from normal_cmd() and edit().
   */
      void
! do_check_scrollbind(int check)
  {
      static win_T	*old_curwin = NULL;
      static linenr_T	old_topline = 0;
***************
*** 4087,4095 ****
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
      void
! check_scrollbind(topline_diff, leftcol_diff)
!     linenr_T	topline_diff;
!     long	leftcol_diff;
  {
      int		want_ver;
      int		want_hor;
--- 4062,4068 ----
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
      void
! check_scrollbind(linenr_T topline_diff, long leftcol_diff)
  {
      int		want_ver;
      int		want_hor;
***************
*** 4181,4188 ****
   * xon/xoff.
   */
      static void
! nv_ignore(cap)
!     cmdarg_T	*cap;
  {
      cap->retval |= CA_COMMAND_BUSY;	/* don't call edit() now */
  }
--- 4154,4160 ----
   * xon/xoff.
   */
      static void
! nv_ignore(cmdarg_T *cap)
  {
      cap->retval |= CA_COMMAND_BUSY;	/* don't call edit() now */
  }
***************
*** 4192,4199 ****
   * start edit().  Used for "startinsert" executed while starting up.
   */
      static void
! nv_nop(cap)
!     cmdarg_T	*cap UNUSED;
  {
  }
  
--- 4164,4170 ----
   * start edit().  Used for "startinsert" executed while starting up.
   */
      static void
! nv_nop(cmdarg_T *cap UNUSED)
  {
  }
  
***************
*** 4201,4208 ****
   * Command character doesn't exist.
   */
      static void
! nv_error(cap)
!     cmdarg_T	*cap;
  {
      clearopbeep(cap->oap);
  }
--- 4172,4178 ----
   * Command character doesn't exist.
   */
      static void
! nv_error(cmdarg_T *cap)
  {
      clearopbeep(cap->oap);
  }
***************
*** 4211,4218 ****
   * <Help> and <F1> commands.
   */
      static void
! nv_help(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearopq(cap->oap))
  	ex_help(NULL);
--- 4181,4187 ----
   * <Help> and <F1> commands.
   */
      static void
! nv_help(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
  	ex_help(NULL);
***************
*** 4222,4229 ****
   * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.
   */
      static void
! nv_addsub(cap)
!     cmdarg_T	*cap;
  {
      if (!VIsual_active && cap->oap->op_type == OP_NOP)
      {
--- 4191,4197 ----
   * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.
   */
      static void
! nv_addsub(cmdarg_T *cap)
  {
      if (!VIsual_active && cap->oap->op_type == OP_NOP)
      {
***************
*** 4242,4249 ****
   * CTRL-F, CTRL-B, etc: Scroll page up or down.
   */
      static void
! nv_page(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearop(cap->oap))
      {
--- 4210,4216 ----
   * CTRL-F, CTRL-B, etc: Scroll page up or down.
   */
      static void
! nv_page(cmdarg_T *cap)
  {
      if (!checkclearop(cap->oap))
      {
***************
*** 4266,4275 ****
   * Implementation of "gd" and "gD" command.
   */
      static void
! nv_gd(oap, nchar, thisblock)
!     oparg_T	*oap;
!     int		nchar;
!     int		thisblock;	/* 1 for "1gd" and "1gD" */
  {
      int		len;
      char_u	*ptr;
--- 4233,4242 ----
   * Implementation of "gd" and "gD" command.
   */
      static void
! nv_gd(
!     oparg_T	*oap,
!     int		nchar,
!     int		thisblock)	/* 1 for "1gd" and "1gD" */
  {
      int		len;
      char_u	*ptr;
***************
*** 4291,4302 ****
   * Return FAIL when not found.
   */
      int
! find_decl(ptr, len, locally, thisblock, searchflags)
!     char_u	*ptr;
!     int		len;
!     int		locally;
!     int		thisblock;
!     int		searchflags;	/* flags passed to searchit() */
  {
      char_u	*pat;
      pos_T	old_pos;
--- 4258,4269 ----
   * Return FAIL when not found.
   */
      int
! find_decl(
!     char_u	*ptr,
!     int		len,
!     int		locally,
!     int		thisblock,
!     int		searchflags)	/* flags passed to searchit() */
  {
      char_u	*pat;
      pos_T	old_pos;
***************
*** 4423,4432 ****
   * Return OK if able to move cursor, FAIL otherwise.
   */
      static int
! nv_screengo(oap, dir, dist)
!     oparg_T	*oap;
!     int		dir;
!     long	dist;
  {
      int		linelen = linetabsize(ml_get_curline());
      int		retval = OK;
--- 4390,4396 ----
   * Return OK if able to move cursor, FAIL otherwise.
   */
      static int
! nv_screengo(oparg_T *oap, int dir, long dist)
  {
      int		linelen = linetabsize(ml_get_curline());
      int		retval = OK;
***************
*** 4586,4593 ****
   * K_MOUSELEFT (cap->arg == -1) or K_MOUSERIGHT (cap->arg == -2)
   */
      static void
! nv_mousescroll(cap)
!     cmdarg_T	*cap;
  {
  # ifdef FEAT_WINDOWS
      win_T *old_curwin = curwin;
--- 4550,4556 ----
   * K_MOUSELEFT (cap->arg == -1) or K_MOUSERIGHT (cap->arg == -2)
   */
      static void
! nv_mousescroll(cmdarg_T *cap)
  {
  # ifdef FEAT_WINDOWS
      win_T *old_curwin = curwin;
***************
*** 4649,4656 ****
   * Mouse clicks and drags.
   */
      static void
! nv_mouse(cap)
!     cmdarg_T	*cap;
  {
      (void)do_mouse(cap->oap, cap->cmdchar, BACKWARD, cap->count1, 0);
  }
--- 4612,4618 ----
   * Mouse clicks and drags.
   */
      static void
! nv_mouse(cmdarg_T *cap)
  {
      (void)do_mouse(cap->oap, cap->cmdchar, BACKWARD, cap->count1, 0);
  }
***************
*** 4661,4668 ****
   * cap->arg must be TRUE for CTRL-E.
   */
      static void
! nv_scroll_line(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearop(cap->oap))
  	scroll_redraw(cap->arg, cap->count1);
--- 4623,4629 ----
   * cap->arg must be TRUE for CTRL-E.
   */
      static void
! nv_scroll_line(cmdarg_T *cap)
  {
      if (!checkclearop(cap->oap))
  	scroll_redraw(cap->arg, cap->count1);
***************
*** 4672,4680 ****
   * Scroll "count" lines up or down, and redraw.
   */
      void
! scroll_redraw(up, count)
!     int		up;
!     long	count;
  {
      linenr_T	prev_topline = curwin->w_topline;
  #ifdef FEAT_DIFF
--- 4633,4639 ----
   * Scroll "count" lines up or down, and redraw.
   */
      void
! scroll_redraw(int up, long count)
  {
      linenr_T	prev_topline = curwin->w_topline;
  #ifdef FEAT_DIFF
***************
*** 4731,4738 ****
   * Commands that start with "z".
   */
      static void
! nv_zet(cap)
!     cmdarg_T  *cap;
  {
      long	n;
      colnr_T	col;
--- 4690,4696 ----
   * Commands that start with "z".
   */
      static void
! nv_zet(cmdarg_T *cap)
  {
      long	n;
      colnr_T	col;
***************
*** 5227,5234 ****
   * Vertical scrollbar movement.
   */
      static void
! nv_ver_scrollbar(cap)
!     cmdarg_T	*cap;
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
--- 5185,5191 ----
   * Vertical scrollbar movement.
   */
      static void
! nv_ver_scrollbar(cmdarg_T *cap)
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
***************
*** 5241,5248 ****
   * Horizontal scrollbar movement.
   */
      static void
! nv_hor_scrollbar(cap)
!     cmdarg_T	*cap;
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
--- 5198,5204 ----
   * Horizontal scrollbar movement.
   */
      static void
! nv_hor_scrollbar(cmdarg_T *cap)
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
***************
*** 5257,5264 ****
   * Click in GUI tab.
   */
      static void
! nv_tabline(cap)
!     cmdarg_T	*cap;
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
--- 5213,5219 ----
   * Click in GUI tab.
   */
      static void
! nv_tabline(cmdarg_T *cap)
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
***************
*** 5271,5278 ****
   * Selected item in tab line menu.
   */
      static void
! nv_tabmenu(cap)
!     cmdarg_T	*cap;
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
--- 5226,5232 ----
   * Selected item in tab line menu.
   */
      static void
! nv_tabmenu(cmdarg_T *cap)
  {
      if (cap->oap->op_type != OP_NOP)
  	clearopbeep(cap->oap);
***************
*** 5286,5292 ****
   * Used in Normal and Insert mode.
   */
      void
! handle_tabmenu()
  {
      switch (current_tabmenu)
      {
--- 5240,5246 ----
   * Used in Normal and Insert mode.
   */
      void
! handle_tabmenu(void)
  {
      switch (current_tabmenu)
      {
***************
*** 5330,5337 ****
   * "Q" command.
   */
      static void
! nv_exmode(cap)
!     cmdarg_T	*cap;
  {
      /*
       * Ignore 'Q' in Visual mode, just give a beep.
--- 5284,5290 ----
   * "Q" command.
   */
      static void
! nv_exmode(cmdarg_T *cap)
  {
      /*
       * Ignore 'Q' in Visual mode, just give a beep.
***************
*** 5346,5353 ****
   * Handle a ":" command.
   */
      static void
! nv_colon(cap)
!     cmdarg_T  *cap;
  {
      int	    old_p_im;
      int	    cmd_result;
--- 5299,5305 ----
   * Handle a ":" command.
   */
      static void
! nv_colon(cmdarg_T *cap)
  {
      int	    old_p_im;
      int	    cmd_result;
***************
*** 5411,5418 ****
   * Handle CTRL-G command.
   */
      static void
! nv_ctrlg(cap)
!     cmdarg_T *cap;
  {
      if (VIsual_active)	/* toggle Selection/Visual mode */
      {
--- 5363,5369 ----
   * Handle CTRL-G command.
   */
      static void
! nv_ctrlg(cmdarg_T *cap)
  {
      if (VIsual_active)	/* toggle Selection/Visual mode */
      {
***************
*** 5428,5435 ****
   * Handle CTRL-H <Backspace> command.
   */
      static void
! nv_ctrlh(cap)
!     cmdarg_T *cap;
  {
      if (VIsual_active && VIsual_select)
      {
--- 5379,5385 ----
   * Handle CTRL-H <Backspace> command.
   */
      static void
! nv_ctrlh(cmdarg_T *cap)
  {
      if (VIsual_active && VIsual_select)
      {
***************
*** 5444,5451 ****
   * CTRL-L: clear screen and redraw.
   */
      static void
! nv_clear(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearop(cap->oap))
      {
--- 5394,5400 ----
   * CTRL-L: clear screen and redraw.
   */
      static void
! nv_clear(cmdarg_T *cap)
  {
      if (!checkclearop(cap->oap))
      {
***************
*** 5470,5477 ****
   * Otherwise: Go to older pcmark.
   */
      static void
! nv_ctrlo(cap)
!     cmdarg_T	*cap;
  {
      if (VIsual_active && VIsual_select)
      {
--- 5419,5425 ----
   * Otherwise: Go to older pcmark.
   */
      static void
! nv_ctrlo(cmdarg_T *cap)
  {
      if (VIsual_active && VIsual_select)
      {
***************
*** 5490,5497 ****
   * CTRL-^ command, short for ":e #"
   */
      static void
! nv_hat(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearopq(cap->oap))
  	(void)buflist_getfile((int)cap->count0, (linenr_T)0,
--- 5438,5444 ----
   * CTRL-^ command, short for ":e #"
   */
      static void
! nv_hat(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
  	(void)buflist_getfile((int)cap->count0, (linenr_T)0,
***************
*** 5502,5509 ****
   * "Z" commands.
   */
      static void
! nv_Zet(cap)
!     cmdarg_T *cap;
  {
      if (!checkclearopq(cap->oap))
      {
--- 5449,5455 ----
   * "Z" commands.
   */
      static void
! nv_Zet(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
      {
***************
*** 5527,5535 ****
   * Call nv_ident() as if "c1" was used, with "c2" as next character.
   */
      void
! do_nv_ident(c1, c2)
!     int		c1;
!     int		c2;
  {
      oparg_T	oa;
      cmdarg_T	ca;
--- 5473,5479 ----
   * Call nv_ident() as if "c1" was used, with "c2" as next character.
   */
      void
! do_nv_ident(int c1, int c2)
  {
      oparg_T	oa;
      cmdarg_T	ca;
***************
*** 5552,5559 ****
   *  g  ']'	:tselect for current identifier
   */
      static void
! nv_ident(cap)
!     cmdarg_T	*cap;
  {
      char_u	*ptr = NULL;
      char_u	*buf;
--- 5496,5502 ----
   *  g  ']'	:tselect for current identifier
   */
      static void
! nv_ident(cmdarg_T *cap)
  {
      char_u	*ptr = NULL;
      char_u	*buf;
***************
*** 5788,5797 ****
   * Returns FAIL if more than one line selected.
   */
      int
! get_visual_text(cap, pp, lenp)
!     cmdarg_T	*cap;
!     char_u	**pp;	    /* return: start of selected text */
!     int		*lenp;	    /* return: length of selected text */
  {
      if (VIsual_mode != 'V')
  	unadjust_for_sel();
--- 5731,5740 ----
   * Returns FAIL if more than one line selected.
   */
      int
! get_visual_text(
!     cmdarg_T	*cap,
!     char_u	**pp,	    /* return: start of selected text */
!     int		*lenp)	    /* return: length of selected text */
  {
      if (VIsual_mode != 'V')
  	unadjust_for_sel();
***************
*** 5832,5839 ****
   * CTRL-T: backwards in tag stack
   */
      static void
! nv_tagpop(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearopq(cap->oap))
  	do_tag((char_u *)"", DT_POP, (int)cap->count1, FALSE, TRUE);
--- 5775,5781 ----
   * CTRL-T: backwards in tag stack
   */
      static void
! nv_tagpop(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
  	do_tag((char_u *)"", DT_POP, (int)cap->count1, FALSE, TRUE);
***************
*** 5843,5850 ****
   * Handle scrolling command 'H', 'L' and 'M'.
   */
      static void
! nv_scroll(cap)
!     cmdarg_T  *cap;
  {
      int		used = 0;
      long	n;
--- 5785,5791 ----
   * Handle scrolling command 'H', 'L' and 'M'.
   */
      static void
! nv_scroll(cmdarg_T *cap)
  {
      int		used = 0;
      long	n;
***************
*** 5945,5952 ****
   * Cursor right commands.
   */
      static void
! nv_right(cap)
!     cmdarg_T	*cap;
  {
      long	n;
      int		past_line;
--- 5886,5892 ----
   * Cursor right commands.
   */
      static void
! nv_right(cmdarg_T *cap)
  {
      long	n;
      int		past_line;
***************
*** 6056,6063 ****
   * Returns TRUE when operator end should not be adjusted.
   */
      static void
! nv_left(cap)
!     cmdarg_T	*cap;
  {
      long	n;
  
--- 5996,6002 ----
   * Returns TRUE when operator end should not be adjusted.
   */
      static void
! nv_left(cmdarg_T *cap)
  {
      long	n;
  
***************
*** 6134,6141 ****
   * cap->arg is TRUE for "-": Move cursor to first non-blank.
   */
      static void
! nv_up(cap)
!     cmdarg_T	*cap;
  {
      if (mod_mask & MOD_MASK_SHIFT)
      {
--- 6073,6079 ----
   * cap->arg is TRUE for "-": Move cursor to first non-blank.
   */
      static void
! nv_up(cmdarg_T *cap)
  {
      if (mod_mask & MOD_MASK_SHIFT)
      {
***************
*** 6158,6165 ****
   * cap->arg is TRUE for CR and "+": Move cursor to first non-blank.
   */
      static void
! nv_down(cap)
!     cmdarg_T	*cap;
  {
      if (mod_mask & MOD_MASK_SHIFT)
      {
--- 6096,6103 ----
   * cap->arg is TRUE for CR and "+": Move cursor to first non-blank.
   */
      static void
! nv_down(
!     cmdarg_T	*cap)
  {
      if (mod_mask & MOD_MASK_SHIFT)
      {
***************
*** 6199,6206 ****
   * Grab the file name under the cursor and edit it.
   */
      static void
! nv_gotofile(cap)
!     cmdarg_T	*cap;
  {
      char_u	*ptr;
      linenr_T	lnum = -1;
--- 6137,6143 ----
   * Grab the file name under the cursor and edit it.
   */
      static void
! nv_gotofile(cmdarg_T *cap)
  {
      char_u	*ptr;
      linenr_T	lnum = -1;
***************
*** 6246,6253 ****
   * <End> command: to end of current line or last line.
   */
      static void
! nv_end(cap)
!     cmdarg_T	*cap;
  {
      if (cap->arg || (mod_mask & MOD_MASK_CTRL))	/* CTRL-END = goto last line */
      {
--- 6183,6189 ----
   * <End> command: to end of current line or last line.
   */
      static void
! nv_end(cmdarg_T *cap)
  {
      if (cap->arg || (mod_mask & MOD_MASK_CTRL))	/* CTRL-END = goto last line */
      {
***************
*** 6262,6269 ****
   * Handle the "$" command.
   */
      static void
! nv_dollar(cap)
!     cmdarg_T	*cap;
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = TRUE;
--- 6198,6204 ----
   * Handle the "$" command.
   */
      static void
! nv_dollar(cmdarg_T *cap)
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = TRUE;
***************
*** 6289,6296 ****
   * If cap->arg is TRUE don't set PC mark.
   */
      static void
! nv_search(cap)
!     cmdarg_T	    *cap;
  {
      oparg_T	*oap = cap->oap;
  
--- 6224,6230 ----
   * If cap->arg is TRUE don't set PC mark.
   */
      static void
! nv_search(cmdarg_T *cap)
  {
      oparg_T	*oap = cap->oap;
  
***************
*** 6320,6327 ****
   * cap->arg is SEARCH_REV for "N", 0 for "n".
   */
      static void
! nv_next(cap)
!     cmdarg_T	*cap;
  {
      pos_T old = curwin->w_cursor;
      int   i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
--- 6254,6260 ----
   * cap->arg is SEARCH_REV for "N", 0 for "n".
   */
      static void
! nv_next(cmdarg_T *cap)
  {
      pos_T old = curwin->w_cursor;
      int   i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
***************
*** 6343,6353 ****
   * Return 0 for failure, 1 for found, 2 for found and line offset added.
   */
      static int
! normal_search(cap, dir, pat, opt)
!     cmdarg_T	*cap;
!     int		dir;
!     char_u	*pat;
!     int		opt;		/* extra flags for do_search() */
  {
      int		i;
  
--- 6276,6286 ----
   * Return 0 for failure, 1 for found, 2 for found and line offset added.
   */
      static int
! normal_search(
!     cmdarg_T	*cap,
!     int		dir,
!     char_u	*pat,
!     int		opt)		/* extra flags for do_search() */
  {
      int		i;
  
***************
*** 6386,6393 ****
   * cap->nchar is NUL for ',' and ';' (repeat the search)
   */
      static void
! nv_csearch(cap)
!     cmdarg_T	*cap;
  {
      int		t_cmd;
  
--- 6319,6325 ----
   * cap->nchar is NUL for ',' and ';' (repeat the search)
   */
      static void
! nv_csearch(cmdarg_T *cap)
  {
      int		t_cmd;
  
***************
*** 6428,6435 ****
   * cap->arg is BACKWARD for "[" and FORWARD for "]".
   */
      static void
! nv_brackets(cap)
!     cmdarg_T	*cap;
  {
      pos_T	new_pos = INIT_POS_T(0, 0, 0);
      pos_T	prev_pos;
--- 6360,6366 ----
   * cap->arg is BACKWARD for "[" and FORWARD for "]".
   */
      static void
! nv_brackets(cmdarg_T *cap)
  {
      pos_T	new_pos = INIT_POS_T(0, 0, 0);
      pos_T	prev_pos;
***************
*** 6798,6805 ****
   * Handle Normal mode "%" command.
   */
      static void
! nv_percent(cap)
!     cmdarg_T	*cap;
  {
      pos_T	*pos;
  #if defined(FEAT_FOLDING)
--- 6729,6735 ----
   * Handle Normal mode "%" command.
   */
      static void
! nv_percent(cmdarg_T *cap)
  {
      pos_T	*pos;
  #if defined(FEAT_FOLDING)
***************
*** 6859,6866 ****
   * cap->arg is BACKWARD for "(" and FORWARD for ")".
   */
      static void
! nv_brace(cap)
!     cmdarg_T	*cap;
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->use_reg_one = TRUE;
--- 6789,6795 ----
   * cap->arg is BACKWARD for "(" and FORWARD for ")".
   */
      static void
! nv_brace(cmdarg_T *cap)
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->use_reg_one = TRUE;
***************
*** 6888,6895 ****
   * "m" command: Mark a position.
   */
      static void
! nv_mark(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearop(cap->oap))
      {
--- 6817,6823 ----
   * "m" command: Mark a position.
   */
      static void
! nv_mark(cmdarg_T *cap)
  {
      if (!checkclearop(cap->oap))
      {
***************
*** 6903,6910 ****
   * cmd->arg is BACKWARD for "{" and FORWARD for "}".
   */
      static void
! nv_findpar(cap)
!     cmdarg_T	*cap;
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
--- 6831,6837 ----
   * cmd->arg is BACKWARD for "{" and FORWARD for "}".
   */
      static void
! nv_findpar(cmdarg_T *cap)
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
***************
*** 6928,6935 ****
   * "u" command: Undo or make lower case.
   */
      static void
! nv_undo(cap)
!     cmdarg_T	*cap;
  {
      if (cap->oap->op_type == OP_LOWER || VIsual_active)
      {
--- 6855,6861 ----
   * "u" command: Undo or make lower case.
   */
      static void
! nv_undo(cmdarg_T *cap)
  {
      if (cap->oap->op_type == OP_LOWER || VIsual_active)
      {
***************
*** 6946,6953 ****
   * <Undo> command.
   */
      static void
! nv_kundo(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearopq(cap->oap))
      {
--- 6872,6878 ----
   * <Undo> command.
   */
      static void
! nv_kundo(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
      {
***************
*** 6960,6967 ****
   * Handle the "r" command.
   */
      static void
! nv_replace(cap)
!     cmdarg_T	*cap;
  {
      char_u	*ptr;
      int		had_ctrl_v;
--- 6885,6891 ----
   * Handle the "r" command.
   */
      static void
! nv_replace(cmdarg_T *cap)
  {
      char_u	*ptr;
      int		had_ctrl_v;
***************
*** 7176,7183 ****
   * 'O': same, but in block mode exchange left and right corners.
   */
      static void
! v_swap_corners(cmdchar)
!     int		cmdchar;
  {
      pos_T	old_cursor;
      colnr_T	left, right;
--- 7100,7106 ----
   * 'O': same, but in block mode exchange left and right corners.
   */
      static void
! v_swap_corners(int cmdchar)
  {
      pos_T	old_cursor;
      colnr_T	left, right;
***************
*** 7228,7235 ****
   * "R" (cap->arg is FALSE) and "gR" (cap->arg is TRUE).
   */
      static void
! nv_Replace(cap)
!     cmdarg_T	    *cap;
  {
      if (VIsual_active)		/* "R" is replace lines */
      {
--- 7151,7157 ----
   * "R" (cap->arg is FALSE) and "gR" (cap->arg is TRUE).
   */
      static void
! nv_Replace(cmdarg_T *cap)
  {
      if (VIsual_active)		/* "R" is replace lines */
      {
***************
*** 7259,7266 ****
   * "gr".
   */
      static void
! nv_vreplace(cap)
!     cmdarg_T	*cap;
  {
      if (VIsual_active)
      {
--- 7181,7187 ----
   * "gr".
   */
      static void
! nv_vreplace(cmdarg_T *cap)
  {
      if (VIsual_active)
      {
***************
*** 7292,7299 ****
   * Swap case for "~" command, when it does not work like an operator.
   */
      static void
! n_swapchar(cap)
!     cmdarg_T	*cap;
  {
      long	n;
      pos_T	startpos;
--- 7213,7219 ----
   * Swap case for "~" command, when it does not work like an operator.
   */
      static void
! n_swapchar(cmdarg_T *cap)
  {
      long	n;
      pos_T	startpos;
***************
*** 7388,7397 ****
   * Move cursor to mark.
   */
      static void
! nv_cursormark(cap, flag, pos)
!     cmdarg_T	*cap;
!     int		flag;
!     pos_T	*pos;
  {
      if (check_mark(pos) == FAIL)
  	clearop(cap->oap);
--- 7308,7314 ----
   * Move cursor to mark.
   */
      static void
! nv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)
  {
      if (check_mark(pos) == FAIL)
  	clearop(cap->oap);
***************
*** 7419,7426 ****
   * Handle commands that are operators in Visual mode.
   */
      static void
! v_visop(cap)
!     cmdarg_T	*cap;
  {
      static char_u trans[] = "YyDdCcxdXdAAIIrr";
  
--- 7336,7342 ----
   * Handle commands that are operators in Visual mode.
   */
      static void
! v_visop(cmdarg_T *cap)
  {
      static char_u trans[] = "YyDdCcxdXdAAIIrr";
  
***************
*** 7444,7451 ****
   * "s" and "S" commands.
   */
      static void
! nv_subst(cap)
!     cmdarg_T	*cap;
  {
      if (VIsual_active)	/* "vs" and "vS" are the same as "vc" */
      {
--- 7360,7366 ----
   * "s" and "S" commands.
   */
      static void
! nv_subst(cmdarg_T *cap)
  {
      if (VIsual_active)	/* "vs" and "vS" are the same as "vc" */
      {
***************
*** 7465,7472 ****
   * Abbreviated commands.
   */
      static void
! nv_abbrev(cap)
!     cmdarg_T	*cap;
  {
      if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)
  	cap->cmdchar = 'x';		/* DEL key behaves like 'x' */
--- 7380,7386 ----
   * Abbreviated commands.
   */
      static void
! nv_abbrev(cmdarg_T *cap)
  {
      if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)
  	cap->cmdchar = 'x';		/* DEL key behaves like 'x' */
***************
*** 7482,7489 ****
   * Translate a command into another command.
   */
      static void
! nv_optrans(cap)
!     cmdarg_T	*cap;
  {
      static char_u *(ar[8]) = {(char_u *)"dl", (char_u *)"dh",
  			      (char_u *)"d$", (char_u *)"c$",
--- 7396,7402 ----
   * Translate a command into another command.
   */
      static void
! nv_optrans(cmdarg_T *cap)
  {
      static char_u *(ar[8]) = {(char_u *)"dl", (char_u *)"dh",
  			      (char_u *)"d$", (char_u *)"c$",
***************
*** 7523,7530 ****
   * cap->arg is TRUE for "'" and "g'".
   */
      static void
! nv_gomark(cap)
!     cmdarg_T	*cap;
  {
      pos_T	*pos;
      int		c;
--- 7436,7442 ----
   * cap->arg is TRUE for "'" and "g'".
   */
      static void
! nv_gomark(cmdarg_T *cap)
  {
      pos_T	*pos;
      int		c;
***************
*** 7570,7577 ****
   * Handle CTRL-O, CTRL-I, "g;" and "g," commands.
   */
      static void
! nv_pcmark(cap)
!     cmdarg_T	*cap;
  {
  #ifdef FEAT_JUMPLIST
      pos_T	*pos;
--- 7482,7488 ----
   * Handle CTRL-O, CTRL-I, "g;" and "g," commands.
   */
      static void
! nv_pcmark(cmdarg_T *cap)
  {
  #ifdef FEAT_JUMPLIST
      pos_T	*pos;
***************
*** 7621,7628 ****
   * Handle '"' command.
   */
      static void
! nv_regname(cap)
!     cmdarg_T	*cap;
  {
      if (checkclearop(cap->oap))
  	return;
--- 7532,7538 ----
   * Handle '"' command.
   */
      static void
! nv_regname(cmdarg_T *cap)
  {
      if (checkclearop(cap->oap))
  	return;
***************
*** 7649,7656 ****
   * Handle CTRL-Q just like CTRL-V.
   */
      static void
! nv_visual(cap)
!     cmdarg_T	*cap;
  {
      if (cap->cmdchar == Ctrl_Q)
  	cap->cmdchar = Ctrl_V;
--- 7559,7565 ----
   * Handle CTRL-Q just like CTRL-V.
   */
      static void
! nv_visual(cmdarg_T *cap)
  {
      if (cap->cmdchar == Ctrl_Q)
  	cap->cmdchar = Ctrl_V;
***************
*** 7758,7764 ****
   * Start selection for Shift-movement keys.
   */
      void
! start_selection()
  {
      /* if 'selectmode' contains "key", start Select mode */
      may_start_select('k');
--- 7667,7673 ----
   * Start selection for Shift-movement keys.
   */
      void
! start_selection(void)
  {
      /* if 'selectmode' contains "key", start Select mode */
      may_start_select('k');
***************
*** 7769,7776 ****
   * Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.
   */
      void
! may_start_select(c)
!     int		c;
  {
      VIsual_select = (stuff_empty() && typebuf_typed()
  		    && (vim_strchr(p_slm, c) != NULL));
--- 7678,7684 ----
   * Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.
   */
      void
! may_start_select(int c)
  {
      VIsual_select = (stuff_empty() && typebuf_typed()
  		    && (vim_strchr(p_slm, c) != NULL));
***************
*** 7781,7788 ****
   * Should set VIsual_select before calling this.
   */
      static void
! n_start_visual_mode(c)
!     int		c;
  {
  #ifdef FEAT_CONCEAL
      /* Check for redraw before changing the state. */
--- 7689,7695 ----
   * Should set VIsual_select before calling this.
   */
      static void
! n_start_visual_mode(int c)
  {
  #ifdef FEAT_CONCEAL
      /* Check for redraw before changing the state. */
***************
*** 7838,7845 ****
   * CTRL-W: Window commands
   */
      static void
! nv_window(cap)
!     cmdarg_T	*cap;
  {
  #ifdef FEAT_WINDOWS
      if (!checkclearop(cap->oap))
--- 7745,7751 ----
   * CTRL-W: Window commands
   */
      static void
! nv_window(cmdarg_T *cap)
  {
  #ifdef FEAT_WINDOWS
      if (!checkclearop(cap->oap))
***************
*** 7853,7860 ****
   * CTRL-Z: Suspend
   */
      static void
! nv_suspend(cap)
!     cmdarg_T	*cap;
  {
      clearop(cap->oap);
      if (VIsual_active)
--- 7759,7765 ----
   * CTRL-Z: Suspend
   */
      static void
! nv_suspend(cmdarg_T *cap)
  {
      clearop(cap->oap);
      if (VIsual_active)
***************
*** 7866,7873 ****
   * Commands starting with "g".
   */
      static void
! nv_g_cmd(cap)
!     cmdarg_T	*cap;
  {
      oparg_T	*oap = cap->oap;
      pos_T	tpos;
--- 7771,7777 ----
   * Commands starting with "g".
   */
      static void
! nv_g_cmd(cmdarg_T *cap)
  {
      oparg_T	*oap = cap->oap;
      pos_T	tpos;
***************
*** 8461,8468 ****
   * Handle "o" and "O" commands.
   */
      static void
! n_opencmd(cap)
!     cmdarg_T	*cap;
  {
  #ifdef FEAT_CONCEAL
      linenr_T	oldline = curwin->w_cursor.lnum;
--- 8365,8371 ----
   * Handle "o" and "O" commands.
   */
      static void
! n_opencmd(cmdarg_T *cap)
  {
  #ifdef FEAT_CONCEAL
      linenr_T	oldline = curwin->w_cursor.lnum;
***************
*** 8512,8519 ****
   * "." command: redo last change.
   */
      static void
! nv_dot(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearopq(cap->oap))
      {
--- 8415,8421 ----
   * "." command: redo last change.
   */
      static void
! nv_dot(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
      {
***************
*** 8531,8538 ****
   * CTRL-R: undo undo
   */
      static void
! nv_redo(cap)
!     cmdarg_T	*cap;
  {
      if (!checkclearopq(cap->oap))
      {
--- 8433,8439 ----
   * CTRL-R: undo undo
   */
      static void
! nv_redo(cmdarg_T *cap)
  {
      if (!checkclearopq(cap->oap))
      {
***************
*** 8545,8552 ****
   * Handle "U" command.
   */
      static void
! nv_Undo(cap)
!     cmdarg_T	*cap;
  {
      /* In Visual mode and typing "gUU" triggers an operator */
      if (cap->oap->op_type == OP_UPPER || VIsual_active)
--- 8446,8452 ----
   * Handle "U" command.
   */
      static void
! nv_Undo(cmdarg_T *cap)
  {
      /* In Visual mode and typing "gUU" triggers an operator */
      if (cap->oap->op_type == OP_UPPER || VIsual_active)
***************
*** 8568,8575 ****
   * single character.
   */
      static void
! nv_tilde(cap)
!     cmdarg_T	*cap;
  {
      if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)
  	n_swapchar(cap);
--- 8468,8474 ----
   * single character.
   */
      static void
! nv_tilde(cmdarg_T *cap)
  {
      if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)
  	n_swapchar(cap);
***************
*** 8582,8589 ****
   * The actual work is done by do_pending_operator().
   */
      static void
! nv_operator(cap)
!     cmdarg_T	*cap;
  {
      int	    op_type;
  
--- 8481,8487 ----
   * The actual work is done by do_pending_operator().
   */
      static void
! nv_operator(cmdarg_T *cap)
  {
      int	    op_type;
  
***************
*** 8606,8613 ****
   * Set v:operator to the characters for "optype".
   */
      static void
! set_op_var(optype)
!     int optype;
  {
      char_u	opchars[3];
  
--- 8504,8510 ----
   * Set v:operator to the characters for "optype".
   */
      static void
! set_op_var(int optype)
  {
      char_u	opchars[3];
  
***************
*** 8633,8640 ****
   * "d3_" works to delete 3 lines.
   */
      static void
! nv_lineop(cap)
!     cmdarg_T	*cap;
  {
      cap->oap->motion_type = MLINE;
      if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)
--- 8530,8536 ----
   * "d3_" works to delete 3 lines.
   */
      static void
! nv_lineop(cmdarg_T *cap)
  {
      cap->oap->motion_type = MLINE;
      if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)
***************
*** 8653,8660 ****
   * <Home> command.
   */
      static void
! nv_home(cap)
!     cmdarg_T	*cap;
  {
      /* CTRL-HOME is like "gg" */
      if (mod_mask & MOD_MASK_CTRL)
--- 8549,8555 ----
   * <Home> command.
   */
      static void
! nv_home(cmdarg_T *cap)
  {
      /* CTRL-HOME is like "gg" */
      if (mod_mask & MOD_MASK_CTRL)
***************
*** 8672,8679 ****
   * "|" command.
   */
      static void
! nv_pipe(cap)
!     cmdarg_T *cap;
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
--- 8567,8573 ----
   * "|" command.
   */
      static void
! nv_pipe(cmdarg_T *cap)
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
***************
*** 8695,8702 ****
   * cap->arg is 1 for "B"
   */
      static void
! nv_bck_word(cap)
!     cmdarg_T	*cap;
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
--- 8589,8595 ----
   * cap->arg is 1 for "B"
   */
      static void
! nv_bck_word(cmdarg_T *cap)
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
***************
*** 8714,8721 ****
   * cap->arg is TRUE for "E" and "W".
   */
      static void
! nv_wordcmd(cap)
!     cmdarg_T	*cap;
  {
      int		n;
      int		word_end;
--- 8607,8613 ----
   * cap->arg is TRUE for "E" and "W".
   */
      static void
! nv_wordcmd(cmdarg_T *cap)
  {
      int		n;
      int		word_end;
***************
*** 8804,8811 ****
   * inclusive.
   */
      static void
! adjust_cursor(oap)
!     oparg_T *oap;
  {
      /* The cursor cannot remain on the NUL when:
       * - the column is > 0
--- 8696,8702 ----
   * inclusive.
   */
      static void
! adjust_cursor(oparg_T *oap)
  {
      /* The cursor cannot remain on the NUL when:
       * - the column is > 0
***************
*** 8834,8841 ****
   * cap->arg is the argument for beginline().
   */
      static void
! nv_beginline(cap)
!     cmdarg_T	*cap;
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
--- 8725,8731 ----
   * cap->arg is the argument for beginline().
   */
      static void
! nv_beginline(cmdarg_T *cap)
  {
      cap->oap->motion_type = MCHAR;
      cap->oap->inclusive = FALSE;
***************
*** 8852,8859 ****
   * In exclusive Visual mode, may include the last character.
   */
      static void
! adjust_for_sel(cap)
!     cmdarg_T	*cap;
  {
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
  	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
--- 8742,8748 ----
   * In exclusive Visual mode, may include the last character.
   */
      static void
! adjust_for_sel(cmdarg_T *cap)
  {
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
  	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
***************
*** 8874,8880 ****
   * Returns TRUE when backed up to the previous line.
   */
      static int
! unadjust_for_sel()
  {
      pos_T	*pp;
  
--- 8763,8769 ----
   * Returns TRUE when backed up to the previous line.
   */
      static int
! unadjust_for_sel(void)
  {
      pos_T	*pp;
  
***************
*** 8910,8917 ****
   * SELECT key in Normal or Visual mode: end of Select mode mapping.
   */
      static void
! nv_select(cap)
!     cmdarg_T	*cap;
  {
      if (VIsual_active)
  	VIsual_select = TRUE;
--- 8799,8805 ----
   * SELECT key in Normal or Visual mode: end of Select mode mapping.
   */
      static void
! nv_select(cmdarg_T *cap)
  {
      if (VIsual_active)
  	VIsual_select = TRUE;
***************
*** 8929,8936 ****
   * cap->arg is TRUE for "G".
   */
      static void
! nv_goto(cap)
!     cmdarg_T	*cap;
  {
      linenr_T	lnum;
  
--- 8817,8823 ----
   * cap->arg is TRUE for "G".
   */
      static void
! nv_goto(cmdarg_T *cap)
  {
      linenr_T	lnum;
  
***************
*** 8960,8967 ****
   * CTRL-\ in Normal mode.
   */
      static void
! nv_normal(cap)
!     cmdarg_T	*cap;
  {
      if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)
      {
--- 8847,8853 ----
   * CTRL-\ in Normal mode.
   */
      static void
! nv_normal(cmdarg_T *cap)
  {
      if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)
      {
***************
*** 8991,8998 ****
   * Don't even beep if we are canceling a command.
   */
      static void
! nv_esc(cap)
!     cmdarg_T	*cap;
  {
      int		no_reason;
  
--- 8877,8883 ----
   * Don't even beep if we are canceling a command.
   */
      static void
! nv_esc(cmdarg_T *cap)
  {
      int		no_reason;
  
***************
*** 9051,9058 ****
   * Handle "A", "a", "I", "i" and <Insert> commands.
   */
      static void
! nv_edit(cap)
!     cmdarg_T *cap;
  {
      /* <Insert> is equal to "i" */
      if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)
--- 8936,8942 ----
   * Handle "A", "a", "I", "i" and <Insert> commands.
   */
      static void
! nv_edit(cmdarg_T *cap)
  {
      /* <Insert> is equal to "i" */
      if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)
***************
*** 9144,9154 ****
   * Invoke edit() and take care of "restart_edit" and the return value.
   */
      static void
! invoke_edit(cap, repl, cmd, startln)
!     cmdarg_T	*cap;
!     int		repl;		/* "r" or "gr" command */
!     int		cmd;
!     int		startln;
  {
      int		restart_edit_save = 0;
  
--- 9028,9038 ----
   * Invoke edit() and take care of "restart_edit" and the return value.
   */
      static void
! invoke_edit(
!     cmdarg_T	*cap,
!     int		repl,		/* "r" or "gr" command */
!     int		cmd,
!     int		startln)
  {
      int		restart_edit_save = 0;
  
***************
*** 9175,9182 ****
   * "a" or "i" while an operator is pending or in Visual mode: object motion.
   */
      static void
! nv_object(cap)
!     cmdarg_T	*cap;
  {
      int		flag;
      int		include;
--- 9059,9066 ----
   * "a" or "i" while an operator is pending or in Visual mode: object motion.
   */
      static void
! nv_object(
!     cmdarg_T	*cap)
  {
      int		flag;
      int		include;
***************
*** 9263,9270 ****
   * "q:", "q/", "q?": edit command-line in command-line window.
   */
      static void
! nv_record(cap)
!     cmdarg_T	*cap;
  {
      if (cap->oap->op_type == OP_FORMAT)
      {
--- 9147,9153 ----
   * "q:", "q/", "q?": edit command-line in command-line window.
   */
      static void
! nv_record(cmdarg_T *cap)
  {
      if (cap->oap->op_type == OP_FORMAT)
      {
***************
*** 9294,9301 ****
   * Handle the "@r" command.
   */
      static void
! nv_at(cap)
!     cmdarg_T	*cap;
  {
      if (checkclearop(cap->oap))
  	return;
--- 9177,9183 ----
   * Handle the "@r" command.
   */
      static void
! nv_at(cmdarg_T *cap)
  {
      if (checkclearop(cap->oap))
  	return;
***************
*** 9321,9328 ****
   * Handle the CTRL-U and CTRL-D commands.
   */
      static void
! nv_halfpage(cap)
!     cmdarg_T	*cap;
  {
      if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)
  	    || (cap->cmdchar == Ctrl_D
--- 9203,9209 ----
   * Handle the CTRL-U and CTRL-D commands.
   */
      static void
! nv_halfpage(cmdarg_T *cap)
  {
      if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)
  	    || (cap->cmdchar == Ctrl_D
***************
*** 9336,9343 ****
   * Handle "J" or "gJ" command.
   */
      static void
! nv_join(cap)
!     cmdarg_T *cap;
  {
      if (VIsual_active)	/* join the visual lines */
  	nv_operator(cap);
--- 9217,9223 ----
   * Handle "J" or "gJ" command.
   */
      static void
! nv_join(cmdarg_T *cap)
  {
      if (VIsual_active)	/* join the visual lines */
  	nv_operator(cap);
***************
*** 9361,9368 ****
   * "P", "gP", "p" and "gp" commands.
   */
      static void
! nv_put(cap)
!     cmdarg_T  *cap;
  {
      int		regname = 0;
      void	*reg1 = NULL, *reg2 = NULL;
--- 9241,9247 ----
   * "P", "gP", "p" and "gp" commands.
   */
      static void
! nv_put(cmdarg_T *cap)
  {
      int		regname = 0;
      void	*reg1 = NULL, *reg2 = NULL;
***************
*** 9496,9503 ****
   * "o" and "O" commands.
   */
      static void
! nv_open(cap)
!     cmdarg_T	*cap;
  {
  #ifdef FEAT_DIFF
      /* "do" is ":diffget" */
--- 9375,9381 ----
   * "o" and "O" commands.
   */
      static void
! nv_open(cmdarg_T *cap)
  {
  #ifdef FEAT_DIFF
      /* "do" is ":diffget" */
***************
*** 9516,9523 ****
  
  #ifdef FEAT_SNIFF
      static void
! nv_sniff(cap)
!     cmdarg_T	*cap UNUSED;
  {
      ProcessSniffRequests();
  }
--- 9394,9400 ----
  
  #ifdef FEAT_SNIFF
      static void
! nv_sniff(cmdarg_T *cap UNUSED)
  {
      ProcessSniffRequests();
  }
***************
*** 9525,9532 ****
  
  #ifdef FEAT_NETBEANS_INTG
      static void
! nv_nbcmd(cap)
!     cmdarg_T	*cap;
  {
      netbeans_keycommand(cap->nchar);
  }
--- 9402,9408 ----
  
  #ifdef FEAT_NETBEANS_INTG
      static void
! nv_nbcmd(cmdarg_T *cap)
  {
      netbeans_keycommand(cap->nchar);
  }
***************
*** 9534,9541 ****
  
  #ifdef FEAT_DND
      static void
! nv_drop(cap)
!     cmdarg_T	*cap UNUSED;
  {
      do_put('~', BACKWARD, 1L, PUT_CURSEND);
  }
--- 9410,9416 ----
  
  #ifdef FEAT_DND
      static void
! nv_drop(cmdarg_T *cap UNUSED)
  {
      do_put('~', BACKWARD, 1L, PUT_CURSEND);
  }
***************
*** 9548,9555 ****
   * input buffer.  "did_cursorhold" is set to avoid retriggering.
   */
      static void
! nv_cursorhold(cap)
!     cmdarg_T	*cap;
  {
      apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);
      did_cursorhold = TRUE;
--- 9423,9429 ----
   * input buffer.  "did_cursorhold" is set to avoid retriggering.
   */
      static void
! nv_cursorhold(cmdarg_T *cap)
  {
      apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);
      did_cursorhold = TRUE;
***************
*** 9561,9570 ****
   * Calculate start/end virtual columns for operating in block mode.
   */
      static void
! get_op_vcol(oap, redo_VIsual_vcol, initial)
!     oparg_T	*oap;
!     colnr_T	redo_VIsual_vcol;
!     int		initial;    /* when TRUE adjust position for 'selectmode' */
  {
      colnr_T	    start, end;
  
--- 9435,9444 ----
   * Calculate start/end virtual columns for operating in block mode.
   */
      static void
! get_op_vcol(
!     oparg_T	*oap,
!     colnr_T	redo_VIsual_vcol,
!     int		initial)    /* when TRUE adjust position for 'selectmode' */
  {
      colnr_T	    start, end;
  
*** ../vim-7.4.1210/src/ops.c	2016-01-29 22:46:58.954534944 +0100
--- src/ops.c	2016-01-30 19:33:44.421613369 +0100
***************
*** 168,176 ****
   * Must only be called with a valid operator name!
   */
      int
! get_op_type(char1, char2)
!     int		char1;
!     int		char2;
  {
      int		i;
  
--- 168,174 ----
   * Must only be called with a valid operator name!
   */
      int
! get_op_type(int char1, int char2)
  {
      int		i;
  
***************
*** 192,199 ****
   * Return TRUE if operator "op" always works on whole lines.
   */
      int
! op_on_lines(op)
!     int op;
  {
      return opchars[op][2];
  }
--- 190,196 ----
   * Return TRUE if operator "op" always works on whole lines.
   */
      int
! op_on_lines(int op)
  {
      return opchars[op][2];
  }
***************
*** 203,210 ****
   * Returns 'g' or 'z' if there is another command character.
   */
      int
! get_op_char(optype)
!     int		optype;
  {
      return opchars[optype][0];
  }
--- 200,206 ----
   * Returns 'g' or 'z' if there is another command character.
   */
      int
! get_op_char(int optype)
  {
      return opchars[optype][0];
  }
***************
*** 213,220 ****
   * Get second operator command character.
   */
      int
! get_extra_op_char(optype)
!     int		optype;
  {
      return opchars[optype][1];
  }
--- 209,215 ----
   * Get second operator command character.
   */
      int
! get_extra_op_char(int optype)
  {
      return opchars[optype][1];
  }
***************
*** 223,232 ****
   * op_shift - handle a shift operation
   */
      void
! op_shift(oap, curs_top, amount)
!     oparg_T	    *oap;
!     int		    curs_top;
!     int		    amount;
  {
      long	    i;
      int		    first_char;
--- 218,224 ----
   * op_shift - handle a shift operation
   */
      void
! op_shift(oparg_T *oap, int curs_top, int amount)
  {
      long	    i;
      int		    first_char;
***************
*** 320,330 ****
   * leaves cursor on first blank in the line
   */
      void
! shift_line(left, round, amount, call_changed_bytes)
!     int	left;
!     int	round;
!     int	amount;
!     int call_changed_bytes;	/* call changed_bytes() */
  {
      int		count;
      int		i, j;
--- 312,322 ----
   * leaves cursor on first blank in the line
   */
      void
! shift_line(
!     int	left,
!     int	round,
!     int	amount,
!     int call_changed_bytes)	/* call changed_bytes() */
  {
      int		count;
      int		i, j;
***************
*** 375,383 ****
   * Leaves cursor on first character in block.
   */
      static void
! shift_block(oap, amount)
!     oparg_T	*oap;
!     int		amount;
  {
      int			left = (oap->op_type == OP_LSHIFT);
      int			oldstate = State;
--- 367,373 ----
   * Leaves cursor on first character in block.
   */
      static void
! shift_block(oparg_T *oap, int amount)
  {
      int			left = (oap->op_type == OP_LSHIFT);
      int			oldstate = State;
***************
*** 562,572 ****
   * Caller must prepare for undo.
   */
      static void
! block_insert(oap, s, b_insert, bdp)
!     oparg_T		*oap;
!     char_u		*s;
!     int			b_insert;
!     struct block_def	*bdp;
  {
      int		p_ts;
      int		count = 0;	/* extra spaces to replace a cut TAB */
--- 552,562 ----
   * Caller must prepare for undo.
   */
      static void
! block_insert(
!     oparg_T		*oap,
!     char_u		*s,
!     int			b_insert,
!     struct block_def	*bdp)
  {
      int		p_ts;
      int		count = 0;	/* extra spaces to replace a cut TAB */
***************
*** 687,695 ****
   * op_reindent - handle reindenting a block of lines.
   */
      void
! op_reindent(oap, how)
!     oparg_T	*oap;
!     int		(*how)(void);
  {
      long	i;
      char_u	*l;
--- 677,683 ----
   * op_reindent - handle reindenting a block of lines.
   */
      void
! op_reindent(oparg_T *oap, int (*how)(void))
  {
      long	i;
      char_u	*l;
***************
*** 781,787 ****
   * Returns '=' when OK, NUL otherwise.
   */
      int
! get_expr_register()
  {
      char_u	*new_line;
  
--- 769,775 ----
   * Returns '=' when OK, NUL otherwise.
   */
      int
! get_expr_register(void)
  {
      char_u	*new_line;
  
***************
*** 800,807 ****
   * Argument must be an allocated string.
   */
      void
! set_expr_line(new_line)
!     char_u	*new_line;
  {
      vim_free(expr_line);
      expr_line = new_line;
--- 788,794 ----
   * Argument must be an allocated string.
   */
      void
! set_expr_line(char_u *new_line)
  {
      vim_free(expr_line);
      expr_line = new_line;
***************
*** 812,818 ****
   * Returns a pointer to allocated memory, or NULL for failure.
   */
      char_u *
! get_expr_line()
  {
      char_u	*expr_copy;
      char_u	*rv;
--- 799,805 ----
   * Returns a pointer to allocated memory, or NULL for failure.
   */
      char_u *
! get_expr_line(void)
  {
      char_u	*expr_copy;
      char_u	*rv;
***************
*** 843,849 ****
   * Get the '=' register expression itself, without evaluating it.
   */
      char_u *
! get_expr_line_src()
  {
      if (expr_line == NULL)
  	return NULL;
--- 830,836 ----
   * Get the '=' register expression itself, without evaluating it.
   */
      char_u *
! get_expr_line_src(void)
  {
      if (expr_line == NULL)
  	return NULL;
***************
*** 856,864 ****
   * Note: There is no check for 0 (default register), caller should do this
   */
      int
! valid_yank_reg(regname, writing)
!     int	    regname;
!     int	    writing;	    /* if TRUE check for writable registers */
  {
      if (       (regname > 0 && ASCII_ISALNUM(regname))
  	    || (!writing && vim_strchr((char_u *)
--- 843,851 ----
   * Note: There is no check for 0 (default register), caller should do this
   */
      int
! valid_yank_reg(
!     int	    regname,
!     int	    writing)	    /* if TRUE check for writable registers */
  {
      if (       (regname > 0 && ASCII_ISALNUM(regname))
  	    || (!writing && vim_strchr((char_u *)
***************
*** 893,901 ****
   * If regname is 0 and reading, use previous register
   */
      void
! get_yank_register(regname, writing)
!     int	    regname;
!     int	    writing;
  {
      int	    i;
  
--- 880,886 ----
   * If regname is 0 and reading, use previous register
   */
      void
! get_yank_register(int regname, int writing)
  {
      int	    i;
  
***************
*** 942,949 ****
   * available return zero, otherwise return "regname".
   */
      int
! may_get_selection(regname)
!     int regname;
  {
      if (regname == '*')
      {
--- 927,933 ----
   * available return zero, otherwise return "regname".
   */
      int
! may_get_selection(int regname)
  {
      if (regname == '*')
      {
***************
*** 968,976 ****
   * The returned pointer has allocated memory, use put_register() later.
   */
      void *
! get_register(name, copy)
!     int		name;
!     int		copy;	/* make a copy, if FALSE make register empty. */
  {
      struct yankreg	*reg;
      int			i;
--- 952,960 ----
   * The returned pointer has allocated memory, use put_register() later.
   */
      void *
! get_register(
!     int		name,
!     int		copy)	/* make a copy, if FALSE make register empty. */
  {
      struct yankreg	*reg;
      int			i;
***************
*** 1021,1029 ****
   * Put "reg" into register "name".  Free any previous contents and "reg".
   */
      void
! put_register(name, reg)
!     int		name;
!     void	*reg;
  {
      get_yank_register(name, 0);
      free_yank_all();
--- 1005,1011 ----
   * Put "reg" into register "name".  Free any previous contents and "reg".
   */
      void
! put_register(int name, void *reg)
  {
      get_yank_register(name, 0);
      free_yank_all();
***************
*** 1037,1044 ****
  }
  
      void
! free_register(reg)
!     void	*reg;
  {
      struct yankreg tmp;
  
--- 1019,1025 ----
  }
  
      void
! free_register(void *reg)
  {
      struct yankreg tmp;
  
***************
*** 1054,1061 ****
   * return TRUE if the current yank register has type MLINE
   */
      int
! yank_register_mline(regname)
!     int	    regname;
  {
      if (regname != 0 && !valid_yank_reg(regname, FALSE))
  	return FALSE;
--- 1035,1041 ----
   * return TRUE if the current yank register has type MLINE
   */
      int
! yank_register_mline(int regname)
  {
      if (regname != 0 && !valid_yank_reg(regname, FALSE))
  	return FALSE;
***************
*** 1072,1079 ****
   * Return FAIL for failure, OK otherwise.
   */
      int
! do_record(c)
!     int c;
  {
      char_u	    *p;
      static int	    regname;
--- 1052,1058 ----
   * Return FAIL for failure, OK otherwise.
   */
      int
! do_record(int c)
  {
      char_u	    *p;
      static int	    regname;
***************
*** 1133,1141 ****
   * return FAIL for failure, OK otherwise
   */
      static int
! stuff_yank(regname, p)
!     int		regname;
!     char_u	*p;
  {
      char_u	*lp;
      char_u	**pp;
--- 1112,1118 ----
   * return FAIL for failure, OK otherwise
   */
      static int
! stuff_yank(int regname, char_u *p)
  {
      char_u	*lp;
      char_u	**pp;
***************
*** 1191,1201 ****
   * return FAIL for failure, OK otherwise
   */
      int
! do_execreg(regname, colon, addcr, silent)
!     int	    regname;
!     int	    colon;		/* insert ':' before each line */
!     int	    addcr;		/* always add '\n' to end of line */
!     int	    silent;		/* set "silent" flag in typeahead buffer */
  {
      long	i;
      char_u	*p;
--- 1168,1178 ----
   * return FAIL for failure, OK otherwise
   */
      int
! do_execreg(
!     int	    regname,
!     int	    colon,		/* insert ':' before each line */
!     int	    addcr,		/* always add '\n' to end of line */
!     int	    silent)		/* set "silent" flag in typeahead buffer */
  {
      long	i;
      char_u	*p;
***************
*** 1317,1324 ****
   * used only after other typeahead has been processed.
   */
      static void
! put_reedit_in_typebuf(silent)
!     int		silent;
  {
      char_u	buf[3];
  
--- 1294,1300 ----
   * used only after other typeahead has been processed.
   */
      static void
! put_reedit_in_typebuf(int silent)
  {
      char_u	buf[3];
  
***************
*** 1347,1357 ****
   * no remapping.
   */
      static int
! put_in_typebuf(s, esc, colon, silent)
!     char_u	*s;
!     int		esc;
!     int		colon;	    /* add ':' before the line */
!     int		silent;
  {
      int		retval = OK;
  
--- 1323,1333 ----
   * no remapping.
   */
      static int
! put_in_typebuf(
!     char_u	*s,
!     int		esc,
!     int		colon,	    /* add ':' before the line */
!     int		silent)
  {
      int		retval = OK;
  
***************
*** 1386,1394 ****
   * return FAIL for failure, OK otherwise
   */
      int
! insert_reg(regname, literally)
!     int		regname;
!     int		literally;	/* insert literally, not as if typed */
  {
      long	i;
      int		retval = OK;
--- 1362,1370 ----
   * return FAIL for failure, OK otherwise
   */
      int
! insert_reg(
!     int		regname,
!     int		literally)	/* insert literally, not as if typed */
  {
      long	i;
      int		retval = OK;
***************
*** 1450,1458 ****
   * literally ("literally" TRUE) or interpret is as typed characters.
   */
      static void
! stuffescaped(arg, literally)
!     char_u	*arg;
!     int		literally;
  {
      int		c;
      char_u	*start;
--- 1426,1432 ----
   * literally ("literally" TRUE) or interpret is as typed characters.
   */
      static void
! stuffescaped(char_u *arg, int literally)
  {
      int		c;
      char_u	*start;
***************
*** 1494,1504 ****
   * value in "argp".
   */
      int
! get_spec_reg(regname, argp, allocated, errmsg)
!     int		regname;
!     char_u	**argp;
!     int		*allocated;	/* return: TRUE when value was allocated */
!     int		errmsg;		/* give error message when failing */
  {
      int		cnt;
  
--- 1468,1478 ----
   * value in "argp".
   */
      int
! get_spec_reg(
!     int		regname,
!     char_u	**argp,
!     int		*allocated,	/* return: TRUE when value was allocated */
!     int		errmsg)		/* give error message when failing */
  {
      int		cnt;
  
***************
*** 1581,1590 ****
   * return FAIL for failure, OK otherwise
   */
      int
! cmdline_paste_reg(regname, literally, remcr)
!     int regname;
!     int literally;	/* Insert text literally instead of "as typed" */
!     int remcr;		/* don't add CR characters */
  {
      long	i;
  
--- 1555,1564 ----
   * return FAIL for failure, OK otherwise
   */
      int
! cmdline_paste_reg(
!     int regname,
!     int literally,	/* Insert text literally instead of "as typed" */
!     int remcr)		/* don't add CR characters */
  {
      long	i;
  
***************
*** 1616,1623 ****
   * used always and the clipboard being available.
   */
      void
! adjust_clip_reg(rp)
!     int		*rp;
  {
      /* If no reg. specified, and "unnamed" or "unnamedplus" is in 'clipboard',
       * use '*' or '+' reg, respectively. "unnamedplus" prevails. */
--- 1590,1596 ----
   * used always and the clipboard being available.
   */
      void
! adjust_clip_reg(int *rp)
  {
      /* If no reg. specified, and "unnamed" or "unnamedplus" is in 'clipboard',
       * use '*' or '+' reg, respectively. "unnamedplus" prevails. */
***************
*** 1643,1650 ****
   * Return FAIL if undo failed, OK otherwise.
   */
      int
! op_delete(oap)
!     oparg_T   *oap;
  {
      int			n;
      linenr_T		lnum;
--- 1616,1622 ----
   * Return FAIL if undo failed, OK otherwise.
   */
      int
! op_delete(oparg_T *oap)
  {
      int			n;
      linenr_T		lnum;
***************
*** 2013,2020 ****
   * Used for deletion.
   */
      static void
! mb_adjust_opend(oap)
!     oparg_T	*oap;
  {
      char_u	*p;
  
--- 1985,1991 ----
   * Used for deletion.
   */
      static void
! mb_adjust_opend(oparg_T *oap)
  {
      char_u	*p;
  
***************
*** 2031,2039 ****
   * Replace a whole area with one character.
   */
      int
! op_replace(oap, c)
!     oparg_T   *oap;
!     int		c;
  {
      int			n, numc;
  #ifdef FEAT_MBYTE
--- 2002,2008 ----
   * Replace a whole area with one character.
   */
      int
! op_replace(oparg_T *oap, int c)
  {
      int			n, numc;
  #ifdef FEAT_MBYTE
***************
*** 2282,2289 ****
   * Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".
   */
      void
! op_tilde(oap)
!     oparg_T	*oap;
  {
      pos_T		pos;
      struct block_def	bd;
--- 2251,2257 ----
   * Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".
   */
      void
! op_tilde(oparg_T *oap)
  {
      pos_T		pos;
      struct block_def	bd;
***************
*** 2403,2412 ****
   * Returns TRUE if some character was changed.
   */
      static int
! swapchars(op_type, pos, length)
!     int		op_type;
!     pos_T	*pos;
!     int		length;
  {
      int todo;
      int	did_change = 0;
--- 2371,2377 ----
   * Returns TRUE if some character was changed.
   */
      static int
! swapchars(int op_type, pos_T *pos, int length)
  {
      int todo;
      int	did_change = 0;
***************
*** 2438,2446 ****
   * returns TRUE when something actually changed.
   */
      int
! swapchar(op_type, pos)
!     int	    op_type;
!     pos_T    *pos;
  {
      int	    c;
      int	    nc;
--- 2403,2409 ----
   * returns TRUE when something actually changed.
   */
      int
! swapchar(int op_type, pos_T *pos)
  {
      int	    c;
      int	    nc;
***************
*** 2510,2518 ****
   * op_insert - Insert and append operators for Visual mode.
   */
      void
! op_insert(oap, count1)
!     oparg_T	*oap;
!     long	count1;
  {
      long		ins_len, pre_textlen = 0;
      char_u		*firstline, *ins_text;
--- 2473,2479 ----
   * op_insert - Insert and append operators for Visual mode.
   */
      void
! op_insert(oparg_T *oap, long count1)
  {
      long		ins_len, pre_textlen = 0;
      char_u		*firstline, *ins_text;
***************
*** 2707,2714 ****
   * return TRUE if edit() returns because of a CTRL-O command
   */
      int
! op_change(oap)
!     oparg_T	*oap;
  {
      colnr_T		l;
      int			retval;
--- 2668,2674 ----
   * return TRUE if edit() returns because of a CTRL-O command
   */
      int
! op_change(oparg_T *oap)
  {
      colnr_T		l;
      int			retval;
***************
*** 2860,2866 ****
   * set all the yank registers to empty (called from main())
   */
      void
! init_yank()
  {
      int		i;
  
--- 2820,2826 ----
   * set all the yank registers to empty (called from main())
   */
      void
! init_yank(void)
  {
      int		i;
  
***************
*** 2870,2876 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! clear_registers()
  {
      int		i;
  
--- 2830,2836 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! clear_registers(void)
  {
      int		i;
  
***************
*** 2888,2895 ****
   * Called for normal freeing and in case of error.
   */
      static void
! free_yank(n)
!     long	n;
  {
      if (y_current->y_array != NULL)
      {
--- 2848,2854 ----
   * Called for normal freeing and in case of error.
   */
      static void
! free_yank(long n)
  {
      if (y_current->y_array != NULL)
      {
***************
*** 2923,2929 ****
  }
  
      static void
! free_yank_all()
  {
      free_yank(y_current->y_size);
  }
--- 2882,2888 ----
  }
  
      static void
! free_yank_all(void)
  {
      free_yank(y_current->y_size);
  }
***************
*** 2937,2946 ****
   * Return FAIL for failure, OK otherwise.
   */
      int
! op_yank(oap, deleting, mess)
!     oparg_T   *oap;
!     int	    deleting;
!     int	    mess;
  {
      long		y_idx;		/* index in y_array[] */
      struct yankreg	*curr;		/* copy of y_current */
--- 2896,2902 ----
   * Return FAIL for failure, OK otherwise.
   */
      int
! op_yank(oparg_T *oap, int deleting, int mess)
  {
      long		y_idx;		/* index in y_array[] */
      struct yankreg	*curr;		/* copy of y_current */
***************
*** 3265,3273 ****
  }
  
      static int
! yank_copy_line(bd, y_idx)
!     struct block_def	*bd;
!     long		y_idx;
  {
      char_u	*pnew;
  
--- 3221,3227 ----
  }
  
      static int
! yank_copy_line(struct block_def *bd, long y_idx)
  {
      char_u	*pnew;
  
***************
*** 3290,3297 ****
   * Make a copy of the y_current register to register "reg".
   */
      static void
! copy_yank_reg(reg)
!     struct yankreg *reg;
  {
      struct yankreg	*curr = y_current;
      long		j;
--- 3244,3250 ----
   * Make a copy of the y_current register to register "reg".
   */
      static void
! copy_yank_reg(struct yankreg *reg)
  {
      struct yankreg	*curr = y_current;
      long		j;
***************
*** 3323,3333 ****
   *	    PUT_LINE		force linewise put (":put")
   */
      void
! do_put(regname, dir, count, flags)
!     int		regname;
!     int		dir;		/* BACKWARD for 'P', FORWARD for 'p' */
!     long	count;
!     int		flags;
  {
      char_u	*ptr;
      char_u	*newp, *oldp;
--- 3276,3286 ----
   *	    PUT_LINE		force linewise put (":put")
   */
      void
! do_put(
!     int		regname,
!     int		dir,		/* BACKWARD for 'P', FORWARD for 'p' */
!     long	count,
!     int		flags)
  {
      char_u	*ptr;
      char_u	*newp, *oldp;
***************
*** 4000,4006 ****
   * there move it left.
   */
      void
! adjust_cursor_eol()
  {
      if (curwin->w_cursor.col > 0
  	    && gchar_cursor() == NUL
--- 3953,3959 ----
   * there move it left.
   */
      void
! adjust_cursor_eol(void)
  {
      if (curwin->w_cursor.col > 0
  	    && gchar_cursor() == NUL
***************
*** 4030,4036 ****
   * Return TRUE if lines starting with '#' should be left aligned.
   */
      int
! preprocs_left()
  {
      return
  # ifdef FEAT_SMARTINDENT
--- 3983,3989 ----
   * Return TRUE if lines starting with '#' should be left aligned.
   */
      int
! preprocs_left(void)
  {
      return
  # ifdef FEAT_SMARTINDENT
***************
*** 4050,4057 ****
  
  /* Return the character name of the register with the given number */
      int
! get_register_name(num)
!     int num;
  {
      if (num == -1)
  	return '"';
--- 4003,4009 ----
  
  /* Return the character name of the register with the given number */
      int
! get_register_name(int num)
  {
      if (num == -1)
  	return '"';
***************
*** 4087,4094 ****
   * ":dis" and ":registers": Display the contents of the yank registers.
   */
      void
! ex_display(eap)
!     exarg_T	*eap;
  {
      int			i, n;
      long		j;
--- 4039,4045 ----
   * ":dis" and ":registers": Display the contents of the yank registers.
   */
      void
! ex_display(exarg_T *eap)
  {
      int			i, n;
      long		j;
***************
*** 4251,4259 ****
   * truncate at end of screen line
   */
      static void
! dis_msg(p, skip_esc)
!     char_u	*p;
!     int		skip_esc;	    /* if TRUE, ignore trailing ESC */
  {
      int		n;
  #ifdef FEAT_MBYTE
--- 4202,4210 ----
   * truncate at end of screen line
   */
      static void
! dis_msg(
!     char_u	*p,
!     int		skip_esc)	    /* if TRUE, ignore trailing ESC */
  {
      int		n;
  #ifdef FEAT_MBYTE
***************
*** 4292,4302 ****
   *		comment.
   */
      static char_u *
! skip_comment(line, process, include_space, is_comment)
!     char_u   *line;
!     int      process;
!     int	     include_space;
!     int      *is_comment;
  {
      char_u *comment_flags = NULL;
      int    lead_len;
--- 4243,4253 ----
   *		comment.
   */
      static char_u *
! skip_comment(
!     char_u   *line,
!     int      process,
!     int	     include_space,
!     int      *is_comment)
  {
      char_u *comment_flags = NULL;
      int    lead_len;
***************
*** 4364,4375 ****
   * return FAIL for failure, OK otherwise
   */
      int
! do_join(count, insert_space, save_undo, use_formatoptions, setmark)
!     long    count;
!     int	    insert_space;
!     int	    save_undo;
!     int	    use_formatoptions UNUSED;
!     int	    setmark;
  {
      char_u	*curr = NULL;
      char_u      *curr_start = NULL;
--- 4315,4326 ----
   * return FAIL for failure, OK otherwise
   */
      int
! do_join(
!     long    count,
!     int	    insert_space,
!     int	    save_undo,
!     int	    use_formatoptions UNUSED,
!     int	    setmark)
  {
      char_u	*curr = NULL;
      char_u      *curr_start = NULL;
***************
*** 4594,4605 ****
   * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb
   */
      static int
! same_leader(lnum, leader1_len, leader1_flags, leader2_len, leader2_flags)
!     linenr_T lnum;
!     int	    leader1_len;
!     char_u  *leader1_flags;
!     int	    leader2_len;
!     char_u  *leader2_flags;
  {
      int	    idx1 = 0, idx2 = 0;
      char_u  *p;
--- 4545,4556 ----
   * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb
   */
      static int
! same_leader(
!     linenr_T lnum,
!     int	    leader1_len,
!     char_u  *leader1_flags,
!     int	    leader2_len,
!     char_u  *leader2_flags)
  {
      int	    idx1 = 0, idx2 = 0;
      char_u  *p;
***************
*** 4669,4677 ****
   * Implementation of the format operator 'gq'.
   */
      void
! op_format(oap, keep_cursor)
!     oparg_T	*oap;
!     int		keep_cursor;		/* keep cursor on same text char */
  {
      long	old_line_count = curbuf->b_ml.ml_line_count;
  
--- 4620,4628 ----
   * Implementation of the format operator 'gq'.
   */
      void
! op_format(
!     oparg_T	*oap,
!     int		keep_cursor)		/* keep cursor on same text char */
  {
      long	old_line_count = curbuf->b_ml.ml_line_count;
  
***************
*** 4742,4749 ****
   * Implementation of the format operator 'gq' for when using 'formatexpr'.
   */
      void
! op_formatexpr(oap)
!     oparg_T	*oap;
  {
      if (oap->is_VIsual)
  	/* When there is no change: need to remove the Visual selection */
--- 4693,4699 ----
   * Implementation of the format operator 'gq' for when using 'formatexpr'.
   */
      void
! op_formatexpr(oparg_T *oap)
  {
      if (oap->is_VIsual)
  	/* When there is no change: need to remove the Visual selection */
***************
*** 4756,4765 ****
  }
  
      int
! fex_format(lnum, count, c)
!     linenr_T	lnum;
!     long	count;
!     int		c;	/* character to be inserted */
  {
      int		use_sandbox = was_set_insecurely((char_u *)"formatexpr",
  								   OPT_LOCAL);
--- 4706,4715 ----
  }
  
      int
! fex_format(
!     linenr_T	lnum,
!     long	count,
!     int		c)	/* character to be inserted */
  {
      int		use_sandbox = was_set_insecurely((char_u *)"formatexpr",
  								   OPT_LOCAL);
***************
*** 4795,4803 ****
   * first line.
   */
      void
! format_lines(line_count, avoid_fex)
!     linenr_T	line_count;
!     int		avoid_fex;		/* don't use 'formatexpr' */
  {
      int		max_len;
      int		is_not_par;		/* current line not part of parag. */
--- 4745,4753 ----
   * first line.
   */
      void
! format_lines(
!     linenr_T	line_count,
!     int		avoid_fex)		/* don't use 'formatexpr' */
  {
      int		max_len;
      int		is_not_par;		/* current line not part of parag. */
***************
*** 5069,5076 ****
   * Return TRUE if line "lnum" ends in a white character.
   */
      static int
! ends_in_white(lnum)
!     linenr_T	lnum;
  {
      char_u	*s = ml_get(lnum);
      size_t	l;
--- 5019,5025 ----
   * Return TRUE if line "lnum" ends in a white character.
   */
      static int
! ends_in_white(linenr_T lnum)
  {
      char_u	*s = ml_get(lnum);
      size_t	l;
***************
*** 5093,5103 ****
   */
  #ifdef FEAT_COMMENTS
      static int
! fmt_check_par(lnum, leader_len, leader_flags, do_comments)
!     linenr_T	lnum;
!     int		*leader_len;
!     char_u	**leader_flags;
!     int		do_comments;
  {
      char_u	*flags = NULL;	    /* init for GCC */
      char_u	*ptr;
--- 5042,5052 ----
   */
  #ifdef FEAT_COMMENTS
      static int
! fmt_check_par(
!     linenr_T	lnum,
!     int		*leader_len,
!     char_u	**leader_flags,
!     int		do_comments)
  {
      char_u	*flags = NULL;	    /* init for GCC */
      char_u	*ptr;
***************
*** 5124,5131 ****
  }
  #else
      static int
! fmt_check_par(lnum)
!     linenr_T	lnum;
  {
      return (*skipwhite(ml_get(lnum)) == NUL || startPS(lnum, NUL, FALSE));
  }
--- 5073,5079 ----
  }
  #else
      static int
! fmt_check_par(linenr_T lnum)
  {
      return (*skipwhite(ml_get(lnum)) == NUL || startPS(lnum, NUL, FALSE));
  }
***************
*** 5136,5143 ****
   * previous line is in the same paragraph.  Used for auto-formatting.
   */
      int
! paragraph_start(lnum)
!     linenr_T	lnum;
  {
      char_u	*p;
  #ifdef FEAT_COMMENTS
--- 5084,5090 ----
   * previous line is in the same paragraph.  Used for auto-formatting.
   */
      int
! paragraph_start(linenr_T lnum)
  {
      char_u	*p;
  #ifdef FEAT_COMMENTS
***************
*** 5201,5211 ****
   *   that are to be yanked.
   */
      static void
! block_prep(oap, bdp, lnum, is_del)
!     oparg_T		*oap;
!     struct block_def	*bdp;
!     linenr_T		lnum;
!     int			is_del;
  {
      int		incr = 0;
      char_u	*pend;
--- 5148,5158 ----
   *   that are to be yanked.
   */
      static void
! block_prep(
!     oparg_T		*oap,
!     struct block_def	*bdp,
!     linenr_T		lnum,
!     int			is_del)
  {
      int		incr = 0;
      char_u	*pend;
***************
*** 5350,5359 ****
   * Handle the add/subtract operator.
   */
      void
! op_addsub(oap, Prenum1, g_cmd)
!     oparg_T	*oap;
!     linenr_T	Prenum1;	    /* Amount of add/subtract */
!     int		g_cmd;		    /* was g<c-a>/g<c-x> */
  {
      pos_T		pos;
      struct block_def	bd;
--- 5297,5306 ----
   * Handle the add/subtract operator.
   */
      void
! op_addsub(
!     oparg_T	*oap,
!     linenr_T	Prenum1,	    /* Amount of add/subtract */
!     int		g_cmd)		    /* was g<c-a>/g<c-x> */
  {
      pos_T		pos;
      struct block_def	bd;
***************
*** 5464,5474 ****
   * Returns TRUE if some character was changed.
   */
      static int
! do_addsub(op_type, pos, length, Prenum1)
!     int		op_type;
!     pos_T	*pos;
!     int		length;
!     linenr_T	Prenum1;
  {
      int		col;
      char_u	*buf1;
--- 5411,5421 ----
   * Returns TRUE if some character was changed.
   */
      static int
! do_addsub(
!     int		op_type,
!     pos_T	*pos,
!     int		length,
!     linenr_T	Prenum1)
  {
      int		col;
      char_u	*buf1;
***************
*** 5834,5842 ****
  
  #ifdef FEAT_VIMINFO
      int
! read_viminfo_register(virp, force)
!     vir_T	*virp;
!     int		force;
  {
      int		eof;
      int		do_it = TRUE;
--- 5781,5787 ----
  
  #ifdef FEAT_VIMINFO
      int
! read_viminfo_register(vir_T *virp, int force)
  {
      int		eof;
      int		do_it = TRUE;
***************
*** 5971,5978 ****
  }
  
      void
! write_viminfo_registers(fp)
!     FILE    *fp;
  {
      int	    i, j;
      char_u  *type;
--- 5916,5922 ----
  }
  
      void
! write_viminfo_registers(FILE *fp)
  {
      int	    i, j;
      char_u  *type;
***************
*** 6093,6099 ****
   */
  #if defined(FEAT_X11) && defined(FEAT_CLIPBOARD)
      void
! x11_export_final_selection()
  {
      Display	*dpy;
      char_u	*str = NULL;
--- 6037,6043 ----
   */
  #if defined(FEAT_X11) && defined(FEAT_CLIPBOARD)
      void
! x11_export_final_selection(void)
  {
      Display	*dpy;
      char_u	*str = NULL;
***************
*** 6173,6180 ****
  #endif
  
      void
! clip_free_selection(cbd)
!     VimClipboard	*cbd;
  {
      struct yankreg *y_ptr = y_current;
  
--- 6117,6123 ----
  #endif
  
      void
! clip_free_selection(VimClipboard *cbd)
  {
      struct yankreg *y_ptr = y_current;
  
***************
*** 6191,6198 ****
   * Get the selected text and put it in the gui selection register '*' or '+'.
   */
      void
! clip_get_selection(cbd)
!     VimClipboard	*cbd;
  {
      struct yankreg *old_y_previous, *old_y_current;
      pos_T	old_cursor;
--- 6134,6140 ----
   * Get the selected text and put it in the gui selection register '*' or '+'.
   */
      void
! clip_get_selection(VimClipboard *cbd)
  {
      struct yankreg *old_y_previous, *old_y_current;
      pos_T	old_cursor;
***************
*** 6253,6263 ****
   * Convert from the GUI selection string into the '*'/'+' register.
   */
      void
! clip_yank_selection(type, str, len, cbd)
!     int		type;
!     char_u	*str;
!     long	len;
!     VimClipboard *cbd;
  {
      struct yankreg *y_ptr;
  
--- 6195,6205 ----
   * Convert from the GUI selection string into the '*'/'+' register.
   */
      void
! clip_yank_selection(
!     int		type,
!     char_u	*str,
!     long	len,
!     VimClipboard *cbd)
  {
      struct yankreg *y_ptr;
  
***************
*** 6277,6286 ****
   * Returns the motion type, or -1 for failure.
   */
      int
! clip_convert_selection(str, len, cbd)
!     char_u	**str;
!     long_u	*len;
!     VimClipboard *cbd;
  {
      char_u	*p;
      int		lnum;
--- 6219,6225 ----
   * Returns the motion type, or -1 for failure.
   */
      int
! clip_convert_selection(char_u **str, long_u *len, VimClipboard *cbd)
  {
      char_u	*p;
      int		lnum;
***************
*** 6345,6351 ****
   * If we have written to a clipboard register, send the text to the clipboard.
   */
      static void
! may_set_selection()
  {
      if (y_current == &(y_regs[STAR_REGISTER]) && clip_star.available)
      {
--- 6284,6290 ----
   * If we have written to a clipboard register, send the text to the clipboard.
   */
      static void
! may_set_selection(void)
  {
      if (y_current == &(y_regs[STAR_REGISTER]) && clip_star.available)
      {
***************
*** 6367,6375 ****
   * Replace the contents of the '~' register with str.
   */
      void
! dnd_yank_drag_data(str, len)
!     char_u	*str;
!     long	len;
  {
      struct yankreg *curr;
  
--- 6306,6312 ----
   * Replace the contents of the '~' register with str.
   */
      void
! dnd_yank_drag_data(char_u *str, long len)
  {
      struct yankreg *curr;
  
***************
*** 6389,6397 ****
   * Returns MAUTO for error.
   */
      char_u
! get_reg_type(regname, reglen)
!     int	    regname;
!     long    *reglen;
  {
      switch (regname)
      {
--- 6326,6332 ----
   * Returns MAUTO for error.
   */
      char_u
! get_reg_type(int regname, long *reglen)
  {
      switch (regname)
      {
***************
*** 6436,6444 ****
   * Otherwise just return "s".
   */
      static char_u *
! getreg_wrap_one_line(s, flags)
!     char_u	*s;
!     int		flags;
  {
      if (flags & GREG_LIST)
      {
--- 6371,6377 ----
   * Otherwise just return "s".
   */
      static char_u *
! getreg_wrap_one_line(char_u *s, int flags)
  {
      if (flags & GREG_LIST)
      {
***************
*** 6469,6477 ****
   *	GREG_LIST	Return a list of lines in place of a single string.
   */
      char_u *
! get_reg_contents(regname, flags)
!     int		regname;
!     int		flags;
  {
      long	i;
      char_u	*retval;
--- 6402,6408 ----
   *	GREG_LIST	Return a list of lines in place of a single string.
   */
      char_u *
! get_reg_contents(int regname, int flags)
  {
      long	i;
      char_u	*retval;
***************
*** 6572,6583 ****
  }
  
      static int
! init_write_reg(name, old_y_previous, old_y_current, must_append, yank_type)
!     int		    name;
!     struct yankreg  **old_y_previous;
!     struct yankreg  **old_y_current;
!     int		    must_append;
!     int		    *yank_type UNUSED;
  {
      if (!valid_yank_reg(name, TRUE))	    /* check for valid reg name */
      {
--- 6503,6514 ----
  }
  
      static int
! init_write_reg(
!     int		    name,
!     struct yankreg  **old_y_previous,
!     struct yankreg  **old_y_current,
!     int		    must_append,
!     int		    *yank_type UNUSED)
  {
      if (!valid_yank_reg(name, TRUE))	    /* check for valid reg name */
      {
***************
*** 6596,6605 ****
  }
  
      static void
! finish_write_reg(name, old_y_previous, old_y_current)
!     int		    name;
!     struct yankreg  *old_y_previous;
!     struct yankreg  *old_y_current;
  {
  # ifdef FEAT_CLIPBOARD
      /* Send text of clipboard register to the clipboard. */
--- 6527,6536 ----
  }
  
      static void
! finish_write_reg(
!     int		    name,
!     struct yankreg  *old_y_previous,
!     struct yankreg  *old_y_current)
  {
  # ifdef FEAT_CLIPBOARD
      /* Send text of clipboard register to the clipboard. */
***************
*** 6622,6644 ****
   * If "str" ends in '\n' or '\r', use linewise, otherwise use characterwise.
   */
      void
! write_reg_contents(name, str, maxlen, must_append)
!     int		name;
!     char_u	*str;
!     int		maxlen;
!     int		must_append;
  {
      write_reg_contents_ex(name, str, maxlen, must_append, MAUTO, 0L);
  }
  
      void
! write_reg_contents_lst(name, strings, maxlen, must_append, yank_type, block_len)
!     int		name;
!     char_u	**strings;
!     int		maxlen UNUSED;
!     int		must_append;
!     int		yank_type;
!     long	block_len;
  {
      struct yankreg  *old_y_previous, *old_y_current;
  
--- 6553,6575 ----
   * If "str" ends in '\n' or '\r', use linewise, otherwise use characterwise.
   */
      void
! write_reg_contents(
!     int		name,
!     char_u	*str,
!     int		maxlen,
!     int		must_append)
  {
      write_reg_contents_ex(name, str, maxlen, must_append, MAUTO, 0L);
  }
  
      void
! write_reg_contents_lst(
!     int		name,
!     char_u	**strings,
!     int		maxlen UNUSED,
!     int		must_append,
!     int		yank_type,
!     long	block_len)
  {
      struct yankreg  *old_y_previous, *old_y_current;
  
***************
*** 6677,6689 ****
  }
  
      void
! write_reg_contents_ex(name, str, maxlen, must_append, yank_type, block_len)
!     int		name;
!     char_u	*str;
!     int		maxlen;
!     int		must_append;
!     int		yank_type;
!     long	block_len;
  {
      struct yankreg  *old_y_previous, *old_y_current;
      long	    len;
--- 6608,6620 ----
  }
  
      void
! write_reg_contents_ex(
!     int		name,
!     char_u	*str,
!     int		maxlen,
!     int		must_append,
!     int		yank_type,
!     long	block_len)
  {
      struct yankreg  *old_y_previous, *old_y_current;
      long	    len;
***************
*** 6759,6771 ****
   * is appended.
   */
      static void
! str_to_reg(y_ptr, yank_type, str, len, blocklen, str_list)
!     struct yankreg	*y_ptr;		/* pointer to yank register */
!     int			yank_type;	/* MCHAR, MLINE, MBLOCK, MAUTO */
!     char_u		*str;		/* string to put in register */
!     long		len;		/* length of string */
!     long		blocklen;	/* width of Visual block */
!     int			str_list;	/* TRUE if str is char_u ** */
  {
      int		type;			/* MCHAR, MLINE or MBLOCK */
      int		lnum;
--- 6690,6702 ----
   * is appended.
   */
      static void
! str_to_reg(
!     struct yankreg	*y_ptr,		/* pointer to yank register */
!     int			yank_type,	/* MCHAR, MLINE, MBLOCK, MAUTO */
!     char_u		*str,		/* string to put in register */
!     long		len,		/* length of string */
!     long		blocklen,	/* width of Visual block */
!     int			str_list)	/* TRUE if str is char_u ** */
  {
      int		type;			/* MCHAR, MLINE or MBLOCK */
      int		lnum;
***************
*** 6899,6906 ****
  #endif /* FEAT_CLIPBOARD || FEAT_EVAL || PROTO */
  
      void
! clear_oparg(oap)
!     oparg_T	*oap;
  {
      vim_memset(oap, 0, sizeof(oparg_T));
  }
--- 6830,6836 ----
  #endif /* FEAT_CLIPBOARD || FEAT_EVAL || PROTO */
  
      void
! clear_oparg(oparg_T *oap)
  {
      vim_memset(oap, 0, sizeof(oparg_T));
  }
***************
*** 6922,6933 ****
   *  the size of the EOL character.
   */
      static long
! line_count_info(line, wc, cc, limit, eol_size)
!     char_u	*line;
!     long	*wc;
!     long	*cc;
!     long	limit;
!     int		eol_size;
  {
      long	i;
      long	words = 0;
--- 6852,6863 ----
   *  the size of the EOL character.
   */
      static long
! line_count_info(
!     char_u	*line,
!     long	*wc,
!     long	*cc,
!     long	limit,
!     int		eol_size)
  {
      long	i;
      long	words = 0;
***************
*** 6975,6982 ****
   * When "dict" is not NULL store the info there instead of showing it.
   */
      void
! cursor_pos_info(dict)
!     dict_T	*dict;
  {
      char_u	*p;
      char_u	buf1[50];
--- 6905,6911 ----
   * When "dict" is not NULL store the info there instead of showing it.
   */
      void
! cursor_pos_info(dict_T *dict)
  {
      char_u	*p;
      char_u	buf1[50];
*** ../vim-7.4.1210/src/option.c	2016-01-29 22:46:58.958534901 +0100
--- src/option.c	2016-01-30 19:38:50.182414811 +0100
***************
*** 3165,3171 ****
   * Called only once from main(), just after creating the first buffer.
   */
      void
! set_init_1()
  {
      char_u	*p;
      int		opt_idx;
--- 3165,3171 ----
   * Called only once from main(), just after creating the first buffer.
   */
      void
! set_init_1(void)
  {
      char_u	*p;
      int		opt_idx;
***************
*** 3589,3598 ****
   * This does not take care of side effects!
   */
      static void
! set_option_default(opt_idx, opt_flags, compatible)
!     int		opt_idx;
!     int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		compatible;	/* use Vi default value */
  {
      char_u	*varp;		/* pointer to variable for current option */
      int		dvi;		/* index in def_val[] */
--- 3589,3598 ----
   * This does not take care of side effects!
   */
      static void
! set_option_default(
!     int		opt_idx,
!     int		opt_flags,	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		compatible)	/* use Vi default value */
  {
      char_u	*varp;		/* pointer to variable for current option */
      int		dvi;		/* index in def_val[] */
***************
*** 3664,3671 ****
   * When "opt_flags" is non-zero skip 'encoding'.
   */
      static void
! set_options_default(opt_flags)
!     int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
  {
      int		i;
  #ifdef FEAT_WINDOWS
--- 3664,3671 ----
   * When "opt_flags" is non-zero skip 'encoding'.
   */
      static void
! set_options_default(
!     int		opt_flags)	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
  {
      int		i;
  #ifdef FEAT_WINDOWS
***************
*** 3707,3715 ****
   * Used for 'sh', 'backupskip' and 'term'.
   */
      void
! set_string_default(name, val)
!     char	*name;
!     char_u	*val;
  {
      char_u	*p;
      int		opt_idx;
--- 3707,3713 ----
   * Used for 'sh', 'backupskip' and 'term'.
   */
      void
! set_string_default(char *name, char_u *val)
  {
      char_u	*p;
      int		opt_idx;
***************
*** 3733,3741 ****
   * Used for 'lines' and 'columns'.
   */
      void
! set_number_default(name, val)
!     char	*name;
!     long	val;
  {
      int		opt_idx;
  
--- 3731,3737 ----
   * Used for 'lines' and 'columns'.
   */
      void
! set_number_default(char *name, long val)
  {
      int		opt_idx;
  
***************
*** 3749,3755 ****
   * Free all options.
   */
      void
! free_all_options()
  {
      int		i;
  
--- 3745,3751 ----
   * Free all options.
   */
      void
! free_all_options(void)
  {
      int		i;
  
***************
*** 3777,3783 ****
   * setting 'term'.
   */
      void
! set_init_2()
  {
      int		idx;
  
--- 3773,3779 ----
   * setting 'term'.
   */
      void
! set_init_2(void)
  {
      int		idx;
  
***************
*** 3841,3847 ****
   * case. If this value is 0-6 or 8, our background is dark.
   */
      static char_u *
! term_bg_default()
  {
  #if defined(MSDOS) || defined(WIN3264)
      /* DOS console nearly always black */
--- 3837,3843 ----
   * case. If this value is 0-6 or 8, our background is dark.
   */
      static char_u *
! term_bg_default(void)
  {
  #if defined(MSDOS) || defined(WIN3264)
      /* DOS console nearly always black */
***************
*** 3866,3872 ****
   * Initialize the options, part three: After reading the .vimrc
   */
      void
! set_init_3()
  {
  #if defined(UNIX) || defined(WIN3264)
  /*
--- 3862,3868 ----
   * Initialize the options, part three: After reading the .vimrc
   */
      void
! set_init_3(void)
  {
  #if defined(UNIX) || defined(WIN3264)
  /*
***************
*** 4054,4061 ****
   * Only the first two characters of "lang" are used.
   */
      void
! set_helplang_default(lang)
!     char_u	*lang;
  {
      int		idx;
  
--- 4050,4056 ----
   * Only the first two characters of "lang" are used.
   */
      void
! set_helplang_default(char_u *lang)
  {
      int		idx;
  
***************
*** 4088,4094 ****
  static char_u *gui_bg_default(void);
  
      static char_u *
! gui_bg_default()
  {
      if (gui_get_lightness(gui.back_pixel) < 127)
  	return (char_u *)"dark";
--- 4083,4089 ----
  static char_u *gui_bg_default(void);
  
      static char_u *
! gui_bg_default(void)
  {
      if (gui_get_lightness(gui.back_pixel) < 127)
  	return (char_u *)"dark";
***************
*** 4099,4105 ****
   * Option initializations that can only be done after opening the GUI window.
   */
      void
! init_gui_options()
  {
      /* Set the 'background' option according to the lightness of the
       * background color, unless the user has set it already. */
--- 4094,4100 ----
   * Option initializations that can only be done after opening the GUI window.
   */
      void
! init_gui_options(void)
  {
      /* Set the 'background' option according to the lightness of the
       * background color, unless the user has set it already. */
***************
*** 4120,4126 ****
   * machine.
   */
      void
! set_title_defaults()
  {
      int	    idx1;
      long    val;
--- 4115,4121 ----
   * machine.
   */
      void
! set_title_defaults(void)
  {
      int	    idx1;
      long    val;
***************
*** 4173,4181 ****
   * returns FAIL if an error is detected, OK otherwise
   */
      int
! do_set(arg, opt_flags)
!     char_u	*arg;		/* option string (may be written to!) */
!     int		opt_flags;
  {
      int		opt_idx;
      char_u	*errmsg;
--- 4168,4176 ----
   * returns FAIL if an error is detected, OK otherwise
   */
      int
! do_set(
!     char_u	*arg,		/* option string (may be written to!) */
!     int		opt_flags)
  {
      int		opt_idx;
      char_u	*errmsg;
***************
*** 5087,5096 ****
   * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.
   */
      static void
! did_set_option(opt_idx, opt_flags, new_value)
!     int	    opt_idx;
!     int	    opt_flags;	    /* possibly with OPT_MODELINE */
!     int	    new_value;	    /* value was replaced completely */
  {
      long_u	*p;
  
--- 5082,5091 ----
   * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.
   */
      static void
! did_set_option(
!     int	    opt_idx,
!     int	    opt_flags,	    /* possibly with OPT_MODELINE */
!     int	    new_value)	    /* value was replaced completely */
  {
      long_u	*p;
  
***************
*** 5111,5119 ****
  }
  
      static char_u *
! illegal_char(errbuf, c)
!     char_u	*errbuf;
!     int		c;
  {
      if (errbuf == NULL)
  	return (char_u *)"";
--- 5106,5112 ----
  }
  
      static char_u *
! illegal_char(char_u *errbuf, int c)
  {
      if (errbuf == NULL)
  	return (char_u *)"";
***************
*** 5127,5134 ****
   * Used for 'wildchar' and 'cedit' options.
   */
      static int
! string_to_key(arg)
!     char_u	*arg;
  {
      if (*arg == '<')
  	return find_key_option(arg + 1);
--- 5120,5126 ----
   * Used for 'wildchar' and 'cedit' options.
   */
      static int
! string_to_key(char_u *arg)
  {
      if (*arg == '<')
  	return find_key_option(arg + 1);
***************
*** 5143,5149 ****
   * Returns NULL if value is OK, error message otherwise.
   */
      static char_u *
! check_cedit()
  {
      int n;
  
--- 5135,5141 ----
   * Returns NULL if value is OK, error message otherwise.
   */
      static char_u *
! check_cedit(void)
  {
      int n;
  
***************
*** 5168,5175 ****
   * the old value back.
   */
      static void
! did_set_title(icon)
!     int	    icon;	    /* Did set icon instead of title */
  {
      if (starting != NO_SCREEN
  #ifdef FEAT_GUI
--- 5160,5167 ----
   * the old value back.
   */
      static void
! did_set_title(
!     int	    icon)	    /* Did set icon instead of title */
  {
      if (starting != NO_SCREEN
  #ifdef FEAT_GUI
***************
*** 5196,5205 ****
   * set_options_bin -  called when 'bin' changes value.
   */
      void
! set_options_bin(oldval, newval, opt_flags)
!     int		oldval;
!     int		newval;
!     int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      /*
       * The option values that are changed when 'bin' changes are
--- 5188,5197 ----
   * set_options_bin -  called when 'bin' changes value.
   */
      void
! set_options_bin(
!     int		oldval,
!     int		newval,
!     int		opt_flags)	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      /*
       * The option values that are changed when 'bin' changes are
***************
*** 5269,5276 ****
   * number, return -1.
   */
      int
! get_viminfo_parameter(type)
!     int	    type;
  {
      char_u  *p;
  
--- 5261,5267 ----
   * number, return -1.
   */
      int
! get_viminfo_parameter(int type)
  {
      char_u  *p;
  
***************
*** 5286,5293 ****
   * Return NULL if the parameter is not specified in the string.
   */
      char_u *
! find_viminfo_parameter(type)
!     int	    type;
  {
      char_u  *p;
  
--- 5277,5283 ----
   * Return NULL if the parameter is not specified in the string.
   */
      char_u *
! find_viminfo_parameter(int type)
  {
      char_u  *p;
  
***************
*** 5312,5320 ****
   * Return pointer to NameBuff, or NULL when not expanded.
   */
      static char_u *
! option_expand(opt_idx, val)
!     int		opt_idx;
!     char_u	*val;
  {
      /* if option doesn't need expansion nothing to do */
      if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)
--- 5302,5308 ----
   * Return pointer to NameBuff, or NULL when not expanded.
   */
      static char_u *
! option_expand(int opt_idx, char_u *val)
  {
      /* if option doesn't need expansion nothing to do */
      if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)
***************
*** 5351,5357 ****
   * option values.
   */
      static void
! didset_options()
  {
      /* initialize the table for 'iskeyword' et.al. */
      (void)init_chartab();
--- 5339,5345 ----
   * option values.
   */
      static void
! didset_options(void)
  {
      /* initialize the table for 'iskeyword' et.al. */
      (void)init_chartab();
***************
*** 5406,5412 ****
   * More side effects of setting options.
   */
      static void
! didset_options2()
  {
      /* Initialize the highlight_attr[] table. */
      (void)highlight_changed();
--- 5394,5400 ----
   * More side effects of setting options.
   */
      static void
! didset_options2(void)
  {
      /* Initialize the highlight_attr[] table. */
      (void)highlight_changed();
***************
*** 5430,5436 ****
   * Check for string options that are NULL (normally only termcap options).
   */
      void
! check_options()
  {
      int		opt_idx;
  
--- 5418,5424 ----
   * Check for string options that are NULL (normally only termcap options).
   */
      void
! check_options(void)
  {
      int		opt_idx;
  
***************
*** 5443,5450 ****
   * Check string options in a buffer for NULL value.
   */
      void
! check_buf_options(buf)
!     buf_T	*buf;
  {
  #if defined(FEAT_QUICKFIX)
      check_string_option(&buf->b_p_bh);
--- 5431,5437 ----
   * Check string options in a buffer for NULL value.
   */
      void
! check_buf_options(buf_T *buf)
  {
  #if defined(FEAT_QUICKFIX)
      check_string_option(&buf->b_p_bh);
***************
*** 5552,5567 ****
   * Does NOT check for P_ALLOCED flag!
   */
      void
! free_string_option(p)
!     char_u	*p;
  {
      if (p != empty_option)
  	vim_free(p);
  }
  
      void
! clear_string_option(pp)
!     char_u	**pp;
  {
      if (*pp != empty_option)
  	vim_free(*pp);
--- 5539,5552 ----
   * Does NOT check for P_ALLOCED flag!
   */
      void
! free_string_option(char_u *p)
  {
      if (p != empty_option)
  	vim_free(p);
  }
  
      void
! clear_string_option(char_u **pp)
  {
      if (*pp != empty_option)
  	vim_free(*pp);
***************
*** 5569,5576 ****
  }
  
      static void
! check_string_option(pp)
!     char_u	**pp;
  {
      if (*pp == NULL)
  	*pp = empty_option;
--- 5554,5560 ----
  }
  
      static void
! check_string_option(char_u **pp)
  {
      if (*pp == NULL)
  	*pp = empty_option;
***************
*** 5580,5587 ****
   * Mark a terminal option as allocated, found by a pointer into term_strings[].
   */
      void
! set_term_option_alloced(p)
!     char_u **p;
  {
      int		opt_idx;
  
--- 5564,5570 ----
   * Mark a terminal option as allocated, found by a pointer into term_strings[].
   */
      void
! set_term_option_alloced(char_u **p)
  {
      int		opt_idx;
  
***************
*** 5601,5609 ****
   * Return -1 for an unknown option.
   */
      int
! was_set_insecurely(opt, opt_flags)
!     char_u  *opt;
!     int	    opt_flags;
  {
      int	    idx = findoption(opt);
      long_u  *flagp;
--- 5584,5590 ----
   * Return -1 for an unknown option.
   */
      int
! was_set_insecurely(char_u *opt, int opt_flags)
  {
      int	    idx = findoption(opt);
      long_u  *flagp;
***************
*** 5622,5630 ****
   * "opt_idx".  For some local options a local flags field is used.
   */
      static long_u *
! insecure_flag(opt_idx, opt_flags)
!     int		opt_idx;
!     int		opt_flags;
  {
      if (opt_flags & OPT_LOCAL)
  	switch ((int)options[opt_idx].indir)
--- 5603,5609 ----
   * "opt_idx".  For some local options a local flags field is used.
   */
      static long_u *
! insecure_flag(int opt_idx, int opt_flags)
  {
      if (opt_flags & OPT_LOCAL)
  	switch ((int)options[opt_idx].indir)
***************
*** 5661,5667 ****
  /*
   * Redraw the window title and/or tab page text later.
   */
! static void redraw_titles()
  {
      need_maketitle = TRUE;
  # ifdef FEAT_WINDOWS
--- 5640,5646 ----
  /*
   * Redraw the window title and/or tab page text later.
   */
! static void redraw_titles(void)
  {
      need_maketitle = TRUE;
  # ifdef FEAT_WINDOWS
***************
*** 5678,5689 ****
   * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
   */
      void
! set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
!     char_u	*name;
!     int		opt_idx;
!     char_u	*val;
!     int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		set_sid UNUSED;
  {
      char_u	*s;
      char_u	**varp;
--- 5657,5668 ----
   * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
   */
      void
! set_string_option_direct(
!     char_u	*name,
!     int		opt_idx,
!     char_u	*val,
!     int		opt_flags,	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		set_sid UNUSED)
  {
      char_u	*s;
      char_u	**varp;
***************
*** 5738,5746 ****
   * Set global value for string option when it's a local option.
   */
      static void
! set_string_option_global(opt_idx, varp)
!     int		opt_idx;	/* option index */
!     char_u	**varp;		/* pointer to option variable */
  {
      char_u	**p, *s;
  
--- 5717,5725 ----
   * Set global value for string option when it's a local option.
   */
      static void
! set_string_option_global(
!     int		opt_idx,	/* option index */
!     char_u	**varp)		/* pointer to option variable */
  {
      char_u	**p, *s;
  
***************
*** 5764,5773 ****
   * Returns NULL on success or error message on error.
   */
      static char_u *
! set_string_option(opt_idx, value, opt_flags)
!     int		opt_idx;
!     char_u	*value;
!     int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char_u	*s;
      char_u	**varp;
--- 5743,5752 ----
   * Returns NULL on success or error message on error.
   */
      static char_u *
! set_string_option(
!     int		opt_idx,
!     char_u	*value,
!     int		opt_flags)	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char_u	*s;
      char_u	**varp;
***************
*** 5827,5840 ****
   * Returns NULL for success, or an error message for an error.
   */
      static char_u *
! did_set_string_option(opt_idx, varp, new_value_alloced, oldval, errbuf,
! 								    opt_flags)
!     int		opt_idx;		/* index in options[] table */
!     char_u	**varp;			/* pointer to the option variable */
!     int		new_value_alloced;	/* new value was allocated */
!     char_u	*oldval;		/* previous value of the option */
!     char_u	*errbuf;		/* buffer for errors, or NULL */
!     int		opt_flags;		/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char_u	*errmsg = NULL;
      char_u	*s, *p;
--- 5806,5818 ----
   * Returns NULL for success, or an error message for an error.
   */
      static char_u *
! did_set_string_option(
!     int		opt_idx,		/* index in options[] table */
!     char_u	**varp,			/* pointer to the option variable */
!     int		new_value_alloced,	/* new value was allocated */
!     char_u	*oldval,		/* previous value of the option */
!     char_u	*errbuf,		/* buffer for errors, or NULL */
!     int		opt_flags)		/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char_u	*errmsg = NULL;
      char_u	*s, *p;
***************
*** 7375,7383 ****
   * Simple int comparison function for use with qsort()
   */
      static int
! int_cmp(a, b)
!     const void *a;
!     const void *b;
  {
      return *(const int *)a - *(const int *)b;
  }
--- 7353,7359 ----
   * Simple int comparison function for use with qsort()
   */
      static int
! int_cmp(const void *a, const void *b)
  {
      return *(const int *)a - *(const int *)b;
  }
***************
*** 7387,7394 ****
   * Returns error message, NULL if it's OK.
   */
      char_u *
! check_colorcolumn(wp)
!     win_T	*wp;
  {
      char_u	*s;
      int		col;
--- 7363,7369 ----
   * Returns error message, NULL if it's OK.
   */
      char_u *
! check_colorcolumn(win_T *wp)
  {
      char_u	*s;
      int		col;
***************
*** 7459,7466 ****
   * Returns error message, NULL if it's OK.
   */
      static char_u *
! set_chars_option(varp)
!     char_u	**varp;
  {
      int		round, i, len, entries;
      char_u	*p, *s;
--- 7434,7440 ----
   * Returns error message, NULL if it's OK.
   */
      static char_u *
! set_chars_option(char_u **varp)
  {
      int		round, i, len, entries;
      char_u	*p, *s;
***************
*** 7594,7601 ****
   * Return error message or NULL.
   */
      char_u *
! check_stl_option(s)
!     char_u	*s;
  {
      int		itemcnt = 0;
      int		groupdepth = 0;
--- 7568,7574 ----
   * Return error message or NULL.
   */
      char_u *
! check_stl_option(char_u *s)
  {
      int		itemcnt = 0;
      int		groupdepth = 0;
***************
*** 7666,7672 ****
   * Extract the items in the 'clipboard' option and set global values.
   */
      static char_u *
! check_clipboard_option()
  {
      int		new_unnamed = 0;
      int		new_autoselect_star = FALSE;
--- 7639,7645 ----
   * Extract the items in the 'clipboard' option and set global values.
   */
      static char_u *
! check_clipboard_option(void)
  {
      int		new_unnamed = 0;
      int		new_autoselect_star = FALSE;
***************
*** 7755,7762 ****
  
  #ifdef FEAT_SPELL
      static char_u *
! did_set_spell_option(is_spellfile)
!     int		is_spellfile;
  {
      char_u  *errmsg = NULL;
      win_T   *wp;
--- 7728,7734 ----
  
  #ifdef FEAT_SPELL
      static char_u *
! did_set_spell_option(int is_spellfile)
  {
      char_u  *errmsg = NULL;
      win_T   *wp;
***************
*** 7789,7796 ****
   * Return error message when failed, NULL when OK.
   */
      static char_u *
! compile_cap_prog(synblock)
!     synblock_T *synblock;
  {
      regprog_T   *rp = synblock->b_cap_prog;
      char_u	*re;
--- 7761,7767 ----
   * Return error message when failed, NULL when OK.
   */
      static char_u *
! compile_cap_prog(synblock_T *synblock)
  {
      regprog_T   *rp = synblock->b_cap_prog;
      char_u	*re;
***************
*** 7824,7833 ****
   * window-local value.
   */
      static void
! set_option_scriptID_idx(opt_idx, opt_flags, id)
!     int	    opt_idx;
!     int	    opt_flags;
!     int	    id;
  {
      int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
      int		indir = (int)options[opt_idx].indir;
--- 7795,7801 ----
   * window-local value.
   */
      static void
! set_option_scriptID_idx(int opt_idx, int opt_flags, int id)
  {
      int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
      int		indir = (int)options[opt_idx].indir;
***************
*** 7851,7861 ****
   * Returns NULL for success, or an error message for an error.
   */
      static char_u *
! set_bool_option(opt_idx, varp, value, opt_flags)
!     int		opt_idx;		/* index in options[] table */
!     char_u	*varp;			/* pointer to the option variable */
!     int		value;			/* new value */
!     int		opt_flags;		/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      int		old_value = *(int *)varp;
  
--- 7819,7829 ----
   * Returns NULL for success, or an error message for an error.
   */
      static char_u *
! set_bool_option(
!     int		opt_idx,		/* index in options[] table */
!     char_u	*varp,			/* pointer to the option variable */
!     int		value,			/* new value */
!     int		opt_flags)		/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      int		old_value = *(int *)varp;
  
***************
*** 8433,8445 ****
   * Returns NULL for success, or an error message for an error.
   */
      static char_u *
! set_num_option(opt_idx, varp, value, errbuf, errbuflen, opt_flags)
!     int		opt_idx;		/* index in options[] table */
!     char_u	*varp;			/* pointer to the option variable */
!     long	value;			/* new value */
!     char_u	*errbuf;		/* buffer for error messages */
!     size_t	errbuflen;		/* length of "errbuf" */
!     int		opt_flags;		/* OPT_LOCAL, OPT_GLOBAL and
  					   OPT_MODELINE */
  {
      char_u	*errmsg = NULL;
--- 8401,8413 ----
   * Returns NULL for success, or an error message for an error.
   */
      static char_u *
! set_num_option(
!     int		opt_idx,		/* index in options[] table */
!     char_u	*varp,			/* pointer to the option variable */
!     long	value,			/* new value */
!     char_u	*errbuf,		/* buffer for error messages */
!     size_t	errbuflen,		/* length of "errbuf" */
!     int		opt_flags)		/* OPT_LOCAL, OPT_GLOBAL and
  					   OPT_MODELINE */
  {
      char_u	*errmsg = NULL;
***************
*** 8982,8989 ****
   * Called after an option changed: check if something needs to be redrawn.
   */
      static void
! check_redraw(flags)
!     long_u	flags;
  {
      /* Careful: P_RCLR and P_RALL are a combination of other P_ flags */
      int		doclear = (flags & P_RCLR) == P_RCLR;
--- 8950,8956 ----
   * Called after an option changed: check if something needs to be redrawn.
   */
      static void
! check_redraw(long_u flags)
  {
      /* Careful: P_RCLR and P_RALL are a combination of other P_ flags */
      int		doclear = (flags & P_RCLR) == P_RCLR;
***************
*** 9009,9016 ****
   * Return -1 if not found.
   */
      static int
! findoption(arg)
!     char_u *arg;
  {
      int		    opt_idx;
      char	    *s, *p;
--- 8976,8982 ----
   * Return -1 if not found.
   */
      static int
! findoption(char_u *arg)
  {
      int		    opt_idx;
      char	    *s, *p;
***************
*** 9086,9096 ****
   *		   unknown option: -3.
   */
      int
! get_option_value(name, numval, stringval, opt_flags)
!     char_u	*name;
!     long	*numval;
!     char_u	**stringval;	    /* NULL when only checking existence */
!     int		opt_flags;
  {
      int		opt_idx;
      char_u	*varp;
--- 9052,9062 ----
   *		   unknown option: -3.
   */
      int
! get_option_value(
!     char_u	*name,
!     long	*numval,
!     char_u	**stringval,	    /* NULL when only checking existence */
!     int		opt_flags)
  {
      int		opt_idx;
      char_u	*varp;
***************
*** 9156,9167 ****
   * Possible opt_type values: see SREQ_* in vim.h
   */
      int
! get_option_value_strict(name, numval, stringval, opt_type, from)
!     char_u	*name;
!     long	*numval;
!     char_u	**stringval;	    /* NULL when only obtaining attributes */
!     int		opt_type;
!     void	*from;
  {
      int		opt_idx;
      char_u	*varp = NULL;
--- 9122,9133 ----
   * Possible opt_type values: see SREQ_* in vim.h
   */
      int
! get_option_value_strict(
!     char_u	*name,
!     long	*numval,
!     char_u	**stringval,	    /* NULL when only obtaining attributes */
!     int		opt_type,
!     void	*from)
  {
      int		opt_idx;
      char_u	*varp = NULL;
***************
*** 9287,9295 ****
   * Returns full option name for current option on each call.
   */
      char_u *
! option_iter_next(option, opt_type)
!     void	**option;
!     int		opt_type;
  {
      struct vimoption	*ret = NULL;
      do
--- 9253,9259 ----
   * Returns full option name for current option on each call.
   */
      char_u *
! option_iter_next(void **option, int opt_type)
  {
      struct vimoption	*ret = NULL;
      do
***************
*** 9345,9355 ****
   * Returns NULL on success or error message on error.
   */
      char_u *
! set_option_value(name, number, string, opt_flags)
!     char_u	*name;
!     long	number;
!     char_u	*string;
!     int		opt_flags;	/* OPT_LOCAL or 0 (both) */
  {
      int		opt_idx;
      char_u	*varp;
--- 9309,9319 ----
   * Returns NULL on success or error message on error.
   */
      char_u *
! set_option_value(
!     char_u	*name,
!     long	number,
!     char_u	*string,
!     int		opt_flags)	/* OPT_LOCAL or 0 (both) */
  {
      int		opt_idx;
      char_u	*varp;
***************
*** 9412,9419 ****
   * Returns NULL when not found.
   */
      char_u *
! get_term_code(tname)
!     char_u	*tname;
  {
      int	    opt_idx;
      char_u  *varp;
--- 9376,9382 ----
   * Returns NULL when not found.
   */
      char_u *
! get_term_code(char_u *tname)
  {
      int	    opt_idx;
      char_u  *varp;
***************
*** 9432,9438 ****
  }
  
      char_u *
! get_highlight_default()
  {
      int i;
  
--- 9395,9401 ----
  }
  
      char_u *
! get_highlight_default(void)
  {
      int i;
  
***************
*** 9444,9450 ****
  
  #if defined(FEAT_MBYTE) || defined(PROTO)
      char_u *
! get_encoding_default()
  {
      int i;
  
--- 9407,9413 ----
  
  #if defined(FEAT_MBYTE) || defined(PROTO)
      char_u *
! get_encoding_default(void)
  {
      int i;
  
***************
*** 9459,9466 ****
   * Translate a string like "t_xx", "<t_xx>" or "<S-Tab>" to a key number.
   */
      static int
! find_key_option(arg)
!     char_u *arg;
  {
      int		key;
      int		modifiers;
--- 9422,9428 ----
   * Translate a string like "t_xx", "<t_xx>" or "<S-Tab>" to a key number.
   */
      static int
! find_key_option(char_u *arg)
  {
      int		key;
      int		modifiers;
***************
*** 9488,9496 ****
   * if 'all' == 2: show all terminal options
   */
      static void
! showoptions(all, opt_flags)
!     int		all;
!     int		opt_flags;	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      struct vimoption	*p;
      int			col;
--- 9450,9458 ----
   * if 'all' == 2: show all terminal options
   */
      static void
! showoptions(
!     int		all,
!     int		opt_flags)	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      struct vimoption	*p;
      int			col;
***************
*** 9597,9605 ****
   * Return TRUE if option "p" has its default value.
   */
      static int
! optval_default(p, varp)
!     struct vimoption	*p;
!     char_u		*varp;
  {
      int		dvi;
  
--- 9559,9565 ----
   * Return TRUE if option "p" has its default value.
   */
      static int
! optval_default(struct vimoption *p, char_u *varp)
  {
      int		dvi;
  
***************
*** 9621,9629 ****
   * must not be called with a hidden option!
   */
      static void
! showoneopt(p, opt_flags)
!     struct vimoption	*p;
!     int			opt_flags;	/* OPT_LOCAL or OPT_GLOBAL */
  {
      char_u	*varp;
      int		save_silent = silent_mode;
--- 9581,9589 ----
   * must not be called with a hidden option!
   */
      static void
! showoneopt(
!     struct vimoption	*p,
!     int			opt_flags)	/* OPT_LOCAL or OPT_GLOBAL */
  {
      char_u	*varp;
      int		save_silent = silent_mode;
***************
*** 9677,9686 ****
   * Return FAIL on error, OK otherwise.
   */
      int
! makeset(fd, opt_flags, local_only)
!     FILE	*fd;
!     int		opt_flags;
!     int		local_only;
  {
      struct vimoption	*p;
      char_u		*varp;			/* currently used value */
--- 9637,9643 ----
   * Return FAIL on error, OK otherwise.
   */
      int
! makeset(FILE *fd, int opt_flags, int local_only)
  {
      struct vimoption	*p;
      char_u		*varp;			/* currently used value */
***************
*** 9808,9815 ****
   * 'sessionoptions' or 'viewoptions' contains "folds" but not "options".
   */
      int
! makefoldset(fd)
!     FILE	*fd;
  {
      if (put_setstring(fd, "setlocal", "fdm", &curwin->w_p_fdm, FALSE) == FAIL
  # ifdef FEAT_EVAL
--- 9765,9771 ----
   * 'sessionoptions' or 'viewoptions' contains "folds" but not "options".
   */
      int
! makefoldset(FILE *fd)
  {
      if (put_setstring(fd, "setlocal", "fdm", &curwin->w_p_fdm, FALSE) == FAIL
  # ifdef FEAT_EVAL
***************
*** 9832,9843 ****
  #endif
  
      static int
! put_setstring(fd, cmd, name, valuep, expand)
!     FILE	*fd;
!     char	*cmd;
!     char	*name;
!     char_u	**valuep;
!     int		expand;
  {
      char_u	*s;
      char_u	*buf;
--- 9788,9799 ----
  #endif
  
      static int
! put_setstring(
!     FILE	*fd,
!     char	*cmd,
!     char	*name,
!     char_u	**valuep,
!     int		expand)
  {
      char_u	*s;
      char_u	*buf;
***************
*** 9878,9888 ****
  }
  
      static int
! put_setnum(fd, cmd, name, valuep)
!     FILE	*fd;
!     char	*cmd;
!     char	*name;
!     long	*valuep;
  {
      long	wc;
  
--- 9834,9844 ----
  }
  
      static int
! put_setnum(
!     FILE	*fd,
!     char	*cmd,
!     char	*name,
!     long	*valuep)
  {
      long	wc;
  
***************
*** 9902,9912 ****
  }
  
      static int
! put_setbool(fd, cmd, name, value)
!     FILE	*fd;
!     char	*cmd;
!     char	*name;
!     int		value;
  {
      if (value < 0)	/* global/local option using global value */
  	return OK;
--- 9858,9868 ----
  }
  
      static int
! put_setbool(
!     FILE	*fd,
!     char	*cmd,
!     char	*name,
!     int		value)
  {
      if (value < 0)	/* global/local option using global value */
  	return OK;
***************
*** 9922,9928 ****
   * Terminal options are never hidden or indirect.
   */
      void
! clear_termoptions()
  {
      /*
       * Reset a few things before clearing the old options. This may cause
--- 9878,9884 ----
   * Terminal options are never hidden or indirect.
   */
      void
! clear_termoptions(void)
  {
      /*
       * Reset a few things before clearing the old options. This may cause
***************
*** 9953,9959 ****
  }
  
      void
! free_termoptions()
  {
      struct vimoption   *p;
  
--- 9909,9915 ----
  }
  
      void
! free_termoptions(void)
  {
      struct vimoption   *p;
  
***************
*** 9977,9984 ****
   * "var" points to the option value.
   */
      void
! free_one_termoption(var)
!     char_u *var;
  {
      struct vimoption   *p;
  
--- 9933,9939 ----
   * "var" points to the option value.
   */
      void
! free_one_termoption(char_u *var)
  {
      struct vimoption   *p;
  
***************
*** 9998,10004 ****
   * Used after setting the terminal name.
   */
      void
! set_term_defaults()
  {
      struct vimoption   *p;
  
--- 9953,9959 ----
   * Used after setting the terminal name.
   */
      void
! set_term_defaults(void)
  {
      struct vimoption   *p;
  
***************
*** 10025,10032 ****
   * return TRUE if 'p' starts with 't_'
   */
      static int
! istermoption(p)
!     struct vimoption *p;
  {
      return (p->fullname[0] == 't' && p->fullname[1] == '_');
  }
--- 9980,9986 ----
   * return TRUE if 'p' starts with 't_'
   */
      static int
! istermoption(struct vimoption *p)
  {
      return (p->fullname[0] == 't' && p->fullname[1] == '_');
  }
***************
*** 10041,10047 ****
  #define COL_RULER 17	    /* columns needed by standard ruler */
  
      void
! comp_col()
  {
  #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
      int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
--- 9995,10001 ----
  #define COL_RULER 17	    /* columns needed by standard ruler */
  
      void
! comp_col(void)
  {
  #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
      int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
***************
*** 10081,10089 ****
   * Unset local option value, similar to ":set opt<".
   */
      void
! unset_global_local_option(name, from)
!     char_u	*name;
!     void	*from;
  {
      struct vimoption *p;
      int		opt_idx;
--- 10035,10041 ----
   * Unset local option value, similar to ":set opt<".
   */
      void
! unset_global_local_option(char_u *name, void *from)
  {
      struct vimoption *p;
      int		opt_idx;
***************
*** 10177,10185 ****
   * Get pointer to option variable, depending on local or global scope.
   */
      static char_u *
! get_varp_scope(p, opt_flags)
!     struct vimoption	*p;
!     int			opt_flags;
  {
      if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE)
      {
--- 10129,10135 ----
   * Get pointer to option variable, depending on local or global scope.
   */
      static char_u *
! get_varp_scope(struct vimoption *p, int opt_flags)
  {
      if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE)
      {
***************
*** 10234,10241 ****
   * Get pointer to option variable.
   */
      static char_u *
! get_varp(p)
!     struct vimoption	*p;
  {
      /* hidden option, always return NULL */
      if (p->var == NULL)
--- 10184,10190 ----
   * Get pointer to option variable.
   */
      static char_u *
! get_varp(struct vimoption *p)
  {
      /* hidden option, always return NULL */
      if (p->var == NULL)
***************
*** 10481,10487 ****
   * Get the value of 'equalprg', either the buffer-local one or the global one.
   */
      char_u *
! get_equalprg()
  {
      if (*curbuf->b_p_ep == NUL)
  	return p_ep;
--- 10430,10436 ----
   * Get the value of 'equalprg', either the buffer-local one or the global one.
   */
      char_u *
! get_equalprg(void)
  {
      if (*curbuf->b_p_ep == NUL)
  	return p_ep;
***************
*** 10494,10502 ****
   * Used when splitting a window.
   */
      void
! win_copy_options(wp_from, wp_to)
!     win_T	*wp_from;
!     win_T	*wp_to;
  {
      copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);
      copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);
--- 10443,10449 ----
   * Used when splitting a window.
   */
      void
! win_copy_options(win_T *wp_from, win_T *wp_to)
  {
      copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);
      copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);
***************
*** 10519,10527 ****
   * The 'previewwindow' option is reset, there can be only one preview window.
   */
      void
! copy_winopt(from, to)
!     winopt_T	*from;
!     winopt_T	*to;
  {
  #ifdef FEAT_ARABIC
      to->wo_arab = from->wo_arab;
--- 10466,10472 ----
   * The 'previewwindow' option is reset, there can be only one preview window.
   */
      void
! copy_winopt(winopt_T *from, winopt_T *to)
  {
  #ifdef FEAT_ARABIC
      to->wo_arab = from->wo_arab;
***************
*** 10598,10605 ****
   * Check string options in a window for a NULL value.
   */
      void
! check_win_options(win)
!     win_T	*win;
  {
      check_winopt(&win->w_onebuf_opt);
      check_winopt(&win->w_allbuf_opt);
--- 10543,10549 ----
   * Check string options in a window for a NULL value.
   */
      void
! check_win_options(win_T *win)
  {
      check_winopt(&win->w_onebuf_opt);
      check_winopt(&win->w_allbuf_opt);
***************
*** 10609,10616 ****
   * Check for NULL pointers in a winopt_T and replace them with empty_option.
   */
      static void
! check_winopt(wop)
!     winopt_T	*wop UNUSED;
  {
  #ifdef FEAT_FOLDING
      check_string_option(&wop->wo_fdi);
--- 10553,10559 ----
   * Check for NULL pointers in a winopt_T and replace them with empty_option.
   */
      static void
! check_winopt(winopt_T *wop UNUSED)
  {
  #ifdef FEAT_FOLDING
      check_string_option(&wop->wo_fdi);
***************
*** 10643,10650 ****
   * Free the allocated memory inside a winopt_T.
   */
      void
! clear_winopt(wop)
!     winopt_T	*wop UNUSED;
  {
  #ifdef FEAT_FOLDING
      clear_string_option(&wop->wo_fdi);
--- 10586,10592 ----
   * Free the allocated memory inside a winopt_T.
   */
      void
! clear_winopt(winopt_T *wop UNUSED)
  {
  #ifdef FEAT_FOLDING
      clear_string_option(&wop->wo_fdi);
***************
*** 10683,10691 ****
   * BCO_NOHELP	Don't copy the values to a help buffer.
   */
      void
! buf_copy_options(buf, flags)
!     buf_T	*buf;
!     int		flags;
  {
      int		should_copy = TRUE;
      char_u	*save_p_isk = NULL;	    /* init for GCC */
--- 10625,10631 ----
   * BCO_NOHELP	Don't copy the values to a help buffer.
   */
      void
! buf_copy_options(buf_T *buf, int flags)
  {
      int		should_copy = TRUE;
      char_u	*save_p_isk = NULL;	    /* init for GCC */
***************
*** 10935,10941 ****
   * Reset the 'modifiable' option and its default value.
   */
      void
! reset_modifiable()
  {
      int		opt_idx;
  
--- 10875,10881 ----
   * Reset the 'modifiable' option and its default value.
   */
      void
! reset_modifiable(void)
  {
      int		opt_idx;
  
***************
*** 10950,10956 ****
   * Set the global value for 'iminsert' to the local value.
   */
      void
! set_iminsert_global()
  {
      p_iminsert = curbuf->b_p_iminsert;
  }
--- 10890,10896 ----
   * Set the global value for 'iminsert' to the local value.
   */
      void
! set_iminsert_global(void)
  {
      p_iminsert = curbuf->b_p_iminsert;
  }
***************
*** 10959,10965 ****
   * Set the global value for 'imsearch' to the local value.
   */
      void
! set_imsearch_global()
  {
      p_imsearch = curbuf->b_p_imsearch;
  }
--- 10899,10905 ----
   * Set the global value for 'imsearch' to the local value.
   */
      void
! set_imsearch_global(void)
  {
      p_imsearch = curbuf->b_p_imsearch;
  }
***************
*** 10970,10979 ****
  static int expand_option_flags = 0;
  
      void
! set_context_in_set_cmd(xp, arg, opt_flags)
!     expand_T	*xp;
!     char_u	*arg;
!     int		opt_flags;	/* OPT_GLOBAL and/or OPT_LOCAL */
  {
      int		nextchar;
      long_u	flags = 0;	/* init for GCC */
--- 10910,10919 ----
  static int expand_option_flags = 0;
  
      void
! set_context_in_set_cmd(
!     expand_T	*xp,
!     char_u	*arg,
!     int		opt_flags)	/* OPT_GLOBAL and/or OPT_LOCAL */
  {
      int		nextchar;
      long_u	flags = 0;	/* init for GCC */
***************
*** 11176,11186 ****
  }
  
      int
! ExpandSettings(xp, regmatch, num_file, file)
!     expand_T	*xp;
!     regmatch_T	*regmatch;
!     int		*num_file;
!     char_u	***file;
  {
      int		num_normal = 0;	    /* Nr of matching non-term-code settings */
      int		num_term = 0;	    /* Nr of matching terminal code settings */
--- 11116,11126 ----
  }
  
      int
! ExpandSettings(
!     expand_T	*xp,
!     regmatch_T	*regmatch,
!     int		*num_file,
!     char_u	***file)
  {
      int		num_normal = 0;	    /* Nr of matching non-term-code settings */
      int		num_term = 0;	    /* Nr of matching terminal code settings */
***************
*** 11338,11346 ****
  }
  
      int
! ExpandOldSetting(num_file, file)
!     int	    *num_file;
!     char_u  ***file;
  {
      char_u  *var = NULL;	/* init for GCC */
      char_u  *buf;
--- 11278,11284 ----
  }
  
      int
! ExpandOldSetting(int *num_file, char_u ***file)
  {
      char_u  *var = NULL;	/* init for GCC */
      char_u  *buf;
***************
*** 11403,11411 ****
   * NameBuff[].  Must not be called with a hidden option!
   */
      static void
! option_value2string(opp, opt_flags)
!     struct vimoption	*opp;
!     int			opt_flags;	/* OPT_GLOBAL and/or OPT_LOCAL */
  {
      char_u	*varp;
  
--- 11341,11349 ----
   * NameBuff[].  Must not be called with a hidden option!
   */
      static void
! option_value2string(
!     struct vimoption	*opp,
!     int			opt_flags)	/* OPT_GLOBAL and/or OPT_LOCAL */
  {
      char_u	*varp;
  
***************
*** 11448,11456 ****
   * "*wcp" is set to the value of the option if it's 'wildchar' or 'wildcharm'.
   */
      static int
! wc_use_keyname(varp, wcp)
!     char_u	*varp;
!     long	*wcp;
  {
      if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))
      {
--- 11386,11392 ----
   * "*wcp" is set to the value of the option if it's 'wildchar' or 'wildcharm'.
   */
      static int
! wc_use_keyname(char_u *varp, long *wcp)
  {
      if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm))
      {
***************
*** 11493,11501 ****
   * field.  If not found insert a new entry at the appropriate location.
   */
      static void
! langmap_set_entry(from, to)
!     int    from;
!     int    to;
  {
      langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
      int		    a = 0;
--- 11429,11435 ----
   * field.  If not found insert a new entry at the appropriate location.
   */
      static void
! langmap_set_entry(int from, int to)
  {
      langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
      int		    a = 0;
***************
*** 11534,11541 ****
   * Apply 'langmap' to multi-byte character "c" and return the result.
   */
      int
! langmap_adjust_mb(c)
!     int c;
  {
      langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
      int a = 0;
--- 11468,11474 ----
   * Apply 'langmap' to multi-byte character "c" and return the result.
   */
      int
! langmap_adjust_mb(int c)
  {
      langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
      int a = 0;
***************
*** 11558,11564 ****
  # endif
  
      static void
! langmap_init()
  {
      int i;
  
--- 11491,11497 ----
  # endif
  
      static void
! langmap_init(void)
  {
      int i;
  
***************
*** 11574,11580 ****
   * changed at any time!
   */
      static void
! langmap_set()
  {
      char_u  *p;
      char_u  *p2;
--- 11507,11513 ----
   * changed at any time!
   */
      static void
! langmap_set(void)
  {
      char_u  *p;
      char_u  *p2;
***************
*** 11683,11690 ****
   * Take care of no formatting when 'paste' is set.
   */
      int
! has_format_option(x)
!     int		x;
  {
      if (p_paste)
  	return FALSE;
--- 11616,11622 ----
   * Take care of no formatting when 'paste' is set.
   */
      int
! has_format_option(int x)
  {
      if (p_paste)
  	return FALSE;
***************
*** 11696,11703 ****
   * 'shortmess' contains 'a' and "x" is present in SHM_A.
   */
      int
! shortmess(x)
!     int	    x;
  {
      return p_shm != NULL &&
  	    (   vim_strchr(p_shm, x) != NULL
--- 11628,11634 ----
   * 'shortmess' contains 'a' and "x" is present in SHM_A.
   */
      int
! shortmess(int x)
  {
      return p_shm != NULL &&
  	    (   vim_strchr(p_shm, x) != NULL
***************
*** 11709,11715 ****
   * paste_option_changed() - Called after p_paste was set or reset.
   */
      static void
! paste_option_changed()
  {
      static int	old_p_paste = FALSE;
      static int	save_sm = 0;
--- 11640,11646 ----
   * paste_option_changed() - Called after p_paste was set or reset.
   */
      static void
! paste_option_changed(void)
  {
      static int	old_p_paste = FALSE;
      static int	save_sm = 0;
***************
*** 11843,11851 ****
   * When "fname" is not NULL, use it to set $"envname" when it wasn't set yet.
   */
      void
! vimrc_found(fname, envname)
!     char_u	*fname;
!     char_u	*envname;
  {
      int		opt_idx;
      int		dofree = FALSE;
--- 11774,11780 ----
   * When "fname" is not NULL, use it to set $"envname" when it wasn't set yet.
   */
      void
! vimrc_found(char_u *fname, char_u *envname)
  {
      int		opt_idx;
      int		dofree = FALSE;
***************
*** 11883,11890 ****
   * Set 'compatible' on or off.  Called for "-C" and "-N" command line arg.
   */
      void
! change_compatible(on)
!     int	    on;
  {
      int	    opt_idx;
  
--- 11812,11818 ----
   * Set 'compatible' on or off.  Called for "-C" and "-N" command line arg.
   */
      void
! change_compatible(int on)
  {
      int	    opt_idx;
  
***************
*** 11903,11910 ****
   * Only works correctly for global options.
   */
      int
! option_was_set(name)
!     char_u	*name;
  {
      int idx;
  
--- 11831,11837 ----
   * Only works correctly for global options.
   */
      int
! option_was_set(char_u *name)
  {
      int idx;
  
***************
*** 11920,11927 ****
   * Reset the flag indicating option "name" was set.
   */
      void
! reset_option_was_set(name)
!     char_u	*name;
  {
      int idx = findoption(name);
  
--- 11847,11853 ----
   * Reset the flag indicating option "name" was set.
   */
      void
! reset_option_was_set(char_u *name)
  {
      int idx = findoption(name);
  
***************
*** 11938,11944 ****
   * for Vim (without the P_VI_DEF flag) to that default.
   */
      static void
! compatible_set()
  {
      int	    opt_idx;
  
--- 11864,11870 ----
   * for Vim (without the P_VI_DEF flag) to that default.
   */
      static void
! compatible_set(void)
  {
      int	    opt_idx;
  
***************
*** 11961,11967 ****
   * fill_breakat_flags() -- called when 'breakat' changes value.
   */
      static void
! fill_breakat_flags()
  {
      char_u	*p;
      int		i;
--- 11887,11893 ----
   * fill_breakat_flags() -- called when 'breakat' changes value.
   */
      static void
! fill_breakat_flags(void)
  {
      char_u	*p;
      int		i;
***************
*** 11987,11996 ****
   * Empty is always OK.
   */
      static int
! check_opt_strings(val, values, list)
!     char_u	*val;
!     char	**values;
!     int		list;	    /* when TRUE: accept a list of values */
  {
      return opt_strings_flags(val, values, NULL, list);
  }
--- 11913,11922 ----
   * Empty is always OK.
   */
      static int
! check_opt_strings(
!     char_u	*val,
!     char	**values,
!     int		list)	    /* when TRUE: accept a list of values */
  {
      return opt_strings_flags(val, values, NULL, list);
  }
***************
*** 12003,12013 ****
   * Empty is always OK.
   */
      static int
! opt_strings_flags(val, values, flagp, list)
!     char_u	*val;		/* new value */
!     char	**values;	/* array of valid string values */
!     unsigned	*flagp;
!     int		list;		/* when TRUE: accept a list of values */
  {
      int		i;
      int		len;
--- 11929,11939 ----
   * Empty is always OK.
   */
      static int
! opt_strings_flags(
!     char_u	*val,		/* new value */
!     char	**values,	/* array of valid string values */
!     unsigned	*flagp,
!     int		list)		/* when TRUE: accept a list of values */
  {
      int		i;
      int		len;
***************
*** 12040,12046 ****
   * Read the 'wildmode' option, fill wim_flags[].
   */
      static int
! check_opt_wim()
  {
      char_u	new_wim_flags[4];
      char_u	*p;
--- 11966,11972 ----
   * Read the 'wildmode' option, fill wim_flags[].
   */
      static int
! check_opt_wim(void)
  {
      char_u	new_wim_flags[4];
      char_u	*p;
***************
*** 12092,12099 ****
   * Check if backspacing over something is allowed.
   */
      int
! can_bs(what)
!     int		what;	    /* BS_INDENT, BS_EOL or BS_START */
  {
      switch (*p_bs)
      {
--- 12018,12025 ----
   * Check if backspacing over something is allowed.
   */
      int
! can_bs(
!     int		what)	    /* BS_INDENT, BS_EOL or BS_START */
  {
      switch (*p_bs)
      {
***************
*** 12109,12116 ****
   * the file must be considered changed when the value is different.
   */
      void
! save_file_ff(buf)
!     buf_T	*buf;
  {
      buf->b_start_ffc = *buf->b_p_ff;
      buf->b_start_eol = buf->b_p_eol;
--- 12035,12041 ----
   * the file must be considered changed when the value is different.
   */
      void
! save_file_ff(buf_T *buf)
  {
      buf->b_start_ffc = *buf->b_p_ff;
      buf->b_start_eol = buf->b_p_eol;
***************
*** 12137,12145 ****
   * changed.
   */
      int
! file_ff_differs(buf, ignore_empty)
!     buf_T	*buf;
!     int		ignore_empty;
  {
      /* In a buffer that was never loaded the options are not valid. */
      if (buf->b_flags & BF_NEVERLOADED)
--- 12062,12068 ----
   * changed.
   */
      int
! file_ff_differs(buf_T *buf, int ignore_empty)
  {
      /* In a buffer that was never loaded the options are not valid. */
      if (buf->b_flags & BF_NEVERLOADED)
***************
*** 12168,12175 ****
   * return OK if "p" is a valid fileformat name, FAIL otherwise.
   */
      int
! check_ff_value(p)
!     char_u	*p;
  {
      return check_opt_strings(p, p_ff_values, FALSE);
  }
--- 12091,12097 ----
   * return OK if "p" is a valid fileformat name, FAIL otherwise.
   */
      int
! check_ff_value(char_u *p)
  {
      return check_opt_strings(p, p_ff_values, FALSE);
  }
***************
*** 12179,12186 ****
   * 'tabstop' value when 'shiftwidth' is zero.
   */
      long
! get_sw_value(buf)
!     buf_T *buf;
  {
      return buf->b_p_sw ? buf->b_p_sw : buf->b_p_ts;
  }
--- 12101,12107 ----
   * 'tabstop' value when 'shiftwidth' is zero.
   */
      long
! get_sw_value(buf_T *buf)
  {
      return buf->b_p_sw ? buf->b_p_sw : buf->b_p_ts;
  }
***************
*** 12190,12196 ****
   * 'tabstop' value when 'softtabstop' is negative.
   */
      long
! get_sts_value()
  {
      return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;
  }
--- 12111,12117 ----
   * 'tabstop' value when 'softtabstop' is negative.
   */
      long
! get_sts_value(void)
  {
      return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;
  }
***************
*** 12202,12212 ****
   * When "switchit" is TRUE swap the direction.
   */
      void
! find_mps_values(initc, findc, backwards, switchit)
!     int	    *initc;
!     int	    *findc;
!     int	    *backwards;
!     int	    switchit;
  {
      char_u	*ptr;
  
--- 12123,12133 ----
   * When "switchit" is TRUE swap the direction.
   */
      void
! find_mps_values(
!     int	    *initc,
!     int	    *findc,
!     int	    *backwards,
!     int	    switchit)
  {
      char_u	*ptr;
  
***************
*** 12299,12306 ****
   * initialized.
   */
      static int
! briopt_check(wp)
!     win_T *wp;
  {
      char_u	*p;
      int		bri_shift = 0;
--- 12220,12226 ----
   * initialized.
   */
      static int
! briopt_check(win_T *wp)
  {
      char_u	*p;
      int		bri_shift = 0;
***************
*** 12344,12351 ****
   * Get the local or global value of 'backupcopy'.
   */
      unsigned int
! get_bkc_value(buf)
!     buf_T *buf;
  {
      return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;
  }
--- 12264,12270 ----
   * Get the local or global value of 'backupcopy'.
   */
      unsigned int
! get_bkc_value(buf_T *buf)
  {
      return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;
  }
*** ../vim-7.4.1210/src/version.c	2016-01-30 18:51:05.244231890 +0100
--- src/version.c	2016-01-30 18:52:29.419356714 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1211,
  /**/

-- 
From "know your smileys":
 :-O>-o   Smiley American tourist (note big mouth and camera)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
