To: vim_dev@googlegroups.com
Subject: Patch 7.4.1213
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1213
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/os_amiga.c, src/os_mac_conv.c, src/os_msdos.d, src/os_mswin.c,
            src/os_qnx.c, src/os_unix.c, src/os_vms.c, src/os_win16.c,
            src/os_win32.c, src/popupmnu.c, src/pty.c, src/quickfix.c,
            src/regexp.c, src/regexp_nfa.c, src/screen.c


*** ../vim-7.4.1212/src/os_amiga.c	2016-01-29 22:46:58.962534859 +0100
--- src/os_amiga.c	2016-01-30 19:50:24.831153777 +0100
***************
*** 98,118 ****
  int			size_set = FALSE;   /* set to TRUE if window size was set */
  
      void
! win_resize_on()
  {
      OUT_STR_NF("\033[12{");
  }
  
      void
! win_resize_off()
  {
      OUT_STR_NF("\033[12}");
  }
  
      void
! mch_write(p, len)
!     char_u	*p;
!     int		len;
  {
      Write(raw_out, (char *)p, (long)len);
  }
--- 98,116 ----
  int			size_set = FALSE;   /* set to TRUE if window size was set */
  
      void
! win_resize_on(void)
  {
      OUT_STR_NF("\033[12{");
  }
  
      void
! win_resize_off(void)
  {
      OUT_STR_NF("\033[12}");
  }
  
      void
! mch_write(char_u *p, int len)
  {
      Write(raw_out, (char *)p, (long)len);
  }
***************
*** 127,137 ****
   * Return number of characters read.
   */
      int
! mch_inchar(buf, maxlen, time, tb_change_cnt)
!     char_u  *buf;
!     int	    maxlen;
!     long    time;		/* milli seconds */
!     int	    tb_change_cnt;
  {
      int	    len;
      long    utime;
--- 125,135 ----
   * Return number of characters read.
   */
      int
! mch_inchar(
!     char_u  *buf,
!     int	    maxlen,
!     long    time,		/* milli seconds */
!     int	    tb_change_cnt)
  {
      int	    len;
      long    utime;
***************
*** 190,196 ****
   * return non-zero if a character is available
   */
      int
! mch_char_avail()
  {
      return (WaitForChar(raw_in, 100L) != 0);
  }
--- 188,194 ----
   * return non-zero if a character is available
   */
      int
! mch_char_avail(void)
  {
      return (WaitForChar(raw_in, 100L) != 0);
  }
***************
*** 199,206 ****
   * Return amount of memory still available in Kbyte.
   */
      long_u
! mch_avail_mem(special)
!     int	    special;
  {
  #ifdef __amigaos4__
      return (long_u)AvailMem(MEMF_ANY) >> 10;
--- 197,203 ----
   * Return amount of memory still available in Kbyte.
   */
      long_u
! mch_avail_mem(int special)
  {
  #ifdef __amigaos4__
      return (long_u)AvailMem(MEMF_ANY) >> 10;
***************
*** 214,222 ****
   * ignoreinput is FALSE.
   */
      void
! mch_delay(msec, ignoreinput)
!     long    msec;
!     int	    ignoreinput;
  {
  #ifndef LATTICE		/* SAS declares void Delay(ULONG) */
      void	    Delay(long);
--- 211,217 ----
   * ignoreinput is FALSE.
   */
      void
! mch_delay(long msec, int ignoreinput)
  {
  #ifndef LATTICE		/* SAS declares void Delay(ULONG) */
      void	    Delay(long);
***************
*** 235,241 ****
   * We have no job control, fake it by starting a new shell.
   */
      void
! mch_suspend()
  {
      suspend_shell();
  }
--- 230,236 ----
   * We have no job control, fake it by starting a new shell.
   */
      void
! mch_suspend(void)
  {
      suspend_shell();
  }
***************
*** 245,251 ****
  #endif
  
      void
! mch_init()
  {
      static char	    intlibname[] = "intuition.library";
  
--- 240,246 ----
  #endif
  
      void
! mch_init(void)
  {
      static char	    intlibname[] = "intuition.library";
  
***************
*** 306,314 ****
  #define BUF2SIZE 320	    /* length of buffer for argument with complete path */
  
      int
! mch_check_win(argc, argv)
!     int argc;
!     char **argv;
  {
      int		    i;
      BPTR	    nilfh, fh;
--- 301,307 ----
  #define BUF2SIZE 320	    /* length of buffer for argument with complete path */
  
      int
! mch_check_win(int argc, char **argv)
  {
      int		    i;
      BPTR	    nilfh, fh;
***************
*** 545,551 ****
   * We fake there is a window, because we can always open one!
   */
      int
! mch_input_isatty()
  {
      return TRUE;
  }
--- 538,544 ----
   * We fake there is a window, because we can always open one!
   */
      int
! mch_input_isatty(void)
  {
      return TRUE;
  }
***************
*** 557,565 ****
   */
  /*ARGSUSED*/
      void
! fname_case(name, len)
!     char_u	*name;
!     int		len;		/* buffer size, ignored here */
  {
      struct FileInfoBlock    *fib;
      size_t		    flen;
--- 550,558 ----
   */
  /*ARGSUSED*/
      void
! fname_case(
!     char_u	*name,
!     int		len)		/* buffer size, ignored here */
  {
      struct FileInfoBlock    *fib;
      size_t		    flen;
***************
*** 585,592 ****
   * Returns NULL on error.
   */
      static struct FileInfoBlock *
! get_fib(fname)
!     char_u *fname;
  {
      BPTR		    flock;
      struct FileInfoBlock    *fib;
--- 578,584 ----
   * Returns NULL on error.
   */
      static struct FileInfoBlock *
! get_fib(char_u *fname)
  {
      BPTR		    flock;
      struct FileInfoBlock    *fib;
***************
*** 618,626 ****
   * icon name is not set
   */
      void
! mch_settitle(title, icon)
!     char_u  *title;
!     char_u  *icon;
  {
      if (wb_window != NULL && title != NULL)
  	SetWindowTitles(wb_window, (UBYTE *)title, (UBYTE *)-1L);
--- 610,616 ----
   * icon name is not set
   */
      void
! mch_settitle(char_u *title, char_u *icon)
  {
      if (wb_window != NULL && title != NULL)
  	SetWindowTitles(wb_window, (UBYTE *)title, (UBYTE *)-1L);
***************
*** 634,654 ****
   *  3  Restore title and icon (which we don't have)
   */
      void
! mch_restore_title(which)
!     int which;
  {
      if (which & 1)
  	mch_settitle(oldwindowtitle, NULL);
  }
  
      int
! mch_can_restore_title()
  {
      return (wb_window != NULL);
  }
  
      int
! mch_can_restore_icon()
  {
      return FALSE;
  }
--- 624,643 ----
   *  3  Restore title and icon (which we don't have)
   */
      void
! mch_restore_title(int which)
  {
      if (which & 1)
  	mch_settitle(oldwindowtitle, NULL);
  }
  
      int
! mch_can_restore_title(void)
  {
      return (wb_window != NULL);
  }
  
      int
! mch_can_restore_icon(void)
  {
      return FALSE;
  }
***************
*** 658,666 ****
   * Insert user name in s[len].
   */
      int
! mch_get_user_name(s, len)
!     char_u  *s;
!     int	    len;
  {
      /* TODO: Implement this. */
      *s = NUL;
--- 647,653 ----
   * Insert user name in s[len].
   */
      int
! mch_get_user_name(char_u *s, int len)
  {
      /* TODO: Implement this. */
      *s = NUL;
***************
*** 671,679 ****
   * Insert host name is s[len].
   */
      void
! mch_get_host_name(s, len)
!     char_u  *s;
!     int	    len;
  {
  #if defined(__amigaos4__) && defined(__CLIB2__)
      gethostname(s, len);
--- 658,664 ----
   * Insert host name is s[len].
   */
      void
! mch_get_host_name(char_u *s, int len)
  {
  #if defined(__amigaos4__) && defined(__CLIB2__)
      gethostname(s, len);
***************
*** 686,692 ****
   * return process ID
   */
      long
! mch_get_pid()
  {
  #ifdef __amigaos4__
      /* This is as close to a pid as we can come. We could use CLI numbers also,
--- 671,677 ----
   * return process ID
   */
      long
! mch_get_pid(void)
  {
  #ifdef __amigaos4__
      /* This is as close to a pid as we can come. We could use CLI numbers also,
***************
*** 703,711 ****
   * Return OK for success, FAIL for failure.
   */
      int
! mch_dirname(buf, len)
!     char_u	*buf;
!     int		len;
  {
      return mch_FullName((char_u *)"", buf, len, FALSE);
  }
--- 688,694 ----
   * Return OK for success, FAIL for failure.
   */
      int
! mch_dirname(char_u *buf, int len)
  {
      return mch_FullName((char_u *)"", buf, len, FALSE);
  }
***************
*** 716,725 ****
   * return FAIL for failure, OK otherwise
   */
      int
! mch_FullName(fname, buf, len, force)
!     char_u	*fname, *buf;
!     int		len;
!     int		force;
  {
      BPTR	l;
      int		retval = FAIL;
--- 699,709 ----
   * return FAIL for failure, OK otherwise
   */
      int
! mch_FullName(
!     char_u	*fname,
!     char_u	*buf,
!     int		len,
!     int		force)
  {
      BPTR	l;
      int		retval = FAIL;
***************
*** 764,771 ****
   * Return TRUE if "fname" does not depend on the current directory.
   */
      int
! mch_isFullName(fname)
!     char_u	*fname;
  {
      return (vim_strchr(fname, ':') != NULL && *fname != ':');
  }
--- 748,754 ----
   * Return TRUE if "fname" does not depend on the current directory.
   */
      int
! mch_isFullName(char_u *fname)
  {
      return (vim_strchr(fname, ':') != NULL && *fname != ':');
  }
***************
*** 777,786 ****
   * return FAIL for failure, OK otherwise
   */
      static int
! lock2name(lock, buf, len)
!     BPTR    lock;
!     char_u  *buf;
!     long    len;
  {
  #ifdef FEAT_ARP
      if (dos2)		    /* use 2.0 function */
--- 760,766 ----
   * return FAIL for failure, OK otherwise
   */
      static int
! lock2name(BPTR lock, char_u *buf, long len)
  {
  #ifdef FEAT_ARP
      if (dos2)		    /* use 2.0 function */
***************
*** 797,804 ****
   * Returns -1 when it doesn't exist.
   */
      long
! mch_getperm(name)
!     char_u	*name;
  {
      struct FileInfoBlock    *fib;
      long		    retval = -1;
--- 777,783 ----
   * Returns -1 when it doesn't exist.
   */
      long
! mch_getperm(char_u *name)
  {
      struct FileInfoBlock    *fib;
      long		    retval = -1;
***************
*** 818,826 ****
   * return FAIL for failure, OK otherwise
   */
      int
! mch_setperm(name, perm)
!     char_u	*name;
!     long	perm;
  {
      perm &= ~FIBF_ARCHIVE;		/* reset archived bit */
      return (SetProtection((UBYTE *)name, (long)perm) ? OK : FAIL);
--- 797,803 ----
   * return FAIL for failure, OK otherwise
   */
      int
! mch_setperm(char_u *name, long perm)
  {
      perm &= ~FIBF_ARCHIVE;		/* reset archived bit */
      return (SetProtection((UBYTE *)name, (long)perm) ? OK : FAIL);
***************
*** 830,837 ****
   * Set hidden flag for "name".
   */
      void
! mch_hide(name)
!     char_u	*name;
  {
      /* can't hide a file */
  }
--- 807,813 ----
   * Set hidden flag for "name".
   */
      void
! mch_hide(char_u *name)
  {
      /* can't hide a file */
  }
***************
*** 842,849 ****
   * return FALSE for error.
   */
      int
! mch_isdir(name)
!     char_u	*name;
  {
      struct FileInfoBlock    *fib;
      int			    retval = FALSE;
--- 818,824 ----
   * return FALSE for error.
   */
      int
! mch_isdir(char_u *name)
  {
      struct FileInfoBlock    *fib;
      int			    retval = FALSE;
***************
*** 865,872 ****
   * Create directory "name".
   */
      int
! mch_mkdir(name)
!     char_u	*name;
  {
      BPTR	lock;
  
--- 840,846 ----
   * Create directory "name".
   */
      int
! mch_mkdir(char_u *name)
  {
      BPTR	lock;
  
***************
*** 885,894 ****
   * Return -1 if unknown.
   */
      int
! mch_can_exe(name, path, use_path)
!     char_u	*name;
!     char_u	**path;
!     int		use_path;
  {
      /* TODO */
      return -1;
--- 859,865 ----
   * Return -1 if unknown.
   */
      int
! mch_can_exe(char_u *name, char_u **path, int use_path)
  {
      /* TODO */
      return -1;
***************
*** 901,915 ****
   * NODE_OTHER: non-writable things
   */
      int
! mch_nodetype(name)
!     char_u	*name;
  {
      /* TODO */
      return NODE_NORMAL;
  }
  
      void
! mch_early_init()
  {
  }
  
--- 872,885 ----
   * NODE_OTHER: non-writable things
   */
      int
! mch_nodetype(char_u *name)
  {
      /* TODO */
      return NODE_NORMAL;
  }
  
      void
! mch_early_init(void)
  {
  }
  
***************
*** 917,924 ****
   * Careful: mch_exit() may be called before mch_init()!
   */
      void
! mch_exit(r)
!     int		    r;
  {
      if (raw_in)			    /* put terminal in 'normal' mode */
      {
--- 887,893 ----
   * Careful: mch_exit() may be called before mch_init()!
   */
      void
! mch_exit(int r)
  {
      if (raw_in)			    /* put terminal in 'normal' mode */
      {
***************
*** 977,984 ****
   *	it sends a 0 to the console to make it back into a CON: from a RAW:
   */
      void
! mch_settmode(tmode)
!     int		tmode;
  {
  #if defined(__AROS__) || defined(__amigaos4__)
      if (!SetMode(raw_in, tmode == TMODE_RAW ? 1 : 0))
--- 946,952 ----
   *	it sends a 0 to the console to make it back into a CON: from a RAW:
   */
      void
! mch_settmode(int tmode)
  {
  #if defined(__AROS__) || defined(__amigaos4__)
      if (!SetMode(raw_in, tmode == TMODE_RAW ? 1 : 0))
***************
*** 993,1000 ****
   * set screen mode, always fails.
   */
      int
! mch_screenmode(arg)
!     char_u	*arg;
  {
      EMSG(_(e_screenmode));
      return FAIL;
--- 961,967 ----
   * set screen mode, always fails.
   */
      int
! mch_screenmode(char_u *arg)
  {
      EMSG(_(e_screenmode));
      return FAIL;
***************
*** 1021,1027 ****
   * return FAIL for failure, OK otherwise
   */
      int
! mch_get_shellsize()
  {
      struct ConUnit  *conUnit;
  #ifndef __amigaos4__
--- 988,994 ----
   * return FAIL for failure, OK otherwise
   */
      int
! mch_get_shellsize(void)
  {
      struct ConUnit  *conUnit;
  #ifndef __amigaos4__
***************
*** 1095,1101 ****
   * Try to set the real window size to Rows and Columns.
   */
      void
! mch_set_shellsize()
  {
      if (term_console)
      {
--- 1062,1068 ----
   * Try to set the real window size to Rows and Columns.
   */
      void
! mch_set_shellsize(void)
  {
      if (term_console)
      {
***************
*** 1114,1120 ****
   * Rows and/or Columns has changed.
   */
      void
! mch_new_shellsize()
  {
      /* Nothing to do. */
  }
--- 1081,1087 ----
   * Rows and/or Columns has changed.
   */
      void
! mch_new_shellsize(void)
  {
      /* Nothing to do. */
  }
***************
*** 1123,1130 ****
   * out_num - output a (big) number fast
   */
      static void
! out_num(n)
!     long	n;
  {
      OUT_STR_NF(tltoa((unsigned long)n));
  }
--- 1090,1096 ----
   * out_num - output a (big) number fast
   */
      static void
! out_num(long n)
  {
      OUT_STR_NF(tltoa((unsigned long)n));
  }
***************
*** 1154,1163 ****
   */
  
      static long
! dos_packet(pid, action, arg)
!     struct MsgPort *pid;    /* process identifier ... (handlers message port) */
      long	    action, /* packet type ... (what you want handler to do)   */
! 		    arg;    /* single argument */
  {
  # ifdef FEAT_ARP
      struct MsgPort	    *replyport;
--- 1120,1129 ----
   */
  
      static long
! dos_packet(
!     struct MsgPort *pid,    /* process identifier ... (handlers message port) */
      long	    action, /* packet type ... (what you want handler to do)   */
! 		    arg)    /* single argument */
  {
  # ifdef FEAT_ARP
      struct MsgPort	    *replyport;
***************
*** 1206,1214 ****
   * Return error number for failure, 0 otherwise
   */
      int
! mch_call_shell(cmd, options)
!     char_u	*cmd;
!     int		options;	/* SHELL_*, see vim.h */
  {
      BPTR	mydir;
      int		x;
--- 1172,1180 ----
   * Return error number for failure, 0 otherwise
   */
      int
! mch_call_shell(
!     char_u	*cmd,
!     int		options)	/* SHELL_*, see vim.h */
  {
      BPTR	mydir;
      int		x;
***************
*** 1415,1421 ****
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck()
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
--- 1381,1387 ----
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(void)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
***************
*** 1464,1473 ****
  #endif
  
      int
! mch_expandpath(gap, pat, flags)
!     garray_T	*gap;
!     char_u	*pat;
!     int		flags;		/* EW_* flags */
  {
      struct AnchorPath	*Anchor;
      LONG		Result;
--- 1430,1439 ----
  #endif
  
      int
! mch_expandpath(
!     garray_T	*gap,
!     char_u	*pat,
!     int		flags)		/* EW_* flags */
  {
      struct AnchorPath	*Anchor;
      LONG		Result;
***************
*** 1585,1592 ****
  }
  
      static int
! sortcmp(a, b)
!     const void *a, *b;
  {
      char *s = *(char **)a;
      char *t = *(char **)b;
--- 1551,1557 ----
  }
  
      static int
! sortcmp(const void *a, const void *b)
  {
      char *s = *(char **)a;
      char *t = *(char **)b;
***************
*** 1598,1605 ****
   * Return TRUE if "p" has wildcards that can be expanded by mch_expandpath().
   */
      int
! mch_has_exp_wildcard(p)
!     char_u *p;
  {
      for ( ; *p; mb_ptr_adv(p))
      {
--- 1563,1569 ----
   * Return TRUE if "p" has wildcards that can be expanded by mch_expandpath().
   */
      int
! mch_has_exp_wildcard(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
***************
*** 1612,1619 ****
  }
  
      int
! mch_has_wildcard(p)
!     char_u *p;
  {
      for ( ; *p; mb_ptr_adv(p))
      {
--- 1576,1582 ----
  }
  
      int
! mch_has_wildcard(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
***************
*** 1641,1648 ****
   * - A small one to hold the return value.  It is kept until the next call.
   */
      char_u *
! mch_getenv(var)
!     char_u *var;
  {
      int		    len;
      UBYTE	    *buf;		/* buffer to expand in */
--- 1604,1610 ----
   * - A small one to hold the return value.  It is kept until the next call.
   */
      char_u *
! mch_getenv(char_u *var)
  {
      int		    len;
      UBYTE	    *buf;		/* buffer to expand in */
***************
*** 1685,1694 ****
   */
  /* ARGSUSED */
      int
! mch_setenv(var, value, x)
!     char *var;
!     char *value;
!     int	 x;
  {
  #ifdef FEAT_ARP
      if (!dos2)
--- 1647,1653 ----
   */
  /* ARGSUSED */
      int
! mch_setenv(char *var, char *value, int x)
  {
  #ifdef FEAT_ARP
      if (!dos2)
*** ../vim-7.4.1212/src/os_mac_conv.c	2016-01-29 23:46:16.737225022 +0100
--- src/os_mac_conv.c	2016-01-30 19:51:29.434481736 +0100
***************
*** 44,57 ****
   * A Mac version of string_convert_ext() for special cases.
   */
      char_u *
! mac_string_convert(ptr, len, lenp, fail_on_error, from_enc, to_enc, unconvlenp)
!     char_u		*ptr;
!     int			len;
!     int			*lenp;
!     int			fail_on_error;
!     int			from_enc;
!     int			to_enc;
!     int			*unconvlenp;
  {
      char_u		*retval, *d;
      CFStringRef		cfstr;
--- 44,57 ----
   * A Mac version of string_convert_ext() for special cases.
   */
      char_u *
! mac_string_convert(
!     char_u		*ptr,
!     int			len,
!     int			*lenp,
!     int			fail_on_error,
!     int			from_enc,
!     int			to_enc,
!     int			*unconvlenp)
  {
      char_u		*retval, *d;
      CFStringRef		cfstr;
***************
*** 180,189 ****
   * Returns OK or FAIL.
   */
      int
! macroman2enc(ptr, sizep, real_size)
!     char_u	*ptr;
!     long	*sizep;
!     long	real_size;
  {
      CFStringRef		cfstr;
      CFRange		r;
--- 180,189 ----
   * Returns OK or FAIL.
   */
      int
! macroman2enc(
!     char_u	*ptr,
!     long	*sizep,
!     long	real_size)
  {
      CFStringRef		cfstr;
      CFRange		r;
***************
*** 226,239 ****
   * Returns OK or FAIL.
   */
      int
! enc2macroman(from, fromlen, to, tolenp, maxtolen, rest, restlenp)
!     char_u	*from;
!     size_t	fromlen;
!     char_u	*to;
!     int		*tolenp;
!     int		maxtolen;
!     char_u	*rest;
!     int		*restlenp;
  {
      CFStringRef	cfstr;
      CFRange	r;
--- 226,239 ----
   * Returns OK or FAIL.
   */
      int
! enc2macroman(
!     char_u	*from,
!     size_t	fromlen,
!     char_u	*to,
!     int		*tolenp,
!     int		maxtolen,
!     char_u	*rest,
!     int		*restlenp)
  {
      CFStringRef	cfstr;
      CFRange	r;
***************
*** 274,280 ****
   * Initializes text converters
   */
      void
! mac_conv_init()
  {
      TextEncoding    utf8_encoding;
      TextEncoding    utf8_hfsplus_encoding;
--- 274,280 ----
   * Initializes text converters
   */
      void
! mac_conv_init(void)
  {
      TextEncoding    utf8_encoding;
      TextEncoding    utf8_hfsplus_encoding;
***************
*** 309,315 ****
   * Destroys text converters
   */
      void
! mac_conv_cleanup()
  {
      if (gUTF16ToUTF8Converter)
      {
--- 309,315 ----
   * Destroys text converters
   */
      void
! mac_conv_cleanup(void)
  {
      if (gUTF16ToUTF8Converter)
      {
***************
*** 330,339 ****
   * CFBase.h) to avoid clashes with X11 header files in the .pro file
   */
      char_u *
! mac_utf16_to_enc(from, fromLen, actualLen)
!     unsigned short *from;
!     size_t fromLen;
!     size_t *actualLen;
  {
      /* Following code borrows somewhat from os_mswin.c */
      vimconv_T	conv;
--- 330,339 ----
   * CFBase.h) to avoid clashes with X11 header files in the .pro file
   */
      char_u *
! mac_utf16_to_enc(
!     unsigned short *from,
!     size_t fromLen,
!     size_t *actualLen)
  {
      /* Following code borrows somewhat from os_mswin.c */
      vimconv_T	conv;
***************
*** 384,393 ****
   * CFBase.h) to avoid clashes with X11 header files in the .pro file
   */
      unsigned short *
! mac_enc_to_utf16(from, fromLen, actualLen)
!     char_u *from;
!     size_t fromLen;
!     size_t *actualLen;
  {
      /* Following code borrows somewhat from os_mswin.c */
      vimconv_T	conv;
--- 384,393 ----
   * CFBase.h) to avoid clashes with X11 header files in the .pro file
   */
      unsigned short *
! mac_enc_to_utf16(
!     char_u *from,
!     size_t fromLen,
!     size_t *actualLen)
  {
      /* Following code borrows somewhat from os_mswin.c */
      vimconv_T	conv;
***************
*** 443,451 ****
   * The void * return type is actually a CFStringRef
   */
      void *
! mac_enc_to_cfstring(from, fromLen)
!     char_u  *from;
!     size_t  fromLen;
  {
      UniChar	*utf16_str;
      size_t	utf16_len;
--- 443,451 ----
   * The void * return type is actually a CFStringRef
   */
      void *
! mac_enc_to_cfstring(
!     char_u  *from,
!     size_t  fromLen)
  {
      UniChar	*utf16_str;
      size_t	utf16_len;
***************
*** 465,474 ****
   * Converts a decomposed HFS+ UTF-8 path to precomposed UTF-8
   */
      char_u *
! mac_precompose_path(decompPath, decompLen, precompLen)
!     char_u  *decompPath;
!     size_t  decompLen;
!     size_t  *precompLen;
  {
      char_u  *result = NULL;
      size_t  actualLen = 0;
--- 465,474 ----
   * Converts a decomposed HFS+ UTF-8 path to precomposed UTF-8
   */
      char_u *
! mac_precompose_path(
!     char_u  *decompPath,
!     size_t  decompLen,
!     size_t  *precompLen)
  {
      char_u  *result = NULL;
      size_t  actualLen = 0;
***************
*** 498,507 ****
   * Converts from UTF-16 UniChars to precomposed UTF-8
   */
      static char_u *
! mac_utf16_to_utf8(from, fromLen, actualLen)
!     UniChar *from;
!     size_t fromLen;
!     size_t *actualLen;
  {
      ByteCount		utf8_len;
      ByteCount		inputRead;
--- 498,507 ----
   * Converts from UTF-16 UniChars to precomposed UTF-8
   */
      static char_u *
! mac_utf16_to_utf8(
!     UniChar *from,
!     size_t fromLen,
!     size_t *actualLen)
  {
      ByteCount		utf8_len;
      ByteCount		inputRead;
***************
*** 538,547 ****
   * Converts from UTF-8 to UTF-16 UniChars
   */
      static UniChar *
! mac_utf8_to_utf16(from, fromLen, actualLen)
!     char_u *from;
!     size_t fromLen;
!     size_t *actualLen;
  {
      CFStringRef  utf8_str;
      CFRange      convertRange;
--- 538,547 ----
   * Converts from UTF-8 to UTF-16 UniChars
   */
      static UniChar *
! mac_utf8_to_utf16(
!     char_u *from,
!     size_t fromLen,
!     size_t *actualLen)
  {
      CFStringRef  utf8_str;
      CFRange      convertRange;
***************
*** 573,579 ****
   * Sets LANG environment variable in Vim from Mac locale
   */
      void
! mac_lang_init() {
      if (mch_getenv((char_u *)"LANG") == NULL)
      {
  	char	buf[20];
--- 573,580 ----
   * Sets LANG environment variable in Vim from Mac locale
   */
      void
! mac_lang_init(void)
! {
      if (mch_getenv((char_u *)"LANG") == NULL)
      {
  	char	buf[20];
*** ../vim-7.4.1212/src/os_mswin.c	2016-01-29 21:11:20.967061365 +0100
--- src/os_mswin.c	2016-01-30 19:53:56.632950519 +0100
***************
*** 286,292 ****
   * Return TRUE if the input comes from a terminal, FALSE otherwise.
   */
      int
! mch_input_isatty()
  {
  #ifdef FEAT_GUI_MSWIN
      return OK;	    /* GUI always has a tty */
--- 286,292 ----
   * Return TRUE if the input comes from a terminal, FALSE otherwise.
   */
      int
! mch_input_isatty(void)
  {
  #ifdef FEAT_GUI_MSWIN
      return OK;	    /* GUI always has a tty */
***************
*** 355,361 ****
   * Return TRUE if we can restore the title (we can)
   */
      int
! mch_can_restore_title()
  {
      return TRUE;
  }
--- 355,361 ----
   * Return TRUE if we can restore the title (we can)
   */
      int
! mch_can_restore_title(void)
  {
      return TRUE;
  }
***************
*** 365,371 ****
   * Return TRUE if we can restore the icon title (we can't)
   */
      int
! mch_can_restore_icon()
  {
      return FALSE;
  }
--- 365,371 ----
   * Return TRUE if we can restore the icon title (we can't)
   */
      int
! mch_can_restore_icon(void)
  {
      return FALSE;
  }
***************
*** 486,493 ****
   * When the path looks like a URL leave it unmodified.
   */
      void
! slash_adjust(p)
!     char_u  *p;
  {
      if (path_with_url(p))
  	return;
--- 486,492 ----
   * When the path looks like a URL leave it unmodified.
   */
      void
! slash_adjust(char_u *p)
  {
      if (path_with_url(p))
  	return;
***************
*** 708,714 ****
   * We have no job control, so fake it by starting a new shell.
   */
      void
! mch_suspend()
  {
      suspend_shell();
  }
--- 707,713 ----
   * We have no job control, so fake it by starting a new shell.
   */
      void
! mch_suspend(void)
  {
      suspend_shell();
  }
***************
*** 723,729 ****
   * Display the saved error message(s).
   */
      void
! display_errors()
  {
      char *p;
  
--- 722,728 ----
   * Display the saved error message(s).
   */
      void
! display_errors(void)
  {
      char *p;
  
***************
*** 864,870 ****
   * return non-zero if a character is available
   */
      int
! mch_char_avail()
  {
      /* never used */
      return TRUE;
--- 863,869 ----
   * return non-zero if a character is available
   */
      int
! mch_char_avail(void)
  {
      /* never used */
      return TRUE;
***************
*** 965,972 ****
   * Try loading an icon file from 'runtimepath'.
   */
      int
! mch_icon_load(iconp)
!     HANDLE *iconp;
  {
      return do_in_runtimepath((char_u *)"bitmaps/vim.ico",
  					      FALSE, mch_icon_load_cb, iconp);
--- 964,970 ----
   * Try loading an icon file from 'runtimepath'.
   */
      int
! mch_icon_load(HANDLE *iconp)
  {
      return do_in_runtimepath((char_u *)"bitmaps/vim.ico",
  					      FALSE, mch_icon_load_cb, iconp);
***************
*** 1831,1839 ****
  static int prt_pos_y = 0;
  
      void
! mch_print_start_line(margin, page_line)
!     int		margin;
!     int		page_line;
  {
      if (margin)
  	prt_pos_x = -prt_number_width;
--- 1829,1835 ----
  static int prt_pos_y = 0;
  
      void
! mch_print_start_line(int margin, int page_line)
  {
      if (margin)
  	prt_pos_x = -prt_number_width;
***************
*** 2070,2076 ****
   * Bring ourselves to the foreground.  Does work if the OS doesn't allow it.
   */
      void
! win32_set_foreground()
  {
  # ifndef FEAT_GUI
      GetConsoleHwnd();	    /* get value of s_hwnd */
--- 2066,2072 ----
   * Bring ourselves to the foreground.  Does work if the OS doesn't allow it.
   */
      void
! win32_set_foreground(void)
  {
  # ifndef FEAT_GUI
      GetConsoleHwnd();	    /* get value of s_hwnd */
***************
*** 2486,2494 ****
  }
  
      int
! serverSendReply(name, reply)
!     char_u	*name;		/* Where to send. */
!     char_u	*reply;		/* What to send. */
  {
      HWND	target;
      COPYDATASTRUCT data;
--- 2482,2490 ----
  }
  
      int
! serverSendReply(
!     char_u	*name,		/* Where to send. */
!     char_u	*reply)		/* What to send. */
  {
      HWND	target;
      COPYDATASTRUCT data;
***************
*** 2519,2531 ****
  }
  
      int
! serverSendToVim(name, cmd, result, ptarget, asExpr, silent)
!     char_u	 *name;			/* Where to send. */
!     char_u	 *cmd;			/* What to send. */
!     char_u	 **result;		/* Result of eval'ed expression */
!     void	 *ptarget;		/* HWND of server */
!     int		 asExpr;		/* Expression or keys? */
!     int		 silent;		/* don't complain about no server */
  {
      HWND	target;
      COPYDATASTRUCT data;
--- 2515,2527 ----
  }
  
      int
! serverSendToVim(
!     char_u	 *name,			/* Where to send. */
!     char_u	 *cmd,			/* What to send. */
!     char_u	 **result,		/* Result of eval'ed expression */
!     void	 *ptarget,		/* HWND of server */
!     int		 asExpr,		/* Expression or keys? */
!     int		 silent)		/* don't complain about no server */
  {
      HWND	target;
      COPYDATASTRUCT data;
***************
*** 2578,2585 ****
   * Bring the server to the foreground.
   */
      void
! serverForeground(name)
!     char_u	*name;
  {
      HWND	target = findServer(name);
  
--- 2574,2580 ----
   * Bring the server to the foreground.
   */
      void
! serverForeground(char_u *name)
  {
      HWND	target = findServer(name);
  
***************
*** 3101,3107 ****
   * Initialize the Winsock dll.
   */
      void
! channel_init_winsock()
  {
      WSADATA wsaData;
      int wsaerr;
--- 3096,3102 ----
   * Initialize the Winsock dll.
   */
      void
! channel_init_winsock(void)
  {
      WSADATA wsaData;
      int wsaerr;
*** ../vim-7.4.1212/src/os_qnx.c	2014-03-23 15:12:29.931264336 +0100
--- src/os_qnx.c	2016-01-30 19:54:21.932687345 +0100
***************
*** 19,25 ****
  int is_photon_available;
  #endif
  
! void qnx_init()
  {
  #if defined(FEAT_GUI_PHOTON)
      PhChannelParms_t parms;
--- 19,25 ----
  int is_photon_available;
  #endif
  
! void qnx_init(void)
  {
  #if defined(FEAT_GUI_PHOTON)
      PhChannelParms_t parms;
***************
*** 37,43 ****
  #define CLIP_TYPE_TEXT "TEXT"
  
  /* Turn on the clipboard for a console vim when photon is running */
! void qnx_clip_init()
  {
      if (is_photon_available == TRUE && !gui.in_use)
  	clip_init(TRUE);
--- 37,43 ----
  #define CLIP_TYPE_TEXT "TEXT"
  
  /* Turn on the clipboard for a console vim when photon is running */
! void qnx_clip_init(void)
  {
      if (is_photon_available == TRUE && !gui.in_use)
  	clip_init(TRUE);
*** ../vim-7.4.1212/src/os_unix.c	2016-01-29 23:20:35.305308204 +0100
--- src/os_unix.c	2016-01-30 20:11:03.450270638 +0100
***************
*** 342,349 ****
  };
  
      int
! mch_chdir(path)
!     char *path;
  {
      if (p_verbose >= 5)
      {
--- 342,348 ----
  };
  
      int
! mch_chdir(char *path)
  {
      if (p_verbose >= 5)
      {
***************
*** 362,370 ****
   * Write s[len] to the screen.
   */
      void
! mch_write(s, len)
!     char_u	*s;
!     int		len;
  {
      ignored = (int)write(1, (char *)s, len);
      if (p_wd)		/* Unix is too fast, slow down a bit more */
--- 361,367 ----
   * Write s[len] to the screen.
   */
      void
! mch_write(char_u *s, int len)
  {
      ignored = (int)write(1, (char *)s, len);
      if (p_wd)		/* Unix is too fast, slow down a bit more */
***************
*** 380,390 ****
   * If wtime == -1 wait forever for characters.
   */
      int
! mch_inchar(buf, maxlen, wtime, tb_change_cnt)
!     char_u	*buf;
!     int		maxlen;
!     long	wtime;	    /* don't use "time", MIPS cannot handle it */
!     int		tb_change_cnt;
  {
      int		len;
  
--- 377,387 ----
   * If wtime == -1 wait forever for characters.
   */
      int
! mch_inchar(
!     char_u	*buf,
!     int		maxlen,
!     long	wtime,	    /* don't use "time", MIPS cannot handle it */
!     int		tb_change_cnt)
  {
      int		len;
  
***************
*** 477,483 ****
  }
  
      static void
! handle_resize()
  {
      do_resize = FALSE;
      shell_resized();
--- 474,480 ----
  }
  
      static void
! handle_resize(void)
  {
      do_resize = FALSE;
      shell_resized();
***************
*** 487,493 ****
   * return non-zero if a character is available
   */
      int
! mch_char_avail()
  {
      return WaitForChar(0L);
  }
--- 484,490 ----
   * return non-zero if a character is available
   */
      int
! mch_char_avail(void)
  {
      return WaitForChar(0L);
  }
***************
*** 508,515 ****
   * Doesn't change when memory has been allocated.
   */
      long_u
! mch_total_mem(special)
!     int special UNUSED;
  {
  # ifdef __EMX__
      return ulimit(3, 0L) >> 10;   /* always 32MB? */
--- 505,511 ----
   * Doesn't change when memory has been allocated.
   */
      long_u
! mch_total_mem(int special UNUSED)
  {
  # ifdef __EMX__
      return ulimit(3, 0L) >> 10;   /* always 32MB? */
***************
*** 601,609 ****
  #endif
  
      void
! mch_delay(msec, ignoreinput)
!     long	msec;
!     int		ignoreinput;
  {
      int		old_tmode;
  #ifdef FEAT_MZSCHEME
--- 597,603 ----
  #endif
  
      void
! mch_delay(long msec, int ignoreinput)
  {
      int		old_tmode;
  #ifdef FEAT_MZSCHEME
***************
*** 704,711 ****
   * "p" points to a variable on the stack of the caller.
   */
      static void
! check_stack_growth(p)
!     char	*p;
  {
      int		i;
  
--- 698,704 ----
   * "p" points to a variable on the stack of the caller.
   */
      static void
! check_stack_growth(char *p)
  {
      int		i;
  
***************
*** 727,733 ****
   * deathtrap().
   */
      static void
! get_stack_limit()
  {
      struct rlimit	rlp;
      int			i;
--- 720,726 ----
   * deathtrap().
   */
      static void
! get_stack_limit(void)
  {
      struct rlimit	rlp;
      int			i;
***************
*** 781,788 ****
   * "p" must point to any variable local to the caller that's on the stack.
   */
      int
! mch_stackcheck(p)
!     char	*p;
  {
      if (stack_limit != NULL)
      {
--- 774,780 ----
   * "p" must point to any variable local to the caller that's on the stack.
   */
      int
! mch_stackcheck(char *p)
  {
      if (stack_limit != NULL)
      {
***************
*** 824,830 ****
  static char *signal_stack;
  
      static void
! init_signal_stack()
  {
      if (signal_stack != NULL)
      {
--- 816,822 ----
  static char *signal_stack;
  
      static void
! init_signal_stack(void)
  {
      if (signal_stack != NULL)
      {
***************
*** 936,942 ****
   * problem and LONGJMP() was used.
   */
      void
! mch_startjmp()
  {
  #ifdef SIGHASARG
      lc_signal = 0;
--- 928,934 ----
   * problem and LONGJMP() was used.
   */
      void
! mch_startjmp(void)
  {
  #ifdef SIGHASARG
      lc_signal = 0;
***************
*** 945,957 ****
  }
  
      void
! mch_endjmp()
  {
      lc_active = FALSE;
  }
  
      void
! mch_didjmp()
  {
  # if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
      /* On FreeBSD the signal stack has to be reset after using siglongjmp(),
--- 937,949 ----
  }
  
      void
! mch_endjmp(void)
  {
      lc_active = FALSE;
  }
  
      void
! mch_didjmp(void)
  {
  # if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
      /* On FreeBSD the signal stack has to be reset after using siglongjmp(),
***************
*** 1166,1172 ****
   * other applications will hang.  But first copy the text to cut buffer 0.
   */
      static void
! loose_clipboard()
  {
      if (clip_star.owned || clip_plus.owned)
      {
--- 1158,1164 ----
   * other applications will hang.  But first copy the text to cut buffer 0.
   */
      static void
! loose_clipboard(void)
  {
      if (clip_star.owned || clip_plus.owned)
      {
***************
*** 1185,1191 ****
   * Save clipboard text to restore later.
   */
      static void
! save_clipboard()
  {
      if (clip_star.owned)
  	clip_star_save = get_register('*', TRUE);
--- 1177,1183 ----
   * Save clipboard text to restore later.
   */
      static void
! save_clipboard(void)
  {
      if (clip_star.owned)
  	clip_star_save = get_register('*', TRUE);
***************
*** 1197,1203 ****
   * Restore clipboard text if no one own the X selection.
   */
      static void
! restore_clipboard()
  {
      if (clip_star_save != NULL)
      {
--- 1189,1195 ----
   * Restore clipboard text if no one own the X selection.
   */
      static void
! restore_clipboard(void)
  {
      if (clip_star_save != NULL)
      {
***************
*** 1224,1230 ****
   * otherwise fake it by starting a new shell.
   */
      void
! mch_suspend()
  {
      /* BeOS does have SIGTSTP, but it doesn't work. */
  #if defined(SIGTSTP) && !defined(__BEOS__)
--- 1216,1222 ----
   * otherwise fake it by starting a new shell.
   */
      void
! mch_suspend(void)
  {
      /* BeOS does have SIGTSTP, but it doesn't work. */
  #if defined(SIGTSTP) && !defined(__BEOS__)
***************
*** 1276,1282 ****
  }
  
      void
! mch_init()
  {
      Columns = 80;
      Rows = 24;
--- 1268,1274 ----
  }
  
      void
! mch_init(void)
  {
      Columns = 80;
      Rows = 24;
***************
*** 1293,1299 ****
  }
  
      static void
! set_signals()
  {
  #if defined(SIGWINCH)
      /*
--- 1285,1291 ----
  }
  
      static void
! set_signals(void)
  {
  #if defined(SIGWINCH)
      /*
***************
*** 1358,1371 ****
   * Catch CTRL-C (only works while in Cooked mode).
   */
      static void
! catch_int_signal()
  {
      signal(SIGINT, (RETSIGTYPE (*)())catch_sigint);
  }
  #endif
  
      void
! reset_signals()
  {
      catch_signals(SIG_DFL, SIG_DFL);
  #if defined(_REENTRANT) && defined(SIGCONT)
--- 1350,1363 ----
   * Catch CTRL-C (only works while in Cooked mode).
   */
      static void
! catch_int_signal(void)
  {
      signal(SIGINT, (RETSIGTYPE (*)())catch_sigint);
  }
  #endif
  
      void
! reset_signals(void)
  {
      catch_signals(SIG_DFL, SIG_DFL);
  #if defined(_REENTRANT) && defined(SIGCONT)
***************
*** 1375,1383 ****
  }
  
      static void
! catch_signals(func_deadly, func_other)
!     RETSIGTYPE (*func_deadly)();
!     RETSIGTYPE (*func_other)();
  {
      int	    i;
  
--- 1367,1375 ----
  }
  
      static void
! catch_signals(
!     RETSIGTYPE (*func_deadly)(),
!     RETSIGTYPE (*func_other)())
  {
      int	    i;
  
***************
*** 1429,1436 ****
   * Returns TRUE when Vim should exit.
   */
      int
! vim_handle_signal(sig)
!     int		sig;
  {
      static int got_signal = 0;
      static int blocked = TRUE;
--- 1421,1427 ----
   * Returns TRUE when Vim should exit.
   */
      int
! vim_handle_signal(int sig)
  {
      static int got_signal = 0;
      static int blocked = TRUE;
***************
*** 1464,1472 ****
   * Check_win checks whether we have an interactive stdout.
   */
      int
! mch_check_win(argc, argv)
!     int	    argc UNUSED;
!     char    **argv UNUSED;
  {
      if (isatty(1))
  	return OK;
--- 1455,1461 ----
   * Check_win checks whether we have an interactive stdout.
   */
      int
! mch_check_win(int argc UNUSED, char **argv UNUSED)
  {
      if (isatty(1))
  	return OK;
***************
*** 1477,1483 ****
   * Return TRUE if the input comes from a terminal, FALSE otherwise.
   */
      int
! mch_input_isatty()
  {
      if (isatty(read_cmd_fd))
  	return TRUE;
--- 1466,1472 ----
   * Return TRUE if the input comes from a terminal, FALSE otherwise.
   */
      int
! mch_input_isatty(void)
  {
      if (isatty(read_cmd_fd))
  	return TRUE;
***************
*** 1495,1502 ****
   * Give a message about the elapsed time for opening the X window.
   */
      static void
! xopen_message(tvp)
!     struct timeval *tvp;	/* must contain start time */
  {
      struct timeval  end_tv;
  
--- 1484,1491 ----
   * Give a message about the elapsed time for opening the X window.
   */
      static void
! xopen_message(
!     struct timeval *tvp)	/* must contain start time */
  {
      struct timeval  end_tv;
  
***************
*** 1524,1532 ****
   * X Error handler, otherwise X just exits!  (very rude) -- webb
   */
      static int
! x_error_handler(dpy, error_event)
!     Display	*dpy;
!     XErrorEvent	*error_event;
  {
      XGetErrorText(dpy, error_event->error_code, (char *)IObuff, IOSIZE);
      STRCAT(IObuff, _("\nVim: Got X error\n"));
--- 1513,1519 ----
   * X Error handler, otherwise X just exits!  (very rude) -- webb
   */
      static int
! x_error_handler(Display *dpy, XErrorEvent *error_event)
  {
      XGetErrorText(dpy, error_event->error_code, (char *)IObuff, IOSIZE);
      STRCAT(IObuff, _("\nVim: Got X error\n"));
***************
*** 1543,1551 ****
   * Another X Error handler, just used to check for errors.
   */
      static int
! x_error_check(dpy, error_event)
!     Display *dpy UNUSED;
!     XErrorEvent	*error_event UNUSED;
  {
      got_x_error = TRUE;
      return 0;
--- 1530,1536 ----
   * Another X Error handler, just used to check for errors.
   */
      static int
! x_error_check(Display *dpy UNUSED, XErrorEvent *error_event UNUSED)
  {
      got_x_error = TRUE;
      return 0;
***************
*** 1559,1566 ****
  static int x_IOerror_check(Display *dpy);
  
      static int
! x_IOerror_check(dpy)
!     Display *dpy UNUSED;
  {
      /* This function should not return, it causes exit().  Longjump instead. */
      LONGJMP(lc_jump_env, 1);
--- 1544,1550 ----
  static int x_IOerror_check(Display *dpy);
  
      static int
! x_IOerror_check(Display *dpy UNUSED)
  {
      /* This function should not return, it causes exit().  Longjump instead. */
      LONGJMP(lc_jump_env, 1);
***************
*** 1578,1585 ****
  static int xterm_dpy_was_reset = FALSE;
  
      static int
! x_IOerror_handler(dpy)
!     Display *dpy UNUSED;
  {
      xterm_dpy = NULL;
      xterm_dpy_was_reset = TRUE;
--- 1562,1568 ----
  static int xterm_dpy_was_reset = FALSE;
  
      static int
! x_IOerror_handler(Display *dpy UNUSED)
  {
      xterm_dpy = NULL;
      xterm_dpy_was_reset = TRUE;
***************
*** 1600,1606 ****
   * (e.g. through tmux).
   */
      static void
! may_restore_clipboard()
  {
      if (xterm_dpy_was_reset)
      {
--- 1583,1589 ----
   * (e.g. through tmux).
   */
      static void
! may_restore_clipboard(void)
  {
      if (xterm_dpy_was_reset)
      {
***************
*** 1626,1632 ****
   * Return TRUE when connection to the X server is desired.
   */
      static int
! x_connect_to_server()
  {
  #if defined(FEAT_CLIENTSERVER)
      if (x_force_connect)
--- 1609,1615 ----
   * Return TRUE when connection to the X server is desired.
   */
      static int
! x_connect_to_server(void)
  {
  #if defined(FEAT_CLIENTSERVER)
      if (x_force_connect)
***************
*** 1652,1659 ****
   * user changes his DISPLAY, but not his WINDOWID) -- webb
   */
      static int
! test_x11_window(dpy)
!     Display	*dpy;
  {
      int			(*old_handler)();
      XTextProperty	text_prop;
--- 1635,1641 ----
   * user changes his DISPLAY, but not his WINDOWID) -- webb
   */
      static int
! test_x11_window(Display *dpy)
  {
      int			(*old_handler)();
      XTextProperty	text_prop;
***************
*** 1684,1690 ****
   * return FAIL for failure, OK otherwise
   */
      static int
! get_x11_windis()
  {
      char	    *winid;
      static int	    result = -1;
--- 1666,1672 ----
   * return FAIL for failure, OK otherwise
   */
      static int
! get_x11_windis(void)
  {
      char	    *winid;
      static int	    result = -1;
***************
*** 1843,1850 ****
   * Determine original x11 Window Title
   */
      static int
! get_x11_title(test_only)
!     int		test_only;
  {
      return get_x11_thing(TRUE, test_only);
  }
--- 1825,1831 ----
   * Determine original x11 Window Title
   */
      static int
! get_x11_title(int test_only)
  {
      return get_x11_thing(TRUE, test_only);
  }
***************
*** 1853,1860 ****
   * Determine original x11 Window icon
   */
      static int
! get_x11_icon(test_only)
!     int		test_only;
  {
      int		retval = FALSE;
  
--- 1834,1840 ----
   * Determine original x11 Window icon
   */
      static int
! get_x11_icon(int test_only)
  {
      int		retval = FALSE;
  
***************
*** 1873,1881 ****
  }
  
      static int
! get_x11_thing(get_title, test_only)
!     int		get_title;	/* get title string */
!     int		test_only;
  {
      XTextProperty	text_prop;
      int			retval = FALSE;
--- 1853,1861 ----
  }
  
      static int
! get_x11_thing(
!     int		get_title,	/* get title string */
!     int		test_only)
  {
      XTextProperty	text_prop;
      int			retval = FALSE;
***************
*** 1990,1997 ****
   * get_x11_windis() must be called before this and have returned OK
   */
      static void
! set_x11_title(title)
!     char_u	*title;
  {
  	/* XmbSetWMProperties() and Xutf8SetWMProperties() should use a STRING
  	 * when possible, COMPOUND_TEXT otherwise.  COMPOUND_TEXT isn't
--- 1970,1976 ----
   * get_x11_windis() must be called before this and have returned OK
   */
      static void
! set_x11_title(char_u *title)
  {
  	/* XmbSetWMProperties() and Xutf8SetWMProperties() should use a STRING
  	 * when possible, COMPOUND_TEXT otherwise.  COMPOUND_TEXT isn't
***************
*** 2030,2037 ****
   * get_x11_windis() must be called before this and have returned OK
   */
      static void
! set_x11_icon(icon)
!     char_u	*icon;
  {
      /* See above for comments about using X*SetWMProperties(). */
  #ifdef USE_UTF8_STRING
--- 2009,2015 ----
   * get_x11_windis() must be called before this and have returned OK
   */
      static void
! set_x11_icon(char_u *icon)
  {
      /* See above for comments about using X*SetWMProperties(). */
  #ifdef USE_UTF8_STRING
***************
*** 2086,2098 ****
  #endif /* FEAT_X11 */
  
      int
! mch_can_restore_title()
  {
      return get_x11_title(TRUE);
  }
  
      int
! mch_can_restore_icon()
  {
      return get_x11_icon(TRUE);
  }
--- 2064,2076 ----
  #endif /* FEAT_X11 */
  
      int
! mch_can_restore_title(void)
  {
      return get_x11_title(TRUE);
  }
  
      int
! mch_can_restore_icon(void)
  {
      return get_x11_icon(TRUE);
  }
***************
*** 2101,2109 ****
   * Set the window title and icon.
   */
      void
! mch_settitle(title, icon)
!     char_u *title;
!     char_u *icon;
  {
      int		type = 0;
      static int	recursive = 0;
--- 2079,2085 ----
   * Set the window title and icon.
   */
      void
! mch_settitle(char_u *title, char_u *icon)
  {
      int		type = 0;
      static int	recursive = 0;
***************
*** 2198,2205 ****
   *  3  restore title and icon
   */
      void
! mch_restore_title(which)
!     int which;
  {
      /* only restore the title or icon when it has been set */
      mch_settitle(((which & 1) && did_set_title) ?
--- 2174,2180 ----
   *  3  restore title and icon
   */
      void
! mch_restore_title(int which)
  {
      /* only restore the title or icon when it has been set */
      mch_settitle(((which & 1) && did_set_title) ?
***************
*** 2214,2221 ****
   * Seiichi Sato mentioned that "mlterm" works like xterm.
   */
      int
! vim_is_xterm(name)
!     char_u *name;
  {
      if (name == NULL)
  	return FALSE;
--- 2189,2195 ----
   * Seiichi Sato mentioned that "mlterm" works like xterm.
   */
      int
! vim_is_xterm(char_u *name)
  {
      if (name == NULL)
  	return FALSE;
***************
*** 2234,2241 ****
   * Relies on term_is_xterm having been set to its correct value.
   */
      int
! use_xterm_like_mouse(name)
!     char_u *name;
  {
      return (name != NULL
  	    && (term_is_xterm || STRNICMP(name, "screen", 6) == 0));
--- 2208,2214 ----
   * Relies on term_is_xterm having been set to its correct value.
   */
      int
! use_xterm_like_mouse(char_u *name)
  {
      return (name != NULL
  	    && (term_is_xterm || STRNICMP(name, "screen", 6) == 0));
***************
*** 2251,2257 ****
   * Return 4 for "sgr".
   */
      int
! use_xterm_mouse()
  {
      if (ttym_flags == TTYM_SGR)
  	return 4;
--- 2224,2230 ----
   * Return 4 for "sgr".
   */
      int
! use_xterm_mouse(void)
  {
      if (ttym_flags == TTYM_SGR)
  	return 4;
***************
*** 2266,2273 ****
  #endif
  
      int
! vim_is_iris(name)
!     char_u  *name;
  {
      if (name == NULL)
  	return FALSE;
--- 2239,2245 ----
  #endif
  
      int
! vim_is_iris(char_u *name)
  {
      if (name == NULL)
  	return FALSE;
***************
*** 2276,2283 ****
  }
  
      int
! vim_is_vt300(name)
!     char_u  *name;
  {
      if (name == NULL)
  	return FALSE;	       /* actually all ANSI comp. terminals should be here  */
--- 2248,2254 ----
  }
  
      int
! vim_is_vt300(char_u *name)
  {
      if (name == NULL)
  	return FALSE;	       /* actually all ANSI comp. terminals should be here  */
***************
*** 2292,2299 ****
   * This should include all windowed terminal emulators.
   */
      int
! vim_is_fastterm(name)
!     char_u  *name;
  {
      if (name == NULL)
  	return FALSE;
--- 2263,2269 ----
   * This should include all windowed terminal emulators.
   */
      int
! vim_is_fastterm(char_u *name)
  {
      if (name == NULL)
  	return FALSE;
***************
*** 2310,2318 ****
   * Return OK if a name found.
   */
      int
! mch_get_user_name(s, len)
!     char_u  *s;
!     int	    len;
  {
  #ifdef VMS
      vim_strncpy(s, (char_u *)cuserid(NULL), len - 1);
--- 2280,2286 ----
   * Return OK if a name found.
   */
      int
! mch_get_user_name(char_u *s, int len)
  {
  #ifdef VMS
      vim_strncpy(s, (char_u *)cuserid(NULL), len - 1);
***************
*** 2327,2336 ****
   * Return OK if a name found.
   */
      int
! mch_get_uname(uid, s, len)
!     uid_t	uid;
!     char_u	*s;
!     int		len;
  {
  #if defined(HAVE_PWD_H) && defined(HAVE_GETPWUID)
      struct passwd   *pw;
--- 2295,2301 ----
   * Return OK if a name found.
   */
      int
! mch_get_uname(uid_t uid, char_u *s, int len)
  {
  #if defined(HAVE_PWD_H) && defined(HAVE_GETPWUID)
      struct passwd   *pw;
***************
*** 2352,2360 ****
  
  #ifdef HAVE_SYS_UTSNAME_H
      void
! mch_get_host_name(s, len)
!     char_u  *s;
!     int	    len;
  {
      struct utsname vutsname;
  
--- 2317,2323 ----
  
  #ifdef HAVE_SYS_UTSNAME_H
      void
! mch_get_host_name(char_u *s, int len)
  {
      struct utsname vutsname;
  
***************
*** 2387,2393 ****
   * return process ID
   */
      long
! mch_get_pid()
  {
      return (long)getpid();
  }
--- 2350,2356 ----
   * return process ID
   */
      long
! mch_get_pid(void)
  {
      return (long)getpid();
  }
***************
*** 2396,2403 ****
  static char *strerror(int);
  
      static char *
! strerror(err)
!     int err;
  {
      extern int	    sys_nerr;
      extern char	    *sys_errlist[];
--- 2359,2365 ----
  static char *strerror(int);
  
      static char *
! strerror(int err)
  {
      extern int	    sys_nerr;
      extern char	    *sys_errlist[];
***************
*** 2415,2423 ****
   * Return OK for success, FAIL for failure.
   */
      int
! mch_dirname(buf, len)
!     char_u  *buf;
!     int	    len;
  {
  #if defined(USE_GETCWD)
      if (getcwd((char *)buf, len) == NULL)
--- 2377,2383 ----
   * Return OK for success, FAIL for failure.
   */
      int
! mch_dirname(char_u *buf, int len)
  {
  #if defined(USE_GETCWD)
      if (getcwd((char *)buf, len) == NULL)
***************
*** 2437,2446 ****
   * return FAIL for failure, OK for success
   */
      int
! mch_FullName(fname, buf, len, force)
!     char_u	*fname, *buf;
!     int		len;
!     int		force;		/* also expand when already absolute path */
  {
      int		l;
  #ifdef HAVE_FCHDIR
--- 2397,2407 ----
   * return FAIL for failure, OK for success
   */
      int
! mch_FullName(
!     char_u	*fname,
!     char_u	*buf,
!     int		len,
!     int		force)		/* also expand when already absolute path */
  {
      int		l;
  #ifdef HAVE_FCHDIR
***************
*** 2585,2592 ****
   * Return TRUE if "fname" does not depend on the current directory.
   */
      int
! mch_isFullName(fname)
!     char_u	*fname;
  {
  #ifdef __EMX__
      return _fnisabs(fname);
--- 2546,2552 ----
   * Return TRUE if "fname" does not depend on the current directory.
   */
      int
! mch_isFullName(char_u *fname)
  {
  #ifdef __EMX__
      return _fnisabs(fname);
***************
*** 2609,2617 ****
   * Only required for file systems where case is ignored and preserved.
   */
      void
! fname_case(name, len)
!     char_u	*name;
!     int		len UNUSED;  /* buffer size, only used when name gets longer */
  {
      struct stat st;
      char_u	*slash, *tail;
--- 2569,2577 ----
   * Only required for file systems where case is ignored and preserved.
   */
      void
! fname_case(
!     char_u	*name,
!     int		len UNUSED)  /* buffer size, only used when name gets longer */
  {
      struct stat st;
      char_u	*slash, *tail;
***************
*** 2672,2679 ****
   * Returns -1 when it doesn't exist.
   */
      long
! mch_getperm(name)
!     char_u *name;
  {
      struct stat statb;
  
--- 2632,2638 ----
   * Returns -1 when it doesn't exist.
   */
      long
! mch_getperm(char_u *name)
  {
      struct stat statb;
  
***************
*** 2699,2707 ****
   * return FAIL for failure, OK otherwise
   */
      int
! mch_setperm(name, perm)
!     char_u  *name;
!     long    perm;
  {
      return (chmod((char *)
  #ifdef VMS
--- 2658,2664 ----
   * return FAIL for failure, OK otherwise
   */
      int
! mch_setperm(char_u *name, long perm)
  {
      return (chmod((char *)
  #ifdef VMS
***************
*** 2732,2740 ****
   * Copy security info from "from_file" to "to_file".
   */
      void
! mch_copy_sec(from_file, to_file)
!     char_u	*from_file;
!     char_u	*to_file;
  {
      if (from_file == NULL)
  	return;
--- 2689,2695 ----
   * Copy security info from "from_file" to "to_file".
   */
      void
! mch_copy_sec(char_u *from_file, char_u *to_file)
  {
      if (from_file == NULL)
  	return;
***************
*** 2866,2873 ****
   * Return NULL if the ACL is not available for whatever reason.
   */
      vim_acl_T
! mch_get_acl(fname)
!     char_u	*fname UNUSED;
  {
      vim_acl_T	ret = NULL;
  #ifdef HAVE_POSIX_ACL
--- 2821,2827 ----
   * Return NULL if the ACL is not available for whatever reason.
   */
      vim_acl_T
! mch_get_acl(char_u *fname UNUSED)
  {
      vim_acl_T	ret = NULL;
  #ifdef HAVE_POSIX_ACL
***************
*** 2934,2942 ****
   * Set the ACL of file "fname" to "acl" (unless it's NULL).
   */
      void
! mch_set_acl(fname, aclent)
!     char_u	*fname UNUSED;
!     vim_acl_T	aclent;
  {
      if (aclent == NULL)
  	return;
--- 2888,2894 ----
   * Set the ACL of file "fname" to "acl" (unless it's NULL).
   */
      void
! mch_set_acl(char_u *fname UNUSED, vim_acl_T aclent)
  {
      if (aclent == NULL)
  	return;
***************
*** 2959,2966 ****
  }
  
      void
! mch_free_acl(aclent)
!     vim_acl_T	aclent;
  {
      if (aclent == NULL)
  	return;
--- 2911,2917 ----
  }
  
      void
! mch_free_acl(vim_acl_T aclent)
  {
      if (aclent == NULL)
  	return;
***************
*** 2987,2994 ****
   * Set hidden flag for "name".
   */
      void
! mch_hide(name)
!     char_u	*name UNUSED;
  {
      /* can't hide a file */
  }
--- 2938,2944 ----
   * Set hidden flag for "name".
   */
      void
! mch_hide(char_u *name UNUSED)
  {
      /* can't hide a file */
  }
***************
*** 2999,3006 ****
   * return FALSE for error
   */
      int
! mch_isdir(name)
!     char_u *name;
  {
      struct stat statb;
  
--- 2949,2955 ----
   * return FALSE for error
   */
      int
! mch_isdir(char_u *name)
  {
      struct stat statb;
  
***************
*** 3021,3028 ****
   * return FALSE for error
   */
      int
! mch_isrealdir(name)
!     char_u *name;
  {
      struct stat statb;
  
--- 2970,2976 ----
   * return FALSE for error
   */
      int
! mch_isrealdir(char_u *name)
  {
      struct stat statb;
  
***************
*** 3043,3050 ****
   * Return 1 if "name" is an executable file, 0 if not or it doesn't exist.
   */
      static int
! executable_file(name)
!     char_u	*name;
  {
      struct stat	st;
  
--- 2991,2997 ----
   * Return 1 if "name" is an executable file, 0 if not or it doesn't exist.
   */
      static int
! executable_file(char_u *name)
  {
      struct stat	st;
  
***************
*** 3078,3087 ****
   * Return -1 if unknown.
   */
      int
! mch_can_exe(name, path, use_path)
!     char_u	*name;
!     char_u	**path;
!     int		use_path;
  {
      char_u	*buf;
      char_u	*p, *e;
--- 3025,3031 ----
   * Return -1 if unknown.
   */
      int
! mch_can_exe(char_u *name, char_u **path, int use_path)
  {
      char_u	*buf;
      char_u	*p, *e;
***************
*** 3161,3168 ****
   * NODE_OTHER: non-writable things
   */
      int
! mch_nodetype(name)
!     char_u	*name;
  {
      struct stat	st;
  
--- 3105,3111 ----
   * NODE_OTHER: non-writable things
   */
      int
! mch_nodetype(char_u *name)
  {
      struct stat	st;
  
***************
*** 3177,3183 ****
  }
  
      void
! mch_early_init()
  {
  #ifdef HAVE_CHECK_STACK_GROWTH
      int			i;
--- 3120,3126 ----
  }
  
      void
! mch_early_init(void)
  {
  #ifdef HAVE_CHECK_STACK_GROWTH
      int			i;
***************
*** 3204,3210 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! mch_free_mem()
  {
  # if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
      if (clip_star.owned)
--- 3147,3153 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! mch_free_mem(void)
  {
  # if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
      if (clip_star.owned)
***************
*** 3254,3260 ****
   * Make sure the newline goes to the same stream as the text.
   */
      static void
! exit_scroll()
  {
      if (silent_mode)
  	return;
--- 3197,3203 ----
   * Make sure the newline goes to the same stream as the text.
   */
      static void
! exit_scroll(void)
  {
      if (silent_mode)
  	return;
***************
*** 3279,3286 ****
  }
  
      void
! mch_exit(r)
!     int r;
  {
      exiting = TRUE;
  
--- 3222,3228 ----
  }
  
      void
! mch_exit(int r)
  {
      exiting = TRUE;
  
***************
*** 3352,3358 ****
  }
  
      static void
! may_core_dump()
  {
      if (deadly_signal != 0)
      {
--- 3294,3300 ----
  }
  
      static void
! may_core_dump(void)
  {
      if (deadly_signal != 0)
      {
***************
*** 3364,3371 ****
  #ifndef VMS
  
      void
! mch_settmode(tmode)
!     int		tmode;
  {
      static int first = TRUE;
  
--- 3306,3312 ----
  #ifndef VMS
  
      void
! mch_settmode(int tmode)
  {
      static int first = TRUE;
  
***************
*** 3468,3474 ****
   * doing forward deletes for no reason. (Eric Fischer)
   */
      void
! get_stty()
  {
      char_u  buf[2];
      char_u  *p;
--- 3409,3415 ----
   * doing forward deletes for no reason. (Eric Fischer)
   */
      void
! get_stty(void)
  {
      char_u  buf[2];
      char_u  *p;
***************
*** 3521,3528 ****
   * Set mouse clicks on or off.
   */
      void
! mch_setmouse(on)
!     int		on;
  {
      static int	ison = FALSE;
      int		xterm_mouse_vers;
--- 3462,3468 ----
   * Set mouse clicks on or off.
   */
      void
! mch_setmouse(int on)
  {
      static int	ison = FALSE;
      int		xterm_mouse_vers;
***************
*** 3667,3673 ****
   * Set the mouse termcode, depending on the 'term' and 'ttymouse' options.
   */
      void
! check_mouse_termcode()
  {
  # ifdef FEAT_MOUSE_XTERM
      if (use_xterm_mouse()
--- 3607,3613 ----
   * Set the mouse termcode, depending on the 'term' and 'ttymouse' options.
   */
      void
! check_mouse_termcode(void)
  {
  # ifdef FEAT_MOUSE_XTERM
      if (use_xterm_mouse()
***************
*** 3812,3819 ****
   * set screen mode, always fails.
   */
      int
! mch_screenmode(arg)
!     char_u   *arg UNUSED;
  {
      EMSG(_(e_screenmode));
      return FAIL;
--- 3752,3758 ----
   * set screen mode, always fails.
   */
      int
! mch_screenmode(char_u *arg UNUSED)
  {
      EMSG(_(e_screenmode));
      return FAIL;
***************
*** 3830,3836 ****
   * Return OK when size could be determined, FAIL otherwise.
   */
      int
! mch_get_shellsize()
  {
      long	rows = 0;
      long	columns = 0;
--- 3769,3775 ----
   * Return OK when size could be determined, FAIL otherwise.
   */
      int
! mch_get_shellsize(void)
  {
      long	rows = 0;
      long	columns = 0;
***************
*** 3924,3930 ****
   * Try to set the window size to Rows and Columns.
   */
      void
! mch_set_shellsize()
  {
      if (*T_CWS)
      {
--- 3863,3869 ----
   * Try to set the window size to Rows and Columns.
   */
      void
! mch_set_shellsize(void)
  {
      if (*T_CWS)
      {
***************
*** 3945,3951 ****
   * Rows and/or Columns has changed.
   */
      void
! mch_new_shellsize()
  {
      /* Nothing to do. */
  }
--- 3884,3890 ----
   * Rows and/or Columns has changed.
   */
      void
! mch_new_shellsize(void)
  {
      /* Nothing to do. */
  }
***************
*** 3955,3963 ****
   * Return "child" if it exited properly, <= 0 on error.
   */
      static pid_t
! wait4pid(child, status)
!     pid_t	child;
!     waitstatus	*status;
  {
      pid_t wait_pid = 0;
  
--- 3894,3900 ----
   * Return "child" if it exited properly, <= 0 on error.
   */
      static pid_t
! wait4pid(pid_t child, waitstatus *status)
  {
      pid_t wait_pid = 0;
  
***************
*** 3989,3997 ****
  }
  
      int
! mch_call_shell(cmd, options)
!     char_u	*cmd;
!     int		options;	/* SHELL_*, see vim.h */
  {
  #ifdef VMS
      char	*ifn = NULL;
--- 3926,3934 ----
  }
  
      int
! mch_call_shell(
!     char_u	*cmd,
!     int		options)	/* SHELL_*, see vim.h */
  {
  #ifdef VMS
      char	*ifn = NULL;
***************
*** 5080,5086 ****
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck()
  {
      if (curr_tmode == TMODE_RAW && RealWaitForChar(read_cmd_fd, 0L, NULL))
  	fill_input_buf(FALSE);
--- 5017,5023 ----
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(void)
  {
      if (curr_tmode == TMODE_RAW && RealWaitForChar(read_cmd_fd, 0L, NULL))
  	fill_input_buf(FALSE);
***************
*** 5092,5099 ****
   * When a GUI is being used, this will never get called -- webb
   */
      static int
! WaitForChar(msec)
!     long	msec;
  {
  #ifdef FEAT_MOUSE_GPM
      int		gpm_process_wanted;
--- 5029,5035 ----
   * When a GUI is being used, this will never get called -- webb
   */
      static int
! WaitForChar(long msec)
  {
  #ifdef FEAT_MOUSE_GPM
      int		gpm_process_wanted;
***************
*** 5183,5192 ****
  #else
      static  int
  #endif
! RealWaitForChar(fd, msec, check_for_gpm)
!     int		fd;
!     long	msec;
!     int		*check_for_gpm UNUSED;
  {
      int		ret;
  #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
--- 5119,5125 ----
  #else
      static  int
  #endif
! RealWaitForChar(int fd, long msec, int *check_for_gpm UNUSED)
  {
      int		ret;
  #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
***************
*** 5583,5592 ****
   * Returns the number of matches found.
   */
      int
! mch_expandpath(gap, path, flags)
!     garray_T	*gap;
!     char_u	*path;
!     int		flags;		/* EW_* flags */
  {
      return unix_expandpath(gap, path, 0, flags, FALSE);
  }
--- 5516,5525 ----
   * Returns the number of matches found.
   */
      int
! mch_expandpath(
!     garray_T	*gap,
!     char_u	*path,
!     int		flags)		/* EW_* flags */
  {
      return unix_expandpath(gap, path, 0, flags, FALSE);
  }
***************
*** 5615,5626 ****
  #define SHELL_SPECIAL (char_u *)"\t \"&'$;<>()\\|"
  
      int
! mch_expand_wildcards(num_pat, pat, num_file, file, flags)
!     int		   num_pat;
!     char_u	 **pat;
!     int		  *num_file;
!     char_u	***file;
!     int		   flags;	/* EW_* flags */
  {
      int		i;
      size_t	len;
--- 5548,5559 ----
  #define SHELL_SPECIAL (char_u *)"\t \"&'$;<>()\\|"
  
      int
! mch_expand_wildcards(
!     int		   num_pat,
!     char_u	 **pat,
!     int		  *num_file,
!     char_u	***file,
!     int		   flags)	/* EW_* flags */
  {
      int		i;
      size_t	len;
***************
*** 6225,6235 ****
  
  #ifndef __EMX__
      static int
! save_patterns(num_pat, pat, num_file, file)
!     int		num_pat;
!     char_u	**pat;
!     int		*num_file;
!     char_u	***file;
  {
      int		i;
      char_u	*s;
--- 6158,6168 ----
  
  #ifndef __EMX__
      static int
! save_patterns(
!     int		num_pat,
!     char_u	**pat,
!     int		*num_file,
!     char_u	***file)
  {
      int		i;
      char_u	*s;
***************
*** 6256,6263 ****
   * expand.
   */
      int
! mch_has_exp_wildcard(p)
!     char_u  *p;
  {
      for ( ; *p; mb_ptr_adv(p))
      {
--- 6189,6195 ----
   * expand.
   */
      int
! mch_has_exp_wildcard(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
***************
*** 6281,6288 ****
   * Don't recognize '~' at the end as a wildcard.
   */
      int
! mch_has_wildcard(p)
!     char_u  *p;
  {
      for ( ; *p; mb_ptr_adv(p))
      {
--- 6213,6219 ----
   * Don't recognize '~' at the end as a wildcard.
   */
      int
! mch_has_wildcard(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
***************
*** 6304,6312 ****
  
  #ifndef __EMX__
      static int
! have_wildcard(num, file)
!     int	    num;
!     char_u  **file;
  {
      int	    i;
  
--- 6235,6241 ----
  
  #ifndef __EMX__
      static int
! have_wildcard(int num, char_u **file)
  {
      int	    i;
  
***************
*** 6317,6325 ****
  }
  
      static int
! have_dollars(num, file)
!     int	    num;
!     char_u  **file;
  {
      int	    i;
  
--- 6246,6252 ----
  }
  
      static int
! have_dollars(int num, char_u **file)
  {
      int	    i;
  
***************
*** 6337,6344 ****
   * destination exists.
   */
      int
! mch_rename(src, dest)
!     const char *src, *dest;
  {
      struct stat	    st;
  
--- 6264,6270 ----
   * destination exists.
   */
      int
! mch_rename(const char *src, *dest)
  {
      struct stat	    st;
  
***************
*** 6358,6364 ****
   * Return 1 if succeeded (or connection already opened), 0 if failed
   */
      static int
! gpm_open()
  {
      static Gpm_Connect gpm_connect; /* Must it be kept till closing ? */
  
--- 6284,6290 ----
   * Return 1 if succeeded (or connection already opened), 0 if failed
   */
      static int
! gpm_open(void)
  {
      static Gpm_Connect gpm_connect; /* Must it be kept till closing ? */
  
***************
*** 6392,6398 ****
   * Closes connection to gpm
   */
      static void
! gpm_close()
  {
      if (gpm_flag && gpm_fd >= 0) /* if Open */
  	Gpm_Close();
--- 6318,6324 ----
   * Closes connection to gpm
   */
      static void
! gpm_close(void)
  {
      if (gpm_flag && gpm_fd >= 0) /* if Open */
  	Gpm_Close();
***************
*** 6403,6409 ****
   * This function is styled after gui_send_mouse_event().
   */
      static int
! mch_gpm_process()
  {
      int			button;
      static Gpm_Event	gpm_event;
--- 6329,6335 ----
   * This function is styled after gui_send_mouse_event().
   */
      static int
! mch_gpm_process(void)
  {
      int			button;
      static Gpm_Event	gpm_event;
***************
*** 6492,6498 ****
   * Return OK if succeeded, FAIL if failed.
   */
      static int
! sysmouse_open()
  {
      struct mouse_info   mouse;
  
--- 6418,6424 ----
   * Return OK if succeeded, FAIL if failed.
   */
      static int
! sysmouse_open(void)
  {
      struct mouse_info   mouse;
  
***************
*** 6514,6520 ****
   * virtual console do not send us any sysmouse related signal.
   */
      static void
! sysmouse_close()
  {
      struct mouse_info	mouse;
  
--- 6440,6446 ----
   * virtual console do not send us any sysmouse related signal.
   */
      static void
! sysmouse_close(void)
  {
      struct mouse_info	mouse;
  
***************
*** 6602,6614 ****
   * and returns an allocated string.
   */
      int
! mch_libcall(libname, funcname, argstring, argint, string_result, number_result)
!     char_u	*libname;
!     char_u	*funcname;
!     char_u	*argstring;	/* NULL when using a argint */
!     int		argint;
!     char_u	**string_result;/* NULL when using number_result */
!     int		*number_result;
  {
  # if defined(USE_DLOPEN)
      void	*hinstLib;
--- 6528,6540 ----
   * and returns an allocated string.
   */
      int
! mch_libcall(
!     char_u	*libname,
!     char_u	*funcname,
!     char_u	*argstring,	/* NULL when using a argint */
!     int		argint,
!     char_u	**string_result,/* NULL when using number_result */
!     int		*number_result)
  {
  # if defined(USE_DLOPEN)
      void	*hinstLib;
***************
*** 6769,6775 ****
   * Setup a dummy window for X selections in a terminal.
   */
      void
! setup_term_clip()
  {
      int		z = 0;
      char	*strp = "";
--- 6695,6701 ----
   * Setup a dummy window for X selections in a terminal.
   */
      void
! setup_term_clip(void)
  {
      int		z = 0;
      char	*strp = "";
***************
*** 6878,6885 ****
  }
  
      void
! start_xterm_trace(button)
!     int button;
  {
      if (x11_window == 0 || xterm_trace < 0 || xterm_Shell == (Widget)0)
  	return;
--- 6804,6810 ----
  }
  
      void
! start_xterm_trace(int button)
  {
      if (x11_window == 0 || xterm_trace < 0 || xterm_Shell == (Widget)0)
  	return;
***************
*** 6890,6896 ****
  
  
      void
! stop_xterm_trace()
  {
      if (xterm_trace < 0)
  	return;
--- 6815,6821 ----
  
  
      void
! stop_xterm_trace(void)
  {
      if (xterm_trace < 0)
  	return;
***************
*** 6902,6908 ****
   * return TRUE if dragging is active, else FALSE
   */
      static int
! do_xterm_trace()
  {
      Window		root, child;
      int			root_x, root_y;
--- 6827,6833 ----
   * return TRUE if dragging is active, else FALSE
   */
      static int
! do_xterm_trace(void)
  {
      Window		root, child;
      int			root_x, root_y;
***************
*** 6985,6991 ****
   * Destroy the display, window and app_context.  Required for GTK.
   */
      void
! clear_xterm_clip()
  {
      if (xterm_Shell != (Widget)0)
      {
--- 6910,6916 ----
   * Destroy the display, window and app_context.  Required for GTK.
   */
      void
! clear_xterm_clip(void)
  {
      if (xterm_Shell != (Widget)0)
      {
***************
*** 7017,7023 ****
   * Catch up with GUI or X events.
   */
      static void
! clip_update()
  {
  # ifdef FEAT_GUI
      if (gui.in_use)
--- 6942,6948 ----
   * Catch up with GUI or X events.
   */
      static void
! clip_update(void)
  {
  # ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 7035,7041 ****
   * immediately.
   */
      static void
! xterm_update()
  {
      XEvent event;
  
--- 6960,6966 ----
   * immediately.
   */
      static void
! xterm_update(void)
  {
      XEvent event;
  
***************
*** 7070,7077 ****
  }
  
      int
! clip_xterm_own_selection(cbd)
!     VimClipboard *cbd;
  {
      if (xterm_Shell != (Widget)0)
  	return clip_x11_own_selection(xterm_Shell, cbd);
--- 6995,7001 ----
  }
  
      int
! clip_xterm_own_selection(VimClipboard *cbd)
  {
      if (xterm_Shell != (Widget)0)
  	return clip_x11_own_selection(xterm_Shell, cbd);
***************
*** 7079,7102 ****
  }
  
      void
! clip_xterm_lose_selection(cbd)
!     VimClipboard *cbd;
  {
      if (xterm_Shell != (Widget)0)
  	clip_x11_lose_selection(xterm_Shell, cbd);
  }
  
      void
! clip_xterm_request_selection(cbd)
!     VimClipboard *cbd;
  {
      if (xterm_Shell != (Widget)0)
  	clip_x11_request_selection(xterm_Shell, xterm_dpy, cbd);
  }
  
      void
! clip_xterm_set_selection(cbd)
!     VimClipboard *cbd;
  {
      clip_x11_set_selection(cbd);
  }
--- 7003,7023 ----
  }
  
      void
! clip_xterm_lose_selection(VimClipboard *cbd)
  {
      if (xterm_Shell != (Widget)0)
  	clip_x11_lose_selection(xterm_Shell, cbd);
  }
  
      void
! clip_xterm_request_selection(VimClipboard *cbd)
  {
      if (xterm_Shell != (Widget)0)
  	clip_x11_request_selection(xterm_Shell, xterm_dpy, cbd);
  }
  
      void
! clip_xterm_set_selection(VimClipboard *cbd)
  {
      clip_x11_set_selection(cbd);
  }
***************
*** 7122,7130 ****
   * or abort the logout
   */
      static void
! xsmp_handle_interaction(smc_conn, client_data)
!     SmcConn	smc_conn;
!     SmPointer	client_data UNUSED;
  {
      cmdmod_T	save_cmdmod;
      int		cancel_shutdown = False;
--- 7043,7049 ----
   * or abort the logout
   */
      static void
! xsmp_handle_interaction(SmcConn smc_conn, SmPointer client_data UNUSED)
  {
      cmdmod_T	save_cmdmod;
      int		cancel_shutdown = False;
***************
*** 7158,7171 ****
   * Callback that starts save-yourself.
   */
      static void
! xsmp_handle_save_yourself(smc_conn, client_data, save_type,
! 					       shutdown, interact_style, fast)
!     SmcConn	smc_conn;
!     SmPointer	client_data UNUSED;
!     int		save_type UNUSED;
!     Bool	shutdown;
!     int		interact_style UNUSED;
!     Bool	fast UNUSED;
  {
      /* Handle already being in saveyourself */
      if (xsmp.save_yourself)
--- 7077,7089 ----
   * Callback that starts save-yourself.
   */
      static void
! xsmp_handle_save_yourself(
!     SmcConn	smc_conn,
!     SmPointer	client_data UNUSED,
!     int		save_type UNUSED,
!     Bool	shutdown,
!     int		interact_style UNUSED,
!     Bool	fast UNUSED)
  {
      /* Handle already being in saveyourself */
      if (xsmp.save_yourself)
***************
*** 7200,7208 ****
   * Callback to warn us of imminent death.
   */
      static void
! xsmp_die(smc_conn, client_data)
!     SmcConn	smc_conn UNUSED;
!     SmPointer	client_data UNUSED;
  {
      xsmp_close();
  
--- 7118,7124 ----
   * Callback to warn us of imminent death.
   */
      static void
! xsmp_die(SmcConn smc_conn UNUSED, SmPointer client_data UNUSED)
  {
      xsmp_close();
  
***************
*** 7215,7223 ****
   * Callback to tell us that save-yourself has completed.
   */
      static void
! xsmp_save_complete(smc_conn, client_data)
!     SmcConn	smc_conn UNUSED;
!     SmPointer	client_data UNUSED;
  {
      xsmp.save_yourself = False;
  }
--- 7131,7139 ----
   * Callback to tell us that save-yourself has completed.
   */
      static void
! xsmp_save_complete(
!     SmcConn	smc_conn UNUSED,
!     SmPointer	client_data UNUSED)
  {
      xsmp.save_yourself = False;
  }
***************
*** 7228,7236 ****
   * (maybe even by us)
   */
      static void
! xsmp_shutdown_cancelled(smc_conn, client_data)
!     SmcConn	smc_conn;
!     SmPointer	client_data UNUSED;
  {
      if (xsmp.save_yourself)
  	SmcSaveYourselfDone(smc_conn, True);
--- 7144,7152 ----
   * (maybe even by us)
   */
      static void
! xsmp_shutdown_cancelled(
!     SmcConn	smc_conn,
!     SmPointer	client_data UNUSED)
  {
      if (xsmp.save_yourself)
  	SmcSaveYourselfDone(smc_conn, True);
***************
*** 7243,7253 ****
   * Callback to tell us that a new ICE connection has been established.
   */
      static void
! xsmp_ice_connection(iceConn, clientData, opening, watchData)
!     IceConn	iceConn;
!     IcePointer	clientData UNUSED;
!     Bool	opening;
!     IcePointer	*watchData UNUSED;
  {
      /* Intercept creation of ICE connection fd */
      if (opening)
--- 7159,7169 ----
   * Callback to tell us that a new ICE connection has been established.
   */
      static void
! xsmp_ice_connection(
!     IceConn	iceConn,
!     IcePointer	clientData UNUSED,
!     Bool	opening,
!     IcePointer	*watchData UNUSED)
  {
      /* Intercept creation of ICE connection fd */
      if (opening)
***************
*** 7260,7266 ****
  
  /* Handle any ICE processing that's required; return FAIL if SM lost */
      int
! xsmp_handle_requests()
  {
      Bool rep;
  
--- 7176,7182 ----
  
  /* Handle any ICE processing that's required; return FAIL if SM lost */
      int
! xsmp_handle_requests(void)
  {
      Bool rep;
  
***************
*** 7359,7365 ****
  
  /* Shut down XSMP comms. */
      void
! xsmp_close()
  {
      if (xsmp_icefd != -1)
      {
--- 7275,7281 ----
  
  /* Shut down XSMP comms. */
      void
! xsmp_close(void)
  {
      if (xsmp_icefd != -1)
      {
*** ../vim-7.4.1212/src/os_vms.c	2016-01-29 22:46:58.962534859 +0100
--- src/os_vms.c	2016-01-30 20:11:32.757965883 +0100
***************
*** 723,732 ****
   * "msec" == -1 will block until a character is available.
   */
      int
! RealWaitForChar(fd, msec, check_for_gpm)
!     int		fd UNUSED; /* always read from iochan */
!     long	msec;
!     int		*check_for_gpm UNUSED;
  {
      int status;
      struct _generic_64 time_curr;
--- 723,732 ----
   * "msec" == -1 will block until a character is available.
   */
      int
! RealWaitForChar(
!     int		fd UNUSED, /* always read from iochan */
!     long	msec,
!     int		*check_for_gpm UNUSED)
  {
      int status;
      struct _generic_64 time_curr;
*** ../vim-7.4.1212/src/os_win16.c	2016-01-29 23:20:35.305308204 +0100
--- src/os_win16.c	2016-01-30 20:12:10.205576487 +0100
***************
*** 156,162 ****
   * GUI version of mch_init().
   */
      void
! mch_init()
  {
      extern int _fmode;
  
--- 156,162 ----
   * GUI version of mch_init().
   */
      void
! mch_init(void)
  {
      extern int _fmode;
  
***************
*** 206,212 ****
   * return process ID
   */
      long
! mch_get_pid()
  {
      return (long)GetCurrentTask();
  }
--- 206,212 ----
   * return process ID
   */
      long
! mch_get_pid(void)
  {
      return (long)GetCurrentTask();
  }
***************
*** 379,385 ****
   * check for an "interrupt signal": CTRL-break or CTRL-C
   */
      void
! mch_breakcheck()
  {
      /* never used */
  }
--- 379,385 ----
   * check for an "interrupt signal": CTRL-break or CTRL-C
   */
      void
! mch_breakcheck(void)
  {
      /* never used */
  }
***************
*** 417,423 ****
   * Get the default shell for the current hardware platform
   */
      char*
! default_shell()
  {
      char* psz = NULL;
  
--- 417,423 ----
   * Get the default shell for the current hardware platform
   */
      char*
! default_shell(void)
  {
      char* psz = NULL;
  
*** ../vim-7.4.1212/src/os_win32.c	2016-01-29 21:11:20.967061365 +0100
--- src/os_win32.c	2016-01-30 20:12:30.169368895 +0100
***************
*** 481,487 ****
  				       = null_libintl_bind_textdomain_codeset;
  
      int
! dyn_libintl_init()
  {
      int i;
      static struct
--- 481,487 ----
  				       = null_libintl_bind_textdomain_codeset;
  
      int
! dyn_libintl_init(void)
  {
      int i;
      static struct
***************
*** 543,549 ****
  }
  
      void
! dyn_libintl_end()
  {
      if (hLibintlDLL)
  	FreeLibrary(hLibintlDLL);
--- 543,549 ----
  }
  
      void
! dyn_libintl_end(void)
  {
      if (hLibintlDLL)
  	FreeLibrary(hLibintlDLL);
*** ../vim-7.4.1212/src/popupmnu.c	2016-01-29 22:46:58.962534859 +0100
--- src/popupmnu.c	2016-01-30 20:13:02.697030659 +0100
***************
*** 42,51 ****
   * The menu appears above the screen line "row" or at "row" + "height" - 1.
   */
      void
! pum_display(array, size, selected)
!     pumitem_T	*array;
!     int		size;
!     int		selected;	/* index of initially selected item, none if
  				   out of range */
  {
      int		w;
--- 42,51 ----
   * The menu appears above the screen line "row" or at "row" + "height" - 1.
   */
      void
! pum_display(
!     pumitem_T	*array,
!     int		size,
!     int		selected)	/* index of initially selected item, none if
  				   out of range */
  {
      int		w;
***************
*** 263,269 ****
   * Redraw the popup menu, using "pum_first" and "pum_selected".
   */
      void
! pum_redraw()
  {
      int		row = pum_row;
      int		col;
--- 263,269 ----
   * Redraw the popup menu, using "pum_first" and "pum_selected".
   */
      void
! pum_redraw(void)
  {
      int		row = pum_row;
      int		col;
***************
*** 487,495 ****
   * must be recomputed.
   */
      static int
! pum_set_selected(n, repeat)
!     int	    n;
!     int	    repeat;
  {
      int	    resized = FALSE;
      int	    context = pum_height / 2;
--- 487,493 ----
   * must be recomputed.
   */
      static int
! pum_set_selected(int n, int repeat)
  {
      int	    resized = FALSE;
      int	    context = pum_height / 2;
***************
*** 704,710 ****
   * Undisplay the popup menu (later).
   */
      void
! pum_undisplay()
  {
      pum_array = NULL;
      redraw_all_later(SOME_VALID);
--- 702,708 ----
   * Undisplay the popup menu (later).
   */
      void
! pum_undisplay(void)
  {
      pum_array = NULL;
      redraw_all_later(SOME_VALID);
***************
*** 719,725 ****
   * displayed item.
   */
      void
! pum_clear()
  {
      pum_first = 0;
  }
--- 717,723 ----
   * displayed item.
   */
      void
! pum_clear(void)
  {
      pum_first = 0;
  }
***************
*** 729,735 ****
   * Overruled when "pum_do_redraw" is set, used to redraw the status lines.
   */
      int
! pum_visible()
  {
      return !pum_do_redraw && pum_array != NULL;
  }
--- 727,733 ----
   * Overruled when "pum_do_redraw" is set, used to redraw the status lines.
   */
      int
! pum_visible(void)
  {
      return !pum_do_redraw && pum_array != NULL;
  }
***************
*** 739,745 ****
   * Only valid when pum_visible() returns TRUE!
   */
      int
! pum_get_height()
  {
      return pum_height;
  }
--- 737,743 ----
   * Only valid when pum_visible() returns TRUE!
   */
      int
! pum_get_height(void)
  {
      return pum_height;
  }
*** ../vim-7.4.1212/src/pty.c	2016-01-29 23:20:35.305308204 +0100
--- src/pty.c	2016-01-30 20:13:39.272650332 +0100
***************
*** 134,141 ****
  #endif
  
      static void
! initmaster(f)
!     int f UNUSED;
  {
  #ifndef VMS
  # ifdef POSIX
--- 134,140 ----
  #endif
  
      static void
! initmaster(int f UNUSED)
  {
  #ifndef VMS
  # ifdef POSIX
***************
*** 156,163 ****
   * pty on others.  Needs to be tuned...
   */
      int
! SetupSlavePTY(fd)
!     int fd;
  {
      if (fd < 0)
  	return 0;
--- 155,161 ----
   * pty on others.  Needs to be tuned...
   */
      int
! SetupSlavePTY(int fd)
  {
      if (fd < 0)
  	return 0;
***************
*** 180,187 ****
  #if defined(OSX) && !defined(PTY_DONE)
  #define PTY_DONE
      int
! OpenPTY(ttyn)
!     char **ttyn;
  {
      int		f;
      static char TtyName[32];
--- 178,184 ----
  #if defined(OSX) && !defined(PTY_DONE)
  #define PTY_DONE
      int
! OpenPTY(char **ttyn)
  {
      int		f;
      static char TtyName[32];
*** ../vim-7.4.1212/src/quickfix.c	2016-01-29 22:46:58.962534859 +0100
--- src/quickfix.c	2016-01-30 20:16:21.362964866 +0100
***************
*** 153,164 ****
   * Return -1 for error, number of errors for success.
   */
      int
! qf_init(wp, efile, errorformat, newlist, qf_title)
!     win_T	    *wp;
!     char_u	    *efile;
!     char_u	    *errorformat;
!     int		    newlist;		/* TRUE: start a new error list */
!     char_u	    *qf_title;
  {
      qf_info_T	    *qi = &ql_info;
  
--- 153,164 ----
   * Return -1 for error, number of errors for success.
   */
      int
! qf_init(
!     win_T	    *wp,
!     char_u	    *efile,
!     char_u	    *errorformat,
!     int		    newlist,		/* TRUE: start a new error list */
!     char_u	    *qf_title)
  {
      qf_info_T	    *qi = &ql_info;
  
***************
*** 184,200 ****
   * Return -1 for error, number of errors for success.
   */
      static int
! qf_init_ext(qi, efile, buf, tv, errorformat, newlist, lnumfirst, lnumlast,
! 								     qf_title)
!     qf_info_T	    *qi;
!     char_u	    *efile;
!     buf_T	    *buf;
!     typval_T	    *tv;
!     char_u	    *errorformat;
!     int		    newlist;		/* TRUE: start a new error list */
!     linenr_T	    lnumfirst;		/* first line number to use */
!     linenr_T	    lnumlast;		/* last line number to use */
!     char_u	    *qf_title;
  {
      char_u	    *namebuf;
      char_u	    *errmsg;
--- 184,199 ----
   * Return -1 for error, number of errors for success.
   */
      static int
! qf_init_ext(
!     qf_info_T	    *qi,
!     char_u	    *efile,
!     buf_T	    *buf,
!     typval_T	    *tv,
!     char_u	    *errorformat,
!     int		    newlist,		/* TRUE: start a new error list */
!     linenr_T	    lnumfirst,		/* first line number to use */
!     linenr_T	    lnumlast,		/* last line number to use */
!     char_u	    *qf_title)
  {
      char_u	    *namebuf;
      char_u	    *errmsg;
***************
*** 887,895 ****
  }
  
      static void
! qf_store_title(qi, title)
!     qf_info_T	*qi;
!     char_u	*title;
  {
      if (title != NULL)
      {
--- 886,892 ----
  }
  
      static void
! qf_store_title(qf_info_T *qi, char_u *title)
  {
      if (title != NULL)
      {
***************
*** 905,913 ****
   * Prepare for adding a new quickfix list.
   */
      static void
! qf_new_list(qi, qf_title)
!     qf_info_T	*qi;
!     char_u	*qf_title;
  {
      int		i;
  
--- 902,908 ----
   * Prepare for adding a new quickfix list.
   */
      static void
! qf_new_list(qf_info_T *qi, char_u *qf_title)
  {
      int		i;
  
***************
*** 940,947 ****
   * Free a location list
   */
      static void
! ll_free_all(pqi)
!     qf_info_T	**pqi;
  {
      int		i;
      qf_info_T	*qi;
--- 935,941 ----
   * Free a location list
   */
      static void
! ll_free_all(qf_info_T **pqi)
  {
      int		i;
      qf_info_T	*qi;
***************
*** 962,969 ****
  }
  
      void
! qf_free_all(wp)
!     win_T	*wp;
  {
      int		i;
      qf_info_T	*qi = &ql_info;
--- 956,962 ----
  }
  
      void
! qf_free_all(win_T *wp)
  {
      int		i;
      qf_info_T	*qi = &ql_info;
***************
*** 985,1005 ****
   * Returns OK or FAIL.
   */
      static int
! qf_add_entry(qi, prevp, dir, fname, bufnum, mesg, lnum, col, vis_col, pattern,
! 	     nr, type, valid)
!     qf_info_T	*qi;		/* quickfix list */
!     qfline_T	**prevp;	/* pointer to previously added entry or NULL */
!     char_u	*dir;		/* optional directory name */
!     char_u	*fname;		/* file name or NULL */
!     int		bufnum;		/* buffer number or zero */
!     char_u	*mesg;		/* message */
!     long	lnum;		/* line number */
!     int		col;		/* column */
!     int		vis_col;	/* using visual column */
!     char_u	*pattern;	/* search pattern */
!     int		nr;		/* error number */
!     int		type;		/* type character */
!     int		valid;		/* valid entry */
  {
      qfline_T	*qfp;
  
--- 978,997 ----
   * Returns OK or FAIL.
   */
      static int
! qf_add_entry(
!     qf_info_T	*qi,		/* quickfix list */
!     qfline_T	**prevp,	/* pointer to previously added entry or NULL */
!     char_u	*dir,		/* optional directory name */
!     char_u	*fname,		/* file name or NULL */
!     int		bufnum,		/* buffer number or zero */
!     char_u	*mesg,		/* message */
!     long	lnum,		/* line number */
!     int		col,		/* column */
!     int		vis_col,	/* using visual column */
!     char_u	*pattern,	/* search pattern */
!     int		nr,		/* error number */
!     int		type,		/* type character */
!     int		valid)		/* valid entry */
  {
      qfline_T	*qfp;
  
***************
*** 1061,1067 ****
   * Allocate a new location list
   */
      static qf_info_T *
! ll_new_list()
  {
      qf_info_T *qi;
  
--- 1053,1059 ----
   * Allocate a new location list
   */
      static qf_info_T *
! ll_new_list(void)
  {
      qf_info_T *qi;
  
***************
*** 1080,1087 ****
   * If not present, allocate a location list
   */
      static qf_info_T *
! ll_get_or_alloc_list(wp)
!     win_T   *wp;
  {
      if (IS_LL_WINDOW(wp))
  	/* For a location list window, use the referenced location list */
--- 1072,1078 ----
   * If not present, allocate a location list
   */
      static qf_info_T *
! ll_get_or_alloc_list(win_T *wp)
  {
      if (IS_LL_WINDOW(wp))
  	/* For a location list window, use the referenced location list */
***************
*** 1102,1110 ****
   * Copy the location list from window "from" to window "to".
   */
      void
! copy_loclist(from, to)
!     win_T	*from;
!     win_T	*to;
  {
      qf_info_T	*qi;
      int		idx;
--- 1093,1099 ----
   * Copy the location list from window "from" to window "to".
   */
      void
! copy_loclist(win_T *from, win_T *to)
  {
      qf_info_T	*qi;
      int		idx;
***************
*** 1206,1214 ****
   * get buffer number for file "dir.name"
   */
      static int
! qf_get_fnum(directory, fname)
!     char_u   *directory;
!     char_u   *fname;
  {
      if (fname == NULL || *fname == NUL)		/* no file name */
  	return 0;
--- 1195,1201 ----
   * get buffer number for file "dir.name"
   */
      static int
! qf_get_fnum(char_u *directory, char_u *fname)
  {
      if (fname == NULL || *fname == NUL)		/* no file name */
  	return 0;
***************
*** 1256,1264 ****
   * NULL on error
   */
      static char_u *
! qf_push_dir(dirbuf, stackptr)
!     char_u		*dirbuf;
!     struct dir_stack_T	**stackptr;
  {
      struct dir_stack_T  *ds_new;
      struct dir_stack_T  *ds_ptr;
--- 1243,1249 ----
   * NULL on error
   */
      static char_u *
! qf_push_dir(char_u *dirbuf, struct dir_stack_T **stackptr)
  {
      struct dir_stack_T  *ds_new;
      struct dir_stack_T  *ds_ptr;
***************
*** 1329,1336 ****
   * stack is empty
   */
      static char_u *
! qf_pop_dir(stackptr)
!     struct dir_stack_T	**stackptr;
  {
      struct dir_stack_T  *ds_ptr;
  
--- 1314,1320 ----
   * stack is empty
   */
      static char_u *
! qf_pop_dir(struct dir_stack_T **stackptr)
  {
      struct dir_stack_T  *ds_ptr;
  
***************
*** 1354,1361 ****
   * clean up directory stack
   */
      static void
! qf_clean_dir_stack(stackptr)
!     struct dir_stack_T	**stackptr;
  {
      struct dir_stack_T  *ds_ptr;
  
--- 1338,1344 ----
   * clean up directory stack
   */
      static void
! qf_clean_dir_stack(struct dir_stack_T **stackptr)
  {
      struct dir_stack_T  *ds_ptr;
  
***************
*** 1388,1395 ****
   * qf_guess_filepath will return NULL.
   */
      static char_u *
! qf_guess_filepath(filename)
!     char_u *filename;
  {
      struct dir_stack_T     *ds_ptr;
      struct dir_stack_T     *ds_tmp;
--- 1371,1377 ----
   * qf_guess_filepath will return NULL.
   */
      static char_u *
! qf_guess_filepath(char_u *filename)
  {
      struct dir_stack_T     *ds_ptr;
      struct dir_stack_T     *ds_tmp;
***************
*** 1440,1450 ****
   * else go to entry "errornr"
   */
      void
! qf_jump(qi, dir, errornr, forceit)
!     qf_info_T	*qi;
!     int		dir;
!     int		errornr;
!     int		forceit;
  {
      qf_info_T		*ll_ref;
      qfline_T		*qf_ptr;
--- 1422,1432 ----
   * else go to entry "errornr"
   */
      void
! qf_jump(
!     qf_info_T	*qi,
!     int		dir,
!     int		errornr,
!     int		forceit)
  {
      qf_info_T		*ll_ref;
      qfline_T		*qf_ptr;
***************
*** 1954,1961 ****
   * ":llist": list all locations
   */
      void
! qf_list(eap)
!     exarg_T	*eap;
  {
      buf_T	*buf;
      char_u	*fname;
--- 1936,1942 ----
   * ":llist": list all locations
   */
      void
! qf_list(exarg_T *eap)
  {
      buf_T	*buf;
      char_u	*fname;
***************
*** 2060,2069 ****
   * Put the result in "buf[bufsize]".
   */
      static void
! qf_fmt_text(text, buf, bufsize)
!     char_u	*text;
!     char_u	*buf;
!     int		bufsize;
  {
      int		i;
      char_u	*p = text;
--- 2041,2047 ----
   * Put the result in "buf[bufsize]".
   */
      static void
! qf_fmt_text(char_u *text, char_u *buf, int bufsize)
  {
      int		i;
      char_u	*p = text;
***************
*** 2090,2097 ****
   * ":lnewer [count]": Down in the location list stack.
   */
      void
! qf_age(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      int		count;
--- 2068,2074 ----
   * ":lnewer [count]": Down in the location list stack.
   */
      void
! qf_age(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      int		count;
***************
*** 2135,2142 ****
  }
  
      static void
! qf_msg(qi)
!     qf_info_T	*qi;
  {
      smsg((char_u *)_("error list %d of %d; %d errors"),
  	    qi->qf_curlist + 1, qi->qf_listcount,
--- 2112,2118 ----
  }
  
      static void
! qf_msg(qf_info_T *qi)
  {
      smsg((char_u *)_("error list %d of %d; %d errors"),
  	    qi->qf_curlist + 1, qi->qf_listcount,
***************
*** 2150,2158 ****
   * Free error list "idx".
   */
      static void
! qf_free(qi, idx)
!     qf_info_T	*qi;
!     int		idx;
  {
      qfline_T	*qfp;
      int		stop = FALSE;
--- 2126,2132 ----
   * Free error list "idx".
   */
      static void
! qf_free(qf_info_T *qi, int idx)
  {
      qfline_T	*qfp;
      int		stop = FALSE;
***************
*** 2184,2195 ****
   * qf_mark_adjust: adjust marks
   */
     void
! qf_mark_adjust(wp, line1, line2, amount, amount_after)
!     win_T	*wp;
!     linenr_T	line1;
!     linenr_T	line2;
!     long	amount;
!     long	amount_after;
  {
      int		i;
      qfline_T	*qfp;
--- 2158,2169 ----
   * qf_mark_adjust: adjust marks
   */
     void
! qf_mark_adjust(
!     win_T	*wp,
!     linenr_T	line1,
!     linenr_T	line2,
!     long	amount,
!     long	amount_after)
  {
      int		i;
      qfline_T	*qfp;
***************
*** 2237,2244 ****
   *  1	      x		""	:helpgrep
   */
      static char_u *
! qf_types(c, nr)
!     int c, nr;
  {
      static char_u	buf[20];
      static char_u	cc[3];
--- 2211,2217 ----
   *  1	      x		""	:helpgrep
   */
      static char_u *
! qf_types(int c, int nr)
  {
      static char_u	buf[20];
      static char_u	cc[3];
***************
*** 2275,2282 ****
   *	       close it if not.
   */
      void
! ex_cwindow(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      win_T	*win;
--- 2248,2254 ----
   *	       close it if not.
   */
      void
! ex_cwindow(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      win_T	*win;
***************
*** 2312,2319 ****
   * ":lclose": close the window showing the location list
   */
      void
! ex_cclose(eap)
!     exarg_T	*eap;
  {
      win_T	*win = NULL;
      qf_info_T	*qi = &ql_info;
--- 2284,2290 ----
   * ":lclose": close the window showing the location list
   */
      void
! ex_cclose(exarg_T *eap)
  {
      win_T	*win = NULL;
      qf_info_T	*qi = &ql_info;
***************
*** 2336,2343 ****
   * ":lopen": open a window that shows the location list.
   */
      void
! ex_copen(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      int		height;
--- 2307,2313 ----
   * ":lopen": open a window that shows the location list.
   */
      void
! ex_copen(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      int		height;
***************
*** 2470,2477 ****
   * window).
   */
       linenr_T
! qf_current_entry(wp)
!     win_T	*wp;
  {
      qf_info_T	*qi = &ql_info;
  
--- 2440,2446 ----
   * window).
   */
       linenr_T
! qf_current_entry(win_T *wp)
  {
      qf_info_T	*qi = &ql_info;
  
***************
*** 2487,2495 ****
   * Return TRUE if there is a quickfix window.
   */
      static int
! qf_win_pos_update(qi, old_qf_index)
!     qf_info_T	*qi;
!     int		old_qf_index;	/* previous qf_index or zero */
  {
      win_T	*win;
      int		qf_index = qi->qf_lists[qi->qf_curlist].qf_index;
--- 2456,2464 ----
   * Return TRUE if there is a quickfix window.
   */
      static int
! qf_win_pos_update(
!     qf_info_T	*qi,
!     int		old_qf_index)	/* previous qf_index or zero */
  {
      win_T	*win;
      int		qf_index = qi->qf_lists[qi->qf_curlist].qf_index;
***************
*** 2533,2541 ****
   * list buffer
   */
      static int
! is_qf_win(win, qi)
!     win_T	*win;
!     qf_info_T	*qi;
  {
      /*
       * A window displaying the quickfix buffer will have the w_llist_ref field
--- 2502,2508 ----
   * list buffer
   */
      static int
! is_qf_win(win_T *win, qf_info_T *qi)
  {
      /*
       * A window displaying the quickfix buffer will have the w_llist_ref field
***************
*** 2556,2563 ****
   * Searches in only the windows opened in the current tab.
   */
      static win_T *
! qf_find_win(qi)
!     qf_info_T	*qi;
  {
      win_T	*win;
  
--- 2523,2529 ----
   * Searches in only the windows opened in the current tab.
   */
      static win_T *
! qf_find_win(qf_info_T *qi)
  {
      win_T	*win;
  
***************
*** 2573,2580 ****
   * Searches in windows opened in all the tabs.
   */
      static buf_T *
! qf_find_buf(qi)
!     qf_info_T	*qi;
  {
      tabpage_T	*tp;
      win_T	*win;
--- 2539,2545 ----
   * Searches in windows opened in all the tabs.
   */
      static buf_T *
! qf_find_buf(qf_info_T *qi)
  {
      tabpage_T	*tp;
      win_T	*win;
***************
*** 2590,2597 ****
   * Find the quickfix buffer.  If it exists, update the contents.
   */
      static void
! qf_update_buffer(qi)
!     qf_info_T	*qi;
  {
      buf_T	*buf;
      win_T	*win;
--- 2555,2561 ----
   * Find the quickfix buffer.  If it exists, update the contents.
   */
      static void
! qf_update_buffer(qf_info_T *qi)
  {
      buf_T	*buf;
      win_T	*win;
***************
*** 2626,2633 ****
   * Set "w:quickfix_title" if "qi" has a title.
   */
      static void
! qf_set_title_var(qi)
!     qf_info_T	*qi;
  {
      if (qi->qf_lists[qi->qf_curlist].qf_title != NULL)
  	set_internal_string_var((char_u *)"w:quickfix_title",
--- 2590,2596 ----
   * Set "w:quickfix_title" if "qi" has a title.
   */
      static void
! qf_set_title_var(qf_info_T *qi)
  {
      if (qi->qf_lists[qi->qf_curlist].qf_title != NULL)
  	set_internal_string_var((char_u *)"w:quickfix_title",
***************
*** 2639,2646 ****
   * curbuf must be the quickfix buffer!
   */
      static void
! qf_fill_buffer(qi)
!     qf_info_T	*qi;
  {
      linenr_T	lnum;
      qfline_T	*qfp;
--- 2602,2608 ----
   * curbuf must be the quickfix buffer!
   */
      static void
! qf_fill_buffer(qf_info_T *qi)
  {
      linenr_T	lnum;
      qfline_T	*qfp;
***************
*** 2742,2749 ****
   * Return TRUE if "buf" is the quickfix buffer.
   */
      int
! bt_quickfix(buf)
!     buf_T	*buf;
  {
      return buf != NULL && buf->b_p_bt[0] == 'q';
  }
--- 2704,2710 ----
   * Return TRUE if "buf" is the quickfix buffer.
   */
      int
! bt_quickfix(buf_T *buf)
  {
      return buf != NULL && buf->b_p_bt[0] == 'q';
  }
***************
*** 2753,2760 ****
   * This means the buffer name is not a file name.
   */
      int
! bt_nofile(buf)
!     buf_T	*buf;
  {
      return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')
  	    || buf->b_p_bt[0] == 'a');
--- 2714,2720 ----
   * This means the buffer name is not a file name.
   */
      int
! bt_nofile(buf_T *buf)
  {
      return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')
  	    || buf->b_p_bt[0] == 'a');
***************
*** 2764,2778 ****
   * Return TRUE if "buf" is a "nowrite" or "nofile" buffer.
   */
      int
! bt_dontwrite(buf)
!     buf_T	*buf;
  {
      return buf != NULL && buf->b_p_bt[0] == 'n';
  }
  
      int
! bt_dontwrite_msg(buf)
!     buf_T	*buf;
  {
      if (bt_dontwrite(buf))
      {
--- 2724,2736 ----
   * Return TRUE if "buf" is a "nowrite" or "nofile" buffer.
   */
      int
! bt_dontwrite(buf_T *buf)
  {
      return buf != NULL && buf->b_p_bt[0] == 'n';
  }
  
      int
! bt_dontwrite_msg(buf_T *buf)
  {
      if (bt_dontwrite(buf))
      {
***************
*** 2787,2794 ****
   * and 'bufhidden'.
   */
      int
! buf_hide(buf)
!     buf_T	*buf;
  {
      /* 'bufhidden' overrules 'hidden' and ":hide", check it first */
      switch (buf->b_p_bh[0])
--- 2745,2751 ----
   * and 'bufhidden'.
   */
      int
! buf_hide(buf_T *buf)
  {
      /* 'bufhidden' overrules 'hidden' and ":hide", check it first */
      switch (buf->b_p_bh[0])
***************
*** 2805,2812 ****
   * Return TRUE when using ":vimgrep" for ":grep".
   */
      int
! grep_internal(cmdidx)
!     cmdidx_T	cmdidx;
  {
      return ((cmdidx == CMD_grep
  		|| cmdidx == CMD_lgrep
--- 2762,2768 ----
   * Return TRUE when using ":vimgrep" for ":grep".
   */
      int
! grep_internal(cmdidx_T cmdidx)
  {
      return ((cmdidx == CMD_grep
  		|| cmdidx == CMD_lgrep
***************
*** 2820,2827 ****
   * Used for ":make", ":lmake", ":grep", ":lgrep", ":grepadd", and ":lgrepadd"
   */
      void
! ex_make(eap)
!     exarg_T	*eap;
  {
      char_u	*fname;
      char_u	*cmd;
--- 2776,2782 ----
   * Used for ":make", ":lmake", ":grep", ":lgrep", ":grepadd", and ":lgrepadd"
   */
      void
! ex_make(exarg_T *eap)
  {
      char_u	*fname;
      char_u	*cmd;
***************
*** 2934,2940 ****
   * Returns NULL for error.
   */
      static char_u *
! get_mef_name()
  {
      char_u	*p;
      char_u	*name;
--- 2889,2895 ----
   * Returns NULL for error.
   */
      static char_u *
! get_mef_name(void)
  {
      char_u	*p;
      char_u	*name;
***************
*** 2989,2996 ****
   * Returns the number of valid entries in the current quickfix/location list.
   */
      int
! qf_get_size(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      qfline_T	*qfp;
--- 2944,2950 ----
   * Returns the number of valid entries in the current quickfix/location list.
   */
      int
! qf_get_size(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      qfline_T	*qfp;
***************
*** 3030,3037 ****
   * Returns 0 if there is an error.
   */
      int
! qf_get_cur_idx(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
  
--- 2984,2990 ----
   * Returns 0 if there is an error.
   */
      int
! qf_get_cur_idx(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
  
***************
*** 3051,3058 ****
   * entries). If no valid entries are in the list, then returns 1.
   */
      int
! qf_get_cur_valid_idx(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      qf_list_T	*qfl;
--- 3004,3010 ----
   * entries). If no valid entries are in the list, then returns 1.
   */
      int
! qf_get_cur_valid_idx(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      qf_list_T	*qfl;
***************
*** 3103,3112 ****
   * For :cfdo and :lfdo returns the 'n'th valid file entry.
   */
      static int
! qf_get_nth_valid_entry(qi, n, fdo)
!     qf_info_T	*qi;
!     int		n;
!     int		fdo;
  {
      qf_list_T	*qfl = &qi->qf_lists[qi->qf_curlist];
      qfline_T	*qfp = qfl->qf_start;
--- 3055,3061 ----
   * For :cfdo and :lfdo returns the 'n'th valid file entry.
   */
      static int
! qf_get_nth_valid_entry(qf_info_T *qi, int n, int fdo)
  {
      qf_list_T	*qfl = &qi->qf_lists[qi->qf_curlist];
      qfline_T	*qfp = qfl->qf_start;
***************
*** 3151,3158 ****
   * ":cdo", ":ldo", ":cfdo" and ":lfdo"
   */
      void
! ex_cc(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      int		errornr;
--- 3100,3106 ----
   * ":cdo", ":ldo", ":cfdo" and ":lfdo"
   */
      void
! ex_cc(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      int		errornr;
***************
*** 3203,3210 ****
   * Also, used by ":cdo", ":ldo", ":cfdo" and ":lfdo" commands.
   */
      void
! ex_cnext(eap)
!     exarg_T	*eap;
  {
      qf_info_T	*qi = &ql_info;
      int		errornr;
--- 3151,3157 ----
   * Also, used by ":cdo", ":ldo", ":cfdo" and ":lfdo" commands.
   */
      void
! ex_cnext(exarg_T *eap)
  {
      qf_info_T	*qi = &ql_info;
      int		errornr;
***************
*** 3251,3258 ****
   * ":lfile"/":lgetfile"/":laddfile" commands.
   */
      void
! ex_cfile(eap)
!     exarg_T	*eap;
  {
      win_T	*wp = NULL;
      qf_info_T	*qi = &ql_info;
--- 3198,3204 ----
   * ":lfile"/":lgetfile"/":laddfile" commands.
   */
      void
! ex_cfile(exarg_T *eap)
  {
      win_T	*wp = NULL;
      qf_info_T	*qi = &ql_info;
***************
*** 3334,3341 ****
   * ":lvimgrepadd {pattern} file(s)"
   */
      void
! ex_vimgrep(eap)
!     exarg_T	*eap;
  {
      regmmatch_T	regmatch;
      int		fcount;
--- 3280,3286 ----
   * ":lvimgrepadd {pattern} file(s)"
   */
      void
! ex_vimgrep(exarg_T *eap)
  {
      regmmatch_T	regmatch;
      int		fcount;
***************
*** 3738,3747 ****
   * Return a pointer to the char just past the pattern plus flags.
   */
      char_u *
! skip_vimgrep_pat(p, s, flags)
!     char_u  *p;
!     char_u  **s;
!     int	    *flags;
  {
      int		c;
  
--- 3683,3689 ----
   * Return a pointer to the char just past the pattern plus flags.
   */
      char_u *
! skip_vimgrep_pat(char_u *p, char_u **s, int *flags)
  {
      int		c;
  
***************
*** 3790,3797 ****
   * into account whether it is set locally or globally.
   */
      static void
! restore_start_dir(dirname_start)
!     char_u	*dirname_start;
  {
      char_u *dirname_now = alloc(MAXPATHL);
  
--- 3732,3738 ----
   * into account whether it is set locally or globally.
   */
      static void
! restore_start_dir(char_u *dirname_start)
  {
      char_u *dirname_now = alloc(MAXPATHL);
  
***************
*** 3825,3834 ****
   * Returns NULL if it fails.
   */
      static buf_T *
! load_dummy_buffer(fname, dirname_start, resulting_dir)
!     char_u	*fname;
!     char_u	*dirname_start;  /* in: old directory */
!     char_u	*resulting_dir;  /* out: new directory */
  {
      buf_T	*newbuf;
      buf_T	*newbuf_to_wipe = NULL;
--- 3766,3775 ----
   * Returns NULL if it fails.
   */
      static buf_T *
! load_dummy_buffer(
!     char_u	*fname,
!     char_u	*dirname_start,  /* in: old directory */
!     char_u	*resulting_dir)  /* out: new directory */
  {
      buf_T	*newbuf;
      buf_T	*newbuf_to_wipe = NULL;
***************
*** 3907,3915 ****
   * 'autochdir' option have changed it.
   */
      static void
! wipe_dummy_buffer(buf, dirname_start)
!     buf_T	*buf;
!     char_u	*dirname_start;
  {
      if (curbuf != buf)		/* safety check */
      {
--- 3848,3854 ----
   * 'autochdir' option have changed it.
   */
      static void
! wipe_dummy_buffer(buf_T *buf, char_u *dirname_start)
  {
      if (curbuf != buf)		/* safety check */
      {
***************
*** 3940,3948 ****
   * 'autochdir' option have changed it.
   */
      static void
! unload_dummy_buffer(buf, dirname_start)
!     buf_T	*buf;
!     char_u	*dirname_start;
  {
      if (curbuf != buf)		/* safety check */
      {
--- 3879,3885 ----
   * 'autochdir' option have changed it.
   */
      static void
! unload_dummy_buffer(buf_T *buf, char_u *dirname_start)
  {
      if (curbuf != buf)		/* safety check */
      {
***************
*** 3958,3966 ****
   * Add each quickfix error to list "list" as a dictionary.
   */
      int
! get_errorlist(wp, list)
!     win_T	*wp;
!     list_T	*list;
  {
      qf_info_T	*qi = &ql_info;
      dict_T	*dict;
--- 3895,3901 ----
   * Add each quickfix error to list "list" as a dictionary.
   */
      int
! get_errorlist(win_T *wp, list_T *list)
  {
      qf_info_T	*qi = &ql_info;
      dict_T	*dict;
***************
*** 4018,4028 ****
   * of dictionaries. "title" will be copied to w:quickfix_title
   */
      int
! set_errorlist(wp, list, action, title)
!     win_T	*wp;
!     list_T	*list;
!     int		action;
!     char_u	*title;
  {
      listitem_T	*li;
      dict_T	*d;
--- 3953,3963 ----
   * of dictionaries. "title" will be copied to w:quickfix_title
   */
      int
! set_errorlist(
!     win_T	*wp,
!     list_T	*list,
!     int		action,
!     char_u	*title)
  {
      listitem_T	*li;
      dict_T	*d;
***************
*** 4146,4153 ****
   * ":[range]lgetbuffer [bufnr]" command.
   */
      void
! ex_cbuffer(eap)
!     exarg_T   *eap;
  {
      buf_T	*buf = NULL;
      qf_info_T	*qi = &ql_info;
--- 4081,4087 ----
   * ":[range]lgetbuffer [bufnr]" command.
   */
      void
! ex_cbuffer(exarg_T *eap)
  {
      buf_T	*buf = NULL;
      qf_info_T	*qi = &ql_info;
***************
*** 4207,4214 ****
   * ":lexpr {expr}", ":lgetexpr {expr}", ":laddexpr {expr}" command.
   */
      void
! ex_cexpr(eap)
!     exarg_T	*eap;
  {
      typval_T	*tv;
      qf_info_T	*qi = &ql_info;
--- 4141,4147 ----
   * ":lexpr {expr}", ":lgetexpr {expr}", ":laddexpr {expr}" command.
   */
      void
! ex_cexpr(exarg_T *eap)
  {
      typval_T	*tv;
      qf_info_T	*qi = &ql_info;
***************
*** 4248,4255 ****
   * ":helpgrep {pattern}"
   */
      void
! ex_helpgrep(eap)
!     exarg_T	*eap;
  {
      regmatch_T	regmatch;
      char_u	*save_cpo;
--- 4181,4187 ----
   * ":helpgrep {pattern}"
   */
      void
! ex_helpgrep(exarg_T *eap)
  {
      regmatch_T	regmatch;
      char_u	*save_cpo;
*** ../vim-7.4.1212/src/regexp.c	2016-01-29 23:20:35.309308162 +0100
--- src/regexp.c	2016-01-30 20:20:29.652383115 +0100
***************
*** 259,266 ****
  static int toggle_Magic(int x);
  
      static int
! no_Magic(x)
!     int		x;
  {
      if (is_Magic(x))
  	return un_Magic(x);
--- 259,265 ----
  static int toggle_Magic(int x);
  
      static int
! no_Magic(int x)
  {
      if (is_Magic(x))
  	return un_Magic(x);
***************
*** 268,275 ****
  }
  
      static int
! toggle_Magic(x)
!     int		x;
  {
      if (is_Magic(x))
  	return un_Magic(x);
--- 267,273 ----
  }
  
      static int
! toggle_Magic(int x)
  {
      if (is_Magic(x))
  	return un_Magic(x);
***************
*** 379,386 ****
   * Return MULTI_MULT if c is a multi "multi" operator.
   */
      static int
! re_multi_type(c)
!     int c;
  {
      if (c == Magic('@') || c == Magic('=') || c == Magic('?'))
  	return MULTI_ONE;
--- 377,383 ----
   * Return MULTI_MULT if c is a multi "multi" operator.
   */
      static int
! re_multi_type(int c)
  {
      if (c == Magic('@') || c == Magic('=') || c == Magic('?'))
  	return MULTI_ONE;
***************
*** 438,445 ****
   * Translate '\x' to its control character, except "\n", which is Magic.
   */
      static int
! backslash_trans(c)
!     int		c;
  {
      switch (c)
      {
--- 435,441 ----
   * Translate '\x' to its control character, except "\n", which is Magic.
   */
      static int
! backslash_trans(int c)
  {
      switch (c)
      {
***************
*** 457,464 ****
   * recognized.  Otherwise "pp" is advanced to after the item.
   */
      static int
! get_char_class(pp)
!     char_u	**pp;
  {
      static const char *(class_names[]) =
      {
--- 453,459 ----
   * recognized.  Otherwise "pp" is advanced to after the item.
   */
      static int
! get_char_class(char_u **pp)
  {
      static const char *(class_names[]) =
      {
***************
*** 527,533 ****
  #define	    RI_WHITE	0x100
  
      static void
! init_class_tab()
  {
      int		i;
      static int	done = FALSE;
--- 522,528 ----
  #define	    RI_WHITE	0x100
  
      static void
! init_class_tab(void)
  {
      int		i;
      static int	done = FALSE;
***************
*** 738,745 ****
   * Return TRUE if compiled regular expression "prog" can match a line break.
   */
      int
! re_multiline(prog)
!     regprog_T *prog;
  {
      return (prog->regflags & RF_HASNL);
  }
--- 733,739 ----
   * Return TRUE if compiled regular expression "prog" can match a line break.
   */
      int
! re_multiline(regprog_T *prog)
  {
      return (prog->regflags & RF_HASNL);
  }
***************
*** 749,756 ****
   * position (pattern contains "\@<=" or "\@<!").
   */
      int
! re_lookbehind(prog)
!     regprog_T *prog;
  {
      return (prog->regflags & RF_LOOKBH);
  }
--- 743,749 ----
   * position (pattern contains "\@<=" or "\@<!").
   */
      int
! re_lookbehind(regprog_T *prog)
  {
      return (prog->regflags & RF_LOOKBH);
  }
***************
*** 761,768 ****
   * recognized.  Otherwise "pp" is advanced to after the item.
   */
      static int
! get_equi_class(pp)
!     char_u	**pp;
  {
      int		c;
      int		l = 1;
--- 754,760 ----
   * recognized.  Otherwise "pp" is advanced to after the item.
   */
      static int
! get_equi_class(char_u **pp)
  {
      int		c;
      int		l = 1;
***************
*** 819,826 ****
   * NOTE: When changing this function, also change nfa_emit_equi_class()
   */
      static void
! reg_equi_class(c)
!     int	    c;
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 || STRCMP(p_enc, "latin1") == 0
--- 811,817 ----
   * NOTE: When changing this function, also change nfa_emit_equi_class()
   */
      static void
! reg_equi_class(int c)
  {
  #ifdef FEAT_MBYTE
      if (enc_utf8 || STRCMP(p_enc, "latin1") == 0
***************
*** 1150,1157 ****
   * Currently only single characters are recognized!
   */
      static int
! get_coll_element(pp)
!     char_u	**pp;
  {
      int		c;
      int		l = 1;
--- 1141,1147 ----
   * Currently only single characters are recognized!
   */
      static int
! get_coll_element(char_u **pp)
  {
      int		c;
      int		l = 1;
***************
*** 1183,1189 ****
  static int reg_cpo_bsl; /* 'cpoptions' contains '\' flag */
  
      static void
! get_cpo_flags()
  {
      reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;
      reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;
--- 1173,1179 ----
  static int reg_cpo_bsl; /* 'cpoptions' contains '\' flag */
  
      static void
! get_cpo_flags(void)
  {
      reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;
      reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;
***************
*** 1195,1202 ****
   * The returned pointer is on the matching ']', or the terminating NUL.
   */
      static char_u *
! skip_anyof(p)
!     char_u	*p;
  {
  #ifdef FEAT_MBYTE
      int		l;
--- 1185,1191 ----
   * The returned pointer is on the matching ']', or the terminating NUL.
   */
      static char_u *
! skip_anyof(char_u *p)
  {
  #ifdef FEAT_MBYTE
      int		l;
***************
*** 1249,1259 ****
   * is changed in-place.
   */
      char_u *
! skip_regexp(startp, dirc, magic, newp)
!     char_u	*startp;
!     int		dirc;
!     int		magic;
!     char_u	**newp;
  {
      int		mymagic;
      char_u	*p = startp;
--- 1238,1248 ----
   * is changed in-place.
   */
      char_u *
! skip_regexp(
!     char_u	*startp,
!     int		dirc,
!     int		magic,
!     char_u	**newp)
  {
      int		mymagic;
      char_u	*p = startp;
***************
*** 1327,1335 ****
   * "re_flags": RE_MAGIC and/or RE_STRING.
   */
      static regprog_T *
! bt_regcomp(expr, re_flags)
!     char_u	*expr;
!     int		re_flags;
  {
      bt_regprog_T    *r;
      char_u	*scan;
--- 1316,1322 ----
   * "re_flags": RE_MAGIC and/or RE_STRING.
   */
      static regprog_T *
! bt_regcomp(char_u *expr, int re_flags)
  {
      bt_regprog_T    *r;
      char_u	*scan;
***************
*** 1464,1471 ****
   * Free a compiled regexp program, returned by bt_regcomp().
   */
      static void
! bt_regfree(prog)
!     regprog_T   *prog;
  {
      vim_free(prog);
  }
--- 1451,1457 ----
   * Free a compiled regexp program, returned by bt_regcomp().
   */
      static void
! bt_regfree(regprog_T *prog)
  {
      vim_free(prog);
  }
***************
*** 1474,1482 ****
   * Setup to parse the regexp.  Used once to get the length and once to do it.
   */
      static void
! regcomp_start(expr, re_flags)
!     char_u	*expr;
!     int		re_flags;	    /* see vim_regcomp() */
  {
      initchr(expr);
      if (re_flags & RE_MAGIC)
--- 1460,1468 ----
   * Setup to parse the regexp.  Used once to get the length and once to do it.
   */
      static void
! regcomp_start(
!     char_u	*expr,
!     int		re_flags)	    /* see vim_regcomp() */
  {
      initchr(expr);
      if (re_flags & RE_MAGIC)
***************
*** 1508,1514 ****
   * found.  This is messy, but it works fine.
   */
      int
! vim_regcomp_had_eol()
  {
      return had_eol;
  }
--- 1494,1500 ----
   * found.  This is messy, but it works fine.
   */
      int
! vim_regcomp_had_eol(void)
  {
      return had_eol;
  }
***************
*** 1524,1532 ****
   * follows makes it hard to avoid.
   */
      static char_u *
! reg(paren, flagp)
!     int		paren;	/* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */
!     int		*flagp;
  {
      char_u	*ret;
      char_u	*br;
--- 1510,1518 ----
   * follows makes it hard to avoid.
   */
      static char_u *
! reg(
!     int		paren,	/* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */
!     int		*flagp)
  {
      char_u	*ret;
      char_u	*br;
***************
*** 1639,1646 ****
   * Implements the & operator.
   */
      static char_u *
! regbranch(flagp)
!     int		*flagp;
  {
      char_u	*ret;
      char_u	*chain = NULL;
--- 1625,1631 ----
   * Implements the & operator.
   */
      static char_u *
! regbranch(int *flagp)
  {
      char_u	*ret;
      char_u	*chain = NULL;
***************
*** 1682,1689 ****
   * Implements the concatenation operator.
   */
      static char_u *
! regconcat(flagp)
!     int		*flagp;
  {
      char_u	*first = NULL;
      char_u	*chain = NULL;
--- 1667,1673 ----
   * Implements the concatenation operator.
   */
      static char_u *
! regconcat(int *flagp)
  {
      char_u	*first = NULL;
      char_u	*chain = NULL;
***************
*** 1767,1774 ****
   * endmarker role is not redundant.
   */
      static char_u *
! regpiece(flagp)
!     int		    *flagp;
  {
      char_u	    *ret;
      int		    op;
--- 1751,1757 ----
   * endmarker role is not redundant.
   */
      static char_u *
! regpiece(int *flagp)
  {
      char_u	    *ret;
      int		    op;
***************
*** 1928,1935 ****
   * faster to run.  Don't do this when one_exactly is set.
   */
      static char_u *
! regatom(flagp)
!     int		   *flagp;
  {
      char_u	    *ret;
      int		    flags;
--- 1911,1917 ----
   * faster to run.  Don't do this when one_exactly is set.
   */
      static char_u *
! regatom(int *flagp)
  {
      char_u	    *ret;
      int		    flags;
***************
*** 2743,2750 ****
   * character "c".
   */
      static int
! use_multibytecode(c)
!     int c;
  {
      return has_mbyte && (*mb_char2len)(c) > 1
  		     && (re_multi_type(peekchr()) != NOT_MULTI
--- 2725,2731 ----
   * character "c".
   */
      static int
! use_multibytecode(int c)
  {
      return has_mbyte && (*mb_char2len)(c) > 1
  		     && (re_multi_type(peekchr()) != NOT_MULTI
***************
*** 2757,2764 ****
   * Return pointer to generated code.
   */
      static char_u *
! regnode(op)
!     int		op;
  {
      char_u  *ret;
  
--- 2738,2744 ----
   * Return pointer to generated code.
   */
      static char_u *
! regnode(int op)
  {
      char_u  *ret;
  
***************
*** 2778,2785 ****
   * Emit (if appropriate) a byte of code
   */
      static void
! regc(b)
!     int		b;
  {
      if (regcode == JUST_CALC_SIZE)
  	regsize++;
--- 2758,2764 ----
   * Emit (if appropriate) a byte of code
   */
      static void
! regc(int b)
  {
      if (regcode == JUST_CALC_SIZE)
  	regsize++;
***************
*** 2792,2799 ****
   * Emit (if appropriate) a multi-byte character of code
   */
      static void
! regmbc(c)
!     int		c;
  {
      if (!has_mbyte && c > 0xff)
  	return;
--- 2771,2777 ----
   * Emit (if appropriate) a multi-byte character of code
   */
      static void
! regmbc(int c)
  {
      if (!has_mbyte && c > 0xff)
  	return;
***************
*** 2810,2818 ****
   * Means relocating the operand.
   */
      static void
! reginsert(op, opnd)
!     int		op;
!     char_u     *opnd;
  {
      char_u	*src;
      char_u	*dst;
--- 2788,2794 ----
   * Means relocating the operand.
   */
      static void
! reginsert(int op, char_u *opnd)
  {
      char_u	*src;
      char_u	*dst;
***************
*** 2840,2849 ****
   * Add a number to the operator.
   */
      static void
! reginsert_nr(op, val, opnd)
!     int		op;
!     long	val;
!     char_u	*opnd;
  {
      char_u	*src;
      char_u	*dst;
--- 2816,2822 ----
   * Add a number to the operator.
   */
      static void
! reginsert_nr(int op, long val, char_u *opnd)
  {
      char_u	*src;
      char_u	*dst;
***************
*** 2874,2884 ****
   * Means relocating the operand.
   */
      static void
! reginsert_limits(op, minval, maxval, opnd)
!     int		op;
!     long	minval;
!     long	maxval;
!     char_u	*opnd;
  {
      char_u	*src;
      char_u	*dst;
--- 2847,2857 ----
   * Means relocating the operand.
   */
      static void
! reginsert_limits(
!     int		op,
!     long	minval,
!     long	maxval,
!     char_u	*opnd)
  {
      char_u	*src;
      char_u	*dst;
***************
*** 2908,2916 ****
   * Write a long as four bytes at "p" and return pointer to the next char.
   */
      static char_u *
! re_put_long(p, val)
!     char_u	*p;
!     long_u	val;
  {
      *p++ = (char_u) ((val >> 24) & 0377);
      *p++ = (char_u) ((val >> 16) & 0377);
--- 2881,2887 ----
   * Write a long as four bytes at "p" and return pointer to the next char.
   */
      static char_u *
! re_put_long(char_u *p, long_u val)
  {
      *p++ = (char_u) ((val >> 24) & 0377);
      *p++ = (char_u) ((val >> 16) & 0377);
***************
*** 2923,2931 ****
   * Set the next-pointer at the end of a node chain.
   */
      static void
! regtail(p, val)
!     char_u	*p;
!     char_u	*val;
  {
      char_u	*scan;
      char_u	*temp;
--- 2894,2900 ----
   * Set the next-pointer at the end of a node chain.
   */
      static void
! regtail(char_u *p, char_u *val)
  {
      char_u	*scan;
      char_u	*temp;
***************
*** 2964,2972 ****
   * Like regtail, on item after a BRANCH; nop if none.
   */
      static void
! regoptail(p, val)
!     char_u	*p;
!     char_u	*val;
  {
      /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless" */
      if (p == NULL || p == JUST_CALC_SIZE
--- 2933,2939 ----
   * Like regtail, on item after a BRANCH; nop if none.
   */
      static void
! regoptail(char_u *p, char_u *val)
  {
      /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless" */
      if (p == NULL || p == JUST_CALC_SIZE
***************
*** 2987,2994 ****
   * Start parsing at "str".
   */
      static void
! initchr(str)
!     char_u *str;
  {
      regparse = str;
      prevchr_len = 0;
--- 2954,2960 ----
   * Start parsing at "str".
   */
      static void
! initchr(char_u *str)
  {
      regparse = str;
      prevchr_len = 0;
***************
*** 3002,3009 ****
   * starts in the same state again.
   */
      static void
! save_parse_state(ps)
!     parse_state_T *ps;
  {
      ps->regparse = regparse;
      ps->prevchr_len = prevchr_len;
--- 2968,2974 ----
   * starts in the same state again.
   */
      static void
! save_parse_state(parse_state_T *ps)
  {
      ps->regparse = regparse;
      ps->prevchr_len = prevchr_len;
***************
*** 3020,3027 ****
   * Restore a previously saved parse state.
   */
      static void
! restore_parse_state(ps)
!     parse_state_T *ps;
  {
      regparse = ps->regparse;
      prevchr_len = ps->prevchr_len;
--- 2985,2991 ----
   * Restore a previously saved parse state.
   */
      static void
! restore_parse_state(parse_state_T *ps)
  {
      regparse = ps->regparse;
      prevchr_len = ps->prevchr_len;
***************
*** 3039,3045 ****
   * Get the next character without advancing.
   */
      static int
! peekchr()
  {
      static int	after_slash = FALSE;
  
--- 3003,3009 ----
   * Get the next character without advancing.
   */
      static int
! peekchr(void)
  {
      static int	after_slash = FALSE;
  
***************
*** 3211,3217 ****
   * Eat one lexed character.  Do this in a way that we can undo it.
   */
      static void
! skipchr()
  {
      /* peekchr() eats a backslash, do the same here */
      if (*regparse == '\\')
--- 3175,3181 ----
   * Eat one lexed character.  Do this in a way that we can undo it.
   */
      static void
! skipchr(void)
  {
      /* peekchr() eats a backslash, do the same here */
      if (*regparse == '\\')
***************
*** 3244,3250 ****
   * prevchr and prevprevchr are also kept.
   */
      static void
! skipchr_keepstart()
  {
      int as = prev_at_start;
      int pr = prevchr;
--- 3208,3214 ----
   * prevchr and prevprevchr are also kept.
   */
      static void
! skipchr_keepstart(void)
  {
      int as = prev_at_start;
      int pr = prevchr;
***************
*** 3261,3267 ****
   * therefore we need a lexical analyzer.
   */
      static int
! getchr()
  {
      int chr = peekchr();
  
--- 3225,3231 ----
   * therefore we need a lexical analyzer.
   */
      static int
! getchr(void)
  {
      int chr = peekchr();
  
***************
*** 3273,3279 ****
   * put character back.  Works only once!
   */
      static void
! ungetchr()
  {
      nextchr = curchr;
      curchr = prevchr;
--- 3237,3243 ----
   * put character back.  Works only once!
   */
      static void
! ungetchr(void)
  {
      nextchr = curchr;
      curchr = prevchr;
***************
*** 3296,3303 ****
   * 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.
   */
      static int
! gethexchrs(maxinputlen)
!     int		maxinputlen;
  {
      int		nr = 0;
      int		c;
--- 3260,3266 ----
   * 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.
   */
      static int
! gethexchrs(int maxinputlen)
  {
      int		nr = 0;
      int		c;
***************
*** 3323,3329 ****
   * current position. Return -1 for invalid.  Consumes all digits.
   */
      static int
! getdecchrs()
  {
      int		nr = 0;
      int		c;
--- 3286,3292 ----
   * current position. Return -1 for invalid.  Consumes all digits.
   */
      static int
! getdecchrs(void)
  {
      int		nr = 0;
      int		c;
***************
*** 3354,3360 ****
   *	   before-^  ^-after
   */
      static int
! getoctchrs()
  {
      int		nr = 0;
      int		c;
--- 3317,3323 ----
   *	   before-^  ^-after
   */
      static int
! getoctchrs(void)
  {
      int		nr = 0;
      int		c;
***************
*** 3380,3386 ****
   * When nothing is recognized return a backslash.
   */
      static int
! coll_get_char()
  {
      int	    nr = -1;
  
--- 3343,3349 ----
   * When nothing is recognized return a backslash.
   */
      static int
! coll_get_char(void)
  {
      int	    nr = -1;
  
***************
*** 3409,3417 ****
   * missing, a very big number is the default.
   */
      static int
! read_limits(minval, maxval)
!     long	*minval;
!     long	*maxval;
  {
      int		reverse = FALSE;
      char_u	*first_char;
--- 3372,3378 ----
   * missing, a very big number is the default.
   */
      static int
! read_limits(long *minval, long *maxval)
  {
      int		reverse = FALSE;
      char_u	*first_char;
***************
*** 3694,3700 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_regexp_stuff()
  {
      ga_clear(&regstack);
      ga_clear(&backpos);
--- 3655,3661 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_regexp_stuff(void)
  {
      ga_clear(&regstack);
      ga_clear(&backpos);
***************
*** 3707,3714 ****
   * Get pointer to the line "lnum", which is relative to "reg_firstlnum".
   */
      static char_u *
! reg_getline(lnum)
!     linenr_T	lnum;
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
--- 3668,3674 ----
   * Get pointer to the line "lnum", which is relative to "reg_firstlnum".
   */
      static char_u *
! reg_getline(linenr_T lnum)
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
***************
*** 3744,3754 ****
   * Returns 0 for failure, number of lines contained in the match otherwise.
   */
      static int
! bt_regexec_nl(rmp, line, col, line_lbr)
!     regmatch_T	*rmp;
!     char_u	*line;	/* string to match against */
!     colnr_T	col;	/* column to start looking for match */
!     int		line_lbr;
  {
      reg_match = rmp;
      reg_mmatch = NULL;
--- 3704,3714 ----
   * Returns 0 for failure, number of lines contained in the match otherwise.
   */
      static int
! bt_regexec_nl(
!     regmatch_T	*rmp,
!     char_u	*line,	/* string to match against */
!     colnr_T	col,	/* column to start looking for match */
!     int		line_lbr)
  {
      reg_match = rmp;
      reg_mmatch = NULL;
***************
*** 3776,3788 ****
   * match otherwise.
   */
      static long
! bt_regexec_multi(rmp, win, buf, lnum, col, tm)
!     regmmatch_T	*rmp;
!     win_T	*win;		/* window in which to search or NULL */
!     buf_T	*buf;		/* buffer in which to search */
!     linenr_T	lnum;		/* nr of line to start looking for match */
!     colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      reg_match = NULL;
      reg_mmatch = rmp;
--- 3736,3748 ----
   * match otherwise.
   */
      static long
! bt_regexec_multi(
!     regmmatch_T	*rmp,
!     win_T	*win,		/* window in which to search or NULL */
!     buf_T	*buf,		/* buffer in which to search */
!     linenr_T	lnum,		/* nr of line to start looking for match */
!     colnr_T	col,		/* column to start looking for match */
!     proftime_T	*tm)		/* timeout limit or NULL */
  {
      reg_match = NULL;
      reg_mmatch = rmp;
***************
*** 3806,3815 ****
   * Returns 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! bt_regexec_both(line, col, tm)
!     char_u	*line;
!     colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm UNUSED;	/* timeout limit or NULL */
  {
      bt_regprog_T    *prog;
      char_u	    *s;
--- 3766,3775 ----
   * Returns 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! bt_regexec_both(
!     char_u	*line,
!     colnr_T	col,		/* column to start looking for match */
!     proftime_T	*tm UNUSED)	/* timeout limit or NULL */
  {
      bt_regprog_T    *prog;
      char_u	    *s;
***************
*** 4039,4045 ****
   * Create a new extmatch and mark it as referenced once.
   */
      static reg_extmatch_T *
! make_extmatch()
  {
      reg_extmatch_T	*em;
  
--- 3999,4005 ----
   * Create a new extmatch and mark it as referenced once.
   */
      static reg_extmatch_T *
! make_extmatch(void)
  {
      reg_extmatch_T	*em;
  
***************
*** 4053,4060 ****
   * Add a reference to an extmatch.
   */
      reg_extmatch_T *
! ref_extmatch(em)
!     reg_extmatch_T	*em;
  {
      if (em != NULL)
  	em->refcnt++;
--- 4013,4019 ----
   * Add a reference to an extmatch.
   */
      reg_extmatch_T *
! ref_extmatch(reg_extmatch_T *em)
  {
      if (em != NULL)
  	em->refcnt++;
***************
*** 4066,4073 ****
   * the info.
   */
      void
! unref_extmatch(em)
!     reg_extmatch_T	*em;
  {
      int i;
  
--- 4025,4031 ----
   * the info.
   */
      void
! unref_extmatch(reg_extmatch_T *em)
  {
      int i;
  
***************
*** 4085,4093 ****
   * Returns 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! regtry(prog, col)
!     bt_regprog_T    *prog;
!     colnr_T	col;
  {
      reginput = regline + col;
      need_clear_subexpr = TRUE;
--- 4043,4049 ----
   * Returns 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! regtry(bt_regprog_T *prog, colnr_T col)
  {
      reginput = regline + col;
      need_clear_subexpr = TRUE;
***************
*** 4168,4174 ****
   * Get class of previous character.
   */
      static int
! reg_prev_class()
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
--- 4124,4130 ----
   * Get class of previous character.
   */
      static int
! reg_prev_class(void)
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
***************
*** 4183,4189 ****
   * Return TRUE if the current reginput position matches the Visual area.
   */
      static int
! reg_match_visual()
  {
      pos_T	top, bot;
      linenr_T    lnum;
--- 4139,4145 ----
   * Return TRUE if the current reginput position matches the Visual area.
   */
      static int
! reg_match_visual(void)
  {
      pos_T	top, bot;
      linenr_T    lnum;
***************
*** 4280,4287 ****
   * undefined state!
   */
      static int
! regmatch(scan)
!     char_u	*scan;		/* Current node. */
  {
    char_u	*next;		/* Next node. */
    int		op;
--- 4236,4243 ----
   * undefined state!
   */
      static int
! regmatch(
!     char_u	*scan)		/* Current node. */
  {
    char_u	*next;		/* Next node. */
    int		op;
***************
*** 5768,5776 ****
   * Returns pointer to new item.  Returns NULL when out of memory.
   */
      static regitem_T *
! regstack_push(state, scan)
!     regstate_T	state;
!     char_u	*scan;
  {
      regitem_T	*rp;
  
--- 5724,5730 ----
   * Returns pointer to new item.  Returns NULL when out of memory.
   */
      static regitem_T *
! regstack_push(regstate_T state, char_u *scan)
  {
      regitem_T	*rp;
  
***************
*** 5794,5801 ****
   * Pop an item from the regstack.
   */
      static void
! regstack_pop(scan)
!     char_u	**scan;
  {
      regitem_T	*rp;
  
--- 5748,5754 ----
   * Pop an item from the regstack.
   */
      static void
! regstack_pop(char_u **scan)
  {
      regitem_T	*rp;
  
***************
*** 5810,5818 ****
   * Advances reginput (and reglnum) to just after the matched chars.
   */
      static int
! regrepeat(p, maxcount)
!     char_u	*p;
!     long	maxcount;   /* maximum number of matches allowed */
  {
      long	count = 0;
      char_u	*scan;
--- 5763,5771 ----
   * Advances reginput (and reglnum) to just after the matched chars.
   */
      static int
! regrepeat(
!     char_u	*p,
!     long	maxcount)   /* maximum number of matches allowed */
  {
      long	count = 0;
      char_u	*scan;
***************
*** 6207,6214 ****
   * there is an error.
   */
      static char_u *
! regnext(p)
!     char_u  *p;
  {
      int	    offset;
  
--- 6160,6166 ----
   * there is an error.
   */
      static char_u *
! regnext(char_u *p)
  {
      int	    offset;
  
***************
*** 6230,6236 ****
   * Return TRUE if it's wrong.
   */
      static int
! prog_magic_wrong()
  {
      regprog_T	*prog;
  
--- 6182,6188 ----
   * Return TRUE if it's wrong.
   */
      static int
! prog_magic_wrong(void)
  {
      regprog_T	*prog;
  
***************
*** 6253,6259 ****
   * used (to increase speed).
   */
      static void
! cleanup_subexpr()
  {
      if (need_clear_subexpr)
      {
--- 6205,6211 ----
   * used (to increase speed).
   */
      static void
! cleanup_subexpr(void)
  {
      if (need_clear_subexpr)
      {
***************
*** 6274,6280 ****
  
  #ifdef FEAT_SYN_HL
      static void
! cleanup_zsubexpr()
  {
      if (need_clear_zsubexpr)
      {
--- 6226,6232 ----
  
  #ifdef FEAT_SYN_HL
      static void
! cleanup_zsubexpr(void)
  {
      if (need_clear_zsubexpr)
      {
***************
*** 6299,6306 ****
   * later by restore_subexpr().
   */
      static void
! save_subexpr(bp)
!     regbehind_T *bp;
  {
      int i;
  
--- 6251,6257 ----
   * later by restore_subexpr().
   */
      static void
! save_subexpr(regbehind_T *bp)
  {
      int i;
  
***************
*** 6329,6336 ****
   * Restore the subexpr from "bp".
   */
      static void
! restore_subexpr(bp)
!     regbehind_T *bp;
  {
      int i;
  
--- 6280,6286 ----
   * Restore the subexpr from "bp".
   */
      static void
! restore_subexpr(regbehind_T *bp)
  {
      int i;
  
***************
*** 6358,6364 ****
   * Advance reglnum, regline and reginput to the next line.
   */
      static void
! reg_nextline()
  {
      regline = reg_getline(++reglnum);
      reginput = regline;
--- 6308,6314 ----
   * Advance reglnum, regline and reginput to the next line.
   */
      static void
! reg_nextline(void)
  {
      regline = reg_getline(++reglnum);
      reginput = regline;
***************
*** 6369,6377 ****
   * Save the input line and position in a regsave_T.
   */
      static void
! reg_save(save, gap)
!     regsave_T	*save;
!     garray_T	*gap;
  {
      if (REG_MULTI)
      {
--- 6319,6325 ----
   * Save the input line and position in a regsave_T.
   */
      static void
! reg_save(regsave_T *save, garray_T *gap)
  {
      if (REG_MULTI)
      {
***************
*** 6387,6395 ****
   * Restore the input line and position from a regsave_T.
   */
      static void
! reg_restore(save, gap)
!     regsave_T	*save;
!     garray_T	*gap;
  {
      if (REG_MULTI)
      {
--- 6335,6341 ----
   * Restore the input line and position from a regsave_T.
   */
      static void
! reg_restore(regsave_T *save, garray_T *gap)
  {
      if (REG_MULTI)
      {
***************
*** 6411,6418 ****
   * Return TRUE if current position is equal to saved position.
   */
      static int
! reg_save_equal(save)
!     regsave_T	*save;
  {
      if (REG_MULTI)
  	return reglnum == save->rs_u.pos.lnum
--- 6357,6363 ----
   * Return TRUE if current position is equal to saved position.
   */
      static int
! reg_save_equal(regsave_T *save)
  {
      if (REG_MULTI)
  	return reglnum == save->rs_u.pos.lnum
***************
*** 6428,6436 ****
   * depending on REG_MULTI.
   */
      static void
! save_se_multi(savep, posp)
!     save_se_T	*savep;
!     lpos_T	*posp;
  {
      savep->se_u.pos = *posp;
      posp->lnum = reglnum;
--- 6373,6379 ----
   * depending on REG_MULTI.
   */
      static void
! save_se_multi(save_se_T *savep, lpos_T *posp)
  {
      savep->se_u.pos = *posp;
      posp->lnum = reglnum;
***************
*** 6438,6446 ****
  }
  
      static void
! save_se_one(savep, pp)
!     save_se_T	*savep;
!     char_u	**pp;
  {
      savep->se_u.ptr = *pp;
      *pp = reginput;
--- 6381,6387 ----
  }
  
      static void
! save_se_one(save_se_T *savep, char_u **pp)
  {
      savep->se_u.ptr = *pp;
      *pp = reginput;
***************
*** 6450,6458 ****
   * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.
   */
      static int
! re_num_cmp(val, scan)
!     long_u	val;
!     char_u	*scan;
  {
      long_u  n = OPERAND_MIN(scan);
  
--- 6391,6397 ----
   * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.
   */
      static int
! re_num_cmp(long_u val, char_u *scan)
  {
      long_u  n = OPERAND_MIN(scan);
  
***************
*** 6470,6481 ****
   * last line.
   */
      static int
! match_with_backref(start_lnum, start_col, end_lnum, end_col, bytelen)
!     linenr_T start_lnum;
!     colnr_T  start_col;
!     linenr_T end_lnum;
!     colnr_T  end_col;
!     int	     *bytelen;
  {
      linenr_T	clnum = start_lnum;
      colnr_T	ccol = start_col;
--- 6409,6420 ----
   * last line.
   */
      static int
! match_with_backref(
!     linenr_T start_lnum,
!     colnr_T  start_col,
!     linenr_T end_lnum,
!     colnr_T  end_col,
!     int	     *bytelen)
  {
      linenr_T	clnum = start_lnum;
      colnr_T	ccol = start_col;
***************
*** 6542,6550 ****
   * regdump - dump a regexp onto stdout in vaguely comprehensible form
   */
      static void
! regdump(pattern, r)
!     char_u	*pattern;
!     bt_regprog_T	*r;
  {
      char_u  *s;
      int	    op = EXACTLY;	/* Arbitrary non-END op. */
--- 6481,6487 ----
   * regdump - dump a regexp onto stdout in vaguely comprehensible form
   */
      static void
! regdump(char_u *pattern, bt_regprog_T *r)
  {
      char_u  *s;
      int	    op = EXACTLY;	/* Arbitrary non-END op. */
***************
*** 6632,6639 ****
   * regprop - printable representation of opcode
   */
      static char_u *
! regprop(op)
!     char_u	   *op;
  {
      char	    *p;
      static char	    buf[50];
--- 6569,6575 ----
   * regprop - printable representation of opcode
   */
      static char_u *
! regprop(char_u *op)
  {
      char	    *p;
      static char	    buf[50];
***************
*** 7016,7023 ****
   * Used in a place where no * or \+ can follow.
   */
      static int
! re_mult_next(what)
!     char *what;
  {
      if (re_multi_type(peekchr()) == MULTI_MULT)
  	EMSG2_RET_FAIL(_("E888: (NFA regexp) cannot repeat %s"), what);
--- 6952,6958 ----
   * Used in a place where no * or \+ can follow.
   */
      static int
! re_mult_next(char *what)
  {
      if (re_multi_type(peekchr()) == MULTI_MULT)
  	EMSG2_RET_FAIL(_("E888: (NFA regexp) cannot repeat %s"), what);
***************
*** 7087,7094 ****
  };
  
      static void
! mb_decompose(c, c1, c2, c3)
!     int c, *c1, *c2, *c3;
  {
      decomp_T d;
  
--- 7022,7028 ----
  };
  
      static void
! mb_decompose(int c, int *c1, int *c2, int *c3)
  {
      decomp_T d;
  
***************
*** 7113,7121 ****
   * Correct the length "*n" when composing characters are ignored.
   */
      static int
! cstrncmp(s1, s2, n)
!     char_u	*s1, *s2;
!     int		*n;
  {
      int		result;
  
--- 7047,7053 ----
   * Correct the length "*n" when composing characters are ignored.
   */
      static int
! cstrncmp(char_u *s1, char_u *s2, int *n)
  {
      int		result;
  
***************
*** 7169,7177 ****
   * cstrchr: This function is used a lot for simple searches, keep it fast!
   */
      static char_u *
! cstrchr(s, c)
!     char_u	*s;
!     int		c;
  {
      char_u	*p;
      int		cc;
--- 7101,7107 ----
   * cstrchr: This function is used a lot for simple searches, keep it fast!
   */
      static char_u *
! cstrchr(char_u *s, int c)
  {
      char_u	*p;
      int		cc;
***************
*** 7242,7250 ****
  static int vim_regsub_both(char_u *source, char_u *dest, int copy, int magic, int backslash);
  
      static fptr_T
! do_upper(d, c)
!     int		*d;
!     int		c;
  {
      *d = MB_TOUPPER(c);
  
--- 7172,7178 ----
  static int vim_regsub_both(char_u *source, char_u *dest, int copy, int magic, int backslash);
  
      static fptr_T
! do_upper(int *d, int c)
  {
      *d = MB_TOUPPER(c);
  
***************
*** 7252,7260 ****
  }
  
      static fptr_T
! do_Upper(d, c)
!     int		*d;
!     int		c;
  {
      *d = MB_TOUPPER(c);
  
--- 7180,7186 ----
  }
  
      static fptr_T
! do_Upper(int *d, int c)
  {
      *d = MB_TOUPPER(c);
  
***************
*** 7262,7270 ****
  }
  
      static fptr_T
! do_lower(d, c)
!     int		*d;
!     int		c;
  {
      *d = MB_TOLOWER(c);
  
--- 7188,7194 ----
  }
  
      static fptr_T
! do_lower(int *d, int c)
  {
      *d = MB_TOLOWER(c);
  
***************
*** 7272,7280 ****
  }
  
      static fptr_T
! do_Lower(d, c)
!     int		*d;
!     int		c;
  {
      *d = MB_TOLOWER(c);
  
--- 7196,7202 ----
  }
  
      static fptr_T
! do_Lower(int *d, int c)
  {
      *d = MB_TOLOWER(c);
  
***************
*** 7294,7302 ****
   * The tildes are parsed once before the first call to vim_regsub().
   */
      char_u *
! regtilde(source, magic)
!     char_u	*source;
!     int		magic;
  {
      char_u	*newsub = source;
      char_u	*tmpsub;
--- 7216,7222 ----
   * The tildes are parsed once before the first call to vim_regsub().
   */
      char_u *
! regtilde(char_u *source, int magic)
  {
      char_u	*newsub = source;
      char_u	*tmpsub;
***************
*** 7389,7401 ****
   * Returns the size of the replacement, including terminating NUL.
   */
      int
! vim_regsub(rmp, source, dest, copy, magic, backslash)
!     regmatch_T	*rmp;
!     char_u	*source;
!     char_u	*dest;
!     int		copy;
!     int		magic;
!     int		backslash;
  {
      reg_match = rmp;
      reg_mmatch = NULL;
--- 7309,7321 ----
   * Returns the size of the replacement, including terminating NUL.
   */
      int
! vim_regsub(
!     regmatch_T	*rmp,
!     char_u	*source,
!     char_u	*dest,
!     int		copy,
!     int		magic,
!     int		backslash)
  {
      reg_match = rmp;
      reg_mmatch = NULL;
***************
*** 7407,7420 ****
  #endif
  
      int
! vim_regsub_multi(rmp, lnum, source, dest, copy, magic, backslash)
!     regmmatch_T	*rmp;
!     linenr_T	lnum;
!     char_u	*source;
!     char_u	*dest;
!     int		copy;
!     int		magic;
!     int		backslash;
  {
      reg_match = NULL;
      reg_mmatch = rmp;
--- 7327,7340 ----
  #endif
  
      int
! vim_regsub_multi(
!     regmmatch_T	*rmp,
!     linenr_T	lnum,
!     char_u	*source,
!     char_u	*dest,
!     int		copy,
!     int		magic,
!     int		backslash)
  {
      reg_match = NULL;
      reg_mmatch = rmp;
***************
*** 7426,7437 ****
  }
  
      static int
! vim_regsub_both(source, dest, copy, magic, backslash)
!     char_u	*source;
!     char_u	*dest;
!     int		copy;
!     int		magic;
!     int		backslash;
  {
      char_u	*src;
      char_u	*dst;
--- 7346,7357 ----
  }
  
      static int
! vim_regsub_both(
!     char_u	*source,
!     char_u	*dest,
!     int		copy,
!     int		magic,
!     int		backslash)
  {
      char_u	*src;
      char_u	*dst;
***************
*** 7811,7818 ****
   * overwritten.
   */
      static char_u *
! reg_getline_submatch(lnum)
!     linenr_T	lnum;
  {
      char_u *s;
      linenr_T save_first = reg_firstlnum;
--- 7731,7737 ----
   * overwritten.
   */
      static char_u *
! reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
      linenr_T save_first = reg_firstlnum;
***************
*** 7834,7841 ****
   * Returns NULL when not in a ":s" command and for a non-existing submatch.
   */
      char_u *
! reg_submatch(no)
!     int		no;
  {
      char_u	*retval = NULL;
      char_u	*s;
--- 7753,7759 ----
   * Returns NULL when not in a ":s" command and for a non-existing submatch.
   */
      char_u *
! reg_submatch(int no)
  {
      char_u	*retval = NULL;
      char_u	*s;
***************
*** 7929,7936 ****
   * command, for a non-existing submatch and for any error.
   */
      list_T *
! reg_submatch_list(no)
!     int		no;
  {
      char_u	*s;
      linenr_T	slnum;
--- 7847,7853 ----
   * command, for a non-existing submatch and for any error.
   */
      list_T *
! reg_submatch_list(int no)
  {
      char_u	*s;
      linenr_T	slnum;
***************
*** 8040,8048 ****
   * Returns NULL for an error.
   */
      regprog_T *
! vim_regcomp(expr_arg, re_flags)
!     char_u	*expr_arg;
!     int		re_flags;
  {
      regprog_T   *prog = NULL;
      char_u	*expr = expr_arg;
--- 7957,7963 ----
   * Returns NULL for an error.
   */
      regprog_T *
! vim_regcomp(char_u *expr_arg, int re_flags)
  {
      regprog_T   *prog = NULL;
      char_u	*expr = expr_arg;
***************
*** 8128,8135 ****
   * Free a compiled regexp program, returned by vim_regcomp().
   */
      void
! vim_regfree(prog)
!     regprog_T   *prog;
  {
      if (prog != NULL)
  	prog->engine->regfree(prog);
--- 8043,8049 ----
   * Free a compiled regexp program, returned by vim_regcomp().
   */
      void
! vim_regfree(regprog_T *prog)
  {
      if (prog != NULL)
  	prog->engine->regfree(prog);
***************
*** 8139,8146 ****
  static void report_re_switch(char_u *pat);
  
      static void
! report_re_switch(pat)
!     char_u *pat;
  {
      if (p_verbose > 0)
      {
--- 8053,8059 ----
  static void report_re_switch(char_u *pat);
  
      static void
! report_re_switch(char_u *pat)
  {
      if (p_verbose > 0)
      {
***************
*** 8164,8174 ****
   * Return TRUE if there is a match, FALSE if not.
   */
      static int
! vim_regexec_both(rmp, line, col, nl)
!     regmatch_T	*rmp;
!     char_u	*line;  /* string to match against */
!     colnr_T	col;    /* column to start looking for match */
!     int		nl;
  {
      int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
--- 8077,8087 ----
   * Return TRUE if there is a match, FALSE if not.
   */
      static int
! vim_regexec_both(
!     regmatch_T	*rmp,
!     char_u	*line,  /* string to match against */
!     colnr_T	col,    /* column to start looking for match */
!     int		nl)
  {
      int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
***************
*** 8203,8213 ****
   * Return TRUE if there is a match, FALSE if not.
   */
      int
! vim_regexec_prog(prog, ignore_case, line, col)
!     regprog_T	**prog;
!     int		ignore_case;
!     char_u	*line;
!     colnr_T	col;
  {
      int r;
      regmatch_T regmatch;
--- 8116,8126 ----
   * Return TRUE if there is a match, FALSE if not.
   */
      int
! vim_regexec_prog(
!     regprog_T	**prog,
!     int		ignore_case,
!     char_u	*line,
!     colnr_T	col)
  {
      int r;
      regmatch_T regmatch;
***************
*** 8224,8233 ****
   * Return TRUE if there is a match, FALSE if not.
   */
      int
! vim_regexec(rmp, line, col)
!     regmatch_T	*rmp;
!     char_u	*line;
!     colnr_T	col;
  {
      return vim_regexec_both(rmp, line, col, FALSE);
  }
--- 8137,8143 ----
   * Return TRUE if there is a match, FALSE if not.
   */
      int
! vim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)
  {
      return vim_regexec_both(rmp, line, col, FALSE);
  }
***************
*** 8240,8249 ****
   * Return TRUE if there is a match, FALSE if not.
   */
      int
! vim_regexec_nl(rmp, line, col)
!     regmatch_T	*rmp;
!     char_u	*line;
!     colnr_T	col;
  {
      return vim_regexec_both(rmp, line, col, TRUE);
  }
--- 8150,8156 ----
   * Return TRUE if there is a match, FALSE if not.
   */
      int
! vim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)
  {
      return vim_regexec_both(rmp, line, col, TRUE);
  }
***************
*** 8259,8271 ****
   * match otherwise.
   */
      long
! vim_regexec_multi(rmp, win, buf, lnum, col, tm)
!     regmmatch_T *rmp;
!     win_T       *win;           /* window in which to search or NULL */
!     buf_T       *buf;           /* buffer in which to search */
!     linenr_T    lnum;           /* nr of line to start looking for match */
!     colnr_T     col;            /* column to start looking for match */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      int result = rmp->regprog->engine->regexec_multi(
  						rmp, win, buf, lnum, col, tm);
--- 8166,8178 ----
   * match otherwise.
   */
      long
! vim_regexec_multi(
!     regmmatch_T *rmp,
!     win_T       *win,           /* window in which to search or NULL */
!     buf_T       *buf,           /* buffer in which to search */
!     linenr_T    lnum,           /* nr of line to start looking for match */
!     colnr_T     col,            /* column to start looking for match */
!     proftime_T	*tm)		/* timeout limit or NULL */
  {
      int result = rmp->regprog->engine->regexec_multi(
  						rmp, win, buf, lnum, col, tm);
*** ../vim-7.4.1212/src/regexp_nfa.c	2016-01-29 22:46:58.966534817 +0100
--- src/regexp_nfa.c	2016-01-30 20:23:18.650625878 +0100
***************
*** 332,340 ****
   * Return OK on success, FAIL otherwise.
   */
      static int
! nfa_regcomp_start(expr, re_flags)
!     char_u	*expr;
!     int		re_flags;	    /* see vim_regcomp() */
  {
      size_t	postfix_size;
      int		nstate_max;
--- 332,340 ----
   * Return OK on success, FAIL otherwise.
   */
      static int
! nfa_regcomp_start(
!     char_u	*expr,
!     int		re_flags)	    /* see vim_regcomp() */
  {
      size_t	postfix_size;
      int		nstate_max;
***************
*** 370,378 ****
   * of the line.
   */
      static int
! nfa_get_reganch(start, depth)
!     nfa_state_T *start;
!     int		depth;
  {
      nfa_state_T *p = start;
  
--- 370,376 ----
   * of the line.
   */
      static int
! nfa_get_reganch(nfa_state_T *start, int depth)
  {
      nfa_state_T *p = start;
  
***************
*** 434,442 ****
   * at start of the match.
   */
      static int
! nfa_get_regstart(start, depth)
!     nfa_state_T *start;
!     int		depth;
  {
      nfa_state_T *p = start;
  
--- 432,438 ----
   * at start of the match.
   */
      static int
! nfa_get_regstart(nfa_state_T *start, int depth)
  {
      nfa_state_T *p = start;
  
***************
*** 520,527 ****
   * regstart.  Otherwise return NULL.
   */
      static char_u *
! nfa_get_match_text(start)
!     nfa_state_T *start;
  {
      nfa_state_T *p = start;
      int		len = 0;
--- 516,522 ----
   * regstart.  Otherwise return NULL.
   */
      static char_u *
! nfa_get_match_text(nfa_state_T *start)
  {
      nfa_state_T *p = start;
      int		len = 0;
***************
*** 564,570 ****
   * running above the estimated number of states.
   */
      static int
! realloc_post_list()
  {
      int   nstate_max = (int)(post_end - post_start);
      int   new_max = nstate_max + 1000;
--- 559,565 ----
   * running above the estimated number of states.
   */
      static int
! realloc_post_list(void)
  {
      int   nstate_max = (int)(post_end - post_start);
      int   new_max = nstate_max + 1000;
***************
*** 594,603 ****
   * need to be interpreted as [a-zA-Z].
   */
      static int
! nfa_recognize_char_class(start, end, extra_newl)
!     char_u  *start;
!     char_u  *end;
!     int	    extra_newl;
  {
  #   define CLASS_not		0x80
  #   define CLASS_af		0x40
--- 589,595 ----
   * need to be interpreted as [a-zA-Z].
   */
      static int
! nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)
  {
  #   define CLASS_not		0x80
  #   define CLASS_af		0x40
***************
*** 744,751 ****
   * NOTE! When changing this function, also update reg_equi_class()
   */
      static int
! nfa_emit_equi_class(c)
!     int	    c;
  {
  #define EMIT2(c)    EMIT(c); EMIT(NFA_CONCAT);
  #ifdef FEAT_MBYTE
--- 736,742 ----
   * NOTE! When changing this function, also update reg_equi_class()
   */
      static int
! nfa_emit_equi_class(int c)
  {
  #define EMIT2(c)    EMIT(c); EMIT(NFA_CONCAT);
  #ifdef FEAT_MBYTE
***************
*** 1118,1124 ****
   *     or  \z( pattern \)
   */
      static int
! nfa_regatom()
  {
      int		c;
      int		charclass;
--- 1109,1115 ----
   *     or  \z( pattern \)
   */
      static int
! nfa_regatom(void)
  {
      int		c;
      int		charclass;
***************
*** 1890,1896 ****
   *	or  atom  multi
   */
      static int
! nfa_regpiece()
  {
      int		i;
      int		op;
--- 1881,1887 ----
   *	or  atom  multi
   */
      static int
! nfa_regpiece(void)
  {
      int		i;
      int		op;
***************
*** 2100,2106 ****
   *	etc.
   */
      static int
! nfa_regconcat()
  {
      int		cont = TRUE;
      int		first = TRUE;
--- 2091,2097 ----
   *	etc.
   */
      static int
! nfa_regconcat(void)
  {
      int		cont = TRUE;
      int		first = TRUE;
***************
*** 2178,2184 ****
   *		etc.
   */
      static int
! nfa_regbranch()
  {
      int		ch;
      int		old_post_pos;
--- 2169,2175 ----
   *		etc.
   */
      static int
! nfa_regbranch(void)
  {
      int		ch;
      int		old_post_pos;
***************
*** 2225,2232 ****
   *	etc.
   */
      static int
! nfa_reg(paren)
!     int		paren;	/* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */
  {
      int		parno = 0;
  
--- 2216,2223 ----
   *	etc.
   */
      static int
! nfa_reg(
!     int		paren)	/* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */
  {
      int		parno = 0;
  
***************
*** 2293,2300 ****
  static char_u code[50];
  
      static void
! nfa_set_code(c)
!     int	    c;
  {
      int	    addnl = FALSE;
  
--- 2284,2290 ----
  static char_u code[50];
  
      static void
! nfa_set_code(int c)
  {
      int	    addnl = FALSE;
  
***************
*** 2530,2538 ****
   * Print the postfix notation of the current regexp.
   */
      static void
! nfa_postfix_dump(expr, retval)
!     char_u  *expr;
!     int	    retval;
  {
      int *p;
      FILE *f;
--- 2520,2526 ----
   * Print the postfix notation of the current regexp.
   */
      static void
! nfa_postfix_dump(char_u *expr, int retval)
  {
      int *p;
      FILE *f;
***************
*** 2563,2571 ****
   * Print the NFA starting with a root node "state".
   */
      static void
! nfa_print_state(debugf, state)
!     FILE *debugf;
!     nfa_state_T *state;
  {
      garray_T indent;
  
--- 2551,2557 ----
   * Print the NFA starting with a root node "state".
   */
      static void
! nfa_print_state(FILE *debugf, nfa_state_T *state)
  {
      garray_T indent;
  
***************
*** 2576,2585 ****
  }
  
      static void
! nfa_print_state2(debugf, state, indent)
!     FILE *debugf;
!     nfa_state_T *state;
!     garray_T *indent;
  {
      char_u  *p;
  
--- 2562,2568 ----
  }
  
      static void
! nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)
  {
      char_u  *p;
  
***************
*** 2640,2647 ****
   * Print the NFA state machine.
   */
      static void
! nfa_dump(prog)
!     nfa_regprog_T *prog;
  {
      FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, "a");
  
--- 2623,2629 ----
   * Print the NFA state machine.
   */
      static void
! nfa_dump(nfa_regprog_T *prog)
  {
      FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, "a");
  
***************
*** 2668,2674 ****
   * Return the postfix string on success, NULL otherwise.
   */
      static int *
! re2post()
  {
      if (nfa_reg(REG_NOPAREN) == FAIL)
  	return NULL;
--- 2650,2656 ----
   * Return the postfix string on success, NULL otherwise.
   */
      static int *
! re2post(void)
  {
      if (nfa_reg(REG_NOPAREN) == FAIL)
  	return NULL;
***************
*** 2691,2700 ****
   * Allocate and initialize nfa_state_T.
   */
      static nfa_state_T *
! alloc_state(c, out, out1)
!     int		c;
!     nfa_state_T	*out;
!     nfa_state_T	*out1;
  {
      nfa_state_T *s;
  
--- 2673,2679 ----
   * Allocate and initialize nfa_state_T.
   */
      static nfa_state_T *
! alloc_state(int c, nfa_state_T *out, nfa_state_T *out1)
  {
      nfa_state_T *s;
  
***************
*** 2750,2758 ****
   * Initialize a Frag_T struct and return it.
   */
      static Frag_T
! frag(start, out)
!     nfa_state_T	*start;
!     Ptrlist	*out;
  {
      Frag_T n;
  
--- 2729,2735 ----
   * Initialize a Frag_T struct and return it.
   */
      static Frag_T
! frag(nfa_state_T *start, Ptrlist *out)
  {
      Frag_T n;
  
***************
*** 2765,2772 ****
   * Create singleton list containing just outp.
   */
      static Ptrlist *
! list1(outp)
!     nfa_state_T	**outp;
  {
      Ptrlist *l;
  
--- 2742,2749 ----
   * Create singleton list containing just outp.
   */
      static Ptrlist *
! list1(
!     nfa_state_T	**outp)
  {
      Ptrlist *l;
  
***************
*** 2779,2787 ****
   * Patch the list of states at out to point to start.
   */
      static void
! patch(l, s)
!     Ptrlist	*l;
!     nfa_state_T	*s;
  {
      Ptrlist *next;
  
--- 2756,2762 ----
   * Patch the list of states at out to point to start.
   */
      static void
! patch(Ptrlist *l, nfa_state_T *s)
  {
      Ptrlist *next;
  
***************
*** 2797,2805 ****
   * Join the two lists l1 and l2, returning the combination.
   */
      static Ptrlist *
! append(l1, l2)
!     Ptrlist *l1;
!     Ptrlist *l2;
  {
      Ptrlist *oldl1;
  
--- 2772,2778 ----
   * Join the two lists l1 and l2, returning the combination.
   */
      static Ptrlist *
! append(Ptrlist *l1, Ptrlist *l2)
  {
      Ptrlist *oldl1;
  
***************
*** 2816,2825 ****
  static Frag_T empty;
  
      static void
! st_error(postfix, end, p)
!     int *postfix UNUSED;
!     int *end UNUSED;
!     int *p UNUSED;
  {
  #ifdef NFA_REGEXP_ERROR_LOG
      FILE *df;
--- 2789,2795 ----
  static Frag_T empty;
  
      static void
! st_error(int *postfix UNUSED, int *end UNUSED, int *p UNUSED)
  {
  #ifdef NFA_REGEXP_ERROR_LOG
      FILE *df;
***************
*** 2868,2877 ****
   * Push an item onto the stack.
   */
      static void
! st_push(s, p, stack_end)
!     Frag_T s;
!     Frag_T **p;
!     Frag_T *stack_end;
  {
      Frag_T *stackp = *p;
  
--- 2838,2844 ----
   * Push an item onto the stack.
   */
      static void
! st_push(Frag_T s, Frag_T **p, Frag_T *stack_end)
  {
      Frag_T *stackp = *p;
  
***************
*** 2885,2893 ****
   * Pop an item from the stack.
   */
      static Frag_T
! st_pop(p, stack)
!     Frag_T **p;
!     Frag_T *stack;
  {
      Frag_T *stackp;
  
--- 2852,2858 ----
   * Pop an item from the stack.
   */
      static Frag_T
! st_pop(Frag_T **p, Frag_T *stack)
  {
      Frag_T *stackp;
  
***************
*** 2903,2911 ****
   * When unknown or unlimited return -1.
   */
      static int
! nfa_max_width(startstate, depth)
!     nfa_state_T *startstate;
!     int		depth;
  {
      int		    l, r;
      nfa_state_T	    *state = startstate;
--- 2868,2874 ----
   * When unknown or unlimited return -1.
   */
      static int
! nfa_max_width(nfa_state_T *startstate, int depth)
  {
      int		    l, r;
      nfa_state_T	    *state = startstate;
***************
*** 3128,3137 ****
   * Return the NFA start state on success, NULL otherwise.
   */
      static nfa_state_T *
! post2nfa(postfix, end, nfa_calc_size)
!     int		*postfix;
!     int		*end;
!     int		nfa_calc_size;
  {
      int		*p;
      int		mopen;
--- 3091,3097 ----
   * Return the NFA start state on success, NULL otherwise.
   */
      static nfa_state_T *
! post2nfa(int *postfix, int *end, int nfa_calc_size)
  {
      int		*p;
      int		mopen;
***************
*** 3667,3674 ****
   * After building the NFA program, inspect it to add optimization hints.
   */
      static void
! nfa_postprocess(prog)
!     nfa_regprog_T   *prog;
  {
      int i;
      int c;
--- 3627,3633 ----
   * After building the NFA program, inspect it to add optimization hints.
   */
      static void
! nfa_postprocess(nfa_regprog_T *prog)
  {
      int i;
      int c;
***************
*** 3801,3808 ****
  static char *pim_info(nfa_pim_T *pim);
  
      static void
! log_subsexpr(subs)
!     regsubs_T *subs;
  {
      log_subexpr(&subs->norm);
  # ifdef FEAT_SYN_HL
--- 3760,3766 ----
  static char *pim_info(nfa_pim_T *pim);
  
      static void
! log_subsexpr(regsubs_T *subs)
  {
      log_subexpr(&subs->norm);
  # ifdef FEAT_SYN_HL
***************
*** 3812,3819 ****
  }
  
      static void
! log_subexpr(sub)
!     regsub_T *sub;
  {
      int j;
  
--- 3770,3776 ----
  }
  
      static void
! log_subexpr(regsub_T *sub)
  {
      int j;
  
***************
*** 3838,3845 ****
  }
  
      static char *
! pim_info(pim)
!     nfa_pim_T *pim;
  {
      static char buf[30];
  
--- 3795,3801 ----
  }
  
      static char *
! pim_info(nfa_pim_T *pim)
  {
      static char buf[30];
  
***************
*** 3879,3887 ****
   * Copy postponed invisible match info from "from" to "to".
   */
      static void
! copy_pim(to, from)
!     nfa_pim_T *to;
!     nfa_pim_T *from;
  {
      to->result = from->result;
      to->state = from->state;
--- 3835,3841 ----
   * Copy postponed invisible match info from "from" to "to".
   */
      static void
! copy_pim(nfa_pim_T *to, nfa_pim_T *from)
  {
      to->result = from->result;
      to->state = from->state;
***************
*** 3894,3901 ****
  }
  
      static void
! clear_sub(sub)
!     regsub_T *sub;
  {
      if (REG_MULTI)
  	/* Use 0xff to set lnum to -1 */
--- 3848,3854 ----
  }
  
      static void
! clear_sub(regsub_T *sub)
  {
      if (REG_MULTI)
  	/* Use 0xff to set lnum to -1 */
***************
*** 3910,3918 ****
   * Copy the submatches from "from" to "to".
   */
      static void
! copy_sub(to, from)
!     regsub_T	*to;
!     regsub_T	*from;
  {
      to->in_use = from->in_use;
      if (from->in_use > 0)
--- 3863,3869 ----
   * Copy the submatches from "from" to "to".
   */
      static void
! copy_sub(regsub_T *to, regsub_T *from)
  {
      to->in_use = from->in_use;
      if (from->in_use > 0)
***************
*** 3933,3941 ****
   * Like copy_sub() but exclude the main match.
   */
      static void
! copy_sub_off(to, from)
!     regsub_T	*to;
!     regsub_T	*from;
  {
      if (to->in_use < from->in_use)
  	to->in_use = from->in_use;
--- 3884,3890 ----
   * Like copy_sub() but exclude the main match.
   */
      static void
! copy_sub_off(regsub_T *to, regsub_T *from)
  {
      if (to->in_use < from->in_use)
  	to->in_use = from->in_use;
***************
*** 3957,3965 ****
   * Like copy_sub() but only do the end of the main match if \ze is present.
   */
      static void
! copy_ze_off(to, from)
!     regsub_T	*to;
!     regsub_T	*from;
  {
      if (nfa_has_zend)
      {
--- 3906,3912 ----
   * Like copy_sub() but only do the end of the main match if \ze is present.
   */
      static void
! copy_ze_off(regsub_T *to, regsub_T *from)
  {
      if (nfa_has_zend)
      {
***************
*** 3984,3992 ****
   * When using back-references also check the end position.
   */
      static int
! sub_equal(sub1, sub2)
!     regsub_T	*sub1;
!     regsub_T	*sub2;
  {
      int		i;
      int		todo;
--- 3931,3937 ----
   * When using back-references also check the end position.
   */
      static int
! sub_equal(regsub_T *sub1, regsub_T *sub2)
  {
      int		i;
      int		todo;
***************
*** 4093,4103 ****
   * positions as "subs".
   */
      static int
! has_state_with_pos(l, state, subs, pim)
!     nfa_list_T		*l;	/* runtime state list */
!     nfa_state_T		*state;	/* state to update */
!     regsubs_T		*subs;	/* pointers to subexpressions */
!     nfa_pim_T		*pim;	/* postponed match or NULL */
  {
      nfa_thread_T	*thread;
      int			i;
--- 4038,4048 ----
   * positions as "subs".
   */
      static int
! has_state_with_pos(
!     nfa_list_T		*l,	/* runtime state list */
!     nfa_state_T		*state,	/* state to update */
!     regsubs_T		*subs,	/* pointers to subexpressions */
!     nfa_pim_T		*pim)	/* postponed match or NULL */
  {
      nfa_thread_T	*thread;
      int			i;
***************
*** 4122,4130 ****
   * set.
   */
      static int
! pim_equal(one, two)
!     nfa_pim_T *one;
!     nfa_pim_T *two;
  {
      int one_unused = (one == NULL || one->result == NFA_PIM_UNUSED);
      int two_unused = (two == NULL || two->result == NFA_PIM_UNUSED);
--- 4067,4073 ----
   * set.
   */
      static int
! pim_equal(nfa_pim_T *one, nfa_pim_T *two)
  {
      int one_unused = (one == NULL || one->result == NFA_PIM_UNUSED);
      int two_unused = (two == NULL || two->result == NFA_PIM_UNUSED);
***************
*** 4149,4157 ****
   * Return TRUE if "state" leads to a NFA_MATCH without advancing the input.
   */
      static int
! match_follows(startstate, depth)
!     nfa_state_T *startstate;
!     int		depth;
  {
      nfa_state_T	    *state = startstate;
  
--- 4092,4098 ----
   * Return TRUE if "state" leads to a NFA_MATCH without advancing the input.
   */
      static int
! match_follows(nfa_state_T *startstate, int depth)
  {
      nfa_state_T	    *state = startstate;
  
***************
*** 4244,4253 ****
   * Return TRUE if "state" is already in list "l".
   */
      static int
! state_in_list(l, state, subs)
!     nfa_list_T		*l;	/* runtime state list */
!     nfa_state_T		*state;	/* state to update */
!     regsubs_T		*subs;	/* pointers to subexpressions */
  {
      if (state->lastlist[nfa_ll_index] == l->id)
      {
--- 4185,4194 ----
   * Return TRUE if "state" is already in list "l".
   */
      static int
! state_in_list(
!     nfa_list_T		*l,	/* runtime state list */
!     nfa_state_T		*state,	/* state to update */
!     regsubs_T		*subs)	/* pointers to subexpressions */
  {
      if (state->lastlist[nfa_ll_index] == l->id)
      {
***************
*** 4262,4273 ****
   * Returns "subs_arg", possibly copied into temp_subs.
   */
      static regsubs_T *
! addstate(l, state, subs_arg, pim, off)
!     nfa_list_T		*l;	    /* runtime state list */
!     nfa_state_T		*state;	    /* state to update */
!     regsubs_T		*subs_arg;  /* pointers to subexpressions */
!     nfa_pim_T		*pim;	    /* postponed look-behind match */
!     int			off;	    /* byte offset, when -1 go to next line */
  {
      int			subidx;
      nfa_thread_T	*thread;
--- 4203,4214 ----
   * Returns "subs_arg", possibly copied into temp_subs.
   */
      static regsubs_T *
! addstate(
!     nfa_list_T		*l,	    /* runtime state list */
!     nfa_state_T		*state,	    /* state to update */
!     regsubs_T		*subs_arg,  /* pointers to subexpressions */
!     nfa_pim_T		*pim,	    /* postponed look-behind match */
!     int			off)	    /* byte offset, when -1 go to next line */
  {
      int			subidx;
      nfa_thread_T	*thread;
***************
*** 4678,4689 ****
   * matters for alternatives.
   */
      static void
! addstate_here(l, state, subs, pim, ip)
!     nfa_list_T		*l;	/* runtime state list */
!     nfa_state_T		*state;	/* state to update */
!     regsubs_T		*subs;	/* pointers to subexpressions */
!     nfa_pim_T		*pim;   /* postponed look-behind match */
!     int			*ip;
  {
      int tlen = l->n;
      int count;
--- 4619,4630 ----
   * matters for alternatives.
   */
      static void
! addstate_here(
!     nfa_list_T		*l,	/* runtime state list */
!     nfa_state_T		*state,	/* state to update */
!     regsubs_T		*subs,	/* pointers to subexpressions */
!     nfa_pim_T		*pim,   /* postponed look-behind match */
!     int			*ip)
  {
      int tlen = l->n;
      int count;
***************
*** 4749,4757 ****
   * Check character class "class" against current character c.
   */
      static int
! check_char_class(class, c)
!     int		class;
!     int		c;
  {
      switch (class)
      {
--- 4690,4696 ----
   * Check character class "class" against current character c.
   */
      static int
! check_char_class(int class, int c)
  {
      switch (class)
      {
***************
*** 4833,4842 ****
   * Return TRUE if it matches.
   */
      static int
! match_backref(sub, subidx, bytelen)
!     regsub_T	*sub;	    /* pointers to subexpressions */
!     int		subidx;
!     int		*bytelen;   /* out: length of match in bytes */
  {
      int		len;
  
--- 4772,4781 ----
   * Return TRUE if it matches.
   */
      static int
! match_backref(
!     regsub_T	*sub,	    /* pointers to subexpressions */
!     int		subidx,
!     int		*bytelen)   /* out: length of match in bytes */
  {
      int		len;
  
***************
*** 4900,4908 ****
   * Return TRUE if it matches.
   */
      static int
! match_zref(subidx, bytelen)
!     int		subidx;
!     int		*bytelen;   /* out: length of match in bytes */
  {
      int		len;
  
--- 4839,4847 ----
   * Return TRUE if it matches.
   */
      static int
! match_zref(
!     int		subidx,
!     int		*bytelen)   /* out: length of match in bytes */
  {
      int		len;
  
***************
*** 4930,4938 ****
   * Only used for the recursive value lastlist[1].
   */
      static void
! nfa_save_listids(prog, list)
!     nfa_regprog_T   *prog;
!     int		    *list;
  {
      int		    i;
      nfa_state_T	    *p;
--- 4869,4875 ----
   * Only used for the recursive value lastlist[1].
   */
      static void
! nfa_save_listids(nfa_regprog_T *prog, int *list)
  {
      int		    i;
      nfa_state_T	    *p;
***************
*** 4951,4959 ****
   * Restore list IDs from "list" to all NFA states.
   */
      static void
! nfa_restore_listids(prog, list)
!     nfa_regprog_T   *prog;
!     int		    *list;
  {
      int		    i;
      nfa_state_T	    *p;
--- 4888,4894 ----
   * Restore list IDs from "list" to all NFA states.
   */
      static void
! nfa_restore_listids(nfa_regprog_T *prog, int *list)
  {
      int		    i;
      nfa_state_T	    *p;
***************
*** 4967,4976 ****
  }
  
      static int
! nfa_re_num_cmp(val, op, pos)
!     long_u	val;
!     int		op;
!     long_u	pos;
  {
      if (op == 1) return pos > val;
      if (op == 2) return pos < val;
--- 4902,4908 ----
  }
  
      static int
! nfa_re_num_cmp(long_u val, int op, long_u pos)
  {
      if (op == 1) return pos > val;
      if (op == 2) return pos < val;
***************
*** 4986,4998 ****
   * position).
   */
      static int
! recursive_regmatch(state, pim, prog, submatch, m, listids)
!     nfa_state_T	    *state;
!     nfa_pim_T	    *pim;
!     nfa_regprog_T   *prog;
!     regsubs_T	    *submatch;
!     regsubs_T	    *m;
!     int		    **listids;
  {
      int		save_reginput_col = (int)(reginput - regline);
      int		save_reglnum = reglnum;
--- 4918,4930 ----
   * position).
   */
      static int
! recursive_regmatch(
!     nfa_state_T	    *state,
!     nfa_pim_T	    *pim,
!     nfa_regprog_T   *prog,
!     regsubs_T	    *submatch,
!     regsubs_T	    *m,
!     int		    **listids)
  {
      int		save_reginput_col = (int)(reginput - regline);
      int		save_reglnum = reglnum;
***************
*** 5168,5176 ****
   * specific character: 99
   */
      static int
! failure_chance(state, depth)
!     nfa_state_T *state;
!     int		depth;
  {
      int c = state->c;
      int l, r;
--- 5100,5106 ----
   * specific character: 99
   */
      static int
! failure_chance(nfa_state_T *state, int depth)
  {
      int c = state->c;
      int l, r;
***************
*** 5330,5338 ****
   * Skip until the char "c" we know a match must start with.
   */
      static int
! skip_to_start(c, colp)
!     int		c;
!     colnr_T	*colp;
  {
      char_u *s;
  
--- 5260,5266 ----
   * Skip until the char "c" we know a match must start with.
   */
      static int
! skip_to_start(int c, colnr_T *colp)
  {
      char_u *s;
  
***************
*** 5357,5366 ****
   * Returns zero for no match, 1 for a match.
   */
      static long
! find_match_text(startcol, regstart, match_text)
!     colnr_T startcol;
!     int	    regstart;
!     char_u  *match_text;
  {
      colnr_T col = startcol;
      int	    c1, c2;
--- 5285,5291 ----
   * Returns zero for no match, 1 for a match.
   */
      static long
! find_match_text(colnr_T startcol, int regstart, char_u *match_text)
  {
      colnr_T col = startcol;
      int	    c1, c2;
***************
*** 5426,5436 ****
   * Note: Caller must ensure that: start != NULL.
   */
      static int
! nfa_regmatch(prog, start, submatch, m)
!     nfa_regprog_T	*prog;
!     nfa_state_T		*start;
!     regsubs_T		*submatch;
!     regsubs_T		*m;
  {
      int		result;
      size_t	size = 0;
--- 5351,5361 ----
   * Note: Caller must ensure that: start != NULL.
   */
      static int
! nfa_regmatch(
!     nfa_regprog_T	*prog,
!     nfa_state_T		*start,
!     regsubs_T		*submatch,
!     regsubs_T		*m)
  {
      int		result;
      size_t	size = 0;
***************
*** 6847,6856 ****
   * Returns <= 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! nfa_regtry(prog, col, tm)
!     nfa_regprog_T   *prog;
!     colnr_T	    col;
!     proftime_T	    *tm UNUSED;	/* timeout limit or NULL */
  {
      int		i;
      regsubs_T	subs, m;
--- 6772,6781 ----
   * Returns <= 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! nfa_regtry(
!     nfa_regprog_T   *prog,
!     colnr_T	    col,
!     proftime_T	    *tm UNUSED)	/* timeout limit or NULL */
  {
      int		i;
      regsubs_T	subs, m;
***************
*** 6986,6995 ****
   * Returns <= 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! nfa_regexec_both(line, startcol, tm)
!     char_u	*line;
!     colnr_T	startcol;	/* column to start looking for match */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      nfa_regprog_T   *prog;
      long	    retval = 0L;
--- 6911,6920 ----
   * Returns <= 0 for failure, number of lines contained in the match otherwise.
   */
      static long
! nfa_regexec_both(
!     char_u	*line,
!     colnr_T	startcol,	/* column to start looking for match */
!     proftime_T	*tm)		/* timeout limit or NULL */
  {
      nfa_regprog_T   *prog;
      long	    retval = 0L;
***************
*** 7096,7104 ****
   * Returns the program in allocated space.  Returns NULL for an error.
   */
      static regprog_T *
! nfa_regcomp(expr, re_flags)
!     char_u	*expr;
!     int		re_flags;
  {
      nfa_regprog_T	*prog = NULL;
      size_t		prog_size;
--- 7021,7027 ----
   * Returns the program in allocated space.  Returns NULL for an error.
   */
      static regprog_T *
! nfa_regcomp(char_u *expr, int re_flags)
  {
      nfa_regprog_T	*prog = NULL;
      size_t		prog_size;
***************
*** 7208,7215 ****
   * Free a compiled regexp program, returned by nfa_regcomp().
   */
      static void
! nfa_regfree(prog)
!     regprog_T   *prog;
  {
      if (prog != NULL)
      {
--- 7131,7137 ----
   * Free a compiled regexp program, returned by nfa_regcomp().
   */
      static void
! nfa_regfree(regprog_T *prog)
  {
      if (prog != NULL)
      {
***************
*** 7228,7238 ****
   * Returns <= 0 for failure, number of lines contained in the match otherwise.
   */
      static int
! nfa_regexec_nl(rmp, line, col, line_lbr)
!     regmatch_T	*rmp;
!     char_u	*line;	/* string to match against */
!     colnr_T	col;	/* column to start looking for match */
!     int		line_lbr;
  {
      reg_match = rmp;
      reg_mmatch = NULL;
--- 7150,7160 ----
   * Returns <= 0 for failure, number of lines contained in the match otherwise.
   */
      static int
! nfa_regexec_nl(
!     regmatch_T	*rmp,
!     char_u	*line,	/* string to match against */
!     colnr_T	col,	/* column to start looking for match */
!     int		line_lbr)
  {
      reg_match = rmp;
      reg_mmatch = NULL;
***************
*** 7275,7287 ****
   * FIXME if this behavior is not compatible.
   */
      static long
! nfa_regexec_multi(rmp, win, buf, lnum, col, tm)
!     regmmatch_T	*rmp;
!     win_T	*win;		/* window in which to search or NULL */
!     buf_T	*buf;		/* buffer in which to search */
!     linenr_T	lnum;		/* nr of line to start looking for match */
!     colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      reg_match = NULL;
      reg_mmatch = rmp;
--- 7197,7209 ----
   * FIXME if this behavior is not compatible.
   */
      static long
! nfa_regexec_multi(
!     regmmatch_T	*rmp,
!     win_T	*win,		/* window in which to search or NULL */
!     buf_T	*buf,		/* buffer in which to search */
!     linenr_T	lnum,		/* nr of line to start looking for match */
!     colnr_T	col,		/* column to start looking for match */
!     proftime_T	*tm)		/* timeout limit or NULL */
  {
      reg_match = NULL;
      reg_mmatch = rmp;
*** ../vim-7.4.1212/src/screen.c	2016-01-29 22:46:58.966534817 +0100
--- src/screen.c	2016-01-30 20:28:16.991523774 +0100
***************
*** 191,206 ****
   * e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.
   */
      void
! redraw_later(type)
!     int		type;
  {
      redraw_win_later(curwin, type);
  }
  
      void
! redraw_win_later(wp, type)
!     win_T	*wp;
!     int		type;
  {
      if (wp->w_redr_type < type)
      {
--- 191,205 ----
   * e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.
   */
      void
! redraw_later(int type)
  {
      redraw_win_later(curwin, type);
  }
  
      void
! redraw_win_later(
!     win_T	*wp,
!     int		type)
  {
      if (wp->w_redr_type < type)
      {
***************
*** 217,223 ****
   * after executing a shell command that messes up the screen.
   */
      void
! redraw_later_clear()
  {
      redraw_all_later(CLEAR);
  #ifdef FEAT_GUI
--- 216,222 ----
   * after executing a shell command that messes up the screen.
   */
      void
! redraw_later_clear(void)
  {
      redraw_all_later(CLEAR);
  #ifdef FEAT_GUI
***************
*** 235,242 ****
   * Mark all windows to be redrawn later.
   */
      void
! redraw_all_later(type)
!     int		type;
  {
      win_T	*wp;
  
--- 234,240 ----
   * Mark all windows to be redrawn later.
   */
      void
! redraw_all_later(int type)
  {
      win_T	*wp;
  
***************
*** 250,265 ****
   * Mark all windows that are editing the current buffer to be updated later.
   */
      void
! redraw_curbuf_later(type)
!     int		type;
  {
      redraw_buf_later(curbuf, type);
  }
  
      void
! redraw_buf_later(buf, type)
!     buf_T	*buf;
!     int		type;
  {
      win_T	*wp;
  
--- 248,260 ----
   * Mark all windows that are editing the current buffer to be updated later.
   */
      void
! redraw_curbuf_later(int type)
  {
      redraw_buf_later(curbuf, type);
  }
  
      void
! redraw_buf_later(buf_T *buf, int type)
  {
      win_T	*wp;
  
***************
*** 276,283 ****
   * Return a code indicating what happened.
   */
      int
! redraw_asap(type)
!     int		type;
  {
      int		rows;
      int		cols = screen_Columns;
--- 271,277 ----
   * Return a code indicating what happened.
   */
      int
! redraw_asap(int type)
  {
      int		rows;
      int		cols = screen_Columns;
***************
*** 425,433 ****
   * may become invalid and the whole window will have to be redrawn.
   */
      void
! redrawWinline(lnum, invalid)
!     linenr_T	lnum;
!     int		invalid UNUSED;	/* window line height is invalid now */
  {
  #ifdef FEAT_FOLDING
      int		i;
--- 419,427 ----
   * may become invalid and the whole window will have to be redrawn.
   */
      void
! redrawWinline(
!     linenr_T	lnum,
!     int		invalid UNUSED)	/* window line height is invalid now */
  {
  #ifdef FEAT_FOLDING
      int		i;
***************
*** 454,461 ****
   * update all windows that are editing the current buffer
   */
      void
! update_curbuf(type)
!     int		type;
  {
      redraw_curbuf_later(type);
      update_screen(type);
--- 448,454 ----
   * update all windows that are editing the current buffer
   */
      void
! update_curbuf(int type)
  {
      redraw_curbuf_later(type);
      update_screen(type);
***************
*** 468,475 ****
   * of stuff from Filemem to ScreenLines[], and update curwin->w_botline.
   */
      void
! update_screen(type)
!     int		type;
  {
      win_T	*wp;
      static int	did_intro = FALSE;
--- 461,467 ----
   * of stuff from Filemem to ScreenLines[], and update curwin->w_botline.
   */
      void
! update_screen(int type)
  {
      win_T	*wp;
      static int	did_intro = FALSE;
***************
*** 741,748 ****
   * to the 'concealcursor' option.
   */
      int
! conceal_cursor_line(wp)
!     win_T	*wp;
  {
      int		c;
  
--- 733,739 ----
   * to the 'concealcursor' option.
   */
      int
! conceal_cursor_line(win_T *wp)
  {
      int		c;
  
***************
*** 765,771 ****
   * Check if the cursor line needs to be redrawn because of 'concealcursor'.
   */
      void
! conceal_check_cursur_line()
  {
      if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin))
      {
--- 756,762 ----
   * Check if the cursor line needs to be redrawn because of 'concealcursor'.
   */
      void
! conceal_check_cursur_line(void)
  {
      if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin))
      {
***************
*** 777,785 ****
  }
  
      void
! update_single_line(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      int		row;
      int		j;
--- 768,774 ----
  }
  
      void
! update_single_line(win_T *wp, linenr_T lnum)
  {
      int		row;
      int		j;
***************
*** 834,840 ****
   * Caller must check for "updating_screen" already set to avoid recursiveness.
   */
      static void
! update_prepare()
  {
      cursor_off();
      updating_screen = TRUE;
--- 823,829 ----
   * Caller must check for "updating_screen" already set to avoid recursiveness.
   */
      static void
! update_prepare(void)
  {
      cursor_off();
      updating_screen = TRUE;
***************
*** 853,859 ****
   * Finish updating one or more windows.
   */
      static void
! update_finish()
  {
      if (redraw_cmdline)
  	showmode();
--- 842,848 ----
   * Finish updating one or more windows.
   */
      static void
! update_finish(void)
  {
      if (redraw_cmdline)
  	showmode();
***************
*** 881,889 ****
  
  #if defined(FEAT_SIGNS) || defined(PROTO)
      void
! update_debug_sign(buf, lnum)
!     buf_T	*buf;
!     linenr_T	lnum;
  {
      win_T	*wp;
      int		doit = FALSE;
--- 870,876 ----
  
  #if defined(FEAT_SIGNS) || defined(PROTO)
      void
! update_debug_sign(buf_T *buf, linenr_T lnum)
  {
      win_T	*wp;
      int		doit = FALSE;
***************
*** 949,956 ****
   * Used for the GUI scrollbar.
   */
      void
! updateWindow(wp)
!     win_T	*wp;
  {
      /* return if already busy updating */
      if (updating_screen)
--- 936,942 ----
   * Used for the GUI scrollbar.
   */
      void
! updateWindow(win_T *wp)
  {
      /* return if already busy updating */
      if (updating_screen)
***************
*** 1016,1023 ****
   * bot: from bot_start to last row (when scrolled up)
   */
      static void
! win_update(wp)
!     win_T	*wp;
  {
      buf_T	*buf = wp->w_buffer;
      int		type;
--- 1002,1008 ----
   * bot: from bot_start to last row (when scrolled up)
   */
      static void
! win_update(win_T *wp)
  {
      buf_T	*buf = wp->w_buffer;
      int		type;
***************
*** 2211,2218 ****
   * Return TRUE when window "wp" has a column to draw signs in.
   */
      static int
! draw_signcolumn(wp)
!     win_T *wp;
  {
      return (wp->w_buffer->b_signlist != NULL
  # ifdef FEAT_NETBEANS_INTG
--- 2196,2202 ----
   * Return TRUE when window "wp" has a column to draw signs in.
   */
      static int
! draw_signcolumn(win_T *wp)
  {
      return (wp->w_buffer->b_signlist != NULL
  # ifdef FEAT_NETBEANS_INTG
***************
*** 2227,2239 ****
   * as the filler character.
   */
      static void
! win_draw_end(wp, c1, c2, row, endrow, hl)
!     win_T	*wp;
!     int		c1;
!     int		c2;
!     int		row;
!     int		endrow;
!     hlf_T	hl;
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_SIGNS) || defined(FEAT_CMDWIN)
      int		n = 0;
--- 2211,2223 ----
   * as the filler character.
   */
      static void
! win_draw_end(
!     win_T	*wp,
!     int		c1,
!     int		c2,
!     int		row,
!     int		endrow,
!     hlf_T	hl)
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_SIGNS) || defined(FEAT_CMDWIN)
      int		n = 0;
***************
*** 2340,2348 ****
   * Advance **color_cols and return TRUE when there are columns to draw.
   */
      static int
! advance_color_col(vcol, color_cols)
!     int	    vcol;
!     int	    **color_cols;
  {
      while (**color_cols >= 0 && vcol > **color_cols)
  	++*color_cols;
--- 2324,2330 ----
   * Advance **color_cols and return TRUE when there are columns to draw.
   */
      static int
! advance_color_col(int vcol, int **color_cols)
  {
      while (**color_cols >= 0 && vcol > **color_cols)
  	++*color_cols;
***************
*** 2356,2364 ****
   * space is available for window "wp", minus "col".
   */
      static int
! compute_foldcolumn(wp, col)
!     win_T *wp;
!     int   col;
  {
      int fdc = wp->w_p_fdc;
      int wmw = wp == curwin && p_wmw == 0 ? 1 : p_wmw;
--- 2338,2344 ----
   * space is available for window "wp", minus "col".
   */
      static int
! compute_foldcolumn(win_T *wp, int col)
  {
      int fdc = wp->w_p_fdc;
      int wmw = wp == curwin && p_wmw == 0 ? 1 : p_wmw;
***************
*** 2373,2384 ****
   * Display one folded line.
   */
      static void
! fold_line(wp, fold_count, foldinfo, lnum, row)
!     win_T	*wp;
!     long	fold_count;
!     foldinfo_T	*foldinfo;
!     linenr_T	lnum;
!     int		row;
  {
      char_u	buf[51];
      pos_T	*top, *bot;
--- 2353,2364 ----
   * Display one folded line.
   */
      static void
! fold_line(
!     win_T	*wp,
!     long	fold_count,
!     foldinfo_T	*foldinfo,
!     linenr_T	lnum,
!     int		row)
  {
      char_u	buf[51];
      pos_T	*top, *bot;
***************
*** 2800,2810 ****
   * Copy "buf[len]" to ScreenLines["off"] and set attributes to "attr".
   */
      static void
! copy_text_attr(off, buf, len, attr)
!     int		off;
!     char_u	*buf;
!     int		len;
!     int		attr;
  {
      int		i;
  
--- 2780,2790 ----
   * Copy "buf[len]" to ScreenLines["off"] and set attributes to "attr".
   */
      static void
! copy_text_attr(
!     int		off,
!     char_u	*buf,
!     int		len,
!     int		attr)
  {
      int		i;
  
***************
*** 2822,2832 ****
   * Only to be called when 'foldcolumn' > 0.
   */
      static void
! fill_foldcolumn(p, wp, closed, lnum)
!     char_u	*p;
!     win_T	*wp;
!     int		closed;		/* TRUE of FALSE */
!     linenr_T	lnum;		/* current line number */
  {
      int		i = 0;
      int		level;
--- 2802,2812 ----
   * Only to be called when 'foldcolumn' > 0.
   */
      static void
! fill_foldcolumn(
!     char_u	*p,
!     win_T	*wp,
!     int		closed,		/* TRUE of FALSE */
!     linenr_T	lnum)		/* current line number */
  {
      int		i = 0;
      int		level;
***************
*** 2877,2888 ****
   * Return the number of last row the line occupies.
   */
      static int
! win_line(wp, lnum, startrow, endrow, nochange)
!     win_T	*wp;
!     linenr_T	lnum;
!     int		startrow;
!     int		endrow;
!     int		nochange UNUSED;	/* not updating for changed text */
  {
      int		col;			/* visual column on screen */
      unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
--- 2857,2868 ----
   * Return the number of last row the line occupies.
   */
      static int
! win_line(
!     win_T	*wp,
!     linenr_T	lnum,
!     int		startrow,
!     int		endrow,
!     int		nochange UNUSED)	/* not updating for changed text */
  {
      int		col;			/* visual column on screen */
      unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
***************
*** 5751,5759 ****
   * Only to be used when ScreenLinesUC[off_from] != 0.
   */
      static int
! comp_char_differs(off_from, off_to)
!     int	    off_from;
!     int	    off_to;
  {
      int	    i;
  
--- 5731,5737 ----
   * Only to be used when ScreenLinesUC[off_from] != 0.
   */
      static int
! comp_char_differs(int off_from, int off_to)
  {
      int	    i;
  
***************
*** 5776,5785 ****
   * - the character is two cells wide and the second cell differs.
   */
      static int
! char_needs_redraw(off_from, off_to, cols)
!     int		off_from;
!     int		off_to;
!     int		cols;
  {
      if (cols > 0
  	    && ((ScreenLines[off_from] != ScreenLines[off_to]
--- 5754,5760 ----
   * - the character is two cells wide and the second cell differs.
   */
      static int
! char_needs_redraw(int off_from, int off_to, int cols)
  {
      if (cols > 0
  	    && ((ScreenLines[off_from] != ScreenLines[off_to]
***************
*** 5817,5834 ****
   *    When FALSE and "clear_width" > 0, clear columns "endcol" to "clear_width"
   */
      static void
! screen_line(row, coloff, endcol, clear_width
! #ifdef FEAT_RIGHTLEFT
! 				    , rlflag
! #endif
! 						)
!     int	    row;
!     int	    coloff;
!     int	    endcol;
!     int	    clear_width;
  #ifdef FEAT_RIGHTLEFT
!     int	    rlflag;
  #endif
  {
      unsigned	    off_from;
      unsigned	    off_to;
--- 5792,5806 ----
   *    When FALSE and "clear_width" > 0, clear columns "endcol" to "clear_width"
   */
      static void
! screen_line(
!     int	    row,
!     int	    coloff,
!     int	    endcol,
!     int	    clear_width
  #ifdef FEAT_RIGHTLEFT
!     , int   rlflag
  #endif
+     )
  {
      unsigned	    off_from;
      unsigned	    off_to;
***************
*** 6228,6235 ****
   * Only works for single-byte characters (e.g., numbers).
   */
      void
! rl_mirror(str)
!     char_u	*str;
  {
      char_u	*p1, *p2;
      int		t;
--- 6200,6206 ----
   * Only works for single-byte characters (e.g., numbers).
   */
      void
! rl_mirror(char_u *str)
  {
      char_u	*p1, *p2;
      int		t;
***************
*** 6248,6254 ****
   * mark all status lines for redraw; used after first :cd
   */
      void
! status_redraw_all()
  {
      win_T	*wp;
  
--- 6219,6225 ----
   * mark all status lines for redraw; used after first :cd
   */
      void
! status_redraw_all(void)
  {
      win_T	*wp;
  
***************
*** 6264,6270 ****
   * mark all status lines of the current buffer for redraw
   */
      void
! status_redraw_curbuf()
  {
      win_T	*wp;
  
--- 6235,6241 ----
   * mark all status lines of the current buffer for redraw
   */
      void
! status_redraw_curbuf(void)
  {
      win_T	*wp;
  
***************
*** 6280,6286 ****
   * Redraw all status lines that need to be redrawn.
   */
      void
! redraw_statuslines()
  {
      win_T	*wp;
  
--- 6251,6257 ----
   * Redraw all status lines that need to be redrawn.
   */
      void
! redraw_statuslines(void)
  {
      win_T	*wp;
  
***************
*** 6297,6304 ****
   * Redraw all status lines at the bottom of frame "frp".
   */
      void
! win_redraw_last_status(frp)
!     frame_T	*frp;
  {
      if (frp->fr_layout == FR_LEAF)
  	frp->fr_win->w_redr_status = TRUE;
--- 6268,6274 ----
   * Redraw all status lines at the bottom of frame "frp".
   */
      void
! win_redraw_last_status(frame_T *frp)
  {
      if (frp->fr_layout == FR_LEAF)
  	frp->fr_win->w_redr_status = TRUE;
***************
*** 6322,6330 ****
   * Draw the verticap separator right of window "wp" starting with line "row".
   */
      static void
! draw_vsep_win(wp, row)
!     win_T	*wp;
!     int		row;
  {
      int		hl;
      int		c;
--- 6292,6298 ----
   * Draw the verticap separator right of window "wp" starting with line "row".
   */
      static void
! draw_vsep_win(win_T *wp, int row)
  {
      int		hl;
      int		c;
***************
*** 6348,6356 ****
   * Get the length of an item as it will be shown in the status line.
   */
      static int
! status_match_len(xp, s)
!     expand_T	*xp;
!     char_u	*s;
  {
      int	len = 0;
  
--- 6316,6322 ----
   * Get the length of an item as it will be shown in the status line.
   */
      static int
! status_match_len(expand_T *xp, char_u *s)
  {
      int	len = 0;
  
***************
*** 6378,6386 ****
   * These are backslashes used for escaping.  Do show backslashes in help tags.
   */
      static int
! skip_status_match_char(xp, s)
!     expand_T	*xp;
!     char_u	*s;
  {
      if ((rem_backslash(s) && xp->xp_context != EXPAND_HELP)
  #ifdef FEAT_MENU
--- 6344,6350 ----
   * These are backslashes used for escaping.  Do show backslashes in help tags.
   */
      static int
! skip_status_match_char(expand_T *xp, char_u *s)
  {
      if ((rem_backslash(s) && xp->xp_context != EXPAND_HELP)
  #ifdef FEAT_MENU
***************
*** 6407,6418 ****
   * If inversion is possible we use it. Else '=' characters are used.
   */
      void
! win_redr_status_matches(xp, num_matches, matches, match, showtail)
!     expand_T	*xp;
!     int		num_matches;
!     char_u	**matches;	/* list of matches */
!     int		match;
!     int		showtail;
  {
  #define L_MATCH(m) (showtail ? sm_gettail(matches[m]) : matches[m])
      int		row;
--- 6371,6382 ----
   * If inversion is possible we use it. Else '=' characters are used.
   */
      void
! win_redr_status_matches(
!     expand_T	*xp,
!     int		num_matches,
!     char_u	**matches,	/* list of matches */
!     int		match,
!     int		showtail)
  {
  #define L_MATCH(m) (showtail ? sm_gettail(matches[m]) : matches[m])
      int		row;
***************
*** 6632,6639 ****
   * If inversion is possible we use it. Else '=' characters are used.
   */
      void
! win_redr_status(wp)
!     win_T	*wp;
  {
      int		row;
      char_u	*p;
--- 6596,6602 ----
   * If inversion is possible we use it. Else '=' characters are used.
   */
      void
! win_redr_status(win_T *wp)
  {
      int		row;
      char_u	*p;
***************
*** 6795,6802 ****
   * errors encountered.
   */
      static void
! redraw_custom_statusline(wp)
!     win_T	    *wp;
  {
      static int	    entered = FALSE;
      int		    save_called_emsg = called_emsg;
--- 6758,6764 ----
   * errors encountered.
   */
      static void
! redraw_custom_statusline(win_T *wp)
  {
      static int	    entered = FALSE;
      int		    save_called_emsg = called_emsg;
***************
*** 6830,6837 ****
   * Only call if (wp->w_vsep_width != 0).
   */
      int
! stl_connected(wp)
!     win_T	*wp;
  {
      frame_T	*fr;
  
--- 6792,6798 ----
   * Only call if (wp->w_vsep_width != 0).
   */
      int
! stl_connected(win_T *wp)
  {
      frame_T	*fr;
  
***************
*** 6861,6870 ****
   * Get the value to show for the language mappings, active 'keymap'.
   */
      int
! get_keymap_str(wp, buf, len)
!     win_T	*wp;
!     char_u	*buf;	    /* buffer for the result */
!     int		len;	    /* length of buffer */
  {
      char_u	*p;
  
--- 6822,6831 ----
   * Get the value to show for the language mappings, active 'keymap'.
   */
      int
! get_keymap_str(
!     win_T	*wp,
!     char_u	*buf,	    /* buffer for the result */
!     int		len)	    /* length of buffer */
  {
      char_u	*p;
  
***************
*** 6913,6921 ****
   * When "wp" is NULL redraw the tab pages line from 'tabline'.
   */
      static void
! win_redr_custom(wp, draw_ruler)
!     win_T	*wp;
!     int		draw_ruler;	/* TRUE or FALSE */
  {
      static int	entered = FALSE;
      int		attr;
--- 6874,6882 ----
   * When "wp" is NULL redraw the tab pages line from 'tabline'.
   */
      static void
! win_redr_custom(
!     win_T	*wp,
!     int		draw_ruler)	/* TRUE or FALSE */
  {
      static int	entered = FALSE;
      int		attr;
***************
*** 7110,7119 ****
   * Output a single character directly to the screen and update ScreenLines.
   */
      void
! screen_putchar(c, row, col, attr)
!     int	    c;
!     int	    row, col;
!     int	    attr;
  {
      char_u	buf[MB_MAXBYTES + 1];
  
--- 7071,7077 ----
   * Output a single character directly to the screen and update ScreenLines.
   */
      void
! screen_putchar(int c, int row, int col, int attr)
  {
      char_u	buf[MB_MAXBYTES + 1];
  
***************
*** 7134,7143 ****
   * Also return its attribute in *attrp;
   */
      void
! screen_getbytes(row, col, bytes, attrp)
!     int	    row, col;
!     char_u  *bytes;
!     int	    *attrp;
  {
      unsigned off;
  
--- 7092,7098 ----
   * Also return its attribute in *attrp;
   */
      void
! screen_getbytes(int row, int col, char_u *bytes, int *attrp)
  {
      unsigned off;
  
***************
*** 7176,7184 ****
   * Only to be used when ScreenLinesUC[off] != 0.
   */
      static int
! screen_comp_differs(off, u8cc)
!     int	    off;
!     int	    *u8cc;
  {
      int	    i;
  
--- 7131,7137 ----
   * Only to be used when ScreenLinesUC[off] != 0.
   */
      static int
! screen_comp_differs(int off, int *u8cc)
  {
      int	    i;
  
***************
*** 7200,7210 ****
   * Note: if ScreenLines[], row and/or col is invalid, nothing is done.
   */
      void
! screen_puts(text, row, col, attr)
!     char_u	*text;
!     int		row;
!     int		col;
!     int		attr;
  {
      screen_puts_len(text, -1, row, col, attr);
  }
--- 7153,7163 ----
   * Note: if ScreenLines[], row and/or col is invalid, nothing is done.
   */
      void
! screen_puts(
!     char_u	*text,
!     int		row,
!     int		col,
!     int		attr)
  {
      screen_puts_len(text, -1, row, col, attr);
  }
***************
*** 7214,7225 ****
   * a NUL.
   */
      void
! screen_puts_len(text, textlen, row, col, attr)
!     char_u	*text;
!     int		textlen;
!     int		row;
!     int		col;
!     int		attr;
  {
      unsigned	off;
      char_u	*ptr = text;
--- 7167,7178 ----
   * a NUL.
   */
      void
! screen_puts_len(
!     char_u	*text,
!     int		textlen,
!     int		row,
!     int		col,
!     int		attr)
  {
      unsigned	off;
      char_u	*ptr = text;
***************
*** 7503,7509 ****
   * Prepare for 'hlsearch' highlighting.
   */
      static void
! start_search_hl()
  {
      if (p_hls && !no_hlsearch)
      {
--- 7456,7462 ----
   * Prepare for 'hlsearch' highlighting.
   */
      static void
! start_search_hl(void)
  {
      if (p_hls && !no_hlsearch)
      {
***************
*** 7520,7526 ****
   * Clean up for 'hlsearch' highlighting.
   */
      static void
! end_search_hl()
  {
      if (search_hl.rm.regprog != NULL)
      {
--- 7473,7479 ----
   * Clean up for 'hlsearch' highlighting.
   */
      static void
! end_search_hl(void)
  {
      if (search_hl.rm.regprog != NULL)
      {
***************
*** 7533,7540 ****
   * Init for calling prepare_search_hl().
   */
      static void
! init_search_hl(wp)
!     win_T	*wp;
  {
      matchitem_T *cur;
  
--- 7486,7492 ----
   * Init for calling prepare_search_hl().
   */
      static void
! init_search_hl(win_T *wp)
  {
      matchitem_T *cur;
  
***************
*** 7567,7575 ****
   * Advance to the match in window "wp" line "lnum" or past it.
   */
      static void
! prepare_search_hl(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      matchitem_T *cur;		/* points to the match list */
      match_T	*shl;		/* points to search_hl or a match */
--- 7519,7525 ----
   * Advance to the match in window "wp" line "lnum" or past it.
   */
      static void
! prepare_search_hl(win_T *wp, linenr_T lnum)
  {
      matchitem_T *cur;		/* points to the match list */
      match_T	*shl;		/* points to search_hl or a match */
***************
*** 7649,7660 ****
   * Careful: Any pointers for buffer lines will become invalid.
   */
      static void
! next_search_hl(win, shl, lnum, mincol, cur)
!     win_T	    *win;
!     match_T	    *shl;	/* points to search_hl or a match */
!     linenr_T	    lnum;
!     colnr_T	    mincol;	/* minimal column for a match */
!     matchitem_T	    *cur;	/* to retrieve match positions if any */
  {
      linenr_T	l;
      colnr_T	matchcol;
--- 7599,7610 ----
   * Careful: Any pointers for buffer lines will become invalid.
   */
      static void
! next_search_hl(
!     win_T	    *win,
!     match_T	    *shl,	/* points to search_hl or a match */
!     linenr_T	    lnum,
!     colnr_T	    mincol,	/* minimal column for a match */
!     matchitem_T	    *cur)	/* to retrieve match positions if any */
  {
      linenr_T	l;
      colnr_T	matchcol;
***************
*** 7779,7789 ****
  }
  
      static int
! next_search_hl_pos(shl, lnum, posmatch, mincol)
!     match_T	    *shl;	/* points to a match */
!     linenr_T	    lnum;
!     posmatch_T	    *posmatch;	/* match positions */
!     colnr_T	    mincol;	/* minimal column for a match */
  {
      int	    i;
      int	    bot = -1;
--- 7729,7739 ----
  }
  
      static int
! next_search_hl_pos(
!     match_T	    *shl,	/* points to a match */
!     linenr_T	    lnum,
!     posmatch_T	    *posmatch,	/* match positions */
!     colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
      int	    bot = -1;
***************
*** 7836,7843 ****
  #endif
  
        static void
! screen_start_highlight(attr)
!       int	attr;
  {
      attrentry_T *aep = NULL;
  
--- 7786,7792 ----
  #endif
  
        static void
! screen_start_highlight(int attr)
  {
      attrentry_T *aep = NULL;
  
***************
*** 7912,7918 ****
  }
  
        void
! screen_stop_highlight()
  {
      int	    do_ME = FALSE;	    /* output T_ME code */
  
--- 7861,7867 ----
  }
  
        void
! screen_stop_highlight(void)
  {
      int	    do_ME = FALSE;	    /* output T_ME code */
  
***************
*** 8013,8019 ****
   * The machine specific code may override this again.
   */
      void
! reset_cterm_colors()
  {
      if (t_colors > 1)
      {
--- 7962,7968 ----
   * The machine specific code may override this again.
   */
      void
! reset_cterm_colors(void)
  {
      if (t_colors > 1)
      {
***************
*** 8036,8045 ****
   * using the attributes from ScreenAttrs["off"].
   */
      static void
! screen_char(off, row, col)
!     unsigned	off;
!     int		row;
!     int		col;
  {
      int		attr;
  
--- 7985,7991 ----
   * using the attributes from ScreenAttrs["off"].
   */
      static void
! screen_char(unsigned off, int row, int col)
  {
      int		attr;
  
***************
*** 8119,8128 ****
   * output the two bytes of a double-byte character with nothing in between.
   */
      static void
! screen_char_2(off, row, col)
!     unsigned	off;
!     int		row;
!     int		col;
  {
      /* Check for illegal values (could be wrong when screen was resized). */
      if (off + 1 >= (unsigned)(screen_Rows * screen_Columns))
--- 8065,8071 ----
   * output the two bytes of a double-byte character with nothing in between.
   */
      static void
! screen_char_2(unsigned off, int row, int col)
  {
      /* Check for illegal values (could be wrong when screen was resized). */
      if (off + 1 >= (unsigned)(screen_Rows * screen_Columns))
***************
*** 8150,8161 ****
   * This uses the contents of ScreenLines[] and doesn't change it.
   */
      void
! screen_draw_rectangle(row, col, height, width, invert)
!     int		row;
!     int		col;
!     int		height;
!     int		width;
!     int		invert;
  {
      int		r, c;
      int		off;
--- 8093,8104 ----
   * This uses the contents of ScreenLines[] and doesn't change it.
   */
      void
! screen_draw_rectangle(
!     int		row,
!     int		col,
!     int		height,
!     int		width,
!     int		invert)
  {
      int		r, c;
      int		off;
***************
*** 8203,8212 ****
   * Redraw the characters for a vertically split window.
   */
      static void
! redraw_block(row, end, wp)
!     int		row;
!     int		end;
!     win_T	*wp;
  {
      int		col;
      int		width;
--- 8146,8152 ----
   * Redraw the characters for a vertically split window.
   */
      static void
! redraw_block(int row, int end, win_T *wp)
  {
      int		col;
      int		width;
***************
*** 8235,8245 ****
   * Use attributes 'attr'.
   */
      void
! screen_fill(start_row, end_row, start_col, end_col, c1, c2, attr)
!     int	    start_row, end_row;
!     int	    start_col, end_col;
!     int	    c1, c2;
!     int	    attr;
  {
      int		    row;
      int		    col;
--- 8175,8188 ----
   * Use attributes 'attr'.
   */
      void
! screen_fill(
!     int	    start_row,
!     int	    end_row,
!     int	    start_col,
!     int	    end_col,
!     int	    c1,
!     int	    c2,
!     int	    attr)
  {
      int		    row;
      int		    col;
***************
*** 8426,8433 ****
   * screen or the command line.
   */
      void
! check_for_delay(check_msg_scroll)
!     int	    check_msg_scroll;
  {
      if ((emsg_on_display || (check_msg_scroll && msg_scroll))
  	    && !did_wait_return
--- 8369,8375 ----
   * screen or the command line.
   */
      void
! check_for_delay(int check_msg_scroll)
  {
      if ((emsg_on_display || (check_msg_scroll && msg_scroll))
  	    && !did_wait_return
***************
*** 8448,8455 ****
   *	Returns FALSE when starting up and screen not initialized yet.
   */
      int
! screen_valid(doclear)
!     int	    doclear;
  {
      screenalloc(doclear);	   /* allocate screen buffers if size changed */
      return (ScreenLines != NULL);
--- 8390,8396 ----
   *	Returns FALSE when starting up and screen not initialized yet.
   */
      int
! screen_valid(int doclear)
  {
      screenalloc(doclear);	   /* allocate screen buffers if size changed */
      return (ScreenLines != NULL);
***************
*** 8466,8473 ****
   * final size of the shell is needed.
   */
      void
! screenalloc(doclear)
!     int	    doclear;
  {
      int		    new_row, old_row;
  #ifdef FEAT_GUI
--- 8407,8413 ----
   * final size of the shell is needed.
   */
      void
! screenalloc(int doclear)
  {
      int		    new_row, old_row;
  #ifdef FEAT_GUI
***************
*** 8795,8801 ****
  }
  
      void
! free_screenlines()
  {
  #ifdef FEAT_MBYTE
      int		i;
--- 8735,8741 ----
  }
  
      void
! free_screenlines(void)
  {
  #ifdef FEAT_MBYTE
      int		i;
***************
*** 8815,8821 ****
  }
  
      void
! screenclear()
  {
      check_for_delay(FALSE);
      screenalloc(FALSE);	    /* allocate screen buffers if size changed */
--- 8755,8761 ----
  }
  
      void
! screenclear(void)
  {
      check_for_delay(FALSE);
      screenalloc(FALSE);	    /* allocate screen buffers if size changed */
***************
*** 8823,8829 ****
  }
  
      static void
! screenclear2()
  {
      int	    i;
  
--- 8763,8769 ----
  }
  
      static void
! screenclear2(void)
  {
      int	    i;
  
***************
*** 8888,8896 ****
   * Clear one line in ScreenLines.
   */
      static void
! lineclear(off, width)
!     unsigned	off;
!     int		width;
  {
      (void)vim_memset(ScreenLines + off, ' ', (size_t)width * sizeof(schar_T));
  #ifdef FEAT_MBYTE
--- 8828,8834 ----
   * Clear one line in ScreenLines.
   */
      static void
! lineclear(unsigned off, int width)
  {
      (void)vim_memset(ScreenLines + off, ' ', (size_t)width * sizeof(schar_T));
  #ifdef FEAT_MBYTE
***************
*** 8906,8914 ****
   * invalid value.
   */
      static void
! lineinvalid(off, width)
!     unsigned	off;
!     int		width;
  {
      (void)vim_memset(ScreenAttrs + off, -1, (size_t)width * sizeof(sattr_T));
  }
--- 8844,8850 ----
   * invalid value.
   */
      static void
! lineinvalid(unsigned off, int width)
  {
      (void)vim_memset(ScreenAttrs + off, -1, (size_t)width * sizeof(sattr_T));
  }
***************
*** 8918,8927 ****
   * Copy part of a Screenline for vertically split window "wp".
   */
      static void
! linecopy(to, from, wp)
!     int		to;
!     int		from;
!     win_T	*wp;
  {
      unsigned	off_to = LineOffset[to] + wp->w_wincol;
      unsigned	off_from = LineOffset[from] + wp->w_wincol;
--- 8854,8860 ----
   * Copy part of a Screenline for vertically split window "wp".
   */
      static void
! linecopy(int to, int from, win_T *wp)
  {
      unsigned	off_to = LineOffset[to] + wp->w_wincol;
      unsigned	off_from = LineOffset[from] + wp->w_wincol;
***************
*** 8953,8960 ****
   * It can't work when the string is empty or it won't set the right background.
   */
      int
! can_clear(p)
!     char_u	*p;
  {
      return (*p != NUL && (t_colors <= 1
  #ifdef FEAT_GUI
--- 8886,8892 ----
   * It can't work when the string is empty or it won't set the right background.
   */
      int
! can_clear(char_u *p)
  {
      return (*p != NUL && (t_colors <= 1
  #ifdef FEAT_GUI
***************
*** 8969,8975 ****
   * code.
   */
      void
! screen_start()
  {
      screen_cur_row = screen_cur_col = 9999;
  }
--- 8901,8907 ----
   * code.
   */
      void
! screen_start(void)
  {
      screen_cur_row = screen_cur_col = 9999;
  }
***************
*** 8980,8988 ****
   * characters sent to the terminal.
   */
      void
! windgoto(row, col)
!     int	    row;
!     int	    col;
  {
      sattr_T	    *p;
      int		    i;
--- 8912,8918 ----
   * characters sent to the terminal.
   */
      void
! windgoto(int row, int col)
  {
      sattr_T	    *p;
      int		    i;
***************
*** 9234,9240 ****
   * Set cursor to its position in the current window.
   */
      void
! setcursor()
  {
      if (redrawing())
      {
--- 9164,9170 ----
   * Set cursor to its position in the current window.
   */
      void
! setcursor(void)
  {
      if (redrawing())
      {
***************
*** 9265,9276 ****
   * Returns FAIL if the lines are not inserted, OK for success.
   */
      int
! win_ins_lines(wp, row, line_count, invalid, mayclear)
!     win_T	*wp;
!     int		row;
!     int		line_count;
!     int		invalid;
!     int		mayclear;
  {
      int		did_delete;
      int		nextrow;
--- 9195,9206 ----
   * Returns FAIL if the lines are not inserted, OK for success.
   */
      int
! win_ins_lines(
!     win_T	*wp,
!     int		row,
!     int		line_count,
!     int		invalid,
!     int		mayclear)
  {
      int		did_delete;
      int		nextrow;
***************
*** 9350,9361 ****
   * Return OK for success, FAIL if the lines are not deleted.
   */
      int
! win_del_lines(wp, row, line_count, invalid, mayclear)
!     win_T	*wp;
!     int		row;
!     int		line_count;
!     int		invalid;
!     int		mayclear;
  {
      int		retval;
  
--- 9280,9291 ----
   * Return OK for success, FAIL if the lines are not deleted.
   */
      int
! win_del_lines(
!     win_T	*wp,
!     int		row,
!     int		line_count,
!     int		invalid,
!     int		mayclear)
  {
      int		retval;
  
***************
*** 9403,9414 ****
   * Returns MAYBE when not finished yet.
   */
      static int
! win_do_lines(wp, row, line_count, mayclear, del)
!     win_T	*wp;
!     int		row;
!     int		line_count;
!     int		mayclear;
!     int		del;
  {
      int		retval;
  
--- 9333,9344 ----
   * Returns MAYBE when not finished yet.
   */
      static int
! win_do_lines(
!     win_T	*wp,
!     int		row,
!     int		line_count,
!     int		mayclear,
!     int		del)
  {
      int		retval;
  
***************
*** 9487,9494 ****
   * window 'wp' and everything after it is messed up, mark it for redraw
   */
      static void
! win_rest_invalid(wp)
!     win_T	*wp;
  {
  #ifdef FEAT_WINDOWS
      while (wp != NULL)
--- 9417,9423 ----
   * window 'wp' and everything after it is messed up, mark it for redraw
   */
      static void
! win_rest_invalid(win_T *wp)
  {
  #ifdef FEAT_WINDOWS
      while (wp != NULL)
***************
*** 9537,9548 ****
   * return FAIL for failure, OK for success.
   */
      int
! screen_ins_lines(off, row, line_count, end, wp)
!     int		off;
!     int		row;
!     int		line_count;
!     int		end;
!     win_T	*wp;	    /* NULL or window to use width from */
  {
      int		i;
      int		j;
--- 9466,9477 ----
   * return FAIL for failure, OK for success.
   */
      int
! screen_ins_lines(
!     int		off,
!     int		row,
!     int		line_count,
!     int		end,
!     win_T	*wp)	    /* NULL or window to use width from */
  {
      int		i;
      int		j;
***************
*** 9752,9764 ****
   * Return OK for success, FAIL if the lines are not deleted.
   */
      int
! screen_del_lines(off, row, line_count, end, force, wp)
!     int		off;
!     int		row;
!     int		line_count;
!     int		end;
!     int		force;		/* even when line_count > p_ttyscroll */
!     win_T	*wp UNUSED;	/* NULL or window to use width from */
  {
      int		j;
      int		i;
--- 9681,9693 ----
   * Return OK for success, FAIL if the lines are not deleted.
   */
      int
! screen_del_lines(
!     int		off,
!     int		row,
!     int		line_count,
!     int		end,
!     int		force,		/* even when line_count > p_ttyscroll */
!     win_T	*wp UNUSED)	/* NULL or window to use width from */
  {
      int		j;
      int		i;
***************
*** 10000,10006 ****
   * Return the length of the message (0 if no message).
   */
      int
! showmode()
  {
      int		need_clear;
      int		length = 0;
--- 9929,9935 ----
   * Return the length of the message (0 if no message).
   */
      int
! showmode(void)
  {
      int		need_clear;
      int		length = 0;
***************
*** 10219,10225 ****
   * Position for a mode message.
   */
      static void
! msg_pos_mode()
  {
      msg_col = 0;
      msg_row = Rows - 1;
--- 10148,10154 ----
   * Position for a mode message.
   */
      static void
! msg_pos_mode(void)
  {
      msg_col = 0;
      msg_row = Rows - 1;
***************
*** 10231,10238 ****
   * Caller should check "mode_displayed".
   */
      void
! unshowmode(force)
!     int	    force;
  {
      /*
       * Don't delete it right now, when not redrawing or inside a mapping.
--- 10160,10166 ----
   * Caller should check "mode_displayed".
   */
      void
! unshowmode(int force)
  {
      /*
       * Don't delete it right now, when not redrawing or inside a mapping.
***************
*** 10249,10256 ****
  }
  
      static void
! recording_mode(attr)
!     int attr;
  {
      MSG_PUTS_ATTR(_("recording"), attr);
      if (!shortmess(SHM_RECORDING))
--- 10177,10183 ----
  }
  
      static void
! recording_mode(int attr)
  {
      MSG_PUTS_ATTR(_("recording"), attr);
      if (!shortmess(SHM_RECORDING))
***************
*** 10266,10272 ****
   * Draw the tab pages line at the top of the Vim window.
   */
      static void
! draw_tabline()
  {
      int		tabcount = 0;
      tabpage_T	*tp;
--- 10193,10199 ----
   * Draw the tab pages line at the top of the Vim window.
   */
      static void
! draw_tabline(void)
  {
      int		tabcount = 0;
      tabpage_T	*tp;
***************
*** 10451,10458 ****
   * Takes care of special buffer names and translates special characters.
   */
      void
! get_trans_bufname(buf)
!     buf_T	*buf;
  {
      if (buf_spname(buf) != NULL)
  	vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);
--- 10378,10384 ----
   * Takes care of special buffer names and translates special characters.
   */
      void
! get_trans_bufname(buf_T *buf)
  {
      if (buf_spname(buf) != NULL)
  	vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);
***************
*** 10467,10475 ****
   * Get the character to use in a status line.  Get its attributes in "*attr".
   */
      static int
! fillchar_status(attr, is_curwin)
!     int		*attr;
!     int		is_curwin;
  {
      int fill;
      if (is_curwin)
--- 10393,10399 ----
   * Get the character to use in a status line.  Get its attributes in "*attr".
   */
      static int
! fillchar_status(int *attr, int is_curwin)
  {
      int fill;
      if (is_curwin)
***************
*** 10501,10508 ****
   * Get its attributes in "*attr".
   */
      static int
! fillchar_vsep(attr)
!     int	    *attr;
  {
      *attr = hl_attr(HLF_C);
      if (*attr == 0 && fill_vert == ' ')
--- 10425,10431 ----
   * Get its attributes in "*attr".
   */
      static int
! fillchar_vsep(int *attr)
  {
      *attr = hl_attr(HLF_C);
      if (*attr == 0 && fill_vert == ' ')
***************
*** 10516,10522 ****
   * Return TRUE if redrawing should currently be done.
   */
      int
! redrawing()
  {
      return (!RedrawingDisabled
  		       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));
--- 10439,10445 ----
   * Return TRUE if redrawing should currently be done.
   */
      int
! redrawing(void)
  {
      return (!RedrawingDisabled
  		       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));
***************
*** 10526,10532 ****
   * Return TRUE if printing messages should currently be done.
   */
      int
! messaging()
  {
      return (!(p_lz && char_avail() && !KeyTyped));
  }
--- 10449,10455 ----
   * Return TRUE if printing messages should currently be done.
   */
      int
! messaging(void)
  {
      return (!(p_lz && char_avail() && !KeyTyped));
  }
***************
*** 10536,10543 ****
   * If always is FALSE, only show ruler if position has changed.
   */
      void
! showruler(always)
!     int	    always;
  {
      if (!always && !redrawing())
  	return;
--- 10459,10465 ----
   * If always is FALSE, only show ruler if position has changed.
   */
      void
! showruler(int always)
  {
      if (!always && !redrawing())
  	return;
***************
*** 10580,10588 ****
  
  #ifdef FEAT_CMDL_INFO
      static void
! win_redr_ruler(wp, always)
!     win_T	*wp;
!     int		always;
  {
  #define RULER_BUF_LEN 70
      char_u	buffer[RULER_BUF_LEN];
--- 10502,10508 ----
  
  #ifdef FEAT_CMDL_INFO
      static void
! win_redr_ruler(win_T *wp, int always)
  {
  #define RULER_BUF_LEN 70
      char_u	buffer[RULER_BUF_LEN];
***************
*** 10799,10806 ****
   * Otherwise it depends on 'numberwidth' and the line count.
   */
      int
! number_width(wp)
!     win_T	*wp;
  {
      int		n;
      linenr_T	lnum;
--- 10719,10725 ----
   * Otherwise it depends on 'numberwidth' and the line count.
   */
      int
! number_width(win_T *wp)
  {
      int		n;
      linenr_T	lnum;
***************
*** 10838,10844 ****
   * screen. First column is 0.
   */
      int
! screen_screencol()
  {
      return screen_cur_col;
  }
--- 10757,10763 ----
   * screen. First column is 0.
   */
      int
! screen_screencol(void)
  {
      return screen_cur_col;
  }
***************
*** 10848,10854 ****
   * First row is 0.
   */
      int
! screen_screenrow()
  {
      return screen_cur_row;
  }
--- 10767,10773 ----
   * First row is 0.
   */
      int
! screen_screenrow(void)
  {
      return screen_cur_row;
  }
*** ../vim-7.4.1212/src/version.c	2016-01-30 19:45:44.054087595 +0100
--- src/version.c	2016-01-30 19:47:12.077167591 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1213,
  /**/

-- 
In order for something to become clean, something else must become dirty;
but you can get everything dirty without getting anything clean.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
