To: vim_dev@googlegroups.com
Subject: Patch 7.4.1214
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1214
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/search.c, src/sha256.c, src/spell.c, src/syntax.c, src/tag.c,
            src/term.c, src/termlib.c, src/ui.c, src/undo.c


*** ../vim-7.4.1213/src/search.c	2016-01-29 22:46:58.966534817 +0100
--- src/search.c	2016-01-30 20:35:20.187123541 +0100
***************
*** 140,151 ****
   * returns FAIL if failed, OK otherwise.
   */
      int
! search_regcomp(pat, pat_save, pat_use, options, regmatch)
!     char_u	*pat;
!     int		pat_save;
!     int		pat_use;
!     int		options;
!     regmmatch_T	*regmatch;	/* return: pattern and ignore-case flag */
  {
      int		magic;
      int		i;
--- 140,151 ----
   * returns FAIL if failed, OK otherwise.
   */
      int
! search_regcomp(
!     char_u	*pat,
!     int		pat_save,
!     int		pat_use,
!     int		options,
!     regmmatch_T	*regmatch)	/* return: pattern and ignore-case flag */
  {
      int		magic;
      int		i;
***************
*** 230,236 ****
   * Get search pattern used by search_regcomp().
   */
      char_u *
! get_search_pat()
  {
      return mr_pattern;
  }
--- 230,236 ----
   * Get search pattern used by search_regcomp().
   */
      char_u *
! get_search_pat(void)
  {
      return mr_pattern;
  }
***************
*** 241,248 ****
   * Returns the allocated string, NULL when out of memory.
   */
      char_u *
! reverse_text(s)
!     char_u *s;
  {
      unsigned	len;
      unsigned	s_i, rev_i;
--- 241,247 ----
   * Returns the allocated string, NULL when out of memory.
   */
      char_u *
! reverse_text(char_u *s)
  {
      unsigned	len;
      unsigned	s_i, rev_i;
***************
*** 280,289 ****
  #endif
  
      void
! save_re_pat(idx, pat, magic)
!     int		idx;
!     char_u	*pat;
!     int		magic;
  {
      if (spats[idx].pat != pat)
      {
--- 279,285 ----
  #endif
  
      void
! save_re_pat(int idx, char_u *pat, int magic)
  {
      if (spats[idx].pat != pat)
      {
***************
*** 309,315 ****
  static int save_level = 0;
  
      void
! save_search_patterns()
  {
      if (save_level++ == 0)
      {
--- 305,311 ----
  static int save_level = 0;
  
      void
! save_search_patterns(void)
  {
      if (save_level++ == 0)
      {
***************
*** 327,333 ****
  }
  
      void
! restore_search_patterns()
  {
      if (--save_level == 0)
      {
--- 323,329 ----
  }
  
      void
! restore_search_patterns(void)
  {
      if (--save_level == 0)
      {
***************
*** 348,354 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_search_patterns()
  {
      vim_free(spats[0].pat);
      vim_free(spats[1].pat);
--- 344,350 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_search_patterns(void)
  {
      vim_free(spats[0].pat);
      vim_free(spats[1].pat);
***************
*** 369,376 ****
   * Uses the 'ignorecase' and 'smartcase' options.
   */
      int
! ignorecase(pat)
!     char_u	*pat;
  {
      int		ic = p_ic;
  
--- 365,371 ----
   * Uses the 'ignorecase' and 'smartcase' options.
   */
      int
! ignorecase(char_u *pat)
  {
      int		ic = p_ic;
  
***************
*** 389,396 ****
   * Return TRUE if pattern "pat" has an uppercase character.
   */
      int
! pat_has_uppercase(pat)
!     char_u	*pat;
  {
      char_u *p = pat;
  
--- 384,390 ----
   * Return TRUE if pattern "pat" has an uppercase character.
   */
      int
! pat_has_uppercase(char_u *pat)
  {
      char_u *p = pat;
  
***************
*** 427,433 ****
  }
  
      char_u *
! last_csearch()
  {
  #ifdef FEAT_MBYTE
      return lastc_bytes;
--- 421,427 ----
  }
  
      char_u *
! last_csearch(void)
  {
  #ifdef FEAT_MBYTE
      return lastc_bytes;
***************
*** 437,458 ****
  }
  
      int
! last_csearch_forward()
  {
      return lastcdir == FORWARD;
  }
  
      int
! last_csearch_until()
  {
      return last_t_cmd == TRUE;
  }
  
      void
! set_last_csearch(c, s, len)
!     int		c;
!     char_u	*s UNUSED;
!     int		len UNUSED;
  {
      *lastc = c;
  #ifdef FEAT_MBYTE
--- 431,449 ----
  }
  
      int
! last_csearch_forward(void)
  {
      return lastcdir == FORWARD;
  }
  
      int
! last_csearch_until(void)
  {
      return last_t_cmd == TRUE;
  }
  
      void
! set_last_csearch(int c, char_u *s UNUSED, int len UNUSED)
  {
      *lastc = c;
  #ifdef FEAT_MBYTE
***************
*** 465,485 ****
  }
  
      void
! set_csearch_direction(cdir)
!     int cdir;
  {
      lastcdir = cdir;
  }
  
      void
! set_csearch_until(t_cmd)
!     int t_cmd;
  {
      last_t_cmd = t_cmd;
  }
  
      char_u *
! last_search_pat()
  {
      return spats[last_idx].pat;
  }
--- 456,474 ----
  }
  
      void
! set_csearch_direction(int cdir)
  {
      lastcdir = cdir;
  }
  
      void
! set_csearch_until(int t_cmd)
  {
      last_t_cmd = t_cmd;
  }
  
      char_u *
! last_search_pat(void)
  {
      return spats[last_idx].pat;
  }
***************
*** 488,494 ****
   * Reset search direction to forward.  For "gd" and "gD" commands.
   */
      void
! reset_search_dir()
  {
      spats[0].off.dir = '/';
  #if defined(FEAT_EVAL)
--- 477,483 ----
   * Reset search direction to forward.  For "gd" and "gD" commands.
   */
      void
! reset_search_dir(void)
  {
      spats[0].off.dir = '/';
  #if defined(FEAT_EVAL)
***************
*** 502,512 ****
   * Also set the saved search pattern, so that this works in an autocommand.
   */
      void
! set_last_search_pat(s, idx, magic, setlast)
!     char_u	*s;
!     int		idx;
!     int		magic;
!     int		setlast;
  {
      vim_free(spats[idx].pat);
      /* An empty string means that nothing should be matched. */
--- 491,501 ----
   * Also set the saved search pattern, so that this works in an autocommand.
   */
      void
! set_last_search_pat(
!     char_u	*s,
!     int		idx,
!     int		magic,
!     int		setlast)
  {
      vim_free(spats[idx].pat);
      /* An empty string means that nothing should be matched. */
***************
*** 550,557 ****
   * Values returned in regmatch->regprog and regmatch->rmm_ic.
   */
      void
! last_pat_prog(regmatch)
!     regmmatch_T	*regmatch;
  {
      if (spats[last_idx].pat == NULL)
      {
--- 539,545 ----
   * Values returned in regmatch->regprog and regmatch->rmm_ic.
   */
      void
! last_pat_prog(regmmatch_T *regmatch)
  {
      if (spats[last_idx].pat == NULL)
      {
***************
*** 585,602 ****
   * subpattern plus one; one if there was none.
   */
      int
! searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
!     win_T	*win;		/* window to search in; can be NULL for a
  				   buffer without a window! */
!     buf_T	*buf;
!     pos_T	*pos;
!     int		dir;
!     char_u	*pat;
!     long	count;
!     int		options;
!     int		pat_use;	/* which pattern to use when "pat" is empty */
!     linenr_T	stop_lnum;	/* stop after this line number when != 0 */
!     proftime_T	*tm UNUSED;	/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
--- 573,590 ----
   * subpattern plus one; one if there was none.
   */
      int
! searchit(
!     win_T	*win,		/* window to search in; can be NULL for a
  				   buffer without a window! */
!     buf_T	*buf,
!     pos_T	*pos,
!     int		dir,
!     char_u	*pat,
!     long	count,
!     int		options,
!     int		pat_use,	/* which pattern to use when "pat" is empty */
!     linenr_T	stop_lnum,	/* stop after this line number when != 0 */
!     proftime_T	*tm UNUSED)	/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
***************
*** 1088,1101 ****
  
  #ifdef FEAT_EVAL
      void
! set_search_direction(cdir)
!     int		cdir;
  {
      spats[0].off.dir = cdir;
  }
  
      static void
! set_vv_searchforward()
  {
      set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));
  }
--- 1076,1088 ----
  
  #ifdef FEAT_EVAL
      void
! set_search_direction(int cdir)
  {
      spats[0].off.dir = cdir;
  }
  
      static void
! set_vv_searchforward(void)
  {
      set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));
  }
***************
*** 1105,1112 ****
   * Return zero if none of them matched.
   */
      static int
! first_submatch(rp)
!     regmmatch_T	*rp;
  {
      int		submatch;
  
--- 1092,1098 ----
   * Return zero if none of them matched.
   */
      static int
! first_submatch(regmmatch_T *rp)
  {
      int		submatch;
  
***************
*** 1146,1158 ****
   * Return 0 for failure, 1 for found, 2 for found and line offset added.
   */
      int
! do_search(oap, dirc, pat, count, options, tm)
!     oparg_T	    *oap;	/* can be NULL */
!     int		    dirc;	/* '/' or '?' */
!     char_u	    *pat;
!     long	    count;
!     int		    options;
!     proftime_T	    *tm;	/* timeout limit or NULL */
  {
      pos_T	    pos;	/* position of the last match */
      char_u	    *searchstr;
--- 1132,1144 ----
   * Return 0 for failure, 1 for found, 2 for found and line offset added.
   */
      int
! do_search(
!     oparg_T	    *oap,	/* can be NULL */
!     int		    dirc,	/* '/' or '?' */
!     char_u	    *pat,
!     long	    count,
!     int		    options,
!     proftime_T	    *tm)	/* timeout limit or NULL */
  {
      pos_T	    pos;	/* position of the last match */
      char_u	    *searchstr;
***************
*** 1536,1546 ****
   * Return OK for success, or FAIL if no line found.
   */
      int
! search_for_exact_line(buf, pos, dir, pat)
!     buf_T	*buf;
!     pos_T	*pos;
!     int		dir;
!     char_u	*pat;
  {
      linenr_T	start = 0;
      char_u	*ptr;
--- 1522,1532 ----
   * Return OK for success, or FAIL if no line found.
   */
      int
! search_for_exact_line(
!     buf_T	*buf,
!     pos_T	*pos,
!     int		dir,
!     char_u	*pat)
  {
      linenr_T	start = 0;
      char_u	*ptr;
***************
*** 1617,1625 ****
   * Return FAIL or OK.
   */
      int
! searchc(cap, t_cmd)
!     cmdarg_T	*cap;
!     int		t_cmd;
  {
      int			c = cap->nchar;	/* char to search for */
      int			dir = cap->arg;	/* TRUE for searching forward */
--- 1603,1609 ----
   * Return FAIL or OK.
   */
      int
! searchc(cmdarg_T *cap, int t_cmd)
  {
      int			c = cap->nchar;	/* char to search for */
      int			dir = cap->arg;	/* TRUE for searching forward */
***************
*** 1754,1762 ****
   * Improvement over vi: Braces inside quotes are ignored.
   */
      pos_T *
! findmatch(oap, initc)
!     oparg_T   *oap;
!     int	    initc;
  {
      return findmatchlimit(oap, initc, 0, 0);
  }
--- 1738,1744 ----
   * Improvement over vi: Braces inside quotes are ignored.
   */
      pos_T *
! findmatch(oparg_T *oap, int initc)
  {
      return findmatchlimit(oap, initc, 0, 0);
  }
***************
*** 1769,1779 ****
   * Handles multibyte string correctly.
   */
      static int
! check_prevcol(linep, col, ch, prevcol)
!     char_u	*linep;
!     int		col;
!     int		ch;
!     int		*prevcol;
  {
      --col;
  #ifdef FEAT_MBYTE
--- 1751,1761 ----
   * Handles multibyte string correctly.
   */
      static int
! check_prevcol(
!     char_u	*linep,
!     int		col,
!     int		ch,
!     int		*prevcol)
  {
      --col;
  #ifdef FEAT_MBYTE
***************
*** 1792,1801 ****
   * Return TRUE if the matching end can be found between startpos and endpos.
   */
      static int
! find_rawstring_end(linep, startpos, endpos)
!     char_u  *linep;
!     pos_T   *startpos;
!     pos_T   *endpos;
  {
      char_u	*p;
      char_u	*delim_copy;
--- 1774,1780 ----
   * Return TRUE if the matching end can be found between startpos and endpos.
   */
      static int
! find_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)
  {
      char_u	*p;
      char_u	*delim_copy;
***************
*** 1854,1864 ****
   */
  
      pos_T *
! findmatchlimit(oap, initc, flags, maxtravel)
!     oparg_T	*oap;
!     int		initc;
!     int		flags;
!     int		maxtravel;
  {
      static pos_T pos;			/* current search position */
      int		findc = 0;		/* matching brace */
--- 1833,1843 ----
   */
  
      pos_T *
! findmatchlimit(
!     oparg_T	*oap,
!     int		initc,
!     int		flags,
!     int		maxtravel)
  {
      static pos_T pos;			/* current search position */
      int		findc = 0;		/* matching brace */
***************
*** 2504,2511 ****
   * TODO: skip strings.
   */
      static int
! check_linecomment(line)
!     char_u	*line;
  {
      char_u  *p;
  
--- 2483,2489 ----
   * TODO: skip strings.
   */
      static int
! check_linecomment(char_u *line)
  {
      char_u  *p;
  
***************
*** 2565,2572 ****
   * If there isn't a match, then beep.
   */
      void
! showmatch(c)
!     int		c;	    /* char to show match for */
  {
      pos_T	*lpos, save_cursor;
      pos_T	mpos;
--- 2543,2550 ----
   * If there isn't a match, then beep.
   */
      void
! showmatch(
!     int		c)	    /* char to show match for */
  {
      pos_T	*lpos, save_cursor;
      pos_T	mpos;
***************
*** 2672,2680 ****
   * Return OK if the next sentence was found.
   */
      int
! findsent(dir, count)
!     int		dir;
!     long	count;
  {
      pos_T	pos, tpos;
      int		c;
--- 2650,2656 ----
   * Return OK if the next sentence was found.
   */
      int
! findsent(int dir, long count)
  {
      pos_T	pos, tpos;
      int		c;
***************
*** 2801,2812 ****
   * Return TRUE if the next paragraph or section was found.
   */
      int
! findpar(pincl, dir, count, what, both)
!     int		*pincl;	    /* Return: TRUE if last char is to be included */
!     int		dir;
!     long	count;
!     int		what;
!     int		both;
  {
      linenr_T	curr;
      int		did_skip;   /* TRUE after separating lines have been skipped */
--- 2777,2788 ----
   * Return TRUE if the next paragraph or section was found.
   */
      int
! findpar(
!     int		*pincl,	    /* Return: TRUE if last char is to be included */
!     int		dir,
!     long	count,
!     int		what,
!     int		both)
  {
      linenr_T	curr;
      int		did_skip;   /* TRUE after separating lines have been skipped */
***************
*** 2880,2888 ****
   * check if the string 's' is a nroff macro that is in option 'opt'
   */
      static int
! inmacro(opt, s)
!     char_u	*opt;
!     char_u	*s;
  {
      char_u	*macro;
  
--- 2856,2862 ----
   * check if the string 's' is a nroff macro that is in option 'opt'
   */
      static int
! inmacro(char_u *opt, char_u *s)
  {
      char_u	*macro;
  
***************
*** 2911,2920 ****
   * If 'both' is TRUE also stop at '}'
   */
      int
! startPS(lnum, para, both)
!     linenr_T	lnum;
!     int		para;
!     int		both;
  {
      char_u	*s;
  
--- 2885,2891 ----
   * If 'both' is TRUE also stop at '}'
   */
      int
! startPS(linenr_T lnum, int para, int both)
  {
      char_u	*s;
  
***************
*** 2953,2959 ****
   * boundaries are of interest.
   */
      static int
! cls()
  {
      int	    c;
  
--- 2924,2930 ----
   * boundaries are of interest.
   */
      static int
! cls(void)
  {
      int	    c;
  
***************
*** 3000,3009 ****
   * If eol is TRUE, last word stops at end of line (for operators).
   */
      int
! fwd_word(count, bigword, eol)
!     long	count;
!     int		bigword;    /* "W", "E" or "B" */
!     int		eol;
  {
      int		sclass;	    /* starting class */
      int		i;
--- 2971,2980 ----
   * If eol is TRUE, last word stops at end of line (for operators).
   */
      int
! fwd_word(
!     long	count,
!     int		bigword,    /* "W", "E" or "B" */
!     int		eol)
  {
      int		sclass;	    /* starting class */
      int		i;
***************
*** 3072,3081 ****
   * Returns FAIL if top of the file was reached.
   */
      int
! bck_word(count, bigword, stop)
!     long	count;
!     int		bigword;
!     int		stop;
  {
      int		sclass;	    /* starting class */
  
--- 3043,3049 ----
   * Returns FAIL if top of the file was reached.
   */
      int
! bck_word(long count, int bigword, int stop)
  {
      int		sclass;	    /* starting class */
  
***************
*** 3140,3150 ****
   * If empty is TRUE stop on an empty line.
   */
      int
! end_word(count, bigword, stop, empty)
!     long	count;
!     int		bigword;
!     int		stop;
!     int		empty;
  {
      int		sclass;	    /* starting class */
  
--- 3108,3118 ----
   * If empty is TRUE stop on an empty line.
   */
      int
! end_word(
!     long	count,
!     int		bigword,
!     int		stop,
!     int		empty)
  {
      int		sclass;	    /* starting class */
  
***************
*** 3210,3219 ****
   * Returns FAIL if start of the file was reached.
   */
      int
! bckend_word(count, bigword, eol)
!     long	count;
!     int		bigword;    /* TRUE for "B" */
!     int		eol;	    /* TRUE: stop at end of line. */
  {
      int		sclass;	    /* starting class */
      int		i;
--- 3178,3187 ----
   * Returns FAIL if start of the file was reached.
   */
      int
! bckend_word(
!     long	count,
!     int		bigword,    /* TRUE for "B" */
!     int		eol)	    /* TRUE: stop at end of line. */
  {
      int		sclass;	    /* starting class */
      int		i;
***************
*** 3259,3267 ****
   * Return TRUE when end-of-file reached, FALSE otherwise.
   */
      static int
! skip_chars(cclass, dir)
!     int		cclass;
!     int		dir;
  {
      while (cls() == cclass)
  	if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)
--- 3227,3233 ----
   * Return TRUE when end-of-file reached, FALSE otherwise.
   */
      static int
! skip_chars(int cclass, int dir)
  {
      while (cls() == cclass)
  	if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)
***************
*** 3274,3280 ****
   * Go back to the start of the word or the start of white space
   */
      static void
! back_in_line()
  {
      int		sclass;		    /* starting class */
  
--- 3240,3246 ----
   * Go back to the start of the word or the start of white space
   */
      static void
! back_in_line(void)
  {
      int		sclass;		    /* starting class */
  
***************
*** 3293,3300 ****
  }
  
      static void
! find_first_blank(posp)
!     pos_T    *posp;
  {
      int	    c;
  
--- 3259,3265 ----
  }
  
      static void
! find_first_blank(pos_T *posp)
  {
      int	    c;
  
***************
*** 3313,3321 ****
   * Skip count/2 sentences and count/2 separating white spaces.
   */
      static void
! findsent_forward(count, at_start_sent)
!     long    count;
!     int	    at_start_sent;	/* cursor is at start of sentence */
  {
      while (count--)
      {
--- 3278,3286 ----
   * Skip count/2 sentences and count/2 separating white spaces.
   */
      static void
! findsent_forward(
!     long    count,
!     int	    at_start_sent)	/* cursor is at start of sentence */
  {
      while (count--)
      {
***************
*** 3333,3343 ****
   * Used while an operator is pending, and in Visual mode.
   */
      int
! current_word(oap, count, include, bigword)
!     oparg_T	*oap;
!     long	count;
!     int		include;	/* TRUE: include word and white space */
!     int		bigword;	/* FALSE == word, TRUE == WORD */
  {
      pos_T	start_pos;
      pos_T	pos;
--- 3298,3308 ----
   * Used while an operator is pending, and in Visual mode.
   */
      int
! current_word(
!     oparg_T	*oap,
!     long	count,
!     int		include,	/* TRUE: include word and white space */
!     int		bigword)	/* FALSE == word, TRUE == WORD */
  {
      pos_T	start_pos;
      pos_T	pos;
***************
*** 3507,3516 ****
   * When Visual active, extend it by one or more sentences.
   */
      int
! current_sent(oap, count, include)
!     oparg_T	*oap;
!     long	count;
!     int		include;
  {
      pos_T	start_pos;
      pos_T	pos;
--- 3472,3478 ----
   * When Visual active, extend it by one or more sentences.
   */
      int
! current_sent(oparg_T *oap, long count, int include)
  {
      pos_T	start_pos;
      pos_T	pos;
***************
*** 3687,3698 ****
   * "what" and "other" are two matching parenthesis/brace/etc.
   */
      int
! current_block(oap, count, include, what, other)
!     oparg_T	*oap;
!     long	count;
!     int		include;	/* TRUE == include white space */
!     int		what;		/* '(', '{', etc. */
!     int		other;		/* ')', '}', etc. */
  {
      pos_T	old_pos;
      pos_T	*pos = NULL;
--- 3649,3660 ----
   * "what" and "other" are two matching parenthesis/brace/etc.
   */
      int
! current_block(
!     oparg_T	*oap,
!     long	count,
!     int		include,	/* TRUE == include white space */
!     int		what,		/* '(', '{', etc. */
!     int		other)		/* ')', '}', etc. */
  {
      pos_T	old_pos;
      pos_T	*pos = NULL;
***************
*** 3838,3845 ****
   * When "end_tag" is TRUE return TRUE if the cursor is on "</aaa>".
   */
      static int
! in_html_tag(end_tag)
!     int		end_tag;
  {
      char_u	*line = ml_get_curline();
      char_u	*p;
--- 3800,3807 ----
   * When "end_tag" is TRUE return TRUE if the cursor is on "</aaa>".
   */
      static int
! in_html_tag(
!     int		end_tag)
  {
      char_u	*line = ml_get_curline();
      char_u	*p;
***************
*** 3911,3920 ****
   * Find tag block under the cursor, cursor at end.
   */
      int
! current_tagblock(oap, count_arg, include)
!     oparg_T	*oap;
!     long	count_arg;
!     int		include;	/* TRUE == include white space */
  {
      long	count = count_arg;
      long	n;
--- 3873,3882 ----
   * Find tag block under the cursor, cursor at end.
   */
      int
! current_tagblock(
!     oparg_T	*oap,
!     long	count_arg,
!     int		include)	/* TRUE == include white space */
  {
      long	count = count_arg;
      long	n;
***************
*** 4117,4127 ****
  }
  
      int
! current_par(oap, count, include, type)
!     oparg_T	*oap;
!     long	count;
!     int		include;	/* TRUE == include white space */
!     int		type;		/* 'p' for paragraph, 'S' for section */
  {
      linenr_T	start_lnum;
      linenr_T	end_lnum;
--- 4079,4089 ----
  }
  
      int
! current_par(
!     oparg_T	*oap,
!     long	count,
!     int		include,	/* TRUE == include white space */
!     int		type)		/* 'p' for paragraph, 'S' for section */
  {
      linenr_T	start_lnum;
      linenr_T	end_lnum;
***************
*** 4296,4306 ****
   * Returns column number of "quotechar" or -1 when not found.
   */
      static int
! find_next_quote(line, col, quotechar, escape)
!     char_u	*line;
!     int		col;
!     int		quotechar;
!     char_u	*escape;	/* escape characters, can be NULL */
  {
      int		c;
  
--- 4258,4268 ----
   * Returns column number of "quotechar" or -1 when not found.
   */
      static int
! find_next_quote(
!     char_u	*line,
!     int		col,
!     int		quotechar,
!     char_u	*escape)	/* escape characters, can be NULL */
  {
      int		c;
  
***************
*** 4330,4340 ****
   * Return the found column or zero.
   */
      static int
! find_prev_quote(line, col_start, quotechar, escape)
!     char_u	*line;
!     int		col_start;
!     int		quotechar;
!     char_u	*escape;	/* escape characters, can be NULL */
  {
      int		n;
  
--- 4292,4302 ----
   * Return the found column or zero.
   */
      static int
! find_prev_quote(
!     char_u	*line,
!     int		col_start,
!     int		quotechar,
!     char_u	*escape)	/* escape characters, can be NULL */
  {
      int		n;
  
***************
*** 4362,4372 ****
   * Returns TRUE if found, else FALSE.
   */
      int
! current_quote(oap, count, include, quotechar)
!     oparg_T	*oap;
!     long	count;
!     int		include;	/* TRUE == include quote char */
!     int		quotechar;	/* Quote character */
  {
      char_u	*line = ml_get_curline();
      int		col_end;
--- 4324,4334 ----
   * Returns TRUE if found, else FALSE.
   */
      int
! current_quote(
!     oparg_T	*oap,
!     long	count,
!     int		include,	/* TRUE == include quote char */
!     int		quotechar)	/* Quote character */
  {
      char_u	*line = ml_get_curline();
      int		col_end;
***************
*** 4605,4613 ****
   * Used while an operator is pending, and in Visual mode.
   */
      int
! current_search(count, forward)
!     long	count;
!     int		forward;	/* move forward or backwards */
  {
      pos_T	start_pos;	/* position before the pattern */
      pos_T	orig_pos;	/* position of the cursor at beginning */
--- 4567,4575 ----
   * Used while an operator is pending, and in Visual mode.
   */
      int
! current_search(
!     long	count,
!     int		forward)	/* move forward or backwards */
  {
      pos_T	start_pos;	/* position before the pattern */
      pos_T	orig_pos;	/* position of the cursor at beginning */
***************
*** 4764,4772 ****
   * Returns TRUE, FALSE or -1 for failure.
   */
      static int
! is_one_char(pattern, move)
!     char_u	*pattern;
!     int		move;
  {
      regmmatch_T	regmatch;
      int		nmatched = 0;
--- 4726,4732 ----
   * Returns TRUE, FALSE or -1 for failure.
   */
      static int
! is_one_char(char_u *pattern, int move)
  {
      regmmatch_T	regmatch;
      int		nmatched = 0;
***************
*** 4818,4825 ****
   * return TRUE if line 'lnum' is empty or has white chars only.
   */
      int
! linewhite(lnum)
!     linenr_T	lnum;
  {
      char_u  *p;
  
--- 4778,4784 ----
   * return TRUE if line 'lnum' is empty or has white chars only.
   */
      int
! linewhite(linenr_T lnum)
  {
      char_u  *p;
  
***************
*** 4834,4852 ****
   * If p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
   */
      void
! find_pattern_in_path(ptr, dir, len, whole, skip_comments,
! 				    type, count, action, start_lnum, end_lnum)
!     char_u	*ptr;		/* pointer to search pattern */
!     int		dir UNUSED;	/* direction of expansion */
!     int		len;		/* length of search pattern */
!     int		whole;		/* match whole words only */
!     int		skip_comments;	/* don't match inside comments */
!     int		type;		/* Type of search; are we looking for a type?
  				   a macro? */
!     long	count;
!     int		action;		/* What to do when we find it */
!     linenr_T	start_lnum;	/* first line to start searching */
!     linenr_T	end_lnum;	/* last line for searching */
  {
      SearchedFile *files;		/* Stack of included files */
      SearchedFile *bigger;		/* When we need more space */
--- 4793,4810 ----
   * If p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
   */
      void
! find_pattern_in_path(
!     char_u	*ptr,		/* pointer to search pattern */
!     int		dir UNUSED,	/* direction of expansion */
!     int		len,		/* length of search pattern */
!     int		whole,		/* match whole words only */
!     int		skip_comments,	/* don't match inside comments */
!     int		type,		/* Type of search; are we looking for a type?
  				   a macro? */
!     long	count,
!     int		action,		/* What to do when we find it */
!     linenr_T	start_lnum,	/* first line to start searching */
!     linenr_T	end_lnum)	/* last line for searching */
  {
      SearchedFile *files;		/* Stack of included files */
      SearchedFile *bigger;		/* When we need more space */
***************
*** 5543,5556 ****
  }
  
      static void
! show_pat_in_path(line, type, did_show, action, fp, lnum, count)
!     char_u  *line;
!     int	    type;
!     int	    did_show;
!     int	    action;
!     FILE    *fp;
!     linenr_T *lnum;
!     long    count;
  {
      char_u  *p;
  
--- 5501,5514 ----
  }
  
      static void
! show_pat_in_path(
!     char_u  *line,
!     int	    type,
!     int	    did_show,
!     int	    action,
!     FILE    *fp,
!     linenr_T *lnum,
!     long    count)
  {
      char_u  *p;
  
***************
*** 5607,5615 ****
  
  #ifdef FEAT_VIMINFO
      int
! read_viminfo_search_pattern(virp, force)
!     vir_T	*virp;
!     int		force;
  {
      char_u	*lp;
      int		idx = -1;
--- 5565,5571 ----
  
  #ifdef FEAT_VIMINFO
      int
! read_viminfo_search_pattern(vir_T *virp, int force)
  {
      char_u	*lp;
      int		idx = -1;
***************
*** 5695,5702 ****
  }
  
      void
! write_viminfo_search_pattern(fp)
!     FILE	*fp;
  {
      if (get_viminfo_parameter('/') != 0)
      {
--- 5651,5657 ----
  }
  
      void
! write_viminfo_search_pattern(FILE *fp)
  {
      if (get_viminfo_parameter('/') != 0)
      {
***************
*** 5710,5720 ****
  }
  
      static void
! wvsp_one(fp, idx, s, sc)
!     FILE	*fp;	/* file to write to */
!     int		idx;	/* spats[] index */
!     char	*s;	/* search pat */
!     int		sc;	/* dir char */
  {
      if (spats[idx].pat != NULL)
      {
--- 5665,5675 ----
  }
  
      static void
! wvsp_one(
!     FILE	*fp,	/* file to write to */
!     int		idx,	/* spats[] index */
!     char	*s,	/* search pat */
!     int		sc)	/* dir char */
  {
      if (spats[idx].pat != NULL)
      {
*** ../vim-7.4.1213/src/sha256.c	2016-01-29 22:46:58.970534775 +0100
--- src/sha256.c	2016-01-30 20:36:25.762441722 +0100
***************
*** 43,50 ****
  }
  
       void
! sha256_start(ctx)
!     context_sha256_T *ctx;
  {
      ctx->total[0] = 0;
      ctx->total[1] = 0;
--- 43,49 ----
  }
  
       void
! sha256_start(context_sha256_T *ctx)
  {
      ctx->total[0] = 0;
      ctx->total[1] = 0;
***************
*** 60,68 ****
  }
  
      static void
! sha256_process(ctx, data)
!     context_sha256_T *ctx;
!     char_u	     data[64];
  {
      UINT32_T temp1, temp2, W[64];
      UINT32_T A, B, C, D, E, F, G, H;
--- 59,65 ----
  }
  
      static void
! sha256_process(context_sha256_T *ctx, char_u data[64])
  {
      UINT32_T temp1, temp2, W[64];
      UINT32_T A, B, C, D, E, F, G, H;
***************
*** 194,203 ****
  }
  
      void
! sha256_update(ctx, input, length)
!     context_sha256_T *ctx;
!     char_u	     *input;
!     UINT32_T	     length;
  {
      UINT32_T left, fill;
  
--- 191,197 ----
  }
  
      void
! sha256_update(context_sha256_T *ctx, char_u *input, UINT32_T length)
  {
      UINT32_T left, fill;
  
***************
*** 241,249 ****
  };
  
      void
! sha256_finish(ctx, digest)
!     context_sha256_T *ctx;
!     char_u	     digest[32];
  {
      UINT32_T last, padn;
      UINT32_T high, low;
--- 235,241 ----
  };
  
      void
! sha256_finish(context_sha256_T *ctx, char_u digest[32])
  {
      UINT32_T last, padn;
      UINT32_T high, low;
***************
*** 280,290 ****
   * if "salt" is not NULL also do "salt[salt_len]".
   */
      char_u *
! sha256_bytes(buf, buf_len, salt, salt_len)
!     char_u *buf;
!     int    buf_len;
!     char_u *salt;
!     int    salt_len;
  {
      char_u	     sha256sum[32];
      static char_u    hexit[65];
--- 272,282 ----
   * if "salt" is not NULL also do "salt[salt_len]".
   */
      char_u *
! sha256_bytes(
!     char_u *buf,
!     int    buf_len,
!     char_u *salt,
!     int    salt_len)
  {
      char_u	     sha256sum[32];
      static char_u    hexit[65];
***************
*** 308,317 ****
   * Returns sha256(buf) as 64 hex chars in static array.
   */
      char_u *
! sha256_key(buf, salt, salt_len)
!     char_u *buf;
!     char_u *salt;
!     int    salt_len;
  {
      /* No passwd means don't encrypt */
      if (buf == NULL || *buf == NUL)
--- 300,309 ----
   * Returns sha256(buf) as 64 hex chars in static array.
   */
      char_u *
! sha256_key(
!     char_u *buf,
!     char_u *salt,
!     int    salt_len)
  {
      /* No passwd means don't encrypt */
      if (buf == NULL || *buf == NUL)
***************
*** 344,350 ****
   * Return FAIL or OK.
   */
      int
! sha256_self_test()
  {
      int		     i, j;
      char	     output[65];
--- 336,342 ----
   * Return FAIL or OK.
   */
      int
! sha256_self_test(void)
  {
      int		     i, j;
      char	     output[65];
***************
*** 389,395 ****
  }
  
      static unsigned int
! get_some_time()
  {
  # ifdef HAVE_GETTIMEOFDAY
      struct timeval tv;
--- 381,387 ----
  }
  
      static unsigned int
! get_some_time(void)
  {
  # ifdef HAVE_GETTIMEOFDAY
      struct timeval tv;
***************
*** 407,417 ****
   * Also "salt[salt_len]" when "salt" is not NULL.
   */
      void
! sha2_seed(header, header_len, salt, salt_len)
!     char_u *header;
!     int    header_len;
!     char_u *salt;
!     int    salt_len;
  {
      int		     i;
      static char_u    random_data[1000];
--- 399,409 ----
   * Also "salt[salt_len]" when "salt" is not NULL.
   */
      void
! sha2_seed(
!     char_u *header,
!     int    header_len,
!     char_u *salt,
!     int    salt_len)
  {
      int		     i;
      static char_u    random_data[1000];
*** ../vim-7.4.1213/src/spell.c	2016-01-29 22:46:58.970534775 +0100
--- src/spell.c	2016-01-30 20:43:56.685747218 +0100
***************
*** 1026,1037 ****
   * caller can skip over the word.
   */
      int
! spell_check(wp, ptr, attrp, capcol, docount)
!     win_T	*wp;		/* current window */
!     char_u	*ptr;
!     hlf_T	*attrp;
!     int		*capcol;	/* column to check for Capital */
!     int		docount;	/* count good words */
  {
      matchinf_T	mi;		/* Most things are put in "mi" so that it can
  				   be passed to functions quickly. */
--- 1026,1037 ----
   * caller can skip over the word.
   */
      int
! spell_check(
!     win_T	*wp,		/* current window */
!     char_u	*ptr,
!     hlf_T	*attrp,
!     int		*capcol,	/* column to check for Capital */
!     int		docount)	/* count good words */
  {
      matchinf_T	mi;		/* Most things are put in "mi" so that it can
  				   be passed to functions quickly. */
***************
*** 1247,1255 ****
   * For a match mip->mi_result is updated.
   */
      static void
! find_word(mip, mode)
!     matchinf_T	*mip;
!     int		mode;
  {
      idx_T	arridx = 0;
      int		endlen[MAXWLEN];    /* length at possible word endings */
--- 1247,1253 ----
   * For a match mip->mi_result is updated.
   */
      static void
! find_word(matchinf_T *mip, int mode)
  {
      idx_T	arridx = 0;
      int		endlen[MAXWLEN];    /* length at possible word endings */
***************
*** 1767,1776 ****
   * end of ptr[wlen] and the second part matches after it.
   */
      static int
! match_checkcompoundpattern(ptr, wlen, gap)
!     char_u	*ptr;
!     int		wlen;
!     garray_T	*gap;  /* &sl_comppat */
  {
      int		i;
      char_u	*p;
--- 1765,1774 ----
   * end of ptr[wlen] and the second part matches after it.
   */
      static int
! match_checkcompoundpattern(
!     char_u	*ptr,
!     int		wlen,
!     garray_T	*gap)  /* &sl_comppat */
  {
      int		i;
      char_u	*p;
***************
*** 1797,1806 ****
   * does not have too many syllables.
   */
      static int
! can_compound(slang, word, flags)
!     slang_T	*slang;
!     char_u	*word;
!     char_u	*flags;
  {
  #ifdef FEAT_MBYTE
      char_u	uflags[MAXWLEN * 2];
--- 1795,1801 ----
   * does not have too many syllables.
   */
      static int
! can_compound(slang_T *slang, char_u *word, char_u *flags)
  {
  #ifdef FEAT_MBYTE
      char_u	uflags[MAXWLEN * 2];
***************
*** 1841,1851 ****
   * lines if they don't contain wildcards.
   */
      static int
! can_be_compound(sp, slang, compflags, flag)
!     trystate_T	*sp;
!     slang_T	*slang;
!     char_u	*compflags;
!     int		flag;
  {
      /* If the flag doesn't appear in sl_compstartflags or sl_compallflags
       * then it can't possibly compound. */
--- 1836,1846 ----
   * lines if they don't contain wildcards.
   */
      static int
! can_be_compound(
!     trystate_T	*sp,
!     slang_T	*slang,
!     char_u	*compflags,
!     int		flag)
  {
      /* If the flag doesn't appear in sl_compstartflags or sl_compallflags
       * then it can't possibly compound. */
***************
*** 1878,1886 ****
   * Caller must check that slang->sl_comprules is not NULL.
   */
      static int
! match_compoundrule(slang, compflags)
!     slang_T	*slang;
!     char_u	*compflags;
  {
      char_u	*p;
      int		i;
--- 1873,1879 ----
   * Caller must check that slang->sl_comprules is not NULL.
   */
      static int
! match_compoundrule(slang_T *slang, char_u *compflags)
  {
      char_u	*p;
      int		i;
***************
*** 1933,1945 ****
   * The WF_RAREPFX flag is included in the return value for a rare prefix.
   */
      static int
! valid_word_prefix(totprefcnt, arridx, flags, word, slang, cond_req)
!     int		totprefcnt;	/* nr of prefix IDs */
!     int		arridx;		/* idx in sl_pidxs[] */
!     int		flags;
!     char_u	*word;
!     slang_T	*slang;
!     int		cond_req;	/* only use prefixes with a condition */
  {
      int		prefcnt;
      int		pidx;
--- 1926,1938 ----
   * The WF_RAREPFX flag is included in the return value for a rare prefix.
   */
      static int
! valid_word_prefix(
!     int		totprefcnt,	/* nr of prefix IDs */
!     int		arridx,		/* idx in sl_pidxs[] */
!     int		flags,
!     char_u	*word,
!     slang_T	*slang,
!     int		cond_req)	/* only use prefixes with a condition */
  {
      int		prefcnt;
      int		pidx;
***************
*** 1987,1995 ****
   * For a match mip->mi_result is updated.
   */
      static void
! find_prefix(mip, mode)
!     matchinf_T	*mip;
!     int		mode;
  {
      idx_T	arridx = 0;
      int		len;
--- 1980,1986 ----
   * For a match mip->mi_result is updated.
   */
      static void
! find_prefix(matchinf_T *mip, int mode)
  {
      idx_T	arridx = 0;
      int		len;
***************
*** 2110,2117 ****
   * Return the length of the folded chars in bytes.
   */
      static int
! fold_more(mip)
!     matchinf_T	*mip;
  {
      int		flen;
      char_u	*p;
--- 2101,2107 ----
   * Return the length of the folded chars in bytes.
   */
      static int
! fold_more(matchinf_T *mip)
  {
      int		flen;
      char_u	*p;
***************
*** 2139,2147 ****
   * case.
   */
      static int
! spell_valid_case(wordflags, treeflags)
!     int	    wordflags;	    /* flags for the checked word. */
!     int	    treeflags;	    /* flags for the word in the spell tree */
  {
      return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)
  	    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0
--- 2129,2137 ----
   * case.
   */
      static int
! spell_valid_case(
!     int	    wordflags,	    /* flags for the checked word. */
!     int	    treeflags)	    /* flags for the word in the spell tree */
  {
      return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)
  	    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0
***************
*** 2153,2160 ****
   * Return TRUE if spell checking is not enabled.
   */
      static int
! no_spell_checking(wp)
!     win_T	*wp;
  {
      if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL
  					 || wp->w_s->b_langp.ga_len == 0)
--- 2143,2149 ----
   * Return TRUE if spell checking is not enabled.
   */
      static int
! no_spell_checking(win_T *wp)
  {
      if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL
  					 || wp->w_s->b_langp.ga_len == 0)
***************
*** 2174,2185 ****
   * Return 0 if not found, length of the badly spelled word otherwise.
   */
      int
! spell_move_to(wp, dir, allwords, curline, attrp)
!     win_T	*wp;
!     int		dir;		/* FORWARD or BACKWARD */
!     int		allwords;	/* TRUE for "[s"/"]s", FALSE for "[S"/"]S" */
!     int		curline;
!     hlf_T	*attrp;		/* return: attributes of bad word or NULL
  				   (only when "dir" is FORWARD) */
  {
      linenr_T	lnum;
--- 2163,2174 ----
   * Return 0 if not found, length of the badly spelled word otherwise.
   */
      int
! spell_move_to(
!     win_T	*wp,
!     int		dir,		/* FORWARD or BACKWARD */
!     int		allwords,	/* TRUE for "[s"/"]s", FALSE for "[S"/"]S" */
!     int		curline,
!     hlf_T	*attrp)		/* return: attributes of bad word or NULL
  				   (only when "dir" is FORWARD) */
  {
      linenr_T	lnum;
***************
*** 2421,2430 ****
   * to skip those bytes if the word was OK.
   */
      void
! spell_cat_line(buf, line, maxlen)
!     char_u	*buf;
!     char_u	*line;
!     int		maxlen;
  {
      char_u	*p;
      int		n;
--- 2410,2416 ----
   * to skip those bytes if the word was OK.
   */
      void
! spell_cat_line(char_u *buf, char_u *line, int maxlen)
  {
      char_u	*p;
      int		n;
***************
*** 2461,2468 ****
   * "lang" must be the language without the region: e.g., "en".
   */
      static void
! spell_load_lang(lang)
!     char_u	*lang;
  {
      char_u	fname_enc[85];
      int		r;
--- 2447,2453 ----
   * "lang" must be the language without the region: e.g., "en".
   */
      static void
! spell_load_lang(char_u *lang)
  {
      char_u	fname_enc[85];
      int		r;
***************
*** 2543,2549 ****
   * use "latin1" for "latin9".  And limit to 60 characters (just in case).
   */
      static char_u *
! spell_enc()
  {
  
  #ifdef FEAT_MBYTE
--- 2528,2534 ----
   * use "latin1" for "latin9".  And limit to 60 characters (just in case).
   */
      static char_u *
! spell_enc(void)
  {
  
  #ifdef FEAT_MBYTE
***************
*** 2558,2565 ****
   * "fname[MAXPATHL]".
   */
      static void
! int_wordlist_spl(fname)
!     char_u	    *fname;
  {
      vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,
  						  int_wordlist, spell_enc());
--- 2543,2549 ----
   * "fname[MAXPATHL]".
   */
      static void
! int_wordlist_spl(char_u *fname)
  {
      vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,
  						  int_wordlist, spell_enc());
***************
*** 2570,2577 ****
   * Caller must fill "sl_next".
   */
      static slang_T *
! slang_alloc(lang)
!     char_u	*lang;
  {
      slang_T *lp;
  
--- 2554,2560 ----
   * Caller must fill "sl_next".
   */
      static slang_T *
! slang_alloc(char_u *lang)
  {
      slang_T *lp;
  
***************
*** 2594,2601 ****
   * Free the contents of an slang_T and the structure itself.
   */
      static void
! slang_free(lp)
!     slang_T	*lp;
  {
      vim_free(lp->sl_name);
      vim_free(lp->sl_fname);
--- 2577,2583 ----
   * Free the contents of an slang_T and the structure itself.
   */
      static void
! slang_free(slang_T *lp)
  {
      vim_free(lp->sl_name);
      vim_free(lp->sl_fname);
***************
*** 2607,2614 ****
   * Clear an slang_T so that the file can be reloaded.
   */
      static void
! slang_clear(lp)
!     slang_T	*lp;
  {
      garray_T	*gap;
      fromto_T	*ftp;
--- 2589,2595 ----
   * Clear an slang_T so that the file can be reloaded.
   */
      static void
! slang_clear(slang_T *lp)
  {
      garray_T	*gap;
      fromto_T	*ftp;
***************
*** 2714,2721 ****
   * Clear the info from the .sug file in "lp".
   */
      static void
! slang_clear_sug(lp)
!     slang_T	*lp;
  {
      vim_free(lp->sl_sbyts);
      lp->sl_sbyts = NULL;
--- 2695,2701 ----
   * Clear the info from the .sug file in "lp".
   */
      static void
! slang_clear_sug(slang_T *lp)
  {
      vim_free(lp->sl_sbyts);
      lp->sl_sbyts = NULL;
***************
*** 2732,2740 ****
   * Invoked through do_in_runtimepath().
   */
      static void
! spell_load_cb(fname, cookie)
!     char_u	*fname;
!     void	*cookie;
  {
      spelload_T	*slp = (spelload_T *)cookie;
      slang_T	*slang;
--- 2712,2718 ----
   * Invoked through do_in_runtimepath().
   */
      static void
! spell_load_cb(char_u *fname, void *cookie)
  {
      spelload_T	*slp = (spelload_T *)cookie;
      slang_T	*slang;
***************
*** 2767,2777 ****
   * Returns the slang_T the spell file was loaded into.  NULL for error.
   */
      static slang_T *
! spell_load_file(fname, lang, old_lp, silent)
!     char_u	*fname;
!     char_u	*lang;
!     slang_T	*old_lp;
!     int		silent;		/* no error if file doesn't exist */
  {
      FILE	*fd;
      char_u	buf[VIMSPELLMAGICL];
--- 2745,2755 ----
   * Returns the slang_T the spell file was loaded into.  NULL for error.
   */
      static slang_T *
! spell_load_file(
!     char_u	*fname,
!     char_u	*lang,
!     slang_T	*old_lp,
!     int		silent)		/* no error if file doesn't exist */
  {
      FILE	*fd;
      char_u	buf[VIMSPELLMAGICL];
***************
*** 3025,3034 ****
   * otherwise.
   */
      static char_u *
! read_cnt_string(fd, cnt_bytes, cntp)
!     FILE	*fd;
!     int		cnt_bytes;
!     int		*cntp;
  {
      int		cnt = 0;
      int		i;
--- 3003,3009 ----
   * otherwise.
   */
      static char_u *
! read_cnt_string(FILE *fd, int cnt_bytes, int *cntp)
  {
      int		cnt = 0;
      int		i;
***************
*** 3057,3066 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_region_section(fd, lp, len)
!     FILE	*fd;
!     slang_T	*lp;
!     int		len;
  {
      int		i;
  
--- 3032,3038 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_region_section(FILE *fd, slang_T *lp, int len)
  {
      int		i;
  
***************
*** 3078,3085 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_charflags_section(fd)
!     FILE	*fd;
  {
      char_u	*flags;
      char_u	*fol;
--- 3050,3056 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_charflags_section(FILE *fd)
  {
      char_u	*flags;
      char_u	*fol;
***************
*** 3116,3124 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_prefcond_section(fd, lp)
!     FILE	*fd;
!     slang_T	*lp;
  {
      int		cnt;
      int		i;
--- 3087,3093 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_prefcond_section(FILE *fd, slang_T *lp)
  {
      int		cnt;
      int		i;
***************
*** 3164,3173 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_rep_section(fd, gap, first)
!     FILE	*fd;
!     garray_T	*gap;
!     short	*first;
  {
      int		cnt;
      fromto_T	*ftp;
--- 3133,3139 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_rep_section(FILE *fd, garray_T *gap, short *first)
  {
      int		cnt;
      fromto_T	*ftp;
***************
*** 3216,3224 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_sal_section(fd, slang)
!     FILE	*fd;
!     slang_T	*slang;
  {
      int		i;
      int		cnt;
--- 3182,3188 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_sal_section(FILE *fd, slang_T *slang)
  {
      int		i;
      int		cnt;
***************
*** 3369,3378 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_words_section(fd, lp, len)
!     FILE	*fd;
!     slang_T	*lp;
!     int		len;
  {
      int		done = 0;
      int		i;
--- 3333,3339 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_words_section(FILE *fd, slang_T *lp, int len)
  {
      int		done = 0;
      int		i;
***************
*** 3406,3416 ****
   * If it's already there then the counter is increased.
   */
      static void
! count_common_word(lp, word, len, count)
!     slang_T	*lp;
!     char_u	*word;
!     int		len;	    /* word length, -1 for upto NUL */
!     int		count;	    /* 1 to count once, 10 to init */
  {
      hash_T	hash;
      hashitem_T	*hi;
--- 3367,3377 ----
   * If it's already there then the counter is increased.
   */
      static void
! count_common_word(
!     slang_T	*lp,
!     char_u	*word,
!     int		len,	    /* word length, -1 for upto NUL */
!     int		count)	    /* 1 to count once, 10 to init */
  {
      hash_T	hash;
      hashitem_T	*hi;
***************
*** 3449,3459 ****
   * Adjust the score of common words.
   */
      static int
! score_wordcount_adj(slang, score, word, split)
!     slang_T	*slang;
!     int		score;
!     char_u	*word;
!     int		split;	    /* word was split, less bonus */
  {
      hashitem_T	*hi;
      wordcount_T	*wc;
--- 3410,3420 ----
   * Adjust the score of common words.
   */
      static int
! score_wordcount_adj(
!     slang_T	*slang,
!     int		score,
!     char_u	*word,
!     int		split)	    /* word was split, less bonus */
  {
      hashitem_T	*hi;
      wordcount_T	*wc;
***************
*** 3486,3494 ****
   * Return SP_*ERROR flags.
   */
      static int
! read_sofo_section(fd, slang)
!     FILE	*fd;
!     slang_T	*slang;
  {
      int		cnt;
      char_u	*from, *to;
--- 3447,3453 ----
   * Return SP_*ERROR flags.
   */
      static int
! read_sofo_section(FILE *fd, slang_T *slang)
  {
      int		cnt;
      char_u	*from, *to;
***************
*** 3528,3537 ****
   * Returns SP_*ERROR flags.
   */
      static int
! read_compound(fd, slang, len)
!     FILE	*fd;
!     slang_T	*slang;
!     int		len;
  {
      int		todo = len;
      int		c;
--- 3487,3493 ----
   * Returns SP_*ERROR flags.
   */
      static int
! read_compound(FILE *fd, slang_T *slang, int len)
  {
      int		todo = len;
      int		c;
***************
*** 3728,3736 ****
   * Like strchr() but independent of locale.
   */
      static int
! byte_in_str(str, n)
!     char_u	*str;
!     int		n;
  {
      char_u	*p;
  
--- 3684,3690 ----
   * Like strchr() but independent of locale.
   */
      static int
! byte_in_str(char_u *str, int n)
  {
      char_u	*p;
  
***************
*** 3752,3759 ****
   * in "slang->sl_syl_items".
   */
      static int
! init_syl_tab(slang)
!     slang_T	*slang;
  {
      char_u	*p;
      char_u	*s;
--- 3706,3712 ----
   * in "slang->sl_syl_items".
   */
      static int
! init_syl_tab(slang_T *slang)
  {
      char_u	*p;
      char_u	*s;
***************
*** 3791,3799 ****
   * Returns zero if syllables are not defines.
   */
      static int
! count_syllables(slang, word)
!     slang_T	*slang;
!     char_u	*word;
  {
      int		cnt = 0;
      int		skip = FALSE;
--- 3744,3750 ----
   * Returns zero if syllables are not defines.
   */
      static int
! count_syllables(slang_T *slang, char_u *word)
  {
      int		cnt = 0;
      int		skip = FALSE;
***************
*** 3857,3866 ****
   * Returns SP_*ERROR flags when there is something wrong.
   */
      static int
! set_sofo(lp, from, to)
!     slang_T	*lp;
!     char_u	*from;
!     char_u	*to;
  {
      int		i;
  
--- 3808,3814 ----
   * Returns SP_*ERROR flags when there is something wrong.
   */
      static int
! set_sofo(slang_T *lp, char_u *from, char_u *to)
  {
      int		i;
  
***************
*** 3949,3956 ****
   * Fill the first-index table for "lp".
   */
      static void
! set_sal_first(lp)
!     slang_T	*lp;
  {
      salfirst_T	*sfirst;
      int		i;
--- 3897,3903 ----
   * Fill the first-index table for "lp".
   */
      static void
! set_sal_first(slang_T *lp)
  {
      salfirst_T	*sfirst;
      int		i;
***************
*** 4015,4022 ****
   * Return it in allocated memory (NULL for out-of-memory)
   */
      static int *
! mb_str2wide(s)
!     char_u	*s;
  {
      int		*res;
      char_u	*p;
--- 3962,3968 ----
   * Return it in allocated memory (NULL for out-of-memory)
   */
      static int *
! mb_str2wide(char_u *s)
  {
      int		*res;
      char_u	*p;
***************
*** 4040,4051 ****
   * Returns zero when OK, SP_ value for an error.
   */
      static int
! spell_read_tree(fd, bytsp, idxsp, prefixtree, prefixcnt)
!     FILE	*fd;
!     char_u	**bytsp;
!     idx_T	**idxsp;
!     int		prefixtree;	/* TRUE for the prefix tree */
!     int		prefixcnt;	/* when "prefixtree" is TRUE: prefix count */
  {
      int		len;
      int		idx;
--- 3986,3997 ----
   * Returns zero when OK, SP_ value for an error.
   */
      static int
! spell_read_tree(
!     FILE	*fd,
!     char_u	**bytsp,
!     idx_T	**idxsp,
!     int		prefixtree,	/* TRUE for the prefix tree */
!     int		prefixcnt)	/* when "prefixtree" is TRUE: prefix count */
  {
      int		len;
      int		idx;
***************
*** 4090,4103 ****
   * Returns SP_FORMERROR if there is a format error.
   */
      static idx_T
! read_tree_node(fd, byts, idxs, maxidx, startidx, prefixtree, maxprefcondnr)
!     FILE	*fd;
!     char_u	*byts;
!     idx_T	*idxs;
!     int		maxidx;		    /* size of arrays */
!     idx_T	startidx;	    /* current index in "byts" and "idxs" */
!     int		prefixtree;	    /* TRUE for reading PREFIXTREE */
!     int		maxprefcondnr;	    /* maximum for <prefcondnr> */
  {
      int		len;
      int		i;
--- 4036,4049 ----
   * Returns SP_FORMERROR if there is a format error.
   */
      static idx_T
! read_tree_node(
!     FILE	*fd,
!     char_u	*byts,
!     idx_T	*idxs,
!     int		maxidx,		    /* size of arrays */
!     idx_T	startidx,	    /* current index in "byts" and "idxs" */
!     int		prefixtree,	    /* TRUE for reading PREFIXTREE */
!     int		maxprefcondnr)	    /* maximum for <prefcondnr> */
  {
      int		len;
      int		i;
***************
*** 4206,4213 ****
   * Returns NULL if it's OK, an error message otherwise.
   */
      char_u *
! did_set_spelllang(wp)
!     win_T	*wp;
  {
      garray_T	ga;
      char_u	*splp;
--- 4152,4158 ----
   * Returns NULL if it's OK, an error message otherwise.
   */
      char_u *
! did_set_spelllang(win_T *wp)
  {
      garray_T	ga;
      char_u	*splp;
***************
*** 4530,4537 ****
   * Clear the midword characters for buffer "buf".
   */
      static void
! clear_midword(wp)
!     win_T	*wp;
  {
      vim_memset(wp->w_s->b_spell_ismw, 0, 256);
  #ifdef FEAT_MBYTE
--- 4475,4481 ----
   * Clear the midword characters for buffer "buf".
   */
      static void
! clear_midword(win_T *wp)
  {
      vim_memset(wp->w_s->b_spell_ismw, 0, 256);
  #ifdef FEAT_MBYTE
***************
*** 4545,4553 ****
   * They add up to any currently used midword characters.
   */
      static void
! use_midword(lp, wp)
!     slang_T	*lp;
!     win_T	*wp;
  {
      char_u	*p;
  
--- 4489,4495 ----
   * They add up to any currently used midword characters.
   */
      static void
! use_midword(slang_T *lp, win_T *wp)
  {
      char_u	*p;
  
***************
*** 4593,4601 ****
   * Returns the index if found (first is 0), REGION_ALL if not found.
   */
      static int
! find_region(rp, region)
!     char_u	*rp;
!     char_u	*region;
  {
      int		i;
  
--- 4535,4541 ----
   * Returns the index if found (first is 0), REGION_ALL if not found.
   */
      static int
! find_region(char_u *rp, char_u *region)
  {
      int		i;
  
***************
*** 4617,4625 ****
   * WoRd	wOrd	WF_KEEPCAP
   */
      static int
! captype(word, end)
!     char_u	*word;
!     char_u	*end;	    /* When NULL use up to NUL byte. */
  {
      char_u	*p;
      int		c;
--- 4557,4565 ----
   * WoRd	wOrd	WF_KEEPCAP
   */
      static int
! captype(
!     char_u	*word,
!     char_u	*end)	    /* When NULL use up to NUL byte. */
  {
      char_u	*p;
      int		c;
***************
*** 4673,4681 ****
   * Add ALLCAP for "WOrD".
   */
      static int
! badword_captype(word, end)
!     char_u	*word;
!     char_u	*end;
  {
      int		flags = captype(word, end);
      int		c;
--- 4613,4619 ----
   * Add ALLCAP for "WOrD".
   */
      static int
! badword_captype(char_u *word, char_u *end)
  {
      int		flags = captype(word, end);
      int		c;
***************
*** 4720,4726 ****
   * Delete the internal wordlist and its .spl file.
   */
      void
! spell_delete_wordlist()
  {
      char_u	fname[MAXPATHL];
  
--- 4658,4664 ----
   * Delete the internal wordlist and its .spl file.
   */
      void
! spell_delete_wordlist(void)
  {
      char_u	fname[MAXPATHL];
  
***************
*** 4739,4745 ****
   * Free all languages.
   */
      void
! spell_free_all()
  {
      slang_T	*slang;
      buf_T	*buf;
--- 4677,4683 ----
   * Free all languages.
   */
      void
! spell_free_all(void)
  {
      slang_T	*slang;
      buf_T	*buf;
***************
*** 4770,4776 ****
   * Used after 'encoding' is set and when ":mkspell" was used.
   */
      void
! spell_reload()
  {
      win_T	*wp;
  
--- 4708,4714 ----
   * Used after 'encoding' is set and when ":mkspell" was used.
   */
      void
! spell_reload(void)
  {
      win_T	*wp;
  
***************
*** 4803,4811 ****
   * Reload the spell file "fname" if it's loaded.
   */
      static void
! spell_reload_one(fname, added_word)
!     char_u	*fname;
!     int		added_word;	/* invoked through "zg" */
  {
      slang_T	*slang;
      int		didit = FALSE;
--- 4741,4749 ----
   * Reload the spell file "fname" if it's loaded.
   */
      static void
! spell_reload_one(
!     char_u	*fname,
!     int		added_word)	/* invoked through "zg" */
  {
      slang_T	*slang;
      int		didit = FALSE;
***************
*** 5213,5221 ****
   * Returns an afffile_T, NULL for complete failure.
   */
      static afffile_T *
! spell_read_aff(spin, fname)
!     spellinfo_T	*spin;
!     char_u	*fname;
  {
      FILE	*fd;
      afffile_T	*aff;
--- 5151,5157 ----
   * Returns an afffile_T, NULL for complete failure.
   */
      static afffile_T *
! spell_read_aff(spellinfo_T *spin, char_u *fname)
  {
      FILE	*fd;
      afffile_T	*aff;
***************
*** 6163,6173 ****
   * a comment is following after item "mincount".
   */
      static int
! is_aff_rule(items, itemcnt, rulename, mincount)
!     char_u	**items;
!     int		itemcnt;
!     char	*rulename;
!     int		mincount;
  {
      return (STRCMP(items[0], rulename) == 0
  	    && (itemcnt == mincount
--- 6099,6109 ----
   * a comment is following after item "mincount".
   */
      static int
! is_aff_rule(
!     char_u	**items,
!     int		itemcnt,
!     char	*rulename,
!     int		mincount)
  {
      return (STRCMP(items[0], rulename) == 0
  	    && (itemcnt == mincount
***************
*** 6179,6187 ****
   * ae_flags to ae_comppermit and ae_compforbid.
   */
      static void
! aff_process_flags(affile, entry)
!     afffile_T	*affile;
!     affentry_T	*entry;
  {
      char_u	*p;
      char_u	*prevp;
--- 6115,6121 ----
   * ae_flags to ae_comppermit and ae_compforbid.
   */
      static void
! aff_process_flags(afffile_T *affile, affentry_T *entry)
  {
      char_u	*p;
      char_u	*prevp;
***************
*** 6215,6222 ****
   * Return TRUE if "s" is the name of an info item in the affix file.
   */
      static int
! spell_info_item(s)
!     char_u	*s;
  {
      return STRCMP(s, "NAME") == 0
  	|| STRCMP(s, "HOME") == 0
--- 6149,6155 ----
   * Return TRUE if "s" is the name of an info item in the affix file.
   */
      static int
! spell_info_item(char_u *s)
  {
      return STRCMP(s, "NAME") == 0
  	|| STRCMP(s, "HOME") == 0
***************
*** 6231,6241 ****
   * returns zero for failure.
   */
      static unsigned
! affitem2flag(flagtype, item, fname, lnum)
!     int		flagtype;
!     char_u	*item;
!     char_u	*fname;
!     int		lnum;
  {
      unsigned	res;
      char_u	*p = item;
--- 6164,6174 ----
   * returns zero for failure.
   */
      static unsigned
! affitem2flag(
!     int		flagtype,
!     char_u	*item,
!     char_u	*fname,
!     int		lnum)
  {
      unsigned	res;
      char_u	*p = item;
***************
*** 6264,6272 ****
   * Returns zero for an error, still advances the pointer then.
   */
      static unsigned
! get_affitem(flagtype, pp)
!     int		flagtype;
!     char_u	**pp;
  {
      int		res;
  
--- 6197,6203 ----
   * Returns zero for an error, still advances the pointer then.
   */
      static unsigned
! get_affitem(int flagtype, char_u **pp)
  {
      int		res;
  
***************
*** 6308,6317 ****
   * they fit in one byte.
   */
      static void
! process_compflags(spin, aff, compflags)
!     spellinfo_T	*spin;
!     afffile_T	*aff;
!     char_u	*compflags;
  {
      char_u	*p;
      char_u	*prevp;
--- 6239,6248 ----
   * they fit in one byte.
   */
      static void
! process_compflags(
!     spellinfo_T	*spin,
!     afffile_T	*aff,
!     char_u	*compflags)
  {
      char_u	*p;
      char_u	*prevp;
***************
*** 6392,6399 ****
   * When that is used up an error message is given.
   */
      static void
! check_renumber(spin)
!     spellinfo_T	*spin;
  {
      if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128)
      {
--- 6323,6329 ----
   * When that is used up an error message is given.
   */
      static void
! check_renumber(spellinfo_T *spin)
  {
      if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128)
      {
***************
*** 6406,6415 ****
   * Return TRUE if flag "flag" appears in affix list "afflist".
   */
      static int
! flag_in_afflist(flagtype, afflist, flag)
!     int		flagtype;
!     char_u	*afflist;
!     unsigned	flag;
  {
      char_u	*p;
      unsigned	n;
--- 6336,6342 ----
   * Return TRUE if flag "flag" appears in affix list "afflist".
   */
      static int
! flag_in_afflist(int flagtype, char_u *afflist, unsigned flag)
  {
      char_u	*p;
      unsigned	n;
***************
*** 6458,6467 ****
   * Give a warning when "spinval" and "affval" numbers are set and not the same.
   */
      static void
! aff_check_number(spinval, affval, name)
!     int	    spinval;
!     int	    affval;
!     char    *name;
  {
      if (spinval != 0 && spinval != affval)
  	smsg((char_u *)_("%s value differs from what is used in another .aff file"), name);
--- 6385,6391 ----
   * Give a warning when "spinval" and "affval" numbers are set and not the same.
   */
      static void
! aff_check_number(int spinval, int affval, char *name)
  {
      if (spinval != 0 && spinval != affval)
  	smsg((char_u *)_("%s value differs from what is used in another .aff file"), name);
***************
*** 6471,6480 ****
   * Give a warning when "spinval" and "affval" strings are set and not the same.
   */
      static void
! aff_check_string(spinval, affval, name)
!     char_u	*spinval;
!     char_u	*affval;
!     char	*name;
  {
      if (spinval != NULL && STRCMP(spinval, affval) != 0)
  	smsg((char_u *)_("%s value differs from what is used in another .aff file"), name);
--- 6395,6401 ----
   * Give a warning when "spinval" and "affval" strings are set and not the same.
   */
      static void
! aff_check_string(char_u *spinval, char_u *affval, char *name)
  {
      if (spinval != NULL && STRCMP(spinval, affval) != 0)
  	smsg((char_u *)_("%s value differs from what is used in another .aff file"), name);
***************
*** 6485,6493 ****
   * NULL as equal.
   */
      static int
! str_equal(s1, s2)
!     char_u	*s1;
!     char_u	*s2;
  {
      if (s1 == NULL || s2 == NULL)
  	return s1 == s2;
--- 6406,6412 ----
   * NULL as equal.
   */
      static int
! str_equal(char_u *s1, char_u *s2)
  {
      if (s1 == NULL || s2 == NULL)
  	return s1 == s2;
***************
*** 6499,6509 ****
   * They are stored case-folded.
   */
      static void
! add_fromto(spin, gap, from, to)
!     spellinfo_T	*spin;
!     garray_T	*gap;
!     char_u	*from;
!     char_u	*to;
  {
      fromto_T	*ftp;
      char_u	word[MAXWLEN];
--- 6418,6428 ----
   * They are stored case-folded.
   */
      static void
! add_fromto(
!     spellinfo_T	*spin,
!     garray_T	*gap,
!     char_u	*from,
!     char_u	*to)
  {
      fromto_T	*ftp;
      char_u	word[MAXWLEN];
***************
*** 6523,6530 ****
   * Convert a boolean argument in a SAL line to TRUE or FALSE;
   */
      static int
! sal_to_bool(s)
!     char_u	*s;
  {
      return STRCMP(s, "1") == 0 || STRCMP(s, "true") == 0;
  }
--- 6442,6448 ----
   * Convert a boolean argument in a SAL line to TRUE or FALSE;
   */
      static int
! sal_to_bool(char_u *s)
  {
      return STRCMP(s, "1") == 0 || STRCMP(s, "true") == 0;
  }
***************
*** 6533,6540 ****
   * Free the structure filled by spell_read_aff().
   */
      static void
! spell_free_aff(aff)
!     afffile_T	*aff;
  {
      hashtab_T	*ht;
      hashitem_T	*hi;
--- 6451,6457 ----
   * Free the structure filled by spell_read_aff().
   */
      static void
! spell_free_aff(afffile_T *aff)
  {
      hashtab_T	*ht;
      hashitem_T	*hi;
***************
*** 6572,6581 ****
   * Returns OK or FAIL;
   */
      static int
! spell_read_dic(spin, fname, affile)
!     spellinfo_T	*spin;
!     char_u	*fname;
!     afffile_T	*affile;
  {
      hashtab_T	ht;
      char_u	line[MAXLINELEN];
--- 6489,6495 ----
   * Returns OK or FAIL;
   */
      static int
! spell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile)
  {
      hashtab_T	ht;
      char_u	line[MAXLINELEN];
***************
*** 6789,6797 ****
   * Return WF_ flags.
   */
      static int
! get_affix_flags(affile, afflist)
!     afffile_T	*affile;
!     char_u	*afflist;
  {
      int		flags = 0;
  
--- 6703,6709 ----
   * Return WF_ flags.
   */
      static int
! get_affix_flags(afffile_T *affile, char_u *afflist)
  {
      int		flags = 0;
  
***************
*** 6823,6832 ****
   * and return the number of affixes.
   */
      static int
! get_pfxlist(affile, afflist, store_afflist)
!     afffile_T	*affile;
!     char_u	*afflist;
!     char_u	*store_afflist;
  {
      char_u	*p;
      char_u	*prevp;
--- 6735,6744 ----
   * and return the number of affixes.
   */
      static int
! get_pfxlist(
!     afffile_T	*affile,
!     char_u	*afflist,
!     char_u	*store_afflist)
  {
      char_u	*p;
      char_u	*prevp;
***************
*** 6865,6874 ****
   * Puts the flags in "store_afflist[]".
   */
      static void
! get_compflags(affile, afflist, store_afflist)
!     afffile_T	*affile;
!     char_u	*afflist;
!     char_u	*store_afflist;
  {
      char_u	*p;
      char_u	*prevp;
--- 6777,6786 ----
   * Puts the flags in "store_afflist[]".
   */
      static void
! get_compflags(
!     afffile_T	*affile,
!     char_u	*afflist,
!     char_u	*store_afflist)
  {
      char_u	*p;
      char_u	*prevp;
***************
*** 6904,6921 ****
   * Returns FAIL when out of memory.
   */
      static int
! store_aff_word(spin, word, afflist, affile, ht, xht, condit, flags,
! 							      pfxlist, pfxlen)
!     spellinfo_T	*spin;		/* spell info */
!     char_u	*word;		/* basic word start */
!     char_u	*afflist;	/* list of names of supported affixes */
!     afffile_T	*affile;
!     hashtab_T	*ht;
!     hashtab_T	*xht;
!     int		condit;		/* CONDIT_SUF et al. */
!     int		flags;		/* flags for the word */
!     char_u	*pfxlist;	/* list of prefix IDs */
!     int		pfxlen;		/* nr of flags in "pfxlist" for prefixes, rest
  				 * is compound flags */
  {
      int		todo;
--- 6816,6832 ----
   * Returns FAIL when out of memory.
   */
      static int
! store_aff_word(
!     spellinfo_T	*spin,		/* spell info */
!     char_u	*word,		/* basic word start */
!     char_u	*afflist,	/* list of names of supported affixes */
!     afffile_T	*affile,
!     hashtab_T	*ht,
!     hashtab_T	*xht,
!     int		condit,		/* CONDIT_SUF et al. */
!     int		flags,		/* flags for the word */
!     char_u	*pfxlist,	/* list of prefix IDs */
!     int		pfxlen)		/* nr of flags in "pfxlist" for prefixes, rest
  				 * is compound flags */
  {
      int		todo;
***************
*** 7170,7178 ****
   * Read a file with a list of words.
   */
      static int
! spell_read_wordfile(spin, fname)
!     spellinfo_T	*spin;
!     char_u	*fname;
  {
      FILE	*fd;
      long	lnum = 0;
--- 7081,7087 ----
   * Read a file with a list of words.
   */
      static int
! spell_read_wordfile(spellinfo_T *spin, char_u *fname)
  {
      FILE	*fd;
      long	lnum = 0;
***************
*** 7380,7389 ****
   * Returns NULL when out of memory.
   */
      static void *
! getroom(spin, len, align)
!     spellinfo_T *spin;
!     size_t	len;		/* length needed */
!     int		align;		/* align for pointer */
  {
      char_u	*p;
      sblock_T	*bl = spin->si_blocks;
--- 7289,7298 ----
   * Returns NULL when out of memory.
   */
      static void *
! getroom(
!     spellinfo_T *spin,
!     size_t	len,		/* length needed */
!     int		align)		/* align for pointer */
  {
      char_u	*p;
      sblock_T	*bl = spin->si_blocks;
***************
*** 7428,7436 ****
   * Returns NULL when out of memory.
   */
      static char_u *
! getroom_save(spin, s)
!     spellinfo_T	*spin;
!     char_u	*s;
  {
      char_u	*sc;
  
--- 7337,7343 ----
   * Returns NULL when out of memory.
   */
      static char_u *
! getroom_save(spellinfo_T *spin, char_u *s)
  {
      char_u	*sc;
  
***************
*** 7445,7452 ****
   * Free the list of allocated sblock_T.
   */
      static void
! free_blocks(bl)
!     sblock_T	*bl;
  {
      sblock_T	*next;
  
--- 7352,7358 ----
   * Free the list of allocated sblock_T.
   */
      static void
! free_blocks(sblock_T *bl)
  {
      sblock_T	*next;
  
***************
*** 7463,7470 ****
   * Returns NULL when out of memory.
   */
      static wordnode_T *
! wordtree_alloc(spin)
!     spellinfo_T *spin;
  {
      return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);
  }
--- 7369,7375 ----
   * Returns NULL when out of memory.
   */
      static wordnode_T *
! wordtree_alloc(spellinfo_T *spin)
  {
      return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);
  }
***************
*** 7479,7491 ****
   * compound flag.
   */
      static int
! store_word(spin, word, flags, region, pfxlist, need_affix)
!     spellinfo_T	*spin;
!     char_u	*word;
!     int		flags;		/* extra flags, WF_BANNED */
!     int		region;		/* supported region(s) */
!     char_u	*pfxlist;	/* list of prefix IDs or NULL */
!     int		need_affix;	/* only store word with affix ID */
  {
      int		len = (int)STRLEN(word);
      int		ct = captype(word, word + len);
--- 7384,7396 ----
   * compound flag.
   */
      static int
! store_word(
!     spellinfo_T	*spin,
!     char_u	*word,
!     int		flags,		/* extra flags, WF_BANNED */
!     int		region,		/* supported region(s) */
!     char_u	*pfxlist,	/* list of prefix IDs or NULL */
!     int		need_affix)	/* only store word with affix ID */
  {
      int		len = (int)STRLEN(word);
      int		ct = captype(word, word + len);
***************
*** 7526,7538 ****
   * Returns FAIL when out of memory.
   */
      static int
! tree_add_word(spin, word, root, flags, region, affixID)
!     spellinfo_T	*spin;
!     char_u	*word;
!     wordnode_T	*root;
!     int		flags;
!     int		region;
!     int		affixID;
  {
      wordnode_T	*node = root;
      wordnode_T	*np;
--- 7431,7443 ----
   * Returns FAIL when out of memory.
   */
      static int
! tree_add_word(
!     spellinfo_T	*spin,
!     char_u	*word,
!     wordnode_T	*root,
!     int		flags,
!     int		region,
!     int		affixID)
  {
      wordnode_T	*node = root;
      wordnode_T	*np;
***************
*** 7706,7712 ****
   * Sets "sps_flags".
   */
      int
! spell_check_msm()
  {
      char_u	*p = p_msm;
      long	start = 0;
--- 7611,7617 ----
   * Sets "sps_flags".
   */
      int
! spell_check_msm(void)
  {
      char_u	*p = p_msm;
      long	start = 0;
***************
*** 7748,7755 ****
   * Returns NULL when out of memory.
   */
      static wordnode_T *
! get_wordnode(spin)
!     spellinfo_T	    *spin;
  {
      wordnode_T *n;
  
--- 7653,7659 ----
   * Returns NULL when out of memory.
   */
      static wordnode_T *
! get_wordnode(spellinfo_T *spin)
  {
      wordnode_T *n;
  
***************
*** 7776,7784 ****
   * Returns the number of nodes actually freed.
   */
      static int
! deref_wordnode(spin, node)
!     spellinfo_T *spin;
!     wordnode_T  *node;
  {
      wordnode_T	*np;
      int		cnt = 0;
--- 7680,7686 ----
   * Returns the number of nodes actually freed.
   */
      static int
! deref_wordnode(spellinfo_T *spin, wordnode_T *node)
  {
      wordnode_T	*np;
      int		cnt = 0;
***************
*** 7802,7810 ****
   * Only the "wn_child" field becomes invalid.
   */
      static void
! free_wordnode(spin, n)
!     spellinfo_T	*spin;
!     wordnode_T  *n;
  {
      n->wn_child = spin->si_first_free;
      spin->si_first_free = n;
--- 7704,7710 ----
   * Only the "wn_child" field becomes invalid.
   */
      static void
! free_wordnode(spellinfo_T *spin, wordnode_T *n)
  {
      n->wn_child = spin->si_first_free;
      spin->si_first_free = n;
***************
*** 7815,7823 ****
   * Compress a tree: find tails that are identical and can be shared.
   */
      static void
! wordtree_compress(spin, root)
!     spellinfo_T	    *spin;
!     wordnode_T	    *root;
  {
      hashtab_T	    ht;
      int		    n;
--- 7715,7721 ----
   * Compress a tree: find tails that are identical and can be shared.
   */
      static void
! wordtree_compress(spellinfo_T *spin, wordnode_T *root)
  {
      hashtab_T	    ht;
      int		    n;
***************
*** 7858,7868 ****
   * Returns the number of compressed nodes.
   */
      static int
! node_compress(spin, node, ht, tot)
!     spellinfo_T	*spin;
!     wordnode_T	*node;
!     hashtab_T	*ht;
!     int		*tot;	    /* total count of nodes before compressing,
  			       incremented while going through the tree */
  {
      wordnode_T	*np;
--- 7756,7766 ----
   * Returns the number of compressed nodes.
   */
      static int
! node_compress(
!     spellinfo_T	*spin,
!     wordnode_T	*node,
!     hashtab_T	*ht,
!     int		*tot)	    /* total count of nodes before compressing,
  			       incremented while going through the tree */
  {
      wordnode_T	*np;
***************
*** 7964,7972 ****
   * Return TRUE when two nodes have identical siblings and children.
   */
      static int
! node_equal(n1, n2)
!     wordnode_T	*n1;
!     wordnode_T	*n2;
  {
      wordnode_T	*p1;
      wordnode_T	*p2;
--- 7862,7868 ----
   * Return TRUE when two nodes have identical siblings and children.
   */
      static int
! node_equal(wordnode_T *n1, wordnode_T *n2)
  {
      wordnode_T	*p1;
      wordnode_T	*p2;
***************
*** 7997,8005 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! rep_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      fromto_T	*p1 = (fromto_T *)s1;
      fromto_T	*p2 = (fromto_T *)s2;
--- 7893,7899 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! rep_compare(const void *s1, const void *s2)
  {
      fromto_T	*p1 = (fromto_T *)s1;
      fromto_T	*p2 = (fromto_T *)s2;
***************
*** 8012,8020 ****
   * Return FAIL or OK;
   */
      static int
! write_vim_spell(spin, fname)
!     spellinfo_T	*spin;
!     char_u	*fname;
  {
      FILE	*fd;
      int		regionmask;
--- 7906,7912 ----
   * Return FAIL or OK;
   */
      static int
! write_vim_spell(spellinfo_T *spin, char_u *fname)
  {
      FILE	*fd;
      int		regionmask;
***************
*** 8434,8441 ****
   * space.
   */
      static void
! clear_node(node)
!     wordnode_T	*node;
  {
      wordnode_T	*np;
  
--- 8326,8332 ----
   * space.
   */
      static void
! clear_node(wordnode_T *node)
  {
      wordnode_T	*np;
  
***************
*** 8464,8475 ****
   * Returns the number of nodes used.
   */
      static int
! put_node(fd, node, idx, regionmask, prefixtree)
!     FILE	*fd;		/* NULL when only counting */
!     wordnode_T	*node;
!     int		idx;
!     int		regionmask;
!     int		prefixtree;	/* TRUE for PREFIXTREE */
  {
      int		newindex = idx;
      int		siblingcount = 0;
--- 8355,8366 ----
   * Returns the number of nodes used.
   */
      static int
! put_node(
!     FILE	*fd,		/* NULL when only counting */
!     wordnode_T	*node,
!     int		idx,
!     int		regionmask,
!     int		prefixtree)	/* TRUE for PREFIXTREE */
  {
      int		newindex = idx;
      int		siblingcount = 0;
***************
*** 8594,8601 ****
   * ":mkspell [-ascii] addfile"
   */
      void
! ex_mkspell(eap)
!     exarg_T *eap;
  {
      int		fcount;
      char_u	**fnames;
--- 8485,8491 ----
   * ":mkspell [-ascii] addfile"
   */
      void
! ex_mkspell(exarg_T *eap)
  {
      int		fcount;
      char_u	**fnames;
***************
*** 8622,8630 ****
   * Writes the file with the name "wfname", with ".spl" changed to ".sug".
   */
      static void
! spell_make_sugfile(spin, wfname)
!     spellinfo_T	*spin;
!     char_u	*wfname;
  {
      char_u	*fname = NULL;
      int		len;
--- 8512,8518 ----
   * Writes the file with the name "wfname", with ".spl" changed to ".sug".
   */
      static void
! spell_make_sugfile(spellinfo_T *spin, char_u *wfname)
  {
      char_u	*fname = NULL;
      int		len;
***************
*** 8711,8719 ****
   * Build the soundfold trie for language "slang".
   */
      static int
! sug_filltree(spin, slang)
!     spellinfo_T	*spin;
!     slang_T	*slang;
  {
      char_u	*byts;
      idx_T	*idxs;
--- 8599,8605 ----
   * Build the soundfold trie for language "slang".
   */
      static int
! sug_filltree(spellinfo_T *spin, slang_T *slang)
  {
      char_u	*byts;
      idx_T	*idxs;
***************
*** 8819,8826 ****
   * Returns FAIL when out of memory.
   */
      static int
! sug_maketable(spin)
!     spellinfo_T	*spin;
  {
      garray_T	ga;
      int		res = OK;
--- 8705,8711 ----
   * Returns FAIL when out of memory.
   */
      static int
! sug_maketable(spellinfo_T *spin)
  {
      garray_T	ga;
      int		res = OK;
***************
*** 8849,8859 ****
   * Returns -1 when out of memory.
   */
      static int
! sug_filltable(spin, node, startwordnr, gap)
!     spellinfo_T	*spin;
!     wordnode_T	*node;
!     int		startwordnr;
!     garray_T	*gap;	    /* place to store line of numbers */
  {
      wordnode_T	*p, *np;
      int		wordnr = startwordnr;
--- 8734,8744 ----
   * Returns -1 when out of memory.
   */
      static int
! sug_filltable(
!     spellinfo_T	*spin,
!     wordnode_T	*node,
!     int		startwordnr,
!     garray_T	*gap)	    /* place to store line of numbers */
  {
      wordnode_T	*p, *np;
      int		wordnr = startwordnr;
***************
*** 8916,8924 ****
   * bytes.
   */
      static int
! offset2bytes(nr, buf)
!     int	    nr;
!     char_u  *buf;
  {
      int	    rem;
      int	    b1, b2, b3, b4;
--- 8801,8807 ----
   * bytes.
   */
      static int
! offset2bytes(int nr, char_u *buf)
  {
      int	    rem;
      int	    b1, b2, b3, b4;
***************
*** 8963,8970 ****
   * Returns the offset.
   */
      static int
! bytes2offset(pp)
!     char_u	**pp;
  {
      char_u	*p = *pp;
      int		nr;
--- 8846,8852 ----
   * Returns the offset.
   */
      static int
! bytes2offset(char_u **pp)
  {
      char_u	*p = *pp;
      int		nr;
***************
*** 9002,9010 ****
   * Write the .sug file in "fname".
   */
      static void
! sug_write(spin, fname)
!     spellinfo_T	*spin;
!     char_u	*fname;
  {
      FILE	*fd;
      wordnode_T	*tree;
--- 8884,8890 ----
   * Write the .sug file in "fname".
   */
      static void
! sug_write(spellinfo_T *spin, char_u *fname)
  {
      FILE	*fd;
      wordnode_T	*tree;
***************
*** 9101,9107 ****
   * Returns NULL when out of memory.
   */
      static buf_T *
! open_spellbuf()
  {
      buf_T	*buf;
  
--- 8981,8987 ----
   * Returns NULL when out of memory.
   */
      static buf_T *
! open_spellbuf(void)
  {
      buf_T	*buf;
  
***************
*** 9123,9130 ****
   * Close the buffer used for spell info.
   */
      static void
! close_spellbuf(buf)
!     buf_T	*buf;
  {
      if (buf != NULL)
      {
--- 9003,9009 ----
   * Close the buffer used for spell info.
   */
      static void
! close_spellbuf(buf_T *buf)
  {
      if (buf != NULL)
      {
***************
*** 9142,9153 ****
   * and ".spl" is appended to make the output file name.
   */
      static void
! mkspell(fcount, fnames, ascii, over_write, added_word)
!     int		fcount;
!     char_u	**fnames;
!     int		ascii;		    /* -ascii argument given */
!     int		over_write;	    /* overwrite existing output file */
!     int		added_word;	    /* invoked through "zg" */
  {
      char_u	*fname = NULL;
      char_u	*wfname;
--- 9021,9032 ----
   * and ".spl" is appended to make the output file name.
   */
      static void
! mkspell(
!     int		fcount,
!     char_u	**fnames,
!     int		ascii,		    /* -ascii argument given */
!     int		over_write,	    /* overwrite existing output file */
!     int		added_word)	    /* invoked through "zg" */
  {
      char_u	*fname = NULL;
      char_u	*wfname;
***************
*** 9402,9410 ****
   * ":mkspell".  "str" can be IObuff.
   */
      static void
! spell_message(spin, str)
!     spellinfo_T *spin;
!     char_u	*str;
  {
      if (spin->si_verbose || p_verbose > 2)
      {
--- 9281,9287 ----
   * ":mkspell".  "str" can be IObuff.
   */
      static void
! spell_message(spellinfo_T *spin, char_u *str)
  {
      if (spin->si_verbose || p_verbose > 2)
      {
***************
*** 9423,9430 ****
   * ":[count]spellundo  {word}"
   */
      void
! ex_spell(eap)
!     exarg_T *eap;
  {
      spell_add_word(eap->arg, (int)STRLEN(eap->arg), eap->cmdidx == CMD_spellwrong,
  				   eap->forceit ? 0 : (int)eap->line2,
--- 9300,9306 ----
   * ":[count]spellundo  {word}"
   */
      void
! ex_spell(exarg_T *eap)
  {
      spell_add_word(eap->arg, (int)STRLEN(eap->arg), eap->cmdidx == CMD_spellwrong,
  				   eap->forceit ? 0 : (int)eap->line2,
***************
*** 9435,9447 ****
   * Add "word[len]" to 'spellfile' as a good or bad word.
   */
      void
! spell_add_word(word, len, bad, idx, undo)
!     char_u	*word;
!     int		len;
!     int		bad;
!     int		idx;	    /* "zG" and "zW": zero, otherwise index in
  			       'spellfile' */
!     int		undo;	    /* TRUE for "zug", "zuG", "zuw" and "zuW" */
  {
      FILE	*fd = NULL;
      buf_T	*buf = NULL;
--- 9311,9323 ----
   * Add "word[len]" to 'spellfile' as a good or bad word.
   */
      void
! spell_add_word(
!     char_u	*word,
!     int		len,
!     int		bad,
!     int		idx,	    /* "zG" and "zW": zero, otherwise index in
  			       'spellfile' */
!     int		undo)	    /* TRUE for "zug", "zuG", "zuw" and "zuW" */
  {
      FILE	*fd = NULL;
      buf_T	*buf = NULL;
***************
*** 9604,9610 ****
   * Initialize 'spellfile' for the current buffer.
   */
      static void
! init_spellfile()
  {
      char_u	*buf;
      int		l;
--- 9480,9486 ----
   * Initialize 'spellfile' for the current buffer.
   */
      static void
! init_spellfile(void)
  {
      char_u	*buf;
      int		l;
***************
*** 9685,9692 ****
   * EBCDIC is not supported!
   */
      static void
! clear_spell_chartab(sp)
!     spelltab_T	*sp;
  {
      int		i;
  
--- 9561,9567 ----
   * EBCDIC is not supported!
   */
      static void
! clear_spell_chartab(spelltab_T *sp)
  {
      int		i;
  
***************
*** 9724,9730 ****
   * locale.  For utf-8 we don't use isalpha() but our own functions.
   */
      void
! init_spell_chartab()
  {
      int	    i;
  
--- 9599,9605 ----
   * locale.  For utf-8 we don't use isalpha() but our own functions.
   */
      void
! init_spell_chartab(void)
  {
      int	    i;
  
***************
*** 9779,9788 ****
   * Set the spell character tables from strings in the affix file.
   */
      static int
! set_spell_chartab(fol, low, upp)
!     char_u	*fol;
!     char_u	*low;
!     char_u	*upp;
  {
      /* We build the new tables here first, so that we can compare with the
       * previous one. */
--- 9654,9660 ----
   * Set the spell character tables from strings in the affix file.
   */
      static int
! set_spell_chartab(char_u *fol, char_u *low, char_u *upp)
  {
      /* We build the new tables here first, so that we can compare with the
       * previous one. */
***************
*** 9857,9866 ****
   * Set the spell character tables from strings in the .spl file.
   */
      static void
! set_spell_charflags(flags, cnt, fol)
!     char_u	*flags;
!     int		cnt;	    /* length of "flags" */
!     char_u	*fol;
  {
      /* We build the new tables here first, so that we can compare with the
       * previous one. */
--- 9729,9738 ----
   * Set the spell character tables from strings in the .spl file.
   */
      static void
! set_spell_charflags(
!     char_u	*flags,
!     int		cnt,	    /* length of "flags" */
!     char_u	*fol)
  {
      /* We build the new tables here first, so that we can compare with the
       * previous one. */
***************
*** 9896,9903 ****
  }
  
      static int
! set_spell_finish(new_st)
!     spelltab_T	*new_st;
  {
      int		i;
  
--- 9768,9774 ----
  }
  
      static int
! set_spell_finish(spelltab_T *new_st)
  {
      int		i;
  
***************
*** 9933,9941 ****
   * Thus this only works properly when past the first character of the word.
   */
      static int
! spell_iswordp(p, wp)
!     char_u	*p;
!     win_T	*wp;	    /* buffer used */
  {
  #ifdef FEAT_MBYTE
      char_u	*s;
--- 9804,9812 ----
   * Thus this only works properly when past the first character of the word.
   */
      static int
! spell_iswordp(
!     char_u	*p,
!     win_T	*wp)	    /* buffer used */
  {
  #ifdef FEAT_MBYTE
      char_u	*s;
***************
*** 9976,9984 ****
   * Unlike spell_iswordp() this doesn't check for "midword" characters.
   */
      static int
! spell_iswordp_nmw(p, wp)
!     char_u	*p;
!     win_T	*wp;
  {
  #ifdef FEAT_MBYTE
      int		c;
--- 9847,9853 ----
   * Unlike spell_iswordp() this doesn't check for "midword" characters.
   */
      static int
! spell_iswordp_nmw(char_u *p, win_T *wp)
  {
  #ifdef FEAT_MBYTE
      int		c;
***************
*** 10002,10010 ****
   * See also dbcs_class() and utf_class() in mbyte.c.
   */
      static int
! spell_mb_isword_class(cl, wp)
!     int		cl;
!     win_T	*wp;
  {
      if (wp->w_s->b_cjk)
  	/* East Asian characters are not considered word characters. */
--- 9871,9877 ----
   * See also dbcs_class() and utf_class() in mbyte.c.
   */
      static int
! spell_mb_isword_class(int cl, win_T *wp)
  {
      if (wp->w_s->b_cjk)
  	/* East Asian characters are not considered word characters. */
***************
*** 10017,10025 ****
   * Wide version of spell_iswordp().
   */
      static int
! spell_iswordp_w(p, wp)
!     int		*p;
!     win_T	*wp;
  {
      int		*s;
  
--- 9884,9890 ----
   * Wide version of spell_iswordp().
   */
      static int
! spell_iswordp_w(int *p, win_T *wp)
  {
      int		*s;
  
***************
*** 10048,10056 ****
   * When "fd" is NULL only count the length of what is written.
   */
      static int
! write_spell_prefcond(fd, gap)
!     FILE	*fd;
!     garray_T	*gap;
  {
      int		i;
      char_u	*p;
--- 9913,9919 ----
   * When "fd" is NULL only count the length of what is written.
   */
      static int
! write_spell_prefcond(FILE *fd, garray_T *gap)
  {
      int		i;
      char_u	*p;
***************
*** 10091,10101 ****
   * Returns FAIL when something wrong.
   */
      static int
! spell_casefold(str, len, buf, buflen)
!     char_u	*str;
!     int		len;
!     char_u	*buf;
!     int		buflen;
  {
      int		i;
  
--- 9954,9964 ----
   * Returns FAIL when something wrong.
   */
      static int
! spell_casefold(
!     char_u	*str,
!     int		len,
!     char_u	*buf,
!     int		buflen)
  {
      int		i;
  
***************
*** 10150,10156 ****
   * Sets "sps_flags" and "sps_limit".
   */
      int
! spell_check_sps()
  {
      char_u	*p;
      char_u	*s;
--- 10013,10019 ----
   * Sets "sps_flags" and "sps_limit".
   */
      int
! spell_check_sps(void)
  {
      char_u	*p;
      char_u	*s;
***************
*** 10205,10212 ****
   * When "count" is non-zero use that suggestion.
   */
      void
! spell_suggest(count)
!     int		count;
  {
      char_u	*line;
      pos_T	prev_cursor = curwin->w_cursor;
--- 10068,10074 ----
   * When "count" is non-zero use that suggestion.
   */
      void
! spell_suggest(int count)
  {
      char_u	*line;
      pos_T	prev_cursor = curwin->w_cursor;
***************
*** 10448,10456 ****
   * capital.  This uses 'spellcapcheck' of the current buffer.
   */
      static int
! check_need_cap(lnum, col)
!     linenr_T	lnum;
!     colnr_T	col;
  {
      int		need_cap = FALSE;
      char_u	*line;
--- 10310,10316 ----
   * capital.  This uses 'spellcapcheck' of the current buffer.
   */
      static int
! check_need_cap(linenr_T lnum, colnr_T col)
  {
      int		need_cap = FALSE;
      char_u	*line;
***************
*** 10518,10525 ****
   * ":spellrepall"
   */
      void
! ex_spellrepall(eap)
!     exarg_T *eap UNUSED;
  {
      pos_T	pos = curwin->w_cursor;
      char_u	*frompat;
--- 10378,10384 ----
   * ":spellrepall"
   */
      void
! ex_spellrepall(exarg_T *eap UNUSED)
  {
      pos_T	pos = curwin->w_cursor;
      char_u	*frompat;
***************
*** 10591,10602 ****
   * a list of allocated strings.
   */
      void
! spell_suggest_list(gap, word, maxcount, need_cap, interactive)
!     garray_T	*gap;
!     char_u	*word;
!     int		maxcount;	/* maximum nr of suggestions */
!     int		need_cap;	/* 'spellcapcheck' matched */
!     int		interactive;
  {
      suginfo_T	sug;
      int		i;
--- 10450,10461 ----
   * a list of allocated strings.
   */
      void
! spell_suggest_list(
!     garray_T	*gap,
!     char_u	*word,
!     int		maxcount,	/* maximum nr of suggestions */
!     int		need_cap,	/* 'spellcapcheck' matched */
!     int		interactive)
  {
      suginfo_T	sug;
      int		i;
***************
*** 10636,10649 ****
   * This is based on the mechanisms of Aspell, but completely reimplemented.
   */
      static void
! spell_find_suggest(badptr, badlen, su, maxcount, banbadword, need_cap, interactive)
!     char_u	*badptr;
!     int		badlen;		/* length of bad word or 0 if unknown */
!     suginfo_T	*su;
!     int		maxcount;
!     int		banbadword;	/* don't include badword in suggestions */
!     int		need_cap;	/* word should start with capital */
!     int		interactive;
  {
      hlf_T	attr = HLF_COUNT;
      char_u	buf[MAXPATHL];
--- 10495,10508 ----
   * This is based on the mechanisms of Aspell, but completely reimplemented.
   */
      static void
! spell_find_suggest(
!     char_u	*badptr,
!     int		badlen,		/* length of bad word or 0 if unknown */
!     suginfo_T	*su,
!     int		maxcount,
!     int		banbadword,	/* don't include badword in suggestions */
!     int		need_cap,	/* word should start with capital */
!     int		interactive)
  {
      hlf_T	attr = HLF_COUNT;
      char_u	buf[MAXPATHL];
***************
*** 10769,10777 ****
   * Find suggestions by evaluating expression "expr".
   */
      static void
! spell_suggest_expr(su, expr)
!     suginfo_T	*su;
!     char_u	*expr;
  {
      list_T	*list;
      listitem_T	*li;
--- 10628,10634 ----
   * Find suggestions by evaluating expression "expr".
   */
      static void
! spell_suggest_expr(suginfo_T *su, char_u *expr)
  {
      list_T	*list;
      listitem_T	*li;
***************
*** 10807,10815 ****
   * Find suggestions in file "fname".  Used for "file:" in 'spellsuggest'.
   */
      static void
! spell_suggest_file(su, fname)
!     suginfo_T	*su;
!     char_u	*fname;
  {
      FILE	*fd;
      char_u	line[MAXWLEN * 2];
--- 10664,10670 ----
   * Find suggestions in file "fname".  Used for "file:" in 'spellsuggest'.
   */
      static void
! spell_suggest_file(suginfo_T *su, char_u *fname)
  {
      FILE	*fd;
      char_u	line[MAXWLEN * 2];
***************
*** 10865,10873 ****
   * Find suggestions for the internal method indicated by "sps_flags".
   */
      static void
! spell_suggest_intern(su, interactive)
!     suginfo_T	*su;
!     int		interactive;
  {
      /*
       * Load the .sug file(s) that are available and not done yet.
--- 10720,10726 ----
   * Find suggestions for the internal method indicated by "sps_flags".
   */
      static void
! spell_suggest_intern(suginfo_T *su, int interactive)
  {
      /*
       * Load the .sug file(s) that are available and not done yet.
***************
*** 10959,10965 ****
   * Load the .sug files for languages that have one and weren't loaded yet.
   */
      static void
! suggest_load_files()
  {
      langp_T	*lp;
      int		lpi;
--- 10812,10818 ----
   * Load the .sug files for languages that have one and weren't loaded yet.
   */
      static void
! suggest_load_files(void)
  {
      langp_T	*lp;
      int		lpi;
***************
*** 11100,11108 ****
   * Returns the total number of words.
   */
      static void
! tree_count_words(byts, idxs)
!     char_u	*byts;
!     idx_T	*idxs;
  {
      int		depth;
      idx_T	arridx[MAXWLEN];
--- 10953,10959 ----
   * Returns the total number of words.
   */
      static void
! tree_count_words(char_u *byts, idx_T *idxs)
  {
      int		depth;
      idx_T	arridx[MAXWLEN];
***************
*** 11163,11170 ****
   * Free the info put in "*su" by spell_find_suggest().
   */
      static void
! spell_find_cleanup(su)
!     suginfo_T	*su;
  {
      int		i;
  
--- 11014,11020 ----
   * Free the info put in "*su" by spell_find_suggest().
   */
      static void
! spell_find_cleanup(suginfo_T *su)
  {
      int		i;
  
***************
*** 11186,11195 ****
   * The result is NUL terminated.
   */
      static void
! onecap_copy(word, wcopy, upper)
!     char_u	*word;
!     char_u	*wcopy;
!     int		upper;	    /* TRUE: first letter made upper case */
  {
      char_u	*p;
      int		c;
--- 11036,11045 ----
   * The result is NUL terminated.
   */
      static void
! onecap_copy(
!     char_u	*word,
!     char_u	*wcopy,
!     int		upper)	    /* TRUE: first letter made upper case */
  {
      char_u	*p;
      int		c;
***************
*** 11223,11231 ****
   * "wcopy[MAXWLEN]".  The result is NUL terminated.
   */
      static void
! allcap_copy(word, wcopy)
!     char_u	*word;
!     char_u	*wcopy;
  {
      char_u	*s;
      char_u	*d;
--- 11073,11079 ----
   * "wcopy[MAXWLEN]".  The result is NUL terminated.
   */
      static void
! allcap_copy(char_u *word, char_u *wcopy)
  {
      char_u	*s;
      char_u	*d;
***************
*** 11277,11284 ****
   * Try finding suggestions by recognizing specific situations.
   */
      static void
! suggest_try_special(su)
!     suginfo_T	*su;
  {
      char_u	*p;
      size_t	len;
--- 11125,11131 ----
   * Try finding suggestions by recognizing specific situations.
   */
      static void
! suggest_try_special(suginfo_T *su)
  {
      char_u	*p;
      size_t	len;
***************
*** 11361,11368 ****
   * Try finding suggestions by adding/removing/swapping letters.
   */
      static void
! suggest_try_change(su)
!     suginfo_T	*su;
  {
      char_u	fword[MAXWLEN];	    /* copy of the bad word, case-folded */
      int		n;
--- 11208,11214 ----
   * Try finding suggestions by adding/removing/swapping letters.
   */
      static void
! suggest_try_change(suginfo_T *su)
  {
      char_u	fword[MAXWLEN];	    /* copy of the bad word, case-folded */
      int		n;
***************
*** 11434,11444 ****
   *	use "slang->sl_repsal" instead of "lp->lp_replang->sl_rep"
   */
      static void
! suggest_trie_walk(su, lp, fword, soundfold)
!     suginfo_T	*su;
!     langp_T	*lp;
!     char_u	*fword;
!     int		soundfold;
  {
      char_u	tword[MAXWLEN];	    /* good word collected so far */
      trystate_T	stack[MAXWLEN];
--- 11280,11290 ----
   *	use "slang->sl_repsal" instead of "lp->lp_replang->sl_rep"
   */
      static void
! suggest_trie_walk(
!     suginfo_T	*su,
!     langp_T	*lp,
!     char_u	*fword,
!     int		soundfold)
  {
      char_u	tword[MAXWLEN];	    /* good word collected so far */
      trystate_T	stack[MAXWLEN];
***************
*** 12934,12943 ****
   * Go one level deeper in the tree.
   */
      static void
! go_deeper(stack, depth, score_add)
!     trystate_T	*stack;
!     int		depth;
!     int		score_add;
  {
      stack[depth + 1] = stack[depth];
      stack[depth + 1].ts_state = STATE_START;
--- 12780,12786 ----
   * Go one level deeper in the tree.
   */
      static void
! go_deeper(trystate_T *stack, int depth, int score_add)
  {
      stack[depth + 1] = stack[depth];
      stack[depth + 1].ts_state = STATE_START;
***************
*** 12952,12961 ****
   * fword[flen] and return the byte length of that many chars in "word".
   */
      static int
! nofold_len(fword, flen, word)
!     char_u	*fword;
!     int		flen;
!     char_u	*word;
  {
      char_u	*p;
      int		i = 0;
--- 12795,12801 ----
   * fword[flen] and return the byte length of that many chars in "word".
   */
      static int
! nofold_len(char_u *fword, int flen, char_u *word)
  {
      char_u	*p;
      int		i = 0;
***************
*** 12975,12984 ****
   * same case-folded word, but we only find one...
   */
      static void
! find_keepcap_word(slang, fword, kword)
!     slang_T	*slang;
!     char_u	*fword;
!     char_u	*kword;
  {
      char_u	uword[MAXWLEN];		/* "fword" in upper-case */
      int		depth;
--- 12815,12821 ----
   * same case-folded word, but we only find one...
   */
      static void
! find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)
  {
      char_u	uword[MAXWLEN];		/* "fword" in upper-case */
      int		depth;
***************
*** 13134,13141 ****
   * su->su_sga.
   */
      static void
! score_comp_sal(su)
!     suginfo_T	*su;
  {
      langp_T	*lp;
      char_u	badsound[MAXWLEN];
--- 12971,12977 ----
   * su->su_sga.
   */
      static void
! score_comp_sal(suginfo_T *su)
  {
      langp_T	*lp;
      char_u	badsound[MAXWLEN];
***************
*** 13189,13196 ****
   * They are entwined.
   */
      static void
! score_combine(su)
!     suginfo_T	*su;
  {
      int		i;
      int		j;
--- 13025,13031 ----
   * They are entwined.
   */
      static void
! score_combine(suginfo_T *su)
  {
      int		i;
      int		j;
***************
*** 13302,13312 ****
   * badword.
   */
      static int
! stp_sal_score(stp, su, slang, badsound)
!     suggest_T	*stp;
!     suginfo_T	*su;
!     slang_T	*slang;
!     char_u	*badsound;	/* sound-folded badword */
  {
      char_u	*p;
      char_u	*pbad;
--- 13137,13147 ----
   * badword.
   */
      static int
! stp_sal_score(
!     suggest_T	*stp,
!     suginfo_T	*su,
!     slang_T	*slang,
!     char_u	*badsound)	/* sound-folded badword */
  {
      char_u	*p;
      char_u	*pbad;
***************
*** 13372,13378 ****
   * Prepare for calling suggest_try_soundalike().
   */
      static void
! suggest_try_soundalike_prep()
  {
      langp_T	*lp;
      int		lpi;
--- 13207,13213 ----
   * Prepare for calling suggest_try_soundalike().
   */
      static void
! suggest_try_soundalike_prep(void)
  {
      langp_T	*lp;
      int		lpi;
***************
*** 13395,13402 ****
   * Note: This doesn't support postponed prefixes.
   */
      static void
! suggest_try_soundalike(su)
!     suginfo_T	*su;
  {
      char_u	salword[MAXWLEN];
      langp_T	*lp;
--- 13230,13236 ----
   * Note: This doesn't support postponed prefixes.
   */
      static void
! suggest_try_soundalike(suginfo_T *su)
  {
      char_u	salword[MAXWLEN];
      langp_T	*lp;
***************
*** 13432,13438 ****
   * Finish up after calling suggest_try_soundalike().
   */
      static void
! suggest_try_soundalike_finish()
  {
      langp_T	*lp;
      int		lpi;
--- 13266,13272 ----
   * Finish up after calling suggest_try_soundalike().
   */
      static void
! suggest_try_soundalike_finish(void)
  {
      langp_T	*lp;
      int		lpi;
***************
*** 13469,13479 ****
   * produce this soundfolded word.
   */
      static void
! add_sound_suggest(su, goodword, score, lp)
!     suginfo_T	*su;
!     char_u	*goodword;
!     int		score;		/* soundfold score  */
!     langp_T	*lp;
  {
      slang_T	*slang = lp->lp_slang;	/* language for sound folding */
      int		sfwordnr;
--- 13303,13313 ----
   * produce this soundfolded word.
   */
      static void
! add_sound_suggest(
!     suginfo_T	*su,
!     char_u	*goodword,
!     int		score,		/* soundfold score  */
!     langp_T	*lp)
  {
      slang_T	*slang = lp->lp_slang;	/* language for sound folding */
      int		sfwordnr;
***************
*** 13677,13685 ****
   * Find word "word" in fold-case tree for "slang" and return the word number.
   */
      static int
! soundfold_find(slang, word)
!     slang_T	*slang;
!     char_u	*word;
  {
      idx_T	arridx = 0;
      int		len;
--- 13511,13517 ----
   * Find word "word" in fold-case tree for "slang" and return the word number.
   */
      static int
! soundfold_find(slang_T *slang, char_u *word)
  {
      idx_T	arridx = 0;
      int		len;
***************
*** 13753,13762 ****
   * Copy "fword" to "cword", fixing case according to "flags".
   */
      static void
! make_case_word(fword, cword, flags)
!     char_u	*fword;
!     char_u	*cword;
!     int		flags;
  {
      if (flags & WF_ALLCAP)
  	/* Make it all upper-case */
--- 13585,13591 ----
   * Copy "fword" to "cword", fixing case according to "flags".
   */
      static void
! make_case_word(char_u *fword, char_u *cword, int flags)
  {
      if (flags & WF_ALLCAP)
  	/* Make it all upper-case */
***************
*** 13773,13781 ****
   * Use map string "map" for languages "lp".
   */
      static void
! set_map_str(lp, map)
!     slang_T	*lp;
!     char_u	*map;
  {
      char_u	*p;
      int		headc = 0;
--- 13602,13608 ----
   * Use map string "map" for languages "lp".
   */
      static void
! set_map_str(slang_T *lp, char_u *map)
  {
      char_u	*p;
      int		headc = 0;
***************
*** 13858,13867 ****
   * lines in the .aff file.
   */
      static int
! similar_chars(slang, c1, c2)
!     slang_T	*slang;
!     int		c1;
!     int		c2;
  {
      int		m1, m2;
  #ifdef FEAT_MBYTE
--- 13685,13691 ----
   * lines in the .aff file.
   */
      static int
! similar_chars(slang_T *slang, int c1, int c2)
  {
      int		m1, m2;
  #ifdef FEAT_MBYTE
***************
*** 13906,13922 ****
   * For a suggestion that is already in the list the lowest score is remembered.
   */
      static void
! add_suggestion(su, gap, goodword, badlenarg, score, altscore, had_bonus,
! 								 slang, maxsf)
!     suginfo_T	*su;
!     garray_T	*gap;		/* either su_ga or su_sga */
!     char_u	*goodword;
!     int		badlenarg;	/* len of bad word replaced with "goodword" */
!     int		score;
!     int		altscore;
!     int		had_bonus;	/* value for st_had_bonus */
!     slang_T	*slang;		/* language for sound folding */
!     int		maxsf;		/* su_maxscore applies to soundfold score,
  				   su_sfmaxscore to the total score. */
  {
      int		goodlen;	/* len of goodword changed */
--- 13730,13745 ----
   * For a suggestion that is already in the list the lowest score is remembered.
   */
      static void
! add_suggestion(
!     suginfo_T	*su,
!     garray_T	*gap,		/* either su_ga or su_sga */
!     char_u	*goodword,
!     int		badlenarg,	/* len of bad word replaced with "goodword" */
!     int		score,
!     int		altscore,
!     int		had_bonus,	/* value for st_had_bonus */
!     slang_T	*slang,		/* language for sound folding */
!     int		maxsf)		/* su_maxscore applies to soundfold score,
  				   su_sfmaxscore to the total score. */
  {
      int		goodlen;	/* len of goodword changed */
***************
*** 14043,14051 ****
   * for split words, such as "the the".  Remove these from the list here.
   */
      static void
! check_suggestions(su, gap)
!     suginfo_T	*su;
!     garray_T	*gap;		    /* either su_ga or su_sga */
  {
      suggest_T   *stp;
      int		i;
--- 13866,13874 ----
   * for split words, such as "the the".  Remove these from the list here.
   */
      static void
! check_suggestions(
!     suginfo_T	*su,
!     garray_T	*gap)		    /* either su_ga or su_sga */
  {
      suggest_T   *stp;
      int		i;
***************
*** 14080,14088 ****
   * Add a word to be banned.
   */
      static void
! add_banned(su, word)
!     suginfo_T	*su;
!     char_u	*word;
  {
      char_u	*s;
      hash_T	hash;
--- 13903,13911 ----
   * Add a word to be banned.
   */
      static void
! add_banned(
!     suginfo_T	*su,
!     char_u	*word)
  {
      char_u	*s;
      hash_T	hash;
***************
*** 14103,14110 ****
   * is slow, thus only done for the final results.
   */
      static void
! rescore_suggestions(su)
!     suginfo_T	*su;
  {
      int		i;
  
--- 13926,13932 ----
   * is slow, thus only done for the final results.
   */
      static void
! rescore_suggestions(suginfo_T *su)
  {
      int		i;
  
***************
*** 14117,14125 ****
   * Recompute the score for one suggestion if sound-folding is possible.
   */
      static void
! rescore_one(su, stp)
!     suginfo_T	*su;
!     suggest_T	*stp;
  {
      slang_T	*slang = stp->st_slang;
      char_u	sal_badword[MAXWLEN];
--- 13939,13945 ----
   * Recompute the score for one suggestion if sound-folding is possible.
   */
      static void
! rescore_one(suginfo_T *su, suggest_T *stp)
  {
      slang_T	*slang = stp->st_slang;
      char_u	sal_badword[MAXWLEN];
***************
*** 14159,14167 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sug_compare(s1, s2)
!     const void	*s1;
!     const void	*s2;
  {
      suggest_T	*p1 = (suggest_T *)s1;
      suggest_T	*p2 = (suggest_T *)s2;
--- 13979,13985 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! sug_compare(const void *s1, const void *s2)
  {
      suggest_T	*p1 = (suggest_T *)s1;
      suggest_T	*p2 = (suggest_T *)s2;
***************
*** 14183,14192 ****
   * Returns the maximum score in the list or "maxscore" unmodified.
   */
      static int
! cleanup_suggestions(gap, maxscore, keep)
!     garray_T	*gap;
!     int		maxscore;
!     int		keep;		/* nr of suggestions to keep */
  {
      suggest_T   *stp = &SUG(*gap, 0);
      int		i;
--- 14001,14010 ----
   * Returns the maximum score in the list or "maxscore" unmodified.
   */
      static int
! cleanup_suggestions(
!     garray_T	*gap,
!     int		maxscore,
!     int		keep)		/* nr of suggestions to keep */
  {
      suggest_T   *stp = &SUG(*gap, 0);
      int		i;
***************
*** 14211,14218 ****
   * Result is in allocated memory, NULL for an error.
   */
      char_u *
! eval_soundfold(word)
!     char_u	*word;
  {
      langp_T	*lp;
      char_u	sound[MAXWLEN];
--- 14029,14035 ----
   * Result is in allocated memory, NULL for an error.
   */
      char_u *
! eval_soundfold(char_u *word)
  {
      langp_T	*lp;
      char_u	sound[MAXWLEN];
***************
*** 14249,14259 ****
   * 2. SAL items define a more advanced sound-folding (and much slower).
   */
      static void
! spell_soundfold(slang, inword, folded, res)
!     slang_T	*slang;
!     char_u	*inword;
!     int		folded;	    /* "inword" is already case-folded */
!     char_u	*res;
  {
      char_u	fword[MAXWLEN];
      char_u	*word;
--- 14066,14076 ----
   * 2. SAL items define a more advanced sound-folding (and much slower).
   */
      static void
! spell_soundfold(
!     slang_T	*slang,
!     char_u	*inword,
!     int		folded,	    /* "inword" is already case-folded */
!     char_u	*res)
  {
      char_u	fword[MAXWLEN];
      char_u	*word;
***************
*** 14286,14295 ****
   * SOFOTO lines.
   */
      static void
! spell_soundfold_sofo(slang, inword, res)
!     slang_T	*slang;
!     char_u	*inword;
!     char_u	*res;
  {
      char_u	*s;
      int		ri = 0;
--- 14103,14109 ----
   * SOFOTO lines.
   */
      static void
! spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)
  {
      char_u	*s;
      int		ri = 0;
***************
*** 14360,14369 ****
  }
  
      static void
! spell_soundfold_sal(slang, inword, res)
!     slang_T	*slang;
!     char_u	*inword;
!     char_u	*res;
  {
      salitem_T	*smp;
      char_u	word[MAXWLEN];
--- 14174,14180 ----
  }
  
      static void
! spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)
  {
      salitem_T	*smp;
      char_u	word[MAXWLEN];
***************
*** 14641,14650 ****
   * Multi-byte version of spell_soundfold().
   */
      static void
! spell_soundfold_wsal(slang, inword, res)
!     slang_T	*slang;
!     char_u	*inword;
!     char_u	*res;
  {
      salitem_T	*smp = (salitem_T *)slang->sl_sal.ga_data;
      int		word[MAXWLEN];
--- 14452,14458 ----
   * Multi-byte version of spell_soundfold().
   */
      static void
! spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)
  {
      salitem_T	*smp = (salitem_T *)slang->sl_sal.ga_data;
      int		word[MAXWLEN];
***************
*** 14960,14968 ****
   * avoiding checks that will not be possible.
   */
      static int
! soundalike_score(goodstart, badstart)
!     char_u	*goodstart;	/* sound-folded good word */
!     char_u	*badstart;	/* sound-folded bad word */
  {
      char_u	*goodsound = goodstart;
      char_u	*badsound = badstart;
--- 14768,14776 ----
   * avoiding checks that will not be possible.
   */
      static int
! soundalike_score(
!     char_u	*goodstart,	/* sound-folded good word */
!     char_u	*badstart)	/* sound-folded bad word */
  {
      char_u	*goodsound = goodstart;
      char_u	*badsound = badstart;
***************
*** 15195,15204 ****
   * support multi-byte characters.
   */
      static int
! spell_edit_score(slang, badword, goodword)
!     slang_T	*slang;
!     char_u	*badword;
!     char_u	*goodword;
  {
      int		*cnt;
      int		badlen, goodlen;	/* lengths including NUL */
--- 15003,15012 ----
   * support multi-byte characters.
   */
      static int
! spell_edit_score(
!     slang_T	*slang,
!     char_u	*badword,
!     char_u	*goodword)
  {
      int		*cnt;
      int		badlen, goodlen;	/* lengths including NUL */
***************
*** 15327,15337 ****
   * for multi-byte characters.
   */
      static int
! spell_edit_score_limit(slang, badword, goodword, limit)
!     slang_T	*slang;
!     char_u	*badword;
!     char_u	*goodword;
!     int		limit;
  {
      limitscore_T    stack[10];		/* allow for over 3 * 2 edits */
      int		    stackidx;
--- 15135,15145 ----
   * for multi-byte characters.
   */
      static int
! spell_edit_score_limit(
!     slang_T	*slang,
!     char_u	*badword,
!     char_u	*goodword,
!     int		limit)
  {
      limitscore_T    stack[10];		/* allow for over 3 * 2 edits */
      int		    stackidx;
***************
*** 15509,15519 ****
   * Keep it in sync with the above!
   */
      static int
! spell_edit_score_limit_w(slang, badword, goodword, limit)
!     slang_T	*slang;
!     char_u	*badword;
!     char_u	*goodword;
!     int		limit;
  {
      limitscore_T    stack[10];		/* allow for over 3 * 2 edits */
      int		    stackidx;
--- 15317,15327 ----
   * Keep it in sync with the above!
   */
      static int
! spell_edit_score_limit_w(
!     slang_T	*slang,
!     char_u	*badword,
!     char_u	*goodword,
!     int		limit)
  {
      limitscore_T    stack[10];		/* allow for over 3 * 2 edits */
      int		    stackidx;
***************
*** 15698,15705 ****
   * ":spellinfo"
   */
      void
! ex_spellinfo(eap)
!     exarg_T *eap UNUSED;
  {
      int		lpi;
      langp_T	*lp;
--- 15506,15512 ----
   * ":spellinfo"
   */
      void
! ex_spellinfo(exarg_T *eap UNUSED)
  {
      int		lpi;
      langp_T	*lp;
***************
*** 15735,15742 ****
   * ":spelldump"
   */
      void
! ex_spelldump(eap)
!     exarg_T *eap;
  {
      char_u  *spl;
      long    dummy;
--- 15542,15548 ----
   * ":spelldump"
   */
      void
! ex_spelldump(exarg_T *eap)
  {
      char_u  *spl;
      long    dummy;
***************
*** 15772,15782 ****
   * 2. When "pat" is not NULL: add matching words to insert mode completion.
   */
      void
! spell_dump_compl(pat, ic, dir, dumpflags_arg)
!     char_u	*pat;	    /* leading part of the word */
!     int		ic;	    /* ignore case */
!     int		*dir;	    /* direction for adding matches */
!     int		dumpflags_arg;	/* DUMPFLAG_* */
  {
      langp_T	*lp;
      slang_T	*slang;
--- 15578,15588 ----
   * 2. When "pat" is not NULL: add matching words to insert mode completion.
   */
      void
! spell_dump_compl(
!     char_u	*pat,	    /* leading part of the word */
!     int		ic,	    /* ignore case */
!     int		*dir,	    /* direction for adding matches */
!     int		dumpflags_arg)	/* DUMPFLAG_* */
  {
      langp_T	*lp;
      slang_T	*slang;
***************
*** 15973,15986 ****
   * When "lnum" is zero add insert mode completion.
   */
      static void
! dump_word(slang, word, pat, dir, dumpflags, wordflags, lnum)
!     slang_T	*slang;
!     char_u	*word;
!     char_u	*pat;
!     int		*dir;
!     int		dumpflags;
!     int		wordflags;
!     linenr_T	lnum;
  {
      int		keepcap = FALSE;
      char_u	*p;
--- 15779,15792 ----
   * When "lnum" is zero add insert mode completion.
   */
      static void
! dump_word(
!     slang_T	*slang,
!     char_u	*word,
!     char_u	*pat,
!     int		*dir,
!     int		dumpflags,
!     int		wordflags,
!     linenr_T	lnum)
  {
      int		keepcap = FALSE;
      char_u	*p;
***************
*** 16063,16076 ****
   * Return the updated line number.
   */
      static linenr_T
! dump_prefixes(slang, word, pat, dir, dumpflags, flags, startlnum)
!     slang_T	*slang;
!     char_u	*word;	    /* case-folded word */
!     char_u	*pat;
!     int		*dir;
!     int		dumpflags;
!     int		flags;	    /* flags with prefix ID */
!     linenr_T	startlnum;
  {
      idx_T	arridx[MAXWLEN];
      int		curi[MAXWLEN];
--- 15869,15882 ----
   * Return the updated line number.
   */
      static linenr_T
! dump_prefixes(
!     slang_T	*slang,
!     char_u	*word,	    /* case-folded word */
!     char_u	*pat,
!     int		*dir,
!     int		dumpflags,
!     int		flags,	    /* flags with prefix ID */
!     linenr_T	startlnum)
  {
      idx_T	arridx[MAXWLEN];
      int		curi[MAXWLEN];
***************
*** 16179,16187 ****
   * Uses the spell-checking word characters.
   */
      char_u *
! spell_to_word_end(start, win)
!     char_u  *start;
!     win_T   *win;
  {
      char_u  *p = start;
  
--- 15985,15991 ----
   * Uses the spell-checking word characters.
   */
      char_u *
! spell_to_word_end(char_u *start, win_T *win)
  {
      char_u  *p = start;
  
***************
*** 16199,16206 ****
   * Returns the column number of the word.
   */
      int
! spell_word_start(startcol)
!     int		startcol;
  {
      char_u	*line;
      char_u	*p;
--- 16003,16009 ----
   * Returns the column number of the word.
   */
      int
! spell_word_start(int startcol)
  {
      char_u	*line;
      char_u	*p;
***************
*** 16238,16245 ****
  static int spell_expand_need_cap;
  
      void
! spell_expand_check_cap(col)
!     colnr_T col;
  {
      spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);
  }
--- 16041,16047 ----
  static int spell_expand_need_cap;
  
      void
! spell_expand_check_cap(colnr_T col)
  {
      spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);
  }
***************
*** 16251,16260 ****
   * allocated strings.
   */
      int
! expand_spelling(lnum, pat, matchp)
!     linenr_T	lnum UNUSED;
!     char_u	*pat;
!     char_u	***matchp;
  {
      garray_T	ga;
  
--- 16053,16062 ----
   * allocated strings.
   */
      int
! expand_spelling(
!     linenr_T	lnum UNUSED,
!     char_u	*pat,
!     char_u	***matchp)
  {
      garray_T	ga;
  
*** ../vim-7.4.1213/src/syntax.c	2016-01-29 23:20:35.309308162 +0100
--- src/syntax.c	2016-01-30 20:51:06.489251696 +0100
***************
*** 489,497 ****
   * window.
   */
      void
! syntax_start(wp, lnum)
!     win_T	*wp;
!     linenr_T	lnum;
  {
      synstate_T	*p;
      synstate_T	*last_valid = NULL;
--- 489,495 ----
   * window.
   */
      void
! syntax_start(win_T *wp, linenr_T lnum)
  {
      synstate_T	*p;
      synstate_T	*last_valid = NULL;
***************
*** 668,675 ****
   * have to manually release their extmatch pointers first.
   */
      static void
! clear_syn_state(p)
!     synstate_T *p;
  {
      int		i;
      garray_T	*gap;
--- 666,672 ----
   * have to manually release their extmatch pointers first.
   */
      static void
! clear_syn_state(synstate_T *p)
  {
      int		i;
      garray_T	*gap;
***************
*** 692,698 ****
   * Cleanup the current_state stack.
   */
      static void
! clear_current_state()
  {
      int		i;
      stateitem_T	*sip;
--- 689,695 ----
   * Cleanup the current_state stack.
   */
      static void
! clear_current_state(void)
  {
      int		i;
      stateitem_T	*sip;
***************
*** 713,722 ****
   * 3. Simply start on a given number of lines above "lnum".
   */
      static void
! syn_sync(wp, start_lnum, last_valid)
!     win_T	*wp;
!     linenr_T	start_lnum;
!     synstate_T	*last_valid;
  {
      buf_T	*curbuf_save;
      win_T	*curwin_save;
--- 710,719 ----
   * 3. Simply start on a given number of lines above "lnum".
   */
      static void
! syn_sync(
!     win_T	*wp,
!     linenr_T	start_lnum,
!     synstate_T	*last_valid)
  {
      buf_T	*curbuf_save;
      win_T	*curwin_save;
***************
*** 1009,1016 ****
   * Return TRUE if the line-continuation pattern matches in line "lnum".
   */
      static int
! syn_match_linecont(lnum)
!     linenr_T	lnum;
  {
      regmmatch_T regmatch;
      int r;
--- 1006,1012 ----
   * Return TRUE if the line-continuation pattern matches in line "lnum".
   */
      static int
! syn_match_linecont(linenr_T lnum)
  {
      regmmatch_T regmatch;
      int r;
***************
*** 1035,1041 ****
   * Prepare the current state for the start of a line.
   */
      static void
! syn_start_line()
  {
      current_finished = FALSE;
      current_col = 0;
--- 1031,1037 ----
   * Prepare the current state for the start of a line.
   */
      static void
! syn_start_line(void)
  {
      current_finished = FALSE;
      current_col = 0;
***************
*** 1060,1067 ****
   * When "startofline" is FALSE the item with "keepend" is forcefully updated.
   */
      static void
! syn_update_ends(startofline)
!     int		startofline;
  {
      stateitem_T	*cur_si;
      int		i;
--- 1056,1062 ----
   * When "startofline" is FALSE the item with "keepend" is forcefully updated.
   */
      static void
! syn_update_ends(int startofline)
  {
      stateitem_T	*cur_si;
      int		i;
***************
*** 1161,1168 ****
   */
  
      static void
! syn_stack_free_block(block)
!     synblock_T	*block;
  {
      synstate_T	*p;
  
--- 1156,1162 ----
   */
  
      static void
! syn_stack_free_block(synblock_T *block)
  {
      synstate_T	*p;
  
***************
*** 1180,1187 ****
   * Used when syntax items changed to force resyncing everywhere.
   */
      void
! syn_stack_free_all(block)
!     synblock_T	*block;
  {
      win_T	*wp;
  
--- 1174,1180 ----
   * Used when syntax items changed to force resyncing everywhere.
   */
      void
! syn_stack_free_all(synblock_T *block)
  {
      win_T	*wp;
  
***************
*** 1205,1211 ****
   * Also used to allocate b_sst_array[] for the first time.
   */
      static void
! syn_stack_alloc()
  {
      long	len;
      synstate_T	*to, *from;
--- 1198,1204 ----
   * Also used to allocate b_sst_array[] for the first time.
   */
      static void
! syn_stack_alloc(void)
  {
      long	len;
      synstate_T	*to, *from;
***************
*** 1284,1291 ****
   * displayed buffer.
   */
      void
! syn_stack_apply_changes(buf)
!     buf_T	*buf;
  {
      win_T	*wp;
  
--- 1277,1283 ----
   * displayed buffer.
   */
      void
! syn_stack_apply_changes(buf_T *buf)
  {
      win_T	*wp;
  
***************
*** 1299,1307 ****
  }
  
      static void
! syn_stack_apply_changes_block(block, buf)
!     synblock_T	*block;
!     buf_T	*buf;
  {
      synstate_T	*p, *prev, *np;
      linenr_T	n;
--- 1291,1297 ----
  }
  
      static void
! syn_stack_apply_changes_block(synblock_T *block, buf_T *buf)
  {
      synstate_T	*p, *prev, *np;
      linenr_T	n;
***************
*** 1353,1359 ****
   * Returns TRUE if at least one entry was freed.
   */
      static int
! syn_stack_cleanup()
  {
      synstate_T	*p, *prev;
      disptick_T	tick;
--- 1343,1349 ----
   * Returns TRUE if at least one entry was freed.
   */
      static int
! syn_stack_cleanup(void)
  {
      synstate_T	*p, *prev;
      disptick_T	tick;
***************
*** 1417,1425 ****
   * Move the entry into the free list.
   */
      static void
! syn_stack_free_entry(block, p)
!     synblock_T	*block;
!     synstate_T	*p;
  {
      clear_syn_state(p);
      p->sst_next = block->b_sst_firstfree;
--- 1407,1413 ----
   * Move the entry into the free list.
   */
      static void
! syn_stack_free_entry(synblock_T *block, synstate_T *p)
  {
      clear_syn_state(p);
      p->sst_next = block->b_sst_firstfree;
***************
*** 1432,1439 ****
   * Returns NULL when there is no entry or the first entry is after "lnum".
   */
      static synstate_T *
! syn_stack_find_entry(lnum)
!     linenr_T	lnum;
  {
      synstate_T	*p, *prev;
  
--- 1420,1426 ----
   * Returns NULL when there is no entry or the first entry is after "lnum".
   */
      static synstate_T *
! syn_stack_find_entry(linenr_T lnum)
  {
      synstate_T	*p, *prev;
  
***************
*** 1453,1459 ****
   * The current state must be valid for the start of the current_lnum line!
   */
      static synstate_T *
! store_current_state()
  {
      int		i;
      synstate_T	*p;
--- 1440,1446 ----
   * The current state must be valid for the start of the current_lnum line!
   */
      static synstate_T *
! store_current_state(void)
  {
      int		i;
      synstate_T	*p;
***************
*** 1576,1583 ****
   * Copy a state stack from "from" in b_sst_array[] to current_state;
   */
      static void
! load_current_state(from)
!     synstate_T	*from;
  {
      int		i;
      bufstate_T	*bp;
--- 1563,1569 ----
   * Copy a state stack from "from" in b_sst_array[] to current_state;
   */
      static void
! load_current_state(synstate_T *from)
  {
      int		i;
      bufstate_T	*bp;
***************
*** 1624,1631 ****
   * Return TRUE when they are equal.
   */
      static int
! syn_stack_equal(sp)
!     synstate_T *sp;
  {
      int		i, j;
      bufstate_T	*bp;
--- 1610,1616 ----
   * Return TRUE when they are equal.
   */
      static int
! syn_stack_equal(synstate_T *sp)
  {
      int		i, j;
      bufstate_T	*bp;
***************
*** 1697,1704 ****
   * lnum ->  line below window
   */
      void
! syntax_end_parsing(lnum)
!     linenr_T	lnum;
  {
      synstate_T	*sp;
  
--- 1682,1688 ----
   * lnum ->  line below window
   */
      void
! syntax_end_parsing(linenr_T lnum)
  {
      synstate_T	*sp;
  
***************
*** 1715,1721 ****
   ****************************************/
  
      static void
! invalidate_current_state()
  {
      clear_current_state();
      current_state.ga_itemsize = 0;	/* mark current_state invalid */
--- 1699,1705 ----
   ****************************************/
  
      static void
! invalidate_current_state(void)
  {
      clear_current_state();
      current_state.ga_itemsize = 0;	/* mark current_state invalid */
***************
*** 1724,1730 ****
  }
  
      static void
! validate_current_state()
  {
      current_state.ga_itemsize = sizeof(stateitem_T);
      current_state.ga_growsize = 3;
--- 1708,1714 ----
  }
  
      static void
! validate_current_state(void)
  {
      current_state.ga_itemsize = sizeof(stateitem_T);
      current_state.ga_growsize = 3;
***************
*** 1736,1743 ****
   * line, to check if the next line needs to be redrawn too.
   */
      int
! syntax_check_changed(lnum)
!     linenr_T	lnum;
  {
      int		retval = TRUE;
      synstate_T	*sp;
--- 1720,1726 ----
   * line, to check if the next line needs to be redrawn too.
   */
      int
! syntax_check_changed(linenr_T lnum)
  {
      int		retval = TRUE;
      synstate_T	*sp;
***************
*** 1785,1792 ****
   * is valid.
   */
      static int
! syn_finish_line(syncing)
!     int	    syncing;		/* called for syncing */
  {
      stateitem_T	*cur_si;
      colnr_T	prev_current_col;
--- 1768,1775 ----
   * is valid.
   */
      static int
! syn_finish_line(
!     int	    syncing)		/* called for syncing */
  {
      stateitem_T	*cur_si;
      colnr_T	prev_current_col;
***************
*** 1835,1844 ****
   * done.
   */
      int
! get_syntax_attr(col, can_spell, keep_state)
!     colnr_T	col;
!     int		*can_spell;
!     int		keep_state;	/* keep state of char at "col" */
  {
      int	    attr = 0;
  
--- 1818,1827 ----
   * done.
   */
      int
! get_syntax_attr(
!     colnr_T	col,
!     int		*can_spell,
!     int		keep_state)	/* keep state of char at "col" */
  {
      int	    attr = 0;
  
***************
*** 1888,1898 ****
   * Get syntax attributes for current_lnum, current_col.
   */
      static int
! syn_current_attr(syncing, displaying, can_spell, keep_state)
!     int		syncing;		/* When 1: called for syncing */
!     int		displaying;		/* result will be displayed */
!     int		*can_spell;		/* return: do spell checking */
!     int		keep_state;		/* keep syntax stack afterwards */
  {
      int		syn_id;
      lpos_T	endpos;		/* was: char_u *endp; */
--- 1871,1881 ----
   * Get syntax attributes for current_lnum, current_col.
   */
      static int
! syn_current_attr(
!     int		syncing,		/* When 1: called for syncing */
!     int		displaying,		/* result will be displayed */
!     int		*can_spell,		/* return: do spell checking */
!     int		keep_state)		/* keep syntax stack afterwards */
  {
      int		syn_id;
      lpos_T	endpos;		/* was: char_u *endp; */
***************
*** 2481,2489 ****
   * Check if we already matched pattern "idx" at the current column.
   */
      static int
! did_match_already(idx, gap)
!     int		idx;
!     garray_T	*gap;
  {
      int		i;
  
--- 2464,2470 ----
   * Check if we already matched pattern "idx" at the current column.
   */
      static int
! did_match_already(int idx, garray_T *gap)
  {
      int		i;
  
***************
*** 2506,2513 ****
   * Push the next match onto the stack.
   */
      static stateitem_T *
! push_next_match(cur_si)
!     stateitem_T	*cur_si;
  {
      synpat_T	*spp;
  #ifdef FEAT_CONCEAL
--- 2487,2493 ----
   * Push the next match onto the stack.
   */
      static stateitem_T *
! push_next_match(stateitem_T *cur_si)
  {
      synpat_T	*spp;
  #ifdef FEAT_CONCEAL
***************
*** 2600,2606 ****
   * Check for end of current state (and the states before it).
   */
      static void
! check_state_ends()
  {
      stateitem_T	*cur_si;
      int		had_extend;
--- 2580,2586 ----
   * Check for end of current state (and the states before it).
   */
      static void
! check_state_ends(void)
  {
      stateitem_T	*cur_si;
      int		had_extend;
***************
*** 2705,2712 ****
   * fills in si_attr, si_next_list and si_cont_list.
   */
      static void
! update_si_attr(idx)
!     int	    idx;
  {
      stateitem_T	*sip = &CUR_STATE(idx);
      synpat_T	*spp;
--- 2685,2691 ----
   * fills in si_attr, si_next_list and si_cont_list.
   */
      static void
! update_si_attr(int idx)
  {
      stateitem_T	*sip = &CUR_STATE(idx);
      synpat_T	*spp;
***************
*** 2761,2767 ****
   * Propagate the match-end to contained items, until a "skipend" item is found.
   */
      static void
! check_keepend()
  {
      int		i;
      lpos_T	maxpos;
--- 2740,2746 ----
   * Propagate the match-end to contained items, until a "skipend" item is found.
   */
      static void
! check_keepend(void)
  {
      int		i;
      lpos_T	maxpos;
***************
*** 2821,2830 ****
   * Return the flags for the matched END.
   */
      static void
! update_si_end(sip, startcol, force)
!     stateitem_T	*sip;
!     int		startcol;   /* where to start searching for the end */
!     int		force;	    /* when TRUE overrule a previous end */
  {
      lpos_T	startpos;
      lpos_T	endpos;
--- 2800,2809 ----
   * Return the flags for the matched END.
   */
      static void
! update_si_end(
!     stateitem_T	*sip,
!     int		startcol,   /* where to start searching for the end */
!     int		force)	    /* when TRUE overrule a previous end */
  {
      lpos_T	startpos;
      lpos_T	endpos;
***************
*** 2887,2894 ****
   * Return FAIL if it's not possible (out of memory).
   */
      static int
! push_current_state(idx)
!     int	    idx;
  {
      if (ga_grow(&current_state, 1) == FAIL)
  	return FAIL;
--- 2866,2872 ----
   * Return FAIL if it's not possible (out of memory).
   */
      static int
! push_current_state(int idx)
  {
      if (ga_grow(&current_state, 1) == FAIL)
  	return FAIL;
***************
*** 2902,2908 ****
   * Remove a state from the current_state stack.
   */
      static void
! pop_current_state()
  {
      if (current_state.ga_len)
      {
--- 2880,2886 ----
   * Remove a state from the current_state stack.
   */
      static void
! pop_current_state(void)
  {
      if (current_state.ga_len)
      {
***************
*** 2927,2942 ****
   * computed.
   */
      static void
! find_endpos(idx, startpos, m_endpos, hl_endpos, flagsp, end_endpos,
! 							   end_idx, start_ext)
!     int		idx;		/* index of the pattern */
!     lpos_T	*startpos;	/* where to start looking for an END match */
!     lpos_T	*m_endpos;	/* return: end of match */
!     lpos_T	*hl_endpos;	/* return: end of highlighting */
!     long	*flagsp;	/* return: flags of matching END */
!     lpos_T	*end_endpos;	/* return: end of end pattern match */
!     int		*end_idx;	/* return: group ID for end pat. match, or 0 */
!     reg_extmatch_T *start_ext;	/* submatches from the start pattern */
  {
      colnr_T	matchcol;
      synpat_T	*spp, *spp_skip;
--- 2905,2919 ----
   * computed.
   */
      static void
! find_endpos(
!     int		idx,		/* index of the pattern */
!     lpos_T	*startpos,	/* where to start looking for an END match */
!     lpos_T	*m_endpos,	/* return: end of match */
!     lpos_T	*hl_endpos,	/* return: end of highlighting */
!     long	*flagsp,	/* return: flags of matching END */
!     lpos_T	*end_endpos,	/* return: end of end pattern match */
!     int		*end_idx,	/* return: group ID for end pat. match, or 0 */
!     reg_extmatch_T *start_ext)	/* submatches from the start pattern */
  {
      colnr_T	matchcol;
      synpat_T	*spp, *spp_skip;
***************
*** 3165,3173 ****
   * Limit "pos" not to be after "limit".
   */
      static void
! limit_pos(pos, limit)
!     lpos_T	*pos;
!     lpos_T	*limit;
  {
      if (pos->lnum > limit->lnum)
  	*pos = *limit;
--- 3142,3148 ----
   * Limit "pos" not to be after "limit".
   */
      static void
! limit_pos(lpos_T *pos, lpos_T *limit)
  {
      if (pos->lnum > limit->lnum)
  	*pos = *limit;
***************
*** 3179,3187 ****
   * Limit "pos" not to be after "limit", unless pos->lnum is zero.
   */
      static void
! limit_pos_zero(pos, limit)
!     lpos_T	*pos;
!     lpos_T	*limit;
  {
      if (pos->lnum == 0)
  	*pos = *limit;
--- 3154,3162 ----
   * Limit "pos" not to be after "limit", unless pos->lnum is zero.
   */
      static void
! limit_pos_zero(
!     lpos_T	*pos,
!     lpos_T	*limit)
  {
      if (pos->lnum == 0)
  	*pos = *limit;
***************
*** 3193,3204 ****
   * Add offset to matched text for end of match or highlight.
   */
      static void
! syn_add_end_off(result, regmatch, spp, idx, extra)
!     lpos_T	*result;	/* returned position */
!     regmmatch_T	*regmatch;	/* start/end of match */
!     synpat_T	*spp;		/* matched pattern */
!     int		idx;		/* index of offset */
!     int		extra;		/* extra chars for offset to start */
  {
      int		col;
      int		off;
--- 3168,3179 ----
   * Add offset to matched text for end of match or highlight.
   */
      static void
! syn_add_end_off(
!     lpos_T	*result,	/* returned position */
!     regmmatch_T	*regmatch,	/* start/end of match */
!     synpat_T	*spp,		/* matched pattern */
!     int		idx,		/* index of offset */
!     int		extra)		/* extra chars for offset to start */
  {
      int		col;
      int		off;
***************
*** 3245,3256 ****
   * Avoid resulting column to become negative.
   */
      static void
! syn_add_start_off(result, regmatch, spp, idx, extra)
!     lpos_T	*result;	/* returned position */
!     regmmatch_T	*regmatch;	/* start/end of match */
!     synpat_T	*spp;
!     int		idx;
!     int		extra;	    /* extra chars for offset to end */
  {
      int		col;
      int		off;
--- 3220,3231 ----
   * Avoid resulting column to become negative.
   */
      static void
! syn_add_start_off(
!     lpos_T	*result,	/* returned position */
!     regmmatch_T	*regmatch,	/* start/end of match */
!     synpat_T	*spp,
!     int		idx,
!     int		extra)	    /* extra chars for offset to end */
  {
      int		col;
      int		off;
***************
*** 3298,3304 ****
   * Get current line in syntax buffer.
   */
      static char_u *
! syn_getcurline()
  {
      return ml_get_buf(syn_buf, current_lnum, FALSE);
  }
--- 3273,3279 ----
   * Get current line in syntax buffer.
   */
      static char_u *
! syn_getcurline(void)
  {
      return ml_get_buf(syn_buf, current_lnum, FALSE);
  }
***************
*** 3308,3318 ****
   * Returns TRUE when there is a match.
   */
      static int
! syn_regexec(rmp, lnum, col, st)
!     regmmatch_T	*rmp;
!     linenr_T	lnum;
!     colnr_T	col;
!     syn_time_T  *st UNUSED;
  {
      int r;
  #ifdef FEAT_PROFILE
--- 3283,3293 ----
   * Returns TRUE when there is a match.
   */
      static int
! syn_regexec(
!     regmmatch_T	*rmp,
!     linenr_T	lnum,
!     colnr_T	col,
!     syn_time_T  *st UNUSED)
  {
      int r;
  #ifdef FEAT_PROFILE
***************
*** 3353,3366 ****
   * Return it's ID if found, 0 otherwise.
   */
      static int
! check_keyword_id(line, startcol, endcolp, flagsp, next_listp, cur_si, ccharp)
!     char_u	*line;
!     int		startcol;	/* position in line to check for keyword */
!     int		*endcolp;	/* return: character after found keyword */
!     long	*flagsp;	/* return: flags of matching keyword */
!     short	**next_listp;	/* return: next_list of matching keyword */
!     stateitem_T	*cur_si;	/* item at the top of the stack */
!     int		*ccharp UNUSED;	/* conceal substitution char */
  {
      keyentry_T	*kp;
      char_u	*kwp;
--- 3328,3341 ----
   * Return it's ID if found, 0 otherwise.
   */
      static int
! check_keyword_id(
!     char_u	*line,
!     int		startcol,	/* position in line to check for keyword */
!     int		*endcolp,	/* return: character after found keyword */
!     long	*flagsp,	/* return: flags of matching keyword */
!     short	**next_listp,	/* return: next_list of matching keyword */
!     stateitem_T	*cur_si,	/* item at the top of the stack */
!     int		*ccharp UNUSED)	/* conceal substitution char */
  {
      keyentry_T	*kp;
      char_u	*kwp;
***************
*** 3442,3450 ****
   * Handle ":syntax conceal" command.
   */
      static void
! syn_cmd_conceal(eap, syncing)
!     exarg_T	*eap UNUSED;
!     int		syncing UNUSED;
  {
  #ifdef FEAT_CONCEAL
      char_u	*arg = eap->arg;
--- 3417,3423 ----
   * Handle ":syntax conceal" command.
   */
      static void
! syn_cmd_conceal(exarg_T *eap UNUSED, int syncing UNUSED)
  {
  #ifdef FEAT_CONCEAL
      char_u	*arg = eap->arg;
***************
*** 3468,3476 ****
   * Handle ":syntax case" command.
   */
      static void
! syn_cmd_case(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*next;
--- 3441,3447 ----
   * Handle ":syntax case" command.
   */
      static void
! syn_cmd_case(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg = eap->arg;
      char_u	*next;
***************
*** 3492,3500 ****
   * Handle ":syntax spell" command.
   */
      static void
! syn_cmd_spell(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*next;
--- 3463,3469 ----
   * Handle ":syntax spell" command.
   */
      static void
! syn_cmd_spell(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg = eap->arg;
      char_u	*next;
***************
*** 3524,3532 ****
   * Handle ":syntax iskeyword" command.
   */
      static void
! syn_cmd_iskeyword(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	save_chartab[32];
--- 3493,3499 ----
   * Handle ":syntax iskeyword" command.
   */
      static void
! syn_cmd_iskeyword(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg = eap->arg;
      char_u	save_chartab[32];
***************
*** 3575,3582 ****
   * Clear all syntax info for one buffer.
   */
      void
! syntax_clear(block)
!     synblock_T	*block;
  {
      int i;
  
--- 3542,3548 ----
   * Clear all syntax info for one buffer.
   */
      void
! syntax_clear(synblock_T *block)
  {
      int i;
  
***************
*** 3627,3634 ****
   * Get rid of ownsyntax for window "wp".
   */
      void
! reset_synblock(wp)
!     win_T *wp;
  {
      if (wp->w_s != &wp->w_buffer->b_s)
      {
--- 3593,3599 ----
   * Get rid of ownsyntax for window "wp".
   */
      void
! reset_synblock(win_T *wp)
  {
      if (wp->w_s != &wp->w_buffer->b_s)
      {
***************
*** 3642,3648 ****
   * Clear syncing info for one buffer.
   */
      static void
! syntax_sync_clear()
  {
      int i;
  
--- 3607,3613 ----
   * Clear syncing info for one buffer.
   */
      static void
! syntax_sync_clear(void)
  {
      int i;
  
***************
*** 3669,3677 ****
   * Remove one pattern from the buffer's pattern list.
   */
      static void
! syn_remove_pattern(block, idx)
!     synblock_T	*block;
!     int		idx;
  {
      synpat_T	*spp;
  
--- 3634,3642 ----
   * Remove one pattern from the buffer's pattern list.
   */
      static void
! syn_remove_pattern(
!     synblock_T	*block,
!     int		idx)
  {
      synpat_T	*spp;
  
***************
*** 3691,3699 ****
   * last to first!
   */
      static void
! syn_clear_pattern(block, i)
!     synblock_T	*block;
!     int		i;
  {
      vim_free(SYN_ITEMS(block)[i].sp_pattern);
      vim_regfree(SYN_ITEMS(block)[i].sp_prog);
--- 3656,3662 ----
   * last to first!
   */
      static void
! syn_clear_pattern(synblock_T *block, int i)
  {
      vim_free(SYN_ITEMS(block)[i].sp_pattern);
      vim_regfree(SYN_ITEMS(block)[i].sp_prog);
***************
*** 3710,3718 ****
   * Clear and free one syntax cluster.
   */
      static void
! syn_clear_cluster(block, i)
!     synblock_T	*block;
!     int		i;
  {
      vim_free(SYN_CLSTR(block)[i].scl_name);
      vim_free(SYN_CLSTR(block)[i].scl_name_u);
--- 3673,3679 ----
   * Clear and free one syntax cluster.
   */
      static void
! syn_clear_cluster(synblock_T *block, int i)
  {
      vim_free(SYN_CLSTR(block)[i].scl_name);
      vim_free(SYN_CLSTR(block)[i].scl_name_u);
***************
*** 3723,3731 ****
   * Handle ":syntax clear" command.
   */
      static void
! syn_cmd_clear(eap, syncing)
!     exarg_T	*eap;
!     int		syncing;
  {
      char_u	*arg = eap->arg;
      char_u	*arg_end;
--- 3684,3690 ----
   * Handle ":syntax clear" command.
   */
      static void
! syn_cmd_clear(exarg_T *eap, int syncing)
  {
      char_u	*arg = eap->arg;
      char_u	*arg_end;
***************
*** 3810,3818 ****
   * Clear one syntax group for the current buffer.
   */
      static void
! syn_clear_one(id, syncing)
!     int		id;
!     int		syncing;
  {
      synpat_T	*spp;
      int		idx;
--- 3769,3775 ----
   * Clear one syntax group for the current buffer.
   */
      static void
! syn_clear_one(int id, int syncing)
  {
      synpat_T	*spp;
      int		idx;
***************
*** 3838,3846 ****
   * Handle ":syntax on" command.
   */
      static void
! syn_cmd_on(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      syn_cmd_onoff(eap, "syntax");
  }
--- 3795,3801 ----
   * Handle ":syntax on" command.
   */
      static void
! syn_cmd_on(exarg_T *eap, int syncing UNUSED)
  {
      syn_cmd_onoff(eap, "syntax");
  }
***************
*** 3849,3857 ****
   * Handle ":syntax enable" command.
   */
      static void
! syn_cmd_enable(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
      syn_cmd_onoff(eap, "syntax");
--- 3804,3810 ----
   * Handle ":syntax enable" command.
   */
      static void
! syn_cmd_enable(exarg_T *eap, int syncing UNUSED)
  {
      set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
      syn_cmd_onoff(eap, "syntax");
***************
*** 3862,3870 ****
   * Handle ":syntax reset" command.
   */
      static void
! syn_cmd_reset(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      eap->nextcmd = check_nextcmd(eap->arg);
      if (!eap->skip)
--- 3815,3821 ----
   * Handle ":syntax reset" command.
   */
      static void
! syn_cmd_reset(exarg_T *eap, int syncing UNUSED)
  {
      eap->nextcmd = check_nextcmd(eap->arg);
      if (!eap->skip)
***************
*** 3880,3888 ****
   * Handle ":syntax manual" command.
   */
      static void
! syn_cmd_manual(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      syn_cmd_onoff(eap, "manual");
  }
--- 3831,3837 ----
   * Handle ":syntax manual" command.
   */
      static void
! syn_cmd_manual(exarg_T *eap, int syncing UNUSED)
  {
      syn_cmd_onoff(eap, "manual");
  }
***************
*** 3891,3907 ****
   * Handle ":syntax off" command.
   */
      static void
! syn_cmd_off(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      syn_cmd_onoff(eap, "nosyntax");
  }
  
      static void
! syn_cmd_onoff(eap, name)
!     exarg_T	*eap;
!     char	*name;
  {
      char_u	buf[100];
  
--- 3840,3852 ----
   * Handle ":syntax off" command.
   */
      static void
! syn_cmd_off(exarg_T *eap, int syncing UNUSED)
  {
      syn_cmd_onoff(eap, "nosyntax");
  }
  
      static void
! syn_cmd_onoff(exarg_T *eap, char *name)
  {
      char_u	buf[100];
  
***************
*** 3918,3926 ****
   * Handle ":syntax [list]" command: list current syntax words.
   */
      static void
! syn_cmd_list(eap, syncing)
!     exarg_T	*eap;
!     int		syncing;	    /* when TRUE: list syncing items */
  {
      char_u	*arg = eap->arg;
      int		id;
--- 3863,3871 ----
   * Handle ":syntax [list]" command: list current syntax words.
   */
      static void
! syn_cmd_list(
!     exarg_T	*eap,
!     int		syncing)	    /* when TRUE: list syncing items */
  {
      char_u	*arg = eap->arg;
      int		id;
***************
*** 4011,4017 ****
  }
  
      static void
! syn_lines_msg()
  {
      if (curwin->w_s->b_syn_sync_maxlines > 0
  				      || curwin->w_s->b_syn_sync_minlines > 0)
--- 3956,3962 ----
  }
  
      static void
! syn_lines_msg(void)
  {
      if (curwin->w_s->b_syn_sync_maxlines > 0
  				      || curwin->w_s->b_syn_sync_minlines > 0)
***************
*** 4034,4040 ****
  }
  
      static void
! syn_match_msg()
  {
      if (curwin->w_s->b_syn_sync_linebreaks > 0)
      {
--- 3979,3985 ----
  }
  
      static void
! syn_match_msg(void)
  {
      if (curwin->w_s->b_syn_sync_linebreaks > 0)
      {
***************
*** 4058,4067 ****
   * List one syntax item, for ":syntax" or "syntax list syntax_name".
   */
      static void
! syn_list_one(id, syncing, link_only)
!     int		id;
!     int		syncing;	    /* when TRUE: list syncing items */
!     int		link_only;	    /* when TRUE; list link-only too */
  {
      int		attr;
      int		idx;
--- 4003,4012 ----
   * List one syntax item, for ":syntax" or "syntax list syntax_name".
   */
      static void
! syn_list_one(
!     int		id,
!     int		syncing,	    /* when TRUE: list syncing items */
!     int		link_only)	    /* when TRUE; list link-only too */
  {
      int		attr;
      int		idx;
***************
*** 4169,4178 ****
  }
  
      static void
! syn_list_flags(nlist, flags, attr)
!     struct name_list	*nlist;
!     int			flags;
!     int			attr;
  {
      int		i;
  
--- 4114,4120 ----
  }
  
      static void
! syn_list_flags(struct name_list *nlist, int flags, int attr)
  {
      int		i;
  
***************
*** 4188,4195 ****
   * List one syntax cluster, for ":syntax" or "syntax list syntax_name".
   */
      static void
! syn_list_cluster(id)
!     int id;
  {
      int	    endcol = 15;
  
--- 4130,4136 ----
   * List one syntax cluster, for ":syntax" or "syntax list syntax_name".
   */
      static void
! syn_list_cluster(int id)
  {
      int	    endcol = 15;
  
***************
*** 4216,4225 ****
  }
  
      static void
! put_id_list(name, list, attr)
!     char_u	*name;
!     short	*list;
!     int		attr;
  {
      short		*p;
  
--- 4157,4163 ----
  }
  
      static void
! put_id_list(char_u *name, short *list, int attr)
  {
      short		*p;
  
***************
*** 4258,4268 ****
  }
  
      static void
! put_pattern(s, c, spp, attr)
!     char	*s;
!     int		c;
!     synpat_T	*spp;
!     int		attr;
  {
      long	n;
      int		mask;
--- 4196,4206 ----
  }
  
      static void
! put_pattern(
!     char	*s,
!     int		c,
!     synpat_T	*spp,
!     int		attr)
  {
      long	n;
      int		mask;
***************
*** 4331,4341 ****
   * Return TRUE if the header has been printed.
   */
      static int
! syn_list_keywords(id, ht, did_header, attr)
!     int		id;
!     hashtab_T	*ht;
!     int		did_header;		/* header has already been printed */
!     int		attr;
  {
      int		outlen;
      hashitem_T	*hi;
--- 4269,4279 ----
   * Return TRUE if the header has been printed.
   */
      static int
! syn_list_keywords(
!     int		id,
!     hashtab_T	*ht,
!     int		did_header,		/* header has already been printed */
!     int		attr)
  {
      int		outlen;
      hashitem_T	*hi;
***************
*** 4429,4437 ****
  }
  
      static void
! syn_clear_keyword(id, ht)
!     int		id;
!     hashtab_T	*ht;
  {
      hashitem_T	*hi;
      keyentry_T	*kp;
--- 4367,4373 ----
  }
  
      static void
! syn_clear_keyword(int id, hashtab_T *ht)
  {
      hashitem_T	*hi;
      keyentry_T	*kp;
***************
*** 4481,4488 ****
   * Clear a whole keyword table.
   */
      static void
! clear_keywtab(ht)
!     hashtab_T	*ht;
  {
      hashitem_T	*hi;
      int		todo;
--- 4417,4423 ----
   * Clear a whole keyword table.
   */
      static void
! clear_keywtab(hashtab_T *ht)
  {
      hashitem_T	*hi;
      int		todo;
***************
*** 4512,4524 ****
   * Add a keyword to the list of keywords.
   */
      static void
! add_keyword(name, id, flags, cont_in_list, next_list, conceal_char)
!     char_u	*name;	    /* name of keyword */
!     int		id;	    /* group ID for this keyword */
!     int		flags;	    /* flags for this keyword */
!     short	*cont_in_list; /* containedin for this keyword */
!     short	*next_list; /* nextgroup for this keyword */
!     int		conceal_char;
  {
      keyentry_T	*kp;
      hashtab_T	*ht;
--- 4447,4459 ----
   * Add a keyword to the list of keywords.
   */
      static void
! add_keyword(
!     char_u	*name,	    /* name of keyword */
!     int		id,	    /* group ID for this keyword */
!     int		flags,	    /* flags for this keyword */
!     short	*cont_in_list, /* containedin for this keyword */
!     short	*next_list, /* nextgroup for this keyword */
!     int		conceal_char)
  {
      keyentry_T	*kp;
      hashtab_T	*ht;
***************
*** 4572,4580 ****
   * Return NULL if the end of the command was found instead of further args.
   */
      static char_u *
! get_group_name(arg, name_end)
!     char_u	*arg;		/* start of the argument */
!     char_u	**name_end;	/* pointer to end of the name */
  {
      char_u	*rest;
  
--- 4507,4515 ----
   * Return NULL if the end of the command was found instead of further args.
   */
      static char_u *
! get_group_name(
!     char_u	*arg,		/* start of the argument */
!     char_u	**name_end)	/* pointer to end of the name */
  {
      char_u	*rest;
  
***************
*** 4599,4608 ****
   * Return NULL for any error;
   */
      static char_u *
! get_syn_options(arg, opt, conceal_char)
!     char_u	    *arg;		/* next argument to be checked */
!     syn_opt_arg_T   *opt;		/* various things */
!     int		    *conceal_char UNUSED;
  {
      char_u	*gname_start, *gname;
      int		syn_id;
--- 4534,4543 ----
   * Return NULL for any error;
   */
      static char_u *
! get_syn_options(
!     char_u	    *arg,		/* next argument to be checked */
!     syn_opt_arg_T   *opt,		/* various things */
!     int		    *conceal_char UNUSED)
  {
      char_u	*gname_start, *gname;
      int		syn_id;
***************
*** 4788,4796 ****
   * to the specified top-level group, if any.
   */
      static void
! syn_incl_toplevel(id, flagsp)
!     int		id;
!     int		*flagsp;
  {
      if ((*flagsp & HL_CONTAINED) || curwin->w_s->b_syn_topgrp == 0)
  	return;
--- 4723,4729 ----
   * to the specified top-level group, if any.
   */
      static void
! syn_incl_toplevel(int id, int *flagsp)
  {
      if ((*flagsp & HL_CONTAINED) || curwin->w_s->b_syn_topgrp == 0)
  	return;
***************
*** 4815,4823 ****
   * Handle ":syntax include [@{group-name}] filename" command.
   */
      static void
! syn_cmd_include(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      int		sgl_id = 1;
--- 4748,4754 ----
   * Handle ":syntax include [@{group-name}] filename" command.
   */
      static void
! syn_cmd_include(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg = eap->arg;
      int		sgl_id = 1;
***************
*** 4892,4900 ****
   * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
   */
      static void
! syn_cmd_keyword(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
--- 4823,4829 ----
   * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
   */
      static void
! syn_cmd_keyword(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
***************
*** 5021,5029 ****
   * Also ":syntax sync match {name} [[grouphere | groupthere] {group-name}] .."
   */
      static void
! syn_cmd_match(eap, syncing)
!     exarg_T	*eap;
!     int		syncing;	    /* TRUE for ":syntax sync match .. " */
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
--- 4950,4958 ----
   * Also ":syntax sync match {name} [[grouphere | groupthere] {group-name}] .."
   */
      static void
! syn_cmd_match(
!     exarg_T	*eap,
!     int		syncing)	    /* TRUE for ":syntax sync match .. " */
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
***************
*** 5125,5133 ****
   *		start {start} .. [skip {skip}] end {end} .. [{options}]".
   */
      static void
! syn_cmd_region(eap, syncing)
!     exarg_T	*eap;
!     int		syncing;	    /* TRUE for ":syntax sync region .." */
  {
      char_u		*arg = eap->arg;
      char_u		*group_name_end;
--- 5054,5062 ----
   *		start {start} .. [skip {skip}] end {end} .. [{options}]".
   */
      static void
! syn_cmd_region(
!     exarg_T	*eap,
!     int		syncing)	    /* TRUE for ":syntax sync region .." */
  {
      char_u		*arg = eap->arg;
      char_u		*group_name_end;
***************
*** 5394,5402 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! syn_compare_stub(v1, v2)
!     const void	*v1;
!     const void	*v2;
  {
      const short	*s1 = v1;
      const short	*s2 = v2;
--- 5323,5329 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! syn_compare_stub(const void *v1, const void *v2)
  {
      const short	*s1 = v1;
      const short	*s2 = v2;
***************
*** 5409,5418 ****
   * *clstr1 and *clstr2 must both be allocated memory; they will be consumed.
   */
      static void
! syn_combine_list(clstr1, clstr2, list_op)
!     short	**clstr1;
!     short	**clstr2;
!     int		list_op;
  {
      int		count1 = 0;
      int		count2 = 0;
--- 5336,5342 ----
   * *clstr1 and *clstr2 must both be allocated memory; they will be consumed.
   */
      static void
! syn_combine_list(short **clstr1, short **clstr2, int list_op)
  {
      int		count1 = 0;
      int		count2 = 0;
***************
*** 5536,5543 ****
   * If it is not found, 0 is returned.
   */
      static int
! syn_scl_name2id(name)
!     char_u	*name;
  {
      int		i;
      char_u	*name_u;
--- 5460,5466 ----
   * If it is not found, 0 is returned.
   */
      static int
! syn_scl_name2id(char_u *name)
  {
      int		i;
      char_u	*name_u;
***************
*** 5558,5566 ****
   * Like syn_scl_name2id(), but take a pointer + length argument.
   */
      static int
! syn_scl_namen2id(linep, len)
!     char_u  *linep;
!     int	    len;
  {
      char_u  *name;
      int	    id = 0;
--- 5481,5487 ----
   * Like syn_scl_name2id(), but take a pointer + length argument.
   */
      static int
! syn_scl_namen2id(char_u *linep, int len)
  {
      char_u  *name;
      int	    id = 0;
***************
*** 5581,5589 ****
   * Return 0 for failure.
   */
      static int
! syn_check_cluster(pp, len)
!     char_u	*pp;
!     int		len;
  {
      int		id;
      char_u	*name;
--- 5502,5508 ----
   * Return 0 for failure.
   */
      static int
! syn_check_cluster(char_u *pp, int len)
  {
      int		id;
      char_u	*name;
***************
*** 5606,5613 ****
   * Return 0 for failure.
   */
      static int
! syn_add_cluster(name)
!     char_u	*name;
  {
      int		len;
  
--- 5525,5531 ----
   * Return 0 for failure.
   */
      static int
! syn_add_cluster(char_u *name)
  {
      int		len;
  
***************
*** 5656,5664 ****
   *		[add={groupname},..] [remove={groupname},..]".
   */
      static void
! syn_cmd_cluster(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
--- 5574,5580 ----
   *		[add={groupname},..] [remove={groupname},..]".
   */
      static void
! syn_cmd_cluster(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg = eap->arg;
      char_u	*group_name_end;
***************
*** 5733,5739 ****
   * On first call for current buffer: Init growing array.
   */
      static void
! init_syn_patterns()
  {
      curwin->w_s->b_syn_patterns.ga_itemsize = sizeof(synpat_T);
      curwin->w_s->b_syn_patterns.ga_growsize = 10;
--- 5649,5655 ----
   * On first call for current buffer: Init growing array.
   */
      static void
! init_syn_patterns(void)
  {
      curwin->w_s->b_syn_patterns.ga_itemsize = sizeof(synpat_T);
      curwin->w_s->b_syn_patterns.ga_growsize = 10;
***************
*** 5745,5753 ****
   * Returns a pointer to the next argument, or NULL in case of an error.
   */
      static char_u *
! get_syn_pattern(arg, ci)
!     char_u	*arg;
!     synpat_T	*ci;
  {
      char_u	*end;
      int		*p;
--- 5661,5667 ----
   * Returns a pointer to the next argument, or NULL in case of an error.
   */
      static char_u *
! get_syn_pattern(char_u *arg, synpat_T *ci)
  {
      char_u	*end;
      int		*p;
***************
*** 5849,5857 ****
   * Handle ":syntax sync .." command.
   */
      static void
! syn_cmd_sync(eap, syncing)
!     exarg_T	*eap;
!     int		syncing UNUSED;
  {
      char_u	*arg_start = eap->arg;
      char_u	*arg_end;
--- 5763,5769 ----
   * Handle ":syntax sync .." command.
   */
      static void
! syn_cmd_sync(exarg_T *eap, int syncing UNUSED)
  {
      char_u	*arg_start = eap->arg;
      char_u	*arg_end;
***************
*** 6010,6019 ****
   * returns FAIL for some error, OK for success.
   */
      static int
! get_id_list(arg, keylen, list)
!     char_u	**arg;
!     int		keylen;		/* length of keyword */
!     short	**list;		/* where to store the resulting list, if not
  				   NULL, the list is silently skipped! */
  {
      char_u	*p = NULL;
--- 5922,5931 ----
   * returns FAIL for some error, OK for success.
   */
      static int
! get_id_list(
!     char_u	**arg,
!     int		keylen,		/* length of keyword */
!     short	**list)		/* where to store the resulting list, if not
  				   NULL, the list is silently skipped! */
  {
      char_u	*p = NULL;
***************
*** 6207,6214 ****
   * Make a copy of an ID list.
   */
      static short *
! copy_id_list(list)
!     short   *list;
  {
      int	    len;
      int	    count;
--- 6119,6125 ----
   * Make a copy of an ID list.
   */
      static short *
! copy_id_list(short *list)
  {
      int	    len;
      int	    count;
***************
*** 6235,6245 ****
   * This function is called very often, keep it fast!!
   */
      static int
! in_id_list(cur_si, list, ssp, contained)
!     stateitem_T	*cur_si;	/* current item or NULL */
!     short	*list;		/* id list */
!     struct sp_syn *ssp;		/* group id and ":syn include" tag of group */
!     int		contained;	/* group id is contained */
  {
      int		retval;
      short	*scl_list;
--- 6146,6156 ----
   * This function is called very often, keep it fast!!
   */
      static int
! in_id_list(
!     stateitem_T	*cur_si,	/* current item or NULL */
!     short	*list,		/* id list */
!     struct sp_syn *ssp,		/* group id and ":syn include" tag of group */
!     int		contained)	/* group id is contained */
  {
      int		retval;
      short	*scl_list;
***************
*** 6367,6374 ****
   * syntax_subcommand() function to do the rest.
   */
      void
! ex_syntax(eap)
!     exarg_T	*eap;
  {
      char_u	*arg = eap->arg;
      char_u	*subcmd_end;
--- 6278,6284 ----
   * syntax_subcommand() function to do the rest.
   */
      void
! ex_syntax(exarg_T *eap)
  {
      char_u	*arg = eap->arg;
      char_u	*subcmd_end;
***************
*** 6406,6413 ****
  }
  
      void
! ex_ownsyntax(eap)
!     exarg_T	*eap;
  {
      char_u	*old_value;
      char_u	*new_value;
--- 6316,6322 ----
  }
  
      void
! ex_ownsyntax(exarg_T *eap)
  {
      char_u	*old_value;
      char_u	*new_value;
***************
*** 6453,6460 ****
  }
  
      int
! syntax_present(win)
!     win_T	*win;
  {
      return (win->w_s->b_syn_patterns.ga_len != 0
  	    || win->w_s->b_syn_clusters.ga_len != 0
--- 6362,6368 ----
  }
  
      int
! syntax_present(win_T *win)
  {
      return (win->w_s->b_syn_patterns.ga_len != 0
  	    || win->w_s->b_syn_clusters.ga_len != 0
***************
*** 6475,6481 ****
   * Called when we are done expanding.
   */
      void
! reset_expand_highlight()
  {
      include_link = include_default = include_none = 0;
  }
--- 6383,6389 ----
   * Called when we are done expanding.
   */
      void
! reset_expand_highlight(void)
  {
      include_link = include_default = include_none = 0;
  }
***************
*** 6485,6493 ****
   * as highlight group.
   */
      void
! set_context_in_echohl_cmd(xp, arg)
!     expand_T	*xp;
!     char_u	*arg;
  {
      xp->xp_context = EXPAND_HIGHLIGHT;
      xp->xp_pattern = arg;
--- 6393,6399 ----
   * as highlight group.
   */
      void
! set_context_in_echohl_cmd(expand_T *xp, char_u *arg)
  {
      xp->xp_context = EXPAND_HIGHLIGHT;
      xp->xp_pattern = arg;
***************
*** 6498,6506 ****
   * Handle command line completion for :syntax command.
   */
      void
! set_context_in_syntax_cmd(xp, arg)
!     expand_T	*xp;
!     char_u	*arg;
  {
      char_u	*p;
  
--- 6404,6410 ----
   * Handle command line completion for :syntax command.
   */
      void
! set_context_in_syntax_cmd(expand_T *xp, char_u *arg)
  {
      char_u	*p;
  
***************
*** 6540,6548 ****
   * expansion.
   */
      char_u *
! get_syntax_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      if (expand_what == EXP_SUBCMD)
  	return (char_u *)subcommands[idx].name;
--- 6444,6450 ----
   * expansion.
   */
      char_u *
! get_syntax_name(expand_T *xp UNUSED, int idx)
  {
      if (expand_what == EXP_SUBCMD)
  	return (char_u *)subcommands[idx].name;
***************
*** 6555,6567 ****
   * Function called for expression evaluation: get syntax ID at file position.
   */
      int
! syn_get_id(wp, lnum, col, trans, spellp, keep_state)
!     win_T	*wp;
!     long	lnum;
!     colnr_T	col;
!     int		trans;	     /* remove transparency */
!     int		*spellp;     /* return: can do spell checking */
!     int		keep_state;  /* keep state of char at "col" */
  {
      /* When the position is not after the current position and in the same
       * line of the same buffer, need to restart parsing. */
--- 6457,6469 ----
   * Function called for expression evaluation: get syntax ID at file position.
   */
      int
! syn_get_id(
!     win_T	*wp,
!     long	lnum,
!     colnr_T	col,
!     int		trans,	     /* remove transparency */
!     int		*spellp,     /* return: can do spell checking */
!     int		keep_state)  /* keep state of char at "col" */
  {
      /* When the position is not after the current position and in the same
       * line of the same buffer, need to restart parsing. */
***************
*** 6589,6596 ****
   * Returns the current flags.
   */
      int
! get_syntax_info(seqnrp)
!     int		*seqnrp;
  {
      *seqnrp = current_seqnr;
      return current_flags;
--- 6491,6497 ----
   * Returns the current flags.
   */
      int
! get_syntax_info(int *seqnrp)
  {
      *seqnrp = current_seqnr;
      return current_flags;
***************
*** 6600,6606 ****
   * Return conceal substitution character
   */
      int
! syn_get_sub_char()
  {
      return current_sub_char;
  }
--- 6501,6507 ----
   * Return conceal substitution character
   */
      int
! syn_get_sub_char(void)
  {
      return current_sub_char;
  }
***************
*** 6613,6620 ****
   * Returns -1 when "i" is out of range.
   */
      int
! syn_get_stack_item(i)
!     int i;
  {
      if (i >= current_state.ga_len)
      {
--- 6514,6520 ----
   * Returns -1 when "i" is out of range.
   */
      int
! syn_get_stack_item(int i)
  {
      if (i >= current_state.ga_len)
      {
***************
*** 6633,6641 ****
   * Function called to get folding level for line "lnum" in window "wp".
   */
      int
! syn_get_foldlevel(wp, lnum)
!     win_T	*wp;
!     long	lnum;
  {
      int		level = 0;
      int		i;
--- 6533,6539 ----
   * Function called to get folding level for line "lnum" in window "wp".
   */
      int
! syn_get_foldlevel(win_T *wp, long lnum)
  {
      int		level = 0;
      int		i;
***************
*** 6664,6671 ****
   * ":syntime".
   */
      void
! ex_syntime(eap)
!     exarg_T	*eap;
  {
      if (STRCMP(eap->arg, "on") == 0)
  	syn_time_on = TRUE;
--- 6562,6568 ----
   * ":syntime".
   */
      void
! ex_syntime(exarg_T *eap)
  {
      if (STRCMP(eap->arg, "on") == 0)
  	syn_time_on = TRUE;
***************
*** 6680,6687 ****
  }
  
      static void
! syn_clear_time(st)
!     syn_time_T *st;
  {
      profile_zero(&st->total);
      profile_zero(&st->slowest);
--- 6577,6583 ----
  }
  
      static void
! syn_clear_time(syn_time_T *st)
  {
      profile_zero(&st->total);
      profile_zero(&st->slowest);
***************
*** 6693,6699 ****
   * Clear the syntax timing for the current buffer.
   */
      static void
! syntime_clear()
  {
      int		idx;
      synpat_T	*spp;
--- 6589,6595 ----
   * Clear the syntax timing for the current buffer.
   */
      static void
! syntime_clear(void)
  {
      int		idx;
      synpat_T	*spp;
***************
*** 6716,6724 ****
   * ":syntime {on,off,clear,report}" command.
   */
      char_u *
! get_syntime_arg(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
      switch (idx)
      {
--- 6612,6618 ----
   * ":syntime {on,off,clear,report}" command.
   */
      char_u *
! get_syntime_arg(expand_T *xp UNUSED, int idx)
  {
      switch (idx)
      {
***************
*** 6746,6754 ****
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! syn_compare_syntime(v1, v2)
!     const void	*v1;
!     const void	*v2;
  {
      const time_entry_T	*s1 = v1;
      const time_entry_T	*s2 = v2;
--- 6640,6646 ----
  #ifdef __BORLANDC__
  _RTLENTRYF
  #endif
! syn_compare_syntime(const void *v1, const void *v2)
  {
      const time_entry_T	*s1 = v1;
      const time_entry_T	*s2 = v2;
***************
*** 6760,6766 ****
   * Clear the syntax timing for the current buffer.
   */
      static void
! syntime_report()
  {
      int		idx;
      synpat_T	*spp;
--- 6652,6658 ----
   * Clear the syntax timing for the current buffer.
   */
      static void
! syntime_report(void)
  {
      int		idx;
      synpat_T	*spp;
***************
*** 7095,7103 ****
      };
  
      void
! init_highlight(both, reset)
!     int		both;	    /* include groups where 'bg' doesn't matter */
!     int		reset;	    /* clear group first */
  {
      int		i;
      char	**pp;
--- 6987,6995 ----
      };
  
      void
! init_highlight(
!     int		both,	    /* include groups where 'bg' doesn't matter */
!     int		reset)	    /* clear group first */
  {
      int		i;
      char	**pp;
***************
*** 7193,7200 ****
   * Return OK for success, FAIL for failure.
   */
      int
! load_colors(name)
!     char_u	*name;
  {
      char_u	*buf;
      int		retval = FAIL;
--- 7085,7091 ----
   * Return OK for success, FAIL for failure.
   */
      int
! load_colors(char_u *name)
  {
      char_u	*buf;
      int		retval = FAIL;
***************
*** 7228,7237 ****
   * "forceit" and "init" both TRUE.
   */
      void
! do_highlight(line, forceit, init)
!     char_u	*line;
!     int		forceit;
!     int		init;	    /* TRUE when called for initializing */
  {
      char_u	*name_end;
      char_u	*p;
--- 7119,7128 ----
   * "forceit" and "init" both TRUE.
   */
      void
! do_highlight(
!     char_u	*line,
!     int		forceit,
!     int		init)	    /* TRUE when called for initializing */
  {
      char_u	*name_end;
      char_u	*p;
***************
*** 8143,8149 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_highlight()
  {
      int	    i;
  
--- 8034,8040 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_highlight(void)
  {
      int	    i;
  
***************
*** 8162,8168 ****
   * possible.  Otherwise reset them to zero.
   */
      void
! restore_cterm_colors()
  {
  #if defined(MSDOS) || (defined(WIN3264) && !defined(FEAT_GUI_W32))
      /* Since t_me has been set, this probably means that the user
--- 8053,8059 ----
   * possible.  Otherwise reset them to zero.
   */
      void
! restore_cterm_colors(void)
  {
  #if defined(MSDOS) || (defined(WIN3264) && !defined(FEAT_GUI_W32))
      /* Since t_me has been set, this probably means that the user
***************
*** 8181,8189 ****
   * When "check_link" is TRUE also check for an existing link.
   */
      static int
! hl_has_settings(idx, check_link)
!     int		idx;
!     int		check_link;
  {
      return (   HL_TABLE()[idx].sg_term_attr != 0
  	    || HL_TABLE()[idx].sg_cterm_attr != 0
--- 8072,8078 ----
   * When "check_link" is TRUE also check for an existing link.
   */
      static int
! hl_has_settings(int idx, int check_link)
  {
      return (   HL_TABLE()[idx].sg_term_attr != 0
  	    || HL_TABLE()[idx].sg_cterm_attr != 0
***************
*** 8203,8210 ****
   * Clear highlighting for one group.
   */
      static void
! highlight_clear(idx)
!     int idx;
  {
      HL_TABLE()[idx].sg_term = 0;
      vim_free(HL_TABLE()[idx].sg_start);
--- 8092,8098 ----
   * Clear highlighting for one group.
   */
      static void
! highlight_clear(int idx)
  {
      HL_TABLE()[idx].sg_term = 0;
      vim_free(HL_TABLE()[idx].sg_start);
***************
*** 8255,8261 ****
   * "Tooltip" colors.
   */
      void
! set_normal_colors()
  {
      if (set_group_colors((char_u *)"Normal",
  			     &gui.norm_pixel, &gui.back_pixel,
--- 8143,8149 ----
   * "Tooltip" colors.
   */
      void
! set_normal_colors(void)
  {
      if (set_group_colors((char_u *)"Normal",
  			     &gui.norm_pixel, &gui.back_pixel,
***************
*** 8299,8311 ****
   * Set the colors for "Normal", "Menu", "Tooltip" or "Scrollbar".
   */
      static int
! set_group_colors(name, fgp, bgp, do_menu, use_norm, do_tooltip)
!     char_u	*name;
!     guicolor_T	*fgp;
!     guicolor_T	*bgp;
!     int		do_menu;
!     int		use_norm;
!     int		do_tooltip;
  {
      int		idx;
  
--- 8187,8199 ----
   * Set the colors for "Normal", "Menu", "Tooltip" or "Scrollbar".
   */
      static int
! set_group_colors(
!     char_u	*name,
!     guicolor_T	*fgp,
!     guicolor_T	*bgp,
!     int		do_menu,
!     int		use_norm,
!     int		do_tooltip)
  {
      int		idx;
  
***************
*** 8332,8338 ****
   * Returns "" when it's not found or not set.
   */
      char_u *
! hl_get_font_name()
  {
      int		id;
      char_u	*s;
--- 8220,8226 ----
   * Returns "" when it's not found or not set.
   */
      char_u *
! hl_get_font_name(void)
  {
      int		id;
      char_u	*s;
***************
*** 8352,8359 ****
   * actually chosen to be used.
   */
      void
! hl_set_font_name(font_name)
!     char_u	*font_name;
  {
      int	    id;
  
--- 8240,8246 ----
   * actually chosen to be used.
   */
      void
! hl_set_font_name(char_u *font_name)
  {
      int	    id;
  
***************
*** 8370,8377 ****
   * when the color is known.
   */
      void
! hl_set_bg_color_name(name)
!     char_u  *name;	    /* must have been allocated */
  {
      int	    id;
  
--- 8257,8264 ----
   * when the color is known.
   */
      void
! hl_set_bg_color_name(
!     char_u  *name)	    /* must have been allocated */
  {
      int	    id;
  
***************
*** 8391,8398 ****
   * when the color is known.
   */
      void
! hl_set_fg_color_name(name)
!     char_u  *name;	    /* must have been allocated */
  {
      int	    id;
  
--- 8278,8285 ----
   * when the color is known.
   */
      void
! hl_set_fg_color_name(
!     char_u  *name)	    /* must have been allocated */
  {
      int	    id;
  
***************
*** 8412,8419 ****
   * Returns INVALCOLOR when failed.
   */
      static guicolor_T
! color_name2handle(name)
!     char_u  *name;
  {
      if (STRCMP(name, "NONE") == 0)
  	return INVALCOLOR;
--- 8299,8305 ----
   * Returns INVALCOLOR when failed.
   */
      static guicolor_T
! color_name2handle(char_u *name)
  {
      if (STRCMP(name, "NONE") == 0)
  	return INVALCOLOR;
***************
*** 8431,8438 ****
   * Returns NOFONT when failed.
   */
      static GuiFont
! font_name2handle(name)
!     char_u  *name;
  {
      if (STRCMP(name, "NONE") == 0)
  	return NOFONT;
--- 8317,8323 ----
   * Returns NOFONT when failed.
   */
      static GuiFont
! font_name2handle(char_u *name)
  {
      if (STRCMP(name, "NONE") == 0)
  	return NOFONT;
***************
*** 8446,8454 ****
   * Returns NOFONTSET when failed.
   */
      static GuiFontset
! fontset_name2handle(name, fixed_width)
!     char_u	*name;
!     int		fixed_width;
  {
      if (STRCMP(name, "NONE") == 0)
  	return NOFONTSET;
--- 8331,8337 ----
   * Returns NOFONTSET when failed.
   */
      static GuiFontset
! fontset_name2handle(char_u *name, int fixed_width)
  {
      if (STRCMP(name, "NONE") == 0)
  	return NOFONTSET;
***************
*** 8461,8473 ****
   * Get the font or fontset for one highlight group.
   */
      static void
! hl_do_font(idx, arg, do_normal, do_menu, do_tooltip, free_font)
!     int		idx;
!     char_u	*arg;
!     int		do_normal;		/* set normal font */
!     int		do_menu UNUSED;		/* set menu font */
!     int		do_tooltip UNUSED;	/* set tooltip font */
!     int		free_font;		/* free current font/fontset */
  {
  # ifdef FEAT_XFONTSET
      /* If 'guifontset' is not empty, first try using the name as a
--- 8344,8356 ----
   * Get the font or fontset for one highlight group.
   */
      static void
! hl_do_font(
!     int		idx,
!     char_u	*arg,
!     int		do_normal,		/* set normal font */
!     int		do_menu UNUSED,		/* set menu font */
!     int		do_tooltip UNUSED,	/* set tooltip font */
!     int		free_font)		/* free current font/fontset */
  {
  # ifdef FEAT_XFONTSET
      /* If 'guifontset' is not empty, first try using the name as a
***************
*** 8578,8586 ****
   * Return 0 for error (no more room).
   */
      static int
! get_attr_entry(table, aep)
!     garray_T	*table;
!     attrentry_T	*aep;
  {
      int		i;
      attrentry_T	*taep;
--- 8461,8467 ----
   * Return 0 for error (no more room).
   */
      static int
! get_attr_entry(garray_T *table, attrentry_T *aep)
  {
      int		i;
      attrentry_T	*taep;
***************
*** 8704,8710 ****
   * Clear all highlight tables.
   */
      void
! clear_hl_tables()
  {
      int		i;
      attrentry_T	*taep;
--- 8585,8591 ----
   * Clear all highlight tables.
   */
      void
! clear_hl_tables(void)
  {
      int		i;
      attrentry_T	*taep;
***************
*** 8733,8741 ****
   * Return the resulting attributes.
   */
      int
! hl_combine_attr(char_attr, prim_attr)
!     int	    char_attr;
!     int	    prim_attr;
  {
      attrentry_T *char_aep = NULL;
      attrentry_T *spell_aep;
--- 8614,8620 ----
   * Return the resulting attributes.
   */
      int
! hl_combine_attr(int char_attr, int prim_attr)
  {
      attrentry_T *char_aep = NULL;
      attrentry_T *spell_aep;
***************
*** 8851,8858 ****
  #ifdef FEAT_GUI
  
      attrentry_T *
! syn_gui_attr2entry(attr)
!     int		    attr;
  {
      attr -= ATTR_OFF;
      if (attr >= gui_attr_table.ga_len)	    /* did ":syntax clear" */
--- 8730,8736 ----
  #ifdef FEAT_GUI
  
      attrentry_T *
! syn_gui_attr2entry(int attr)
  {
      attr -= ATTR_OFF;
      if (attr >= gui_attr_table.ga_len)	    /* did ":syntax clear" */
***************
*** 8866,8873 ****
   * Only to be used when "attr" > HL_ALL.
   */
      int
! syn_attr2attr(attr)
!     int	    attr;
  {
      attrentry_T	*aep;
  
--- 8744,8750 ----
   * Only to be used when "attr" > HL_ALL.
   */
      int
! syn_attr2attr(int attr)
  {
      attrentry_T	*aep;
  
***************
*** 8888,8895 ****
  
  
      attrentry_T *
! syn_term_attr2entry(attr)
!     int		    attr;
  {
      attr -= ATTR_OFF;
      if (attr >= term_attr_table.ga_len)	    /* did ":syntax clear" */
--- 8765,8771 ----
  
  
      attrentry_T *
! syn_term_attr2entry(int attr)
  {
      attr -= ATTR_OFF;
      if (attr >= term_attr_table.ga_len)	    /* did ":syntax clear" */
***************
*** 8898,8905 ****
  }
  
      attrentry_T *
! syn_cterm_attr2entry(attr)
!     int		    attr;
  {
      attr -= ATTR_OFF;
      if (attr >= cterm_attr_table.ga_len)	/* did ":syntax clear" */
--- 8774,8780 ----
  }
  
      attrentry_T *
! syn_cterm_attr2entry(int attr)
  {
      attr -= ATTR_OFF;
      if (attr >= cterm_attr_table.ga_len)	/* did ":syntax clear" */
***************
*** 8912,8919 ****
  #define LIST_INT    3
  
      static void
! highlight_list_one(id)
!     int		id;
  {
      struct hl_group	*sgp;
      int			didh = FALSE;
--- 8787,8793 ----
  #define LIST_INT    3
  
      static void
! highlight_list_one(int id)
  {
      struct hl_group	*sgp;
      int			didh = FALSE;
***************
*** 8967,8979 ****
  }
  
      static int
! highlight_list_arg(id, didh, type, iarg, sarg, name)
!     int		id;
!     int		didh;
!     int		type;
!     int		iarg;
!     char_u	*sarg;
!     char	*name;
  {
      char_u	buf[100];
      char_u	*ts;
--- 8841,8853 ----
  }
  
      static int
! highlight_list_arg(
!     int		id,
!     int		didh,
!     int		type,
!     int		iarg,
!     char_u	*sarg,
!     char	*name)
  {
      char_u	buf[100];
      char_u	*ts;
***************
*** 9025,9034 ****
   * Return NULL otherwise.
   */
      char_u *
! highlight_has_attr(id, flag, modec)
!     int		id;
!     int		flag;
!     int		modec;	/* 'g' for GUI, 'c' for cterm, 't' for term */
  {
      int		attr;
  
--- 8899,8908 ----
   * Return NULL otherwise.
   */
      char_u *
! highlight_has_attr(
!     int		id,
!     int		flag,
!     int		modec)	/* 'g' for GUI, 'c' for cterm, 't' for term */
  {
      int		attr;
  
***************
*** 9056,9065 ****
   * Return color name of highlight group "id".
   */
      char_u *
! highlight_color(id, what, modec)
!     int		id;
!     char_u	*what;	/* "font", "fg", "bg", "sp", "fg#", "bg#" or "sp#" */
!     int		modec;	/* 'g' for GUI, 'c' for cterm, 't' for term */
  {
      static char_u	name[20];
      int			n;
--- 8930,8939 ----
   * Return color name of highlight group "id".
   */
      char_u *
! highlight_color(
!     int		id,
!     char_u	*what,	/* "font", "fg", "bg", "sp", "fg#", "bg#" or "sp#" */
!     int		modec)	/* 'g' for GUI, 'c' for cterm, 't' for term */
  {
      static char_u	name[20];
      int			n;
***************
*** 9137,9145 ****
   * Return color name of highlight group "id" as RGB value.
   */
      long_u
! highlight_gui_color_rgb(id, fg)
!     int		id;
!     int		fg;	/* TRUE = fg, FALSE = bg */
  {
      guicolor_T	color;
  
--- 9011,9019 ----
   * Return color name of highlight group "id" as RGB value.
   */
      long_u
! highlight_gui_color_rgb(
!     int		id,
!     int		fg)	/* TRUE = fg, FALSE = bg */
  {
      guicolor_T	color;
  
***************
*** 9163,9172 ****
   * Return TRUE when started a new line.
   */
      static int
! syn_list_header(did_header, outlen, id)
!     int	    did_header;		/* did header already */
!     int	    outlen;		/* length of string that comes */
!     int	    id;			/* highlight group id */
  {
      int	    endcol = 19;
      int	    newline = TRUE;
--- 9037,9046 ----
   * Return TRUE when started a new line.
   */
      static int
! syn_list_header(
!     int	    did_header,		/* did header already */
!     int	    outlen,		/* length of string that comes */
!     int	    id)			/* highlight group id */
  {
      int	    endcol = 19;
      int	    newline = TRUE;
***************
*** 9213,9220 ****
   * Called after one of the attributes has changed.
   */
      static void
! set_hl_attr(idx)
!     int		idx;	    /* index in array */
  {
      attrentry_T		at_en;
      struct hl_group	*sgp = HL_TABLE() + idx;
--- 9087,9094 ----
   * Called after one of the attributes has changed.
   */
      static void
! set_hl_attr(
!     int		idx)	    /* index in array */
  {
      attrentry_T		at_en;
      struct hl_group	*sgp = HL_TABLE() + idx;
***************
*** 9286,9293 ****
   * If it is not found, 0 is returned.
   */
      int
! syn_name2id(name)
!     char_u	*name;
  {
      int		i;
      char_u	name_u[200];
--- 9160,9166 ----
   * If it is not found, 0 is returned.
   */
      int
! syn_name2id(char_u *name)
  {
      int		i;
      char_u	name_u[200];
***************
*** 9309,9316 ****
   * Return TRUE if highlight group "name" exists.
   */
      int
! highlight_exists(name)
!     char_u	*name;
  {
      return (syn_name2id(name) > 0);
  }
--- 9182,9188 ----
   * Return TRUE if highlight group "name" exists.
   */
      int
! highlight_exists(char_u *name)
  {
      return (syn_name2id(name) > 0);
  }
***************
*** 9321,9328 ****
   * When not a valid ID return an empty string.
   */
      char_u *
! syn_id2name(id)
!     int		id;
  {
      if (id <= 0 || id > highlight_ga.ga_len)
  	return (char_u *)"";
--- 9193,9199 ----
   * When not a valid ID return an empty string.
   */
      char_u *
! syn_id2name(int id)
  {
      if (id <= 0 || id > highlight_ga.ga_len)
  	return (char_u *)"";
***************
*** 9335,9343 ****
   * Like syn_name2id(), but take a pointer + length argument.
   */
      int
! syn_namen2id(linep, len)
!     char_u  *linep;
!     int	    len;
  {
      char_u  *name;
      int	    id = 0;
--- 9206,9212 ----
   * Like syn_name2id(), but take a pointer + length argument.
   */
      int
! syn_namen2id(char_u *linep, int len)
  {
      char_u  *name;
      int	    id = 0;
***************
*** 9358,9366 ****
   * Return 0 for failure.
   */
      int
! syn_check_group(pp, len)
!     char_u		*pp;
!     int			len;
  {
      int	    id;
      char_u  *name;
--- 9227,9233 ----
   * Return 0 for failure.
   */
      int
! syn_check_group(char_u *pp, int len)
  {
      int	    id;
      char_u  *name;
***************
*** 9383,9390 ****
   * Return 0 for failure.
   */
      static int
! syn_add_group(name)
!     char_u	*name;
  {
      char_u	*p;
  
--- 9250,9256 ----
   * Return 0 for failure.
   */
      static int
! syn_add_group(char_u *name)
  {
      char_u	*p;
  
***************
*** 9450,9456 ****
   * function deletes the new name.
   */
      static void
! syn_unadd_group()
  {
      --highlight_ga.ga_len;
      vim_free(HL_TABLE()[highlight_ga.ga_len].sg_name);
--- 9316,9322 ----
   * function deletes the new name.
   */
      static void
! syn_unadd_group(void)
  {
      --highlight_ga.ga_len;
      vim_free(HL_TABLE()[highlight_ga.ga_len].sg_name);
***************
*** 9461,9468 ****
   * Translate a group ID to highlight attributes.
   */
      int
! syn_id2attr(hl_id)
!     int			hl_id;
  {
      int			attr;
      struct hl_group	*sgp;
--- 9327,9333 ----
   * Translate a group ID to highlight attributes.
   */
      int
! syn_id2attr(int hl_id)
  {
      int			attr;
      struct hl_group	*sgp;
***************
*** 9492,9501 ****
   * NOTE: the colors will be INVALCOLOR when not set, the color otherwise.
   */
      int
! syn_id2colors(hl_id, fgp, bgp)
!     int		hl_id;
!     guicolor_T	*fgp;
!     guicolor_T	*bgp;
  {
      struct hl_group	*sgp;
  
--- 9357,9363 ----
   * NOTE: the colors will be INVALCOLOR when not set, the color otherwise.
   */
      int
! syn_id2colors(int hl_id, guicolor_T *fgp, guicolor_T *bgp)
  {
      struct hl_group	*sgp;
  
***************
*** 9512,9519 ****
   * Translate a group ID to the final group ID (following links).
   */
      int
! syn_get_final_id(hl_id)
!     int			hl_id;
  {
      int			count;
      struct hl_group	*sgp;
--- 9374,9380 ----
   * Translate a group ID to the final group ID (following links).
   */
      int
! syn_get_final_id(int hl_id)
  {
      int			count;
      struct hl_group	*sgp;
***************
*** 9542,9548 ****
   * It finds the font and color handles for the highlighting groups.
   */
      void
! highlight_gui_started()
  {
      int	    idx;
  
--- 9403,9409 ----
   * It finds the font and color handles for the highlighting groups.
   */
      void
! highlight_gui_started(void)
  {
      int	    idx;
  
***************
*** 9556,9565 ****
  }
  
      static void
! gui_do_one_color(idx, do_menu, do_tooltip)
!     int		idx;
!     int		do_menu;	/* TRUE: might set the menu font */
!     int		do_tooltip;	/* TRUE: might set the tooltip font */
  {
      int		didit = FALSE;
  
--- 9417,9426 ----
  }
  
      static void
! gui_do_one_color(
!     int		idx,
!     int		do_menu,	/* TRUE: might set the menu font */
!     int		do_tooltip)	/* TRUE: might set the tooltip font */
  {
      int		didit = FALSE;
  
***************
*** 9602,9608 ****
   * Return FAIL when an invalid flag is found in 'highlight'.  OK otherwise.
   */
      int
! highlight_changed()
  {
      int		hlf;
      int		i;
--- 9463,9469 ----
   * Return FAIL when an invalid flag is found in 'highlight'.  OK otherwise.
   */
      int
! highlight_changed(void)
  {
      int		hlf;
      int		i;
***************
*** 9813,9821 ****
   * Handle command line completion for :highlight command.
   */
      void
! set_context_in_highlight_cmd(xp, arg)
!     expand_T	*xp;
!     char_u	*arg;
  {
      char_u	*p;
  
--- 9674,9680 ----
   * Handle command line completion for :highlight command.
   */
      void
! set_context_in_highlight_cmd(expand_T *xp, char_u *arg)
  {
      char_u	*p;
  
***************
*** 9865,9871 ****
   * List highlighting matches in a nice way.
   */
      static void
! highlight_list()
  {
      int		i;
  
--- 9724,9730 ----
   * List highlighting matches in a nice way.
   */
      static void
! highlight_list(void)
  {
      int		i;
  
***************
*** 9876,9884 ****
  }
  
      static void
! highlight_list_two(cnt, attr)
!     int	    cnt;
!     int	    attr;
  {
      msg_puts_attr((char_u *)&("N \bI \b!  \b"[cnt / 11]), attr);
      msg_clr_eos();
--- 9735,9741 ----
  }
  
      static void
! highlight_list_two(int cnt, int attr)
  {
      msg_puts_attr((char_u *)&("N \bI \b!  \b"[cnt / 11]), attr);
      msg_clr_eos();
***************
*** 9895,9903 ****
   * Also used for synIDattr() function.
   */
      char_u *
! get_highlight_name(xp, idx)
!     expand_T	*xp UNUSED;
!     int		idx;
  {
  #ifdef FEAT_CMDL_COMPL
      if (idx == highlight_ga.ga_len && include_none != 0)
--- 9752,9758 ----
   * Also used for synIDattr() function.
   */
      char_u *
! get_highlight_name(expand_T *xp UNUSED, int idx)
  {
  #ifdef FEAT_CMDL_COMPL
      if (idx == highlight_ga.ga_len && include_none != 0)
***************
*** 9923,9929 ****
   * Used when quitting for systems which need it.
   */
      void
! free_highlight_fonts()
  {
      int	    idx;
  
--- 9778,9784 ----
   * Used when quitting for systems which need it.
   */
      void
! free_highlight_fonts(void)
  {
      int	    idx;
  
*** ../vim-7.4.1213/src/tag.c	2016-01-29 22:46:58.974534733 +0100
--- src/tag.c	2016-01-30 20:53:16.891888110 +0100
***************
*** 121,132 ****
   * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise
   */
      int
! do_tag(tag, type, count, forceit, verbose)
!     char_u	*tag;		/* tag (pattern) to jump to */
!     int		type;
!     int		count;
!     int		forceit;	/* :ta with ! */
!     int		verbose;	/* print "tag not found" message */
  {
      taggy_T	*tagstack = curwin->w_tagstack;
      int		tagstackidx = curwin->w_tagstackidx;
--- 121,132 ----
   * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise
   */
      int
! do_tag(
!     char_u	*tag,		/* tag (pattern) to jump to */
!     int		type,
!     int		count,
!     int		forceit,	/* :ta with ! */
!     int		verbose)	/* print "tag not found" message */
  {
      taggy_T	*tagstack = curwin->w_tagstack;
      int		tagstackidx = curwin->w_tagstackidx;
***************
*** 1092,1106 ****
   * Free cached tags.
   */
      void
! tag_freematch()
  {
      vim_free(tagmatchname);
      tagmatchname = NULL;
  }
  
      static void
! taglen_advance(l)
!     int		l;
  {
      if (l == MAXCOL)
      {
--- 1092,1105 ----
   * Free cached tags.
   */
      void
! tag_freematch(void)
  {
      vim_free(tagmatchname);
      tagmatchname = NULL;
  }
  
      static void
! taglen_advance(int l)
  {
      if (l == MAXCOL)
      {
***************
*** 1115,1122 ****
   * Print the tag stack
   */
      void
! do_tags(eap)
!     exarg_T	*eap UNUSED;
  {
      int		i;
      char_u	*name;
--- 1114,1120 ----
   * Print the tag stack
   */
      void
! do_tags(exarg_T *eap UNUSED)
  {
      int		i;
      char_u	*name;
***************
*** 1169,1178 ****
   * Make sure case is folded to uppercase in comparison (like for 'sort -f')
   */
      static int
! tag_strnicmp(s1, s2, len)
!     char_u	*s1;
!     char_u	*s2;
!     size_t	len;
  {
      int		i;
  
--- 1167,1173 ----
   * Make sure case is folded to uppercase in comparison (like for 'sort -f')
   */
      static int
! tag_strnicmp(char_u *s1, char_u *s2, size_t len)
  {
      int		i;
  
***************
*** 1209,1217 ****
   * Extract info from the tag search pattern "pats->pat".
   */
      static void
! prepare_pats(pats, has_re)
!     pat_T	*pats;
!     int		has_re;
  {
      pats->head = pats->pat;
      pats->headlen = pats->len;
--- 1204,1210 ----
   * Extract info from the tag search pattern "pats->pat".
   */
      static void
! prepare_pats(pat_T *pats, int has_re)
  {
      pats->head = pats->pat;
      pats->headlen = pats->len;
***************
*** 1267,1280 ****
   * TAG_KEEP_LANG  keep language
   */
      int
! find_tags(pat, num_matches, matchesp, flags, mincount, buf_ffname)
!     char_u	*pat;			/* pattern to search for */
!     int		*num_matches;		/* return: number of matches found */
!     char_u	***matchesp;		/* return: array of matches found */
!     int		flags;
!     int		mincount;		/*  MAXCOL: find all matches
  					     other: minimal number of matches */
!     char_u	*buf_ffname;		/* name of buffer for priority */
  {
      FILE       *fp;
      char_u     *lbuf;			/* line buffer */
--- 1260,1273 ----
   * TAG_KEEP_LANG  keep language
   */
      int
! find_tags(
!     char_u	*pat,			/* pattern to search for */
!     int		*num_matches,		/* return: number of matches found */
!     char_u	***matchesp,		/* return: array of matches found */
!     int		flags,
!     int		mincount,		/*  MAXCOL: find all matches
  					     other: minimal number of matches */
!     char_u	*buf_ffname)		/* name of buffer for priority */
  {
      FILE       *fp;
      char_u     *lbuf;			/* line buffer */
***************
*** 2577,2585 ****
   * 'runtimepath' doc directories.
   */
      static void
! found_tagfile_cb(fname, cookie)
!     char_u	*fname;
!     void	*cookie UNUSED;
  {
      if (ga_grow(&tag_fnames, 1) == OK)
  	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
--- 2570,2576 ----
   * 'runtimepath' doc directories.
   */
      static void
! found_tagfile_cb(char_u *fname, void *cookie UNUSED)
  {
      if (ga_grow(&tag_fnames, 1) == OK)
  	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
***************
*** 2588,2594 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_tag_stuff()
  {
      ga_clear_strings(&tag_fnames);
      do_tag(NULL, DT_FREE, 0, 0, 0);
--- 2579,2585 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! free_tag_stuff(void)
  {
      ga_clear_strings(&tag_fnames);
      do_tag(NULL, DT_FREE, 0, 0, 0);
***************
*** 2611,2620 ****
   * Return FAIL if no more tag file names, OK otherwise.
   */
      int
! get_tagfname(tnp, first, buf)
!     tagname_T	*tnp;	/* holds status info */
!     int		first;	/* TRUE when first file name is wanted */
!     char_u	*buf;	/* pointer to buffer of MAXPATHL chars */
  {
      char_u		*fname = NULL;
      char_u		*r_ptr;
--- 2602,2611 ----
   * Return FAIL if no more tag file names, OK otherwise.
   */
      int
! get_tagfname(
!     tagname_T	*tnp,	/* holds status info */
!     int		first,	/* TRUE when first file name is wanted */
!     char_u	*buf)	/* pointer to buffer of MAXPATHL chars */
  {
      char_u		*fname = NULL;
      char_u		*r_ptr;
***************
*** 2741,2748 ****
   * Free the contents of a tagname_T that was filled by get_tagfname().
   */
      void
! tagname_free(tnp)
!     tagname_T	*tnp;
  {
      vim_free(tnp->tn_tags);
      vim_findfile_cleanup(tnp->tn_search_ctx);
--- 2732,2738 ----
   * Free the contents of a tagname_T that was filled by get_tagfname().
   */
      void
! tagname_free(tagname_T *tnp)
  {
      vim_free(tnp->tn_tags);
      vim_findfile_cleanup(tnp->tn_search_ctx);
***************
*** 2759,2774 ****
   * Return FAIL if there is a format error in this line, OK otherwise.
   */
      static int
! parse_tag_line(lbuf,
! #ifdef FEAT_EMACS_TAGS
! 		    is_etag,
! #endif
! 			      tagp)
!     char_u	*lbuf;		/* line to be parsed */
  #ifdef FEAT_EMACS_TAGS
!     int		is_etag;
  #endif
!     tagptrs_T	*tagp;
  {
      char_u	*p;
  
--- 2749,2760 ----
   * Return FAIL if there is a format error in this line, OK otherwise.
   */
      static int
! parse_tag_line(
!     char_u	*lbuf,		/* line to be parsed */
  #ifdef FEAT_EMACS_TAGS
!     int		is_etag,
  #endif
!     tagptrs_T	*tagp)
  {
      char_u	*p;
  
***************
*** 2895,2902 ****
   * Return FALSE if it is not a static tag.
   */
      static int
! test_for_static(tagp)
!     tagptrs_T	*tagp;
  {
      char_u	*p;
  
--- 2881,2887 ----
   * Return FALSE if it is not a static tag.
   */
      static int
! test_for_static(tagptrs_T *tagp)
  {
      char_u	*p;
  
***************
*** 2942,2950 ****
   * Return OK or FAIL.
   */
      static int
! parse_match(lbuf, tagp)
!     char_u	*lbuf;	    /* input: matching line */
!     tagptrs_T	*tagp;	    /* output: pointers into the line */
  {
      int		retval;
      char_u	*p;
--- 2927,2935 ----
   * Return OK or FAIL.
   */
      static int
! parse_match(
!     char_u	*lbuf,	    /* input: matching line */
!     tagptrs_T	*tagp)	    /* output: pointers into the line */
  {
      int		retval;
      char_u	*p;
***************
*** 3022,3029 ****
   * Returns an allocated string or NULL (out of memory).
   */
      static char_u *
! tag_full_fname(tagp)
!     tagptrs_T	*tagp;
  {
      char_u	*fullname;
      int		c;
--- 3007,3013 ----
   * Returns an allocated string or NULL (out of memory).
   */
      static char_u *
! tag_full_fname(tagptrs_T *tagp)
  {
      char_u	*fullname;
      int		c;
***************
*** 3053,3062 ****
   * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.
   */
      static int
! jumpto_tag(lbuf, forceit, keep_help)
!     char_u	*lbuf;		/* line from the tags file for this tag */
!     int		forceit;	/* :ta with ! */
!     int		keep_help;	/* keep help flag (FALSE for cscope) */
  {
      int		save_secure;
      int		save_magic;
--- 3037,3046 ----
   * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.
   */
      static int
! jumpto_tag(
!     char_u	*lbuf,		/* line from the tags file for this tag */
!     int		forceit,	/* :ta with ! */
!     int		keep_help)	/* keep help flag (FALSE for cscope) */
  {
      int		save_secure;
      int		save_magic;
***************
*** 3417,3426 ****
   * Returns a pointer to allocated memory (or NULL when out of memory).
   */
      static char_u *
! expand_tag_fname(fname, tag_fname, expand)
!     char_u	*fname;
!     char_u	*tag_fname;
!     int		expand;
  {
      char_u	*p;
      char_u	*retval;
--- 3401,3407 ----
   * Returns a pointer to allocated memory (or NULL when out of memory).
   */
      static char_u *
! expand_tag_fname(char_u *fname, char_u *tag_fname, int expand)
  {
      char_u	*p;
      char_u	*retval;
***************
*** 3471,3478 ****
   * length as that supplied, or shorter.
   */
      void
! simplify_filename(filename)
!     char_u	*filename;
  {
  #ifndef AMIGA	    /* Amiga doesn't have "..", it uses "/" */
      int		components = 0;
--- 3452,3458 ----
   * length as that supplied, or shorter.
   */
      void
! simplify_filename(char_u *filename)
  {
  #ifndef AMIGA	    /* Amiga doesn't have "..", it uses "/" */
      int		components = 0;
***************
*** 3684,3699 ****
   * file.
   */
      static int
  #ifdef FEAT_EMACS_TAGS
! test_for_current(is_etag, fname, fname_end, tag_fname, buf_ffname)
!     int	    is_etag;
! #else
! test_for_current(fname, fname_end, tag_fname, buf_ffname)
  #endif
!     char_u  *fname;
!     char_u  *fname_end;
!     char_u  *tag_fname;
!     char_u  *buf_ffname;
  {
      int	    c;
      int	    retval = FALSE;
--- 3664,3677 ----
   * file.
   */
      static int
+ test_for_current(
  #ifdef FEAT_EMACS_TAGS
!     int	    is_etag,
  #endif
!     char_u  *fname,
!     char_u  *fname_end,
!     char_u  *tag_fname,
!     char_u  *buf_ffname)
  {
      int	    c;
      int	    retval = FALSE;
***************
*** 3730,3737 ****
   * Return OK if ";\"" is following, FAIL otherwise.
   */
      static int
! find_extra(pp)
!     char_u	**pp;
  {
      char_u	*str = *pp;
  
--- 3708,3714 ----
   * Return OK if ";\"" is following, FAIL otherwise.
   */
      static int
! find_extra(char_u **pp)
  {
      char_u	*str = *pp;
  
***************
*** 3766,3776 ****
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      int
! expand_tags(tagnames, pat, num_file, file)
!     int		tagnames;	/* expand tag names */
!     char_u	*pat;
!     int		*num_file;
!     char_u	***file;
  {
      int		i;
      int		c;
--- 3743,3753 ----
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      int
! expand_tags(
!     int		tagnames,	/* expand tag names */
!     char_u	*pat,
!     int		*num_file,
!     char_u	***file)
  {
      int		i;
      int		c;
***************
*** 3822,3832 ****
   * Return OK or FAIL.
   */
      static int
! add_tag_field(dict, field_name, start, end)
!     dict_T  *dict;
!     char    *field_name;
!     char_u  *start;		/* start of the value */
!     char_u  *end;		/* after the value; can be NULL */
  {
      char_u	*buf;
      int		len = 0;
--- 3799,3809 ----
   * Return OK or FAIL.
   */
      static int
! add_tag_field(
!     dict_T  *dict,
!     char    *field_name,
!     char_u  *start,		/* start of the value */
!     char_u  *end)		/* after the value; can be NULL */
  {
      char_u	*buf;
      int		len = 0;
***************
*** 3870,3878 ****
   * as a dictionary
   */
      int
! get_tags(list, pat)
!     list_T *list;
!     char_u *pat;
  {
      int		num_matches, i, ret;
      char_u	**matches, *p;
--- 3847,3853 ----
   * as a dictionary
   */
      int
! get_tags(list_T *list, char_u *pat)
  {
      int		num_matches, i, ret;
      char_u	**matches, *p;
*** ../vim-7.4.1213/src/term.c	2016-01-29 22:46:58.974534733 +0100
--- src/term.c	2016-01-30 20:57:11.633433870 +0100
***************
*** 1412,1419 ****
  #endif
  
      static struct builtin_term *
! find_builtin_term(term)
!     char_u	*term;
  {
      struct builtin_term *p;
  
--- 1412,1418 ----
  #endif
  
      static struct builtin_term *
! find_builtin_term(char_u *term)
  {
      struct builtin_term *p;
  
***************
*** 1448,1455 ****
   * The terminal's name is not set, as this is already done in termcapinit().
   */
      static void
! parse_builtin_tcap(term)
!     char_u  *term;
  {
      struct builtin_term	    *p;
      char_u		    name[2];
--- 1447,1453 ----
   * The terminal's name is not set, as this is already done in termcapinit().
   */
      static void
! parse_builtin_tcap(char_u *term)
  {
      struct builtin_term	    *p;
      char_u		    name[2];
***************
*** 1510,1517 ****
   * Store it as a string in T_CCO (using nr_colors[]).
   */
      static void
! set_color_count(nr)
!     int		nr;
  {
      char_u	nr_colors[20];		/* string for number of colors */
  
--- 1508,1514 ----
   * Store it as a string in T_CCO (using nr_colors[]).
   */
      static void
! set_color_count(int nr)
  {
      char_u	nr_colors[20];		/* string for number of colors */
  
***************
*** 1548,1555 ****
   * While doing this, until ttest(), some options may be NULL, be careful.
   */
      int
! set_termname(term)
!     char_u *term;
  {
      struct builtin_term *termp;
  #ifdef HAVE_TGETENT
--- 1545,1551 ----
   * While doing this, until ttest(), some options may be NULL, be careful.
   */
      int
! set_termname(char_u *term)
  {
      struct builtin_term *termp;
  #ifdef HAVE_TGETENT
***************
*** 2031,2039 ****
  
  # if (!defined(UNIX) || defined(FEAT_MOUSE_TTY)) || defined(PROTO)
      void
! set_mouse_termcode(n, s)
!     int		n;	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
!     char_u	*s;
  {
      char_u	name[2];
  
--- 2027,2035 ----
  
  # if (!defined(UNIX) || defined(FEAT_MOUSE_TTY)) || defined(PROTO)
      void
! set_mouse_termcode(
!     int		n,	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
!     char_u	*s)
  {
      char_u	name[2];
  
***************
*** 2079,2086 ****
  # if ((defined(UNIX) || defined(VMS)) \
  	&& defined(FEAT_MOUSE_TTY)) || defined(PROTO)
      void
! del_mouse_termcode(n)
!     int		n;	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
  {
      char_u	name[2];
  
--- 2075,2082 ----
  # if ((defined(UNIX) || defined(VMS)) \
  	&& defined(FEAT_MOUSE_TTY)) || defined(PROTO)
      void
! del_mouse_termcode(
!     int		n)	/* KS_MOUSE, KS_NETTERM_MOUSE or KS_DEC_MOUSE */
  {
      char_u	name[2];
  
***************
*** 2130,2138 ****
   * Return error message if it fails, NULL if it's OK.
   */
      static char_u *
! tgetent_error(tbuf, term)
!     char_u  *tbuf;
!     char_u  *term;
  {
      int	    i;
  
--- 2126,2132 ----
   * Return error message if it fails, NULL if it's OK.
   */
      static char_u *
! tgetent_error(char_u *tbuf, char_u *term)
  {
      int	    i;
  
***************
*** 2167,2175 ****
   * Fix that here.
   */
      static char_u *
! vim_tgetstr(s, pp)
!     char	*s;
!     char_u	**pp;
  {
      char	*p;
  
--- 2161,2167 ----
   * Fix that here.
   */
      static char_u *
! vim_tgetstr(char *s, char_u **pp)
  {
      char	*p;
  
***************
*** 2188,2196 ****
   * Errors while getting the entries are ignored.
   */
      void
! getlinecol(cp, rp)
!     long	*cp;	/* pointer to columns */
!     long	*rp;	/* pointer to rows */
  {
      char_u	tbuf[TBUFSZ];
  
--- 2180,2188 ----
   * Errors while getting the entries are ignored.
   */
      void
! getlinecol(
!     long	*cp,	/* pointer to columns */
!     long	*rp)	/* pointer to rows */
  {
      char_u	tbuf[TBUFSZ];
  
***************
*** 2212,2220 ****
   * Return FAIL if the entry was not found, OK if the entry was added.
   */
      int
! add_termcap_entry(name, force)
!     char_u  *name;
!     int	    force;
  {
      char_u  *term;
      int	    key;
--- 2204,2210 ----
   * Return FAIL if the entry was not found, OK if the entry was added.
   */
      int
! add_termcap_entry(char_u *name, int force)
  {
      char_u  *term;
      int	    key;
***************
*** 2321,2328 ****
  }
  
      static int
! term_is_builtin(name)
!     char_u  *name;
  {
      return (STRNCMP(name, "builtin_", (size_t)8) == 0);
  }
--- 2311,2317 ----
  }
  
      static int
! term_is_builtin(char_u *name)
  {
      return (STRNCMP(name, "builtin_", (size_t)8) == 0);
  }
***************
*** 2333,2340 ****
   * "8bit", like in "xterm-8bit".
   */
      int
! term_is_8bit(name)
!     char_u  *name;
  {
      return (detected_8bit || strstr((char *)name, "8bit") != NULL);
  }
--- 2322,2328 ----
   * "8bit", like in "xterm-8bit".
   */
      int
! term_is_8bit(char_u *name)
  {
      return (detected_8bit || strstr((char *)name, "8bit") != NULL);
  }
***************
*** 2346,2353 ****
   * <Esc>O -> <M-C-O>
   */
      static int
! term_7to8bit(p)
!     char_u  *p;
  {
      if (*p == ESC)
      {
--- 2334,2340 ----
   * <Esc>O -> <M-C-O>
   */
      static int
! term_7to8bit(char_u *p)
  {
      if (*p == ESC)
      {
***************
*** 2363,2370 ****
  
  #ifdef FEAT_GUI
      int
! term_is_gui(name)
!     char_u  *name;
  {
      return (STRCMP(name, "builtin_gui") == 0 || STRCMP(name, "gui") == 0);
  }
--- 2350,2356 ----
  
  #ifdef FEAT_GUI
      int
! term_is_gui(char_u *name)
  {
      return (STRCMP(name, "builtin_gui") == 0 || STRCMP(name, "gui") == 0);
  }
***************
*** 2373,2380 ****
  #if !defined(HAVE_TGETENT) || defined(AMIGA) || defined(PROTO)
  
      char_u *
! tltoa(i)
!     unsigned long i;
  {
      static char_u buf[16];
      char_u	*p;
--- 2359,2365 ----
  #if !defined(HAVE_TGETENT) || defined(AMIGA) || defined(PROTO)
  
      char_u *
! tltoa(unsigned long i)
  {
      static char_u buf[16];
      char_u	*p;
***************
*** 2401,2409 ****
  static char *tgoto(char *, int, int);
  
      static char *
! tgoto(cm, x, y)
!     char *cm;
!     int x, y;
  {
      static char buf[30];
      char *p, *s, *e;
--- 2386,2392 ----
  static char *tgoto(char *, int, int);
  
      static char *
! tgoto(char *cm, int x, int y)
  {
      static char buf[30];
      char *p, *s, *e;
***************
*** 2453,2460 ****
   * If that fails, use the default terminal name.
   */
      void
! termcapinit(name)
!     char_u *name;
  {
      char_u	*term;
  
--- 2436,2442 ----
   * If that fails, use the default terminal name.
   */
      void
! termcapinit(char_u *name)
  {
      char_u	*term;
  
***************
*** 2511,2517 ****
   * out_flush(): flush the output buffer
   */
      void
! out_flush()
  {
      int	    len;
  
--- 2493,2499 ----
   * out_flush(): flush the output buffer
   */
      void
! out_flush(void)
  {
      int	    len;
  
***************
*** 2530,2536 ****
   * To avoid flushing half of the character, call this function first.
   */
      void
! out_flush_check()
  {
      if (enc_dbcs != 0 && out_pos >= OUT_SIZE - MB_MAXBYTES)
  	out_flush();
--- 2512,2518 ----
   * To avoid flushing half of the character, call this function first.
   */
      void
! out_flush_check(void)
  {
      if (enc_dbcs != 0 && out_pos >= OUT_SIZE - MB_MAXBYTES)
  	out_flush();
***************
*** 2542,2548 ****
   * out_trash(): Throw away the contents of the output buffer
   */
      void
! out_trash()
  {
      out_pos = 0;
  }
--- 2524,2530 ----
   * out_trash(): Throw away the contents of the output buffer
   */
      void
! out_trash(void)
  {
      out_pos = 0;
  }
***************
*** 2555,2562 ****
   * like msg_puts() and screen_putchar() for that).
   */
      void
! out_char(c)
!     unsigned	c;
  {
  #if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
      if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
--- 2537,2543 ----
   * like msg_puts() and screen_putchar() for that).
   */
      void
! out_char(unsigned c)
  {
  #if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
      if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
***************
*** 2576,2583 ****
   * out_char_nf(c): like out_char(), but don't flush when p_wd is set
   */
      static void
! out_char_nf(c)
!     unsigned	c;
  {
  #if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
      if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
--- 2557,2563 ----
   * out_char_nf(c): like out_char(), but don't flush when p_wd is set
   */
      static void
! out_char_nf(unsigned c)
  {
  #if defined(UNIX) || defined(VMS) || defined(AMIGA) || defined(MACOS_X_UNIX)
      if (c == '\n')	/* turn LF into CR-LF (CRMOD doesn't seem to do this) */
***************
*** 2602,2609 ****
   * normal text (use functions like msg_puts() and screen_putchar() for that).
   */
      void
! out_str_nf(s)
!     char_u *s;
  {
      if (out_pos > OUT_SIZE - 20)  /* avoid terminal strings being split up */
  	out_flush();
--- 2582,2588 ----
   * normal text (use functions like msg_puts() and screen_putchar() for that).
   */
      void
! out_str_nf(char_u *s)
  {
      if (out_pos > OUT_SIZE - 20)  /* avoid terminal strings being split up */
  	out_flush();
***************
*** 2623,2630 ****
   * normal text (use functions like msg_puts() and screen_putchar() for that).
   */
      void
! out_str(s)
!     char_u	 *s;
  {
      if (s != NULL && *s)
      {
--- 2602,2608 ----
   * normal text (use functions like msg_puts() and screen_putchar() for that).
   */
      void
! out_str(char_u *s)
  {
      if (s != NULL && *s)
      {
***************
*** 2656,2694 ****
   * cursor positioning using termcap parser. (jw)
   */
      void
! term_windgoto(row, col)
!     int	    row;
!     int	    col;
  {
      OUT_STR(tgoto((char *)T_CM, col, row));
  }
  
      void
! term_cursor_right(i)
!     int	    i;
  {
      OUT_STR(tgoto((char *)T_CRI, 0, i));
  }
  
      void
! term_append_lines(line_count)
!     int	    line_count;
  {
      OUT_STR(tgoto((char *)T_CAL, 0, line_count));
  }
  
      void
! term_delete_lines(line_count)
!     int	    line_count;
  {
      OUT_STR(tgoto((char *)T_CDL, 0, line_count));
  }
  
  #if defined(HAVE_TGETENT) || defined(PROTO)
      void
! term_set_winpos(x, y)
!     int	    x;
!     int	    y;
  {
      /* Can't handle a negative value here */
      if (x < 0)
--- 2634,2665 ----
   * cursor positioning using termcap parser. (jw)
   */
      void
! term_windgoto(int row, int col)
  {
      OUT_STR(tgoto((char *)T_CM, col, row));
  }
  
      void
! term_cursor_right(int i)
  {
      OUT_STR(tgoto((char *)T_CRI, 0, i));
  }
  
      void
! term_append_lines(int line_count)
  {
      OUT_STR(tgoto((char *)T_CAL, 0, line_count));
  }
  
      void
! term_delete_lines(int line_count)
  {
      OUT_STR(tgoto((char *)T_CDL, 0, line_count));
  }
  
  #if defined(HAVE_TGETENT) || defined(PROTO)
      void
! term_set_winpos(int x, int y)
  {
      /* Can't handle a negative value here */
      if (x < 0)
***************
*** 2699,2715 ****
  }
  
      void
! term_set_winsize(width, height)
!     int	    width;
!     int	    height;
  {
      OUT_STR(tgoto((char *)T_CWS, height, width));
  }
  #endif
  
      void
! term_fg_color(n)
!     int	    n;
  {
      /* Use "AF" termcap entry if present, "Sf" entry otherwise */
      if (*T_CAF)
--- 2670,2683 ----
  }
  
      void
! term_set_winsize(int width, int height)
  {
      OUT_STR(tgoto((char *)T_CWS, height, width));
  }
  #endif
  
      void
! term_fg_color(int n)
  {
      /* Use "AF" termcap entry if present, "Sf" entry otherwise */
      if (*T_CAF)
***************
*** 2719,2726 ****
  }
  
      void
! term_bg_color(n)
!     int	    n;
  {
      /* Use "AB" termcap entry if present, "Sb" entry otherwise */
      if (*T_CAB)
--- 2687,2693 ----
  }
  
      void
! term_bg_color(int n)
  {
      /* Use "AB" termcap entry if present, "Sb" entry otherwise */
      if (*T_CAB)
***************
*** 2730,2738 ****
  }
  
      static void
! term_color(s, n)
!     char_u	*s;
!     int		n;
  {
      char	buf[20];
      int i = 2;	/* index in s[] just after <Esc>[ or CSI */
--- 2697,2703 ----
  }
  
      static void
! term_color(char_u *s, int n)
  {
      char	buf[20];
      int i = 2;	/* index in s[] just after <Esc>[ or CSI */
***************
*** 2768,2775 ****
   * Generic function to set window title, using t_ts and t_fs.
   */
      void
! term_settitle(title)
!     char_u	*title;
  {
      /* t_ts takes one argument: column in status line */
      OUT_STR(tgoto((char *)T_TS, 0, 0));	/* set title start */
--- 2733,2739 ----
   * Generic function to set window title, using t_ts and t_fs.
   */
      void
! term_settitle(char_u *title)
  {
      /* t_ts takes one argument: column in status line */
      OUT_STR(tgoto((char *)T_TS, 0, 0));	/* set title start */
***************
*** 2784,2791 ****
   * Replace all entries that are NULL by empty_option
   */
      void
! ttest(pairs)
!     int	pairs;
  {
      check_options();		    /* make sure no options are NULL */
  
--- 2748,2754 ----
   * Replace all entries that are NULL by empty_option
   */
      void
! ttest(int pairs)
  {
      check_options();		    /* make sure no options are NULL */
  
***************
*** 2884,2892 ****
   * byte first, and store them in dst.
   */
      void
! add_long_to_buf(val, dst)
!     long_u  val;
!     char_u  *dst;
  {
      int	    i;
      int	    shift;
--- 2847,2853 ----
   * byte first, and store them in dst.
   */
      void
! add_long_to_buf(long_u val, char_u *dst)
  {
      int	    i;
      int	    shift;
***************
*** 2909,2917 ****
   * were present.
   */
      static int
! get_long_from_buf(buf, val)
!     char_u  *buf;
!     long_u  *val;
  {
      int	    len;
      char_u  bytes[sizeof(long_u)];
--- 2870,2876 ----
   * were present.
   */
      static int
! get_long_from_buf(char_u *buf, long_u *val)
  {
      int	    len;
      char_u  bytes[sizeof(long_u)];
***************
*** 2942,2951 ****
   * available.
   */
      static int
! get_bytes_from_buf(buf, bytes, num_bytes)
!     char_u  *buf;
!     char_u  *bytes;
!     int	    num_bytes;
  {
      int	    len = 0;
      int	    i;
--- 2901,2907 ----
   * available.
   */
      static int
! get_bytes_from_buf(char_u *buf, char_u *bytes, int num_bytes)
  {
      int	    len = 0;
      int	    i;
***************
*** 2982,2988 ****
   * too big.
   */
      void
! check_shellsize()
  {
      if (Rows < min_rows())	/* need room for one window and command line */
  	Rows = min_rows();
--- 2938,2944 ----
   * too big.
   */
      void
! check_shellsize(void)
  {
      if (Rows < min_rows())	/* need room for one window and command line */
  	Rows = min_rows();
***************
*** 2993,2999 ****
   * Limit Rows and Columns to avoid an overflow in Rows * Columns.
   */
      void
! limit_screen_size()
  {
      if (Columns < MIN_COLUMNS)
  	Columns = MIN_COLUMNS;
--- 2949,2955 ----
   * Limit Rows and Columns to avoid an overflow in Rows * Columns.
   */
      void
! limit_screen_size(void)
  {
      if (Columns < MIN_COLUMNS)
  	Columns = MIN_COLUMNS;
***************
*** 3007,3013 ****
   * Invoked just before the screen structures are going to be (re)allocated.
   */
      void
! win_new_shellsize()
  {
      static int	old_Rows = 0;
      static int	old_Columns = 0;
--- 2963,2969 ----
   * Invoked just before the screen structures are going to be (re)allocated.
   */
      void
! win_new_shellsize(void)
  {
      static int	old_Rows = 0;
      static int	old_Columns = 0;
***************
*** 3036,3042 ****
   * Will obtain the current size and redraw (also when size didn't change).
   */
      void
! shell_resized()
  {
      set_shellsize(0, 0, FALSE);
  }
--- 2992,2998 ----
   * Will obtain the current size and redraw (also when size didn't change).
   */
      void
! shell_resized(void)
  {
      set_shellsize(0, 0, FALSE);
  }
***************
*** 3046,3052 ****
   * When the size didn't change, nothing happens.
   */
      void
! shell_resized_check()
  {
      int		old_Rows = Rows;
      int		old_Columns = Columns;
--- 3002,3008 ----
   * When the size didn't change, nothing happens.
   */
      void
! shell_resized_check(void)
  {
      int		old_Rows = Rows;
      int		old_Columns = Columns;
***************
*** 3074,3082 ****
   * it fails use 'width' and 'height'.
   */
      void
! set_shellsize(width, height, mustset)
!     int	    width, height;
!     int	    mustset;
  {
      static int		busy = FALSE;
  
--- 3030,3036 ----
   * it fails use 'width' and 'height'.
   */
      void
! set_shellsize(int width, int height, int mustset)
  {
      static int		busy = FALSE;
  
***************
*** 3192,3199 ****
   * commands and Ex mode).
   */
      void
! settmode(tmode)
!     int	 tmode;
  {
  #ifdef FEAT_GUI
      /* don't set the term where gvim was started to any mode */
--- 3146,3152 ----
   * commands and Ex mode).
   */
      void
! settmode(int tmode)
  {
  #ifdef FEAT_GUI
      /* don't set the term where gvim was started to any mode */
***************
*** 3248,3254 ****
  }
  
      void
! starttermcap()
  {
      if (full_screen && !termcap_active)
      {
--- 3201,3207 ----
  }
  
      void
! starttermcap(void)
  {
      if (full_screen && !termcap_active)
      {
***************
*** 3273,3279 ****
  }
  
      void
! stoptermcap()
  {
      screen_stop_highlight();
      reset_cterm_colors();
--- 3226,3232 ----
  }
  
      void
! stoptermcap(void)
  {
      screen_stop_highlight();
      reset_cterm_colors();
***************
*** 3329,3335 ****
   * The result is caught in check_termcode().
   */
      void
! may_req_termresponse()
  {
      if (crv_status == CRV_GET
  	    && cur_tmode == TMODE_RAW
--- 3282,3288 ----
   * The result is caught in check_termcode().
   */
      void
! may_req_termresponse(void)
  {
      if (crv_status == CRV_GET
  	    && cur_tmode == TMODE_RAW
***************
*** 3363,3369 ****
   * it must be called immediately after entering termcap mode.
   */
      void
! may_req_ambiguous_char_width()
  {
      if (u7_status == U7_GET
  	    && cur_tmode == TMODE_RAW
--- 3316,3322 ----
   * it must be called immediately after entering termcap mode.
   */
      void
! may_req_ambiguous_char_width(void)
  {
      if (u7_status == U7_GET
  	    && cur_tmode == TMODE_RAW
***************
*** 3404,3410 ****
   * color when it is the right moment.
   */
      void
! may_req_bg_color()
  {
      if (rbg_status == RBG_GET
  	    && cur_tmode == TMODE_RAW
--- 3357,3363 ----
   * color when it is the right moment.
   */
      void
! may_req_bg_color(void)
  {
      if (rbg_status == RBG_GET
  	    && cur_tmode == TMODE_RAW
***************
*** 3456,3462 ****
   * Return TRUE when saving and restoring the screen.
   */
      int
! swapping_screen()
  {
      return (full_screen && *T_TI != NUL);
  }
--- 3409,3415 ----
   * Return TRUE when saving and restoring the screen.
   */
      int
! swapping_screen(void)
  {
      return (full_screen && *T_TI != NUL);
  }
***************
*** 3466,3472 ****
   * setmouse() - switch mouse on/off depending on current mode and 'mouse'
   */
      void
! setmouse()
  {
  # ifdef FEAT_MOUSE_TTY
      int	    checkfor;
--- 3419,3425 ----
   * setmouse() - switch mouse on/off depending on current mode and 'mouse'
   */
      void
! setmouse(void)
  {
  # ifdef FEAT_MOUSE_TTY
      int	    checkfor;
***************
*** 3521,3528 ****
   *   normal editing mode (not at hit-return message).
   */
      int
! mouse_has(c)
!     int	    c;
  {
      char_u	*p;
  
--- 3474,3480 ----
   *   normal editing mode (not at hit-return message).
   */
      int
! mouse_has(int c)
  {
      char_u	*p;
  
***************
*** 3544,3550 ****
   * Return TRUE when 'mousemodel' is set to "popup" or "popup_setpos".
   */
      int
! mouse_model_popup()
  {
      return (p_mousem[0] == 'p');
  }
--- 3496,3502 ----
   * Return TRUE when 'mousemodel' is set to "popup" or "popup_setpos".
   */
      int
! mouse_model_popup(void)
  {
      return (p_mousem[0] == 'p');
  }
***************
*** 3556,3562 ****
   * Used when starting Vim or returning from a shell.
   */
      void
! scroll_start()
  {
      if (*T_VS != NUL)
      {
--- 3508,3514 ----
   * Used when starting Vim or returning from a shell.
   */
      void
! scroll_start(void)
  {
      if (*T_VS != NUL)
      {
***************
*** 3572,3578 ****
   * Enable the cursor.
   */
      void
! cursor_on()
  {
      if (cursor_is_off)
      {
--- 3524,3530 ----
   * Enable the cursor.
   */
      void
! cursor_on(void)
  {
      if (cursor_is_off)
      {
***************
*** 3585,3591 ****
   * Disable the cursor.
   */
      void
! cursor_off()
  {
      if (full_screen)
      {
--- 3537,3543 ----
   * Disable the cursor.
   */
      void
! cursor_off(void)
  {
      if (full_screen)
      {
***************
*** 3600,3606 ****
   * Set cursor shape to match Insert or Replace mode.
   */
      void
! term_cursor_shape()
  {
      static int showing_mode = NORMAL;
      char_u *p;
--- 3552,3558 ----
   * Set cursor shape to match Insert or Replace mode.
   */
      void
! term_cursor_shape(void)
  {
      static int showing_mode = NORMAL;
      char_u *p;
***************
*** 3648,3656 ****
   * the full width of the window, excluding the vertical separator.
   */
      void
! scroll_region_set(wp, off)
!     win_T	*wp;
!     int		off;
  {
      OUT_STR(tgoto((char *)T_CS, W_WINROW(wp) + wp->w_height - 1,
  							 W_WINROW(wp) + off));
--- 3600,3606 ----
   * the full width of the window, excluding the vertical separator.
   */
      void
! scroll_region_set(win_T *wp, int off)
  {
      OUT_STR(tgoto((char *)T_CS, W_WINROW(wp) + wp->w_height - 1,
  							 W_WINROW(wp) + off));
***************
*** 3666,3672 ****
   * Reset scrolling region to the whole screen.
   */
      void
! scroll_region_reset()
  {
      OUT_STR(tgoto((char *)T_CS, (int)Rows - 1, 0));
  #ifdef FEAT_VERTSPLIT
--- 3616,3622 ----
   * Reset scrolling region to the whole screen.
   */
      void
! scroll_region_reset(void)
  {
      OUT_STR(tgoto((char *)T_CS, (int)Rows - 1, 0));
  #ifdef FEAT_VERTSPLIT
***************
*** 3695,3701 ****
  static int termcode_star(char_u *code, int len);
  
      void
! clear_termcodes()
  {
      while (tc_len > 0)
  	vim_free(termcodes[--tc_len].code);
--- 3645,3651 ----
  static int termcode_star(char_u *code, int len);
  
      void
! clear_termcodes(void)
  {
      while (tc_len > 0)
  	vim_free(termcodes[--tc_len].code);
***************
*** 3722,3731 ****
   * "flags" can also be ATC_FROM_TERM for got_code_from_term().
   */
      void
! add_termcode(name, string, flags)
!     char_u	*name;
!     char_u	*string;
!     int		flags;
  {
      struct termcode *new_tc;
      int		    i, j;
--- 3672,3678 ----
   * "flags" can also be ATC_FROM_TERM for got_code_from_term().
   */
      void
! add_termcode(char_u *name, char_u *string, int flags)
  {
      struct termcode *new_tc;
      int		    i, j;
***************
*** 3854,3862 ****
   * Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.
   */
      static int
! termcode_star(code, len)
!     char_u	*code;
!     int		len;
  {
      /* Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X */
      if (len >= 3 && code[len - 2] == '*')
--- 3801,3807 ----
   * Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.
   */
      static int
! termcode_star(char_u *code, int len)
  {
      /* Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X */
      if (len >= 3 && code[len - 2] == '*')
***************
*** 3870,3877 ****
  }
  
      char_u  *
! find_termcode(name)
!     char_u  *name;
  {
      int	    i;
  
--- 3815,3821 ----
  }
  
      char_u  *
! find_termcode(char_u *name)
  {
      int	    i;
  
***************
*** 3883,3890 ****
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      char_u *
! get_termcode(i)
!     int	    i;
  {
      if (i >= tc_len)
  	return NULL;
--- 3827,3833 ----
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
      char_u *
! get_termcode(int i)
  {
      if (i >= tc_len)
  	return NULL;
***************
*** 3893,3900 ****
  #endif
  
      void
! del_termcode(name)
!     char_u  *name;
  {
      int	    i;
  
--- 3836,3842 ----
  #endif
  
      void
! del_termcode(char_u *name)
  {
      int	    i;
  
***************
*** 3913,3920 ****
  }
  
      static void
! del_termcode_idx(idx)
!     int		idx;
  {
      int		i;
  
--- 3855,3861 ----
  }
  
      static void
! del_termcode_idx(int idx)
  {
      int		i;
  
***************
*** 3930,3936 ****
   * Convert all 7-bit codes to their 8-bit equivalent.
   */
      static void
! switch_to_8bit()
  {
      int		i;
      int		c;
--- 3871,3877 ----
   * Convert all 7-bit codes to their 8-bit equivalent.
   */
      static void
! switch_to_8bit(void)
  {
      int		i;
      int		c;
***************
*** 3971,3978 ****
   * click still works.
   */
      void
! set_mouse_topline(wp)
!     win_T	*wp;
  {
      orig_topline = wp->w_topline;
  # ifdef FEAT_DIFF
--- 3912,3918 ----
   * click still works.
   */
      void
! set_mouse_topline(win_T *wp)
  {
      orig_topline = wp->w_topline;
  # ifdef FEAT_DIFF
***************
*** 3995,4005 ****
   * inserts and deletes.
   */
      int
! check_termcode(max_offset, buf, bufsize, buflen)
!     int		max_offset;
!     char_u	*buf;
!     int		bufsize;
!     int		*buflen;
  {
      char_u	*tp;
      char_u	*p;
--- 3935,3945 ----
   * inserts and deletes.
   */
      int
! check_termcode(
!     int		max_offset,
!     char_u	*buf,
!     int		bufsize,
!     int		*buflen)
  {
      char_u	*tp;
      char_u	*p;
***************
*** 5459,5470 ****
   * instead of a CTRL-V.
   */
      char_u *
! replace_termcodes(from, bufp, from_part, do_lt, special)
!     char_u	*from;
!     char_u	**bufp;
!     int		from_part;
!     int		do_lt;		/* also translate <lt> */
!     int		special;	/* always accept <key> notation */
  {
      int		i;
      int		slen;
--- 5399,5410 ----
   * instead of a CTRL-V.
   */
      char_u *
! replace_termcodes(
!     char_u	*from,
!     char_u	**bufp,
!     int		from_part,
!     int		do_lt,		/* also translate <lt> */
!     int		special)	/* always accept <key> notation */
  {
      int		i;
      int		slen;
***************
*** 5673,5680 ****
   * Return the index in termcodes[], or -1 if not found.
   */
      int
! find_term_bykeys(src)
!     char_u	*src;
  {
      int		i;
      int		slen = (int)STRLEN(src);
--- 5613,5619 ----
   * Return the index in termcodes[], or -1 if not found.
   */
      int
! find_term_bykeys(char_u *src)
  {
      int		i;
      int		slen = (int)STRLEN(src);
***************
*** 5693,5699 ****
   * Used to speed up check_termcode().
   */
      static void
! gather_termleader()
  {
      int	    i;
      int	    len = 0;
--- 5632,5638 ----
   * Used to speed up check_termcode().
   */
      static void
! gather_termleader(void)
  {
      int	    i;
      int	    len = 0;
***************
*** 5724,5730 ****
   * This code looks a lot like showoptions(), but is different.
   */
      void
! show_termcodes()
  {
      int		col;
      int		*items;
--- 5663,5669 ----
   * This code looks a lot like showoptions(), but is different.
   */
      void
! show_termcodes(void)
  {
      int		col;
      int		*items;
***************
*** 5810,5819 ****
   * Output goes into IObuff[]
   */
      int
! show_one_termcode(name, code, printit)
!     char_u  *name;
!     char_u  *code;
!     int	    printit;
  {
      char_u	*p;
      int		len;
--- 5749,5755 ----
   * Output goes into IObuff[]
   */
      int
! show_one_termcode(char_u *name, char_u *code, int printit)
  {
      char_u	*p;
      int		len;
***************
*** 5870,5876 ****
  static int xt_index_out = 0;
  
      static void
! req_codes_from_term()
  {
      xt_index_out = 0;
      xt_index_in = 0;
--- 5806,5812 ----
  static int xt_index_out = 0;
  
      static void
! req_codes_from_term(void)
  {
      xt_index_out = 0;
      xt_index_in = 0;
***************
*** 5878,5884 ****
  }
  
      static void
! req_more_codes_from_term()
  {
      char	buf[11];
      int		old_idx = xt_index_out;
--- 5814,5820 ----
  }
  
      static void
! req_more_codes_from_term(void)
  {
      char	buf[11];
      int		old_idx = xt_index_out;
***************
*** 5916,5924 ****
   * "code" points to the "0" or "1".
   */
      static void
! got_code_from_term(code, len)
!     char_u	*code;
!     int		len;
  {
  #define XT_LEN 100
      char_u	name[3];
--- 5852,5858 ----
   * "code" points to the "0" or "1".
   */
      static void
! got_code_from_term(char_u *code, int len)
  {
  #define XT_LEN 100
      char_u	name[3];
***************
*** 6006,6012 ****
   * handled as typed text.
   */
      static void
! check_for_codes_from_term()
  {
      int		c;
  
--- 5940,5946 ----
   * handled as typed text.
   */
      static void
! check_for_codes_from_term(void)
  {
      int		c;
  
***************
*** 6058,6066 ****
   * Returns NULL when there is a problem.
   */
      char_u *
! translate_mapping(str, expmap)
!     char_u	*str;
!     int		expmap;  /* TRUE when expanding mappings on command-line */
  {
      garray_T	ga;
      int		c;
--- 5992,6000 ----
   * Returns NULL when there is a problem.
   */
      char_u *
! translate_mapping(
!     char_u	*str,
!     int		expmap)  /* TRUE when expanding mappings on command-line */
  {
      garray_T	ga;
      int		c;
***************
*** 6148,6155 ****
   * For Win32 console: update termcap codes for existing console attributes.
   */
      void
! update_tcap(attr)
!     int attr;
  {
      struct builtin_term *p;
  
--- 6082,6088 ----
   * For Win32 console: update termcap codes for existing console attributes.
   */
      void
! update_tcap(int attr)
  {
      struct builtin_term *p;
  
*** ../vim-7.4.1213/src/termlib.c	2016-01-29 22:46:58.974534733 +0100
--- src/termlib.c	2016-01-30 21:00:16.595500392 +0100
***************
*** 66,74 ****
  #endif
  
      int
! tgetent(tbuf, term)
!     char    *tbuf;		/* Buffer to hold termcap entry, TBUFSZ bytes max */
!     char    *term;		/* Name of terminal */
  {
      char    tcbuf[32];		/* Temp buffer to handle */
      char    *tcptr = tcbuf;	/* extended entries */
--- 66,74 ----
  #endif
  
      int
! tgetent(
!     char    *tbuf,		/* Buffer to hold termcap entry, TBUFSZ bytes max */
!     char    *term)		/* Name of terminal */
  {
      char    tcbuf[32];		/* Temp buffer to handle */
      char    *tcptr = tcbuf;	/* extended entries */
***************
*** 140,149 ****
  }
  
      static int
! getent(tbuf, term, termcap, buflen)
!     char    *tbuf, *term;
!     FILE    *termcap;
!     int	    buflen;
  {
      char    *tptr;
      int	    tlen = strlen(term);
--- 140,146 ----
  }
  
      static int
! getent(char *tbuf, *term, FILE *termcap, int buflen)
  {
      char    *tptr;
      int	    tlen = strlen(term);
***************
*** 171,181 ****
      return 0;
  }
  
      static int
! nextent(tbuf, termcap, buflen)		/* Read 1 entry from TERMCAP file */
!     char    *tbuf;
!     FILE    *termcap;
!     int	    buflen;
  {
      char *lbuf = tbuf;				/* lbuf=line buffer */
  				/* read lines straight into buffer */
--- 168,178 ----
      return 0;
  }
  
+ /*
+  * Read 1 entry from TERMCAP file.
+  */
      static int
! nextent(char *tbuf, FILE *termcap, int buflen)
  {
      char *lbuf = tbuf;				/* lbuf=line buffer */
  				/* read lines straight into buffer */
***************
*** 218,225 ****
   */
  
      int
! tgetflag(id)
!     char *id;
  {
      char    buf[256], *ptr = buf;
  
--- 215,221 ----
   */
  
      int
! tgetflag(char *id)
  {
      char    buf[256], *ptr = buf;
  
***************
*** 237,244 ****
   */
  
      int
! tgetnum(id)
!     char *id;
  {
      char *ptr, buf[256];
      ptr = buf;
--- 233,239 ----
   */
  
      int
! tgetnum(char *id)
  {
      char *ptr, buf[256];
      ptr = buf;
***************
*** 277,284 ****
   */
  
      char *
! tgetstr(id, buf)
!     char	*id, **buf;
  {
      int		len = strlen(id);
      char	*tmp=tent;
--- 272,278 ----
   */
  
      char *
! tgetstr(char *id, char **buf)
  {
      int		len = strlen(id);
      char	*tmp=tent;
***************
*** 387,396 ****
   */
  
      char *
! tgoto(cm, col, line)
!     char	*cm;				/* cm string, from termcap */
!     int col,					/* column, x position */
!     line;					/* line, y position */
  {
      char    gx, gy,				/* x, y */
  	*ptr,					/* pointer in 'cm' */
--- 381,390 ----
   */
  
      char *
! tgoto(
!     char    *cm,				/* cm string, from termcap */
!     int	    col,				/* column, x position */
!     int	    line)				/* line, y position */
  {
      char    gx, gy,				/* x, y */
  	*ptr,					/* pointer in 'cm' */
***************
*** 533,542 ****
      4800,   9600,   19200,  19200 };
  
      int
! tputs(cp, affcnt, outc)
!     char *cp;				/* string to print */
!     int affcnt;				/* Number of lines affected */
!     void (*outc)(unsigned int);/* routine to output 1 character */
  {
      long    frac,			/* 10^(#digits after decimal point) */
  	counter,			/* digits */
--- 527,536 ----
      4800,   9600,   19200,  19200 };
  
      int
! tputs(
!     char *cp,				/* string to print */
!     int affcnt,				/* Number of lines affected */
!     void (*outc)(unsigned int))		/* routine to output 1 character */
  {
      long    frac,			/* 10^(#digits after decimal point) */
  	counter,			/* digits */
***************
*** 578,588 ****
   * Module: tutil.c
   *
   * Purpose: Utility routines for TERMLIB functions.
!  *
   */
      static int
! _match(s1, s2)		/* returns length of text common to s1 and s2 */
!     char *s1, *s2;
  {
      int i = 0;
  
--- 572,581 ----
   * Module: tutil.c
   *
   * Purpose: Utility routines for TERMLIB functions.
!  * Returns length of text common to s1 and s2.
   */
      static int
! _match(char *s1, char *s2)
  {
      int i = 0;
  
***************
*** 596,603 ****
   * finds next c in s that's a member of set, returns pointer
   */
      static char *
! _find(s, set)
!     char *s, *set;
  {
      for(; *s; s++)
      {
--- 589,595 ----
   * finds next c in s that's a member of set, returns pointer
   */
      static char *
! _find(char *s, char *set)
  {
      for(; *s; s++)
      {
***************
*** 617,625 ****
   * add val to buf according to format fmt
   */
      static char *
! _addfmt(buf, fmt, val)
!     char *buf, *fmt;
!     int val;
  {
      sprintf(buf, fmt, val);
      while (*buf)
--- 609,615 ----
   * add val to buf according to format fmt
   */
      static char *
! _addfmt(char *buf, char *fmt, int val)
  {
      sprintf(buf, fmt, val);
      while (*buf)
*** ../vim-7.4.1213/src/ui.c	2016-01-29 22:46:58.974534733 +0100
--- src/ui.c	2016-01-30 21:03:44.993319008 +0100
***************
*** 25,33 ****
  #endif
  
      void
! ui_write(s, len)
!     char_u  *s;
!     int	    len;
  {
  #ifdef FEAT_GUI
      if (gui.in_use && !gui.dying && !gui.starting)
--- 25,31 ----
  #endif
  
      void
! ui_write(char_u *s, int len)
  {
  #ifdef FEAT_GUI
      if (gui.in_use && !gui.dying && !gui.starting)
***************
*** 75,83 ****
  static int ta_len;	/* length of ta_str when it's not NULL*/
  
      void
! ui_inchar_undo(s, len)
!     char_u	*s;
!     int		len;
  {
      char_u  *new;
      int	    newlen;
--- 73,79 ----
  static int ta_len;	/* length of ta_str when it's not NULL*/
  
      void
! ui_inchar_undo(char_u *s, int len)
  {
      char_u  *new;
      int	    newlen;
***************
*** 117,127 ****
   * otherwise.
   */
      int
! ui_inchar(buf, maxlen, wtime, tb_change_cnt)
!     char_u	*buf;
!     int		maxlen;
!     long	wtime;	    /* don't use "time", MIPS cannot handle it */
!     int		tb_change_cnt;
  {
      int		retval = 0;
  
--- 113,123 ----
   * otherwise.
   */
      int
! ui_inchar(
!     char_u	*buf,
!     int		maxlen,
!     long	wtime,	    /* don't use "time", MIPS cannot handle it */
!     int		tb_change_cnt)
  {
      int		retval = 0;
  
***************
*** 220,226 ****
   * return non-zero if a character is available
   */
      int
! ui_char_avail()
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 216,222 ----
   * return non-zero if a character is available
   */
      int
! ui_char_avail(void)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 245,253 ****
   * cancel the delay if a key is hit.
   */
      void
! ui_delay(msec, ignoreinput)
!     long	msec;
!     int		ignoreinput;
  {
  #ifdef FEAT_GUI
      if (gui.in_use && !ignoreinput)
--- 241,247 ----
   * cancel the delay if a key is hit.
   */
      void
! ui_delay(long msec, int ignoreinput)
  {
  #ifdef FEAT_GUI
      if (gui.in_use && !ignoreinput)
***************
*** 263,269 ****
   * When running the GUI iconify the window.
   */
      void
! ui_suspend()
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 257,263 ----
   * When running the GUI iconify the window.
   */
      void
! ui_suspend(void)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 281,287 ****
   * This is never called in the GUI.
   */
      void
! suspend_shell()
  {
      if (*p_sh == NUL)
  	EMSG(_(e_shellempty));
--- 275,281 ----
   * This is never called in the GUI.
   */
      void
! suspend_shell(void)
  {
      if (*p_sh == NUL)
  	EMSG(_(e_shellempty));
***************
*** 299,305 ****
   * Return OK when size could be determined, FAIL otherwise.
   */
      int
! ui_get_shellsize()
  {
      int	    retval;
  
--- 293,299 ----
   * Return OK when size could be determined, FAIL otherwise.
   */
      int
! ui_get_shellsize(void)
  {
      int	    retval;
  
***************
*** 327,334 ****
   * new size.  If this is not possible, it will adjust Rows and Columns.
   */
      void
! ui_set_shellsize(mustset)
!     int		mustset UNUSED;	/* set by the user */
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 321,328 ----
   * new size.  If this is not possible, it will adjust Rows and Columns.
   */
      void
! ui_set_shellsize(
!     int		mustset UNUSED)	/* set by the user */
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 343,349 ****
   * region.
   */
      void
! ui_new_shellsize()
  {
      if (full_screen && !exiting)
      {
--- 337,343 ----
   * region.
   */
      void
! ui_new_shellsize(void)
  {
      if (full_screen && !exiting)
      {
***************
*** 357,363 ****
  }
  
      void
! ui_breakcheck()
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 351,357 ----
  }
  
      void
! ui_breakcheck(void)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 395,402 ****
   * the GUI starts.
   */
      void
! clip_init(can_use)
!     int	    can_use;
  {
      VimClipboard *cb;
  
--- 389,395 ----
   * the GUI starts.
   */
      void
! clip_init(int can_use)
  {
      VimClipboard *cb;
  
***************
*** 425,432 ****
   * this is called whenever VIsual mode is ended.
   */
      void
! clip_update_selection(clip)
!     VimClipboard    *clip;
  {
      pos_T	    start, end;
  
--- 418,424 ----
   * this is called whenever VIsual mode is ended.
   */
      void
! clip_update_selection(VimClipboard *clip)
  {
      pos_T	    start, end;
  
***************
*** 463,470 ****
  }
  
      void
! clip_own_selection(cbd)
!     VimClipboard	*cbd;
  {
      /*
       * Also want to check somehow that we are reading from the keyboard rather
--- 455,461 ----
  }
  
      void
! clip_own_selection(VimClipboard *cbd)
  {
      /*
       * Also want to check somehow that we are reading from the keyboard rather
***************
*** 500,507 ****
  }
  
      void
! clip_lose_selection(cbd)
!     VimClipboard	*cbd;
  {
  #ifdef FEAT_X11
      int	    was_owned = cbd->owned;
--- 491,497 ----
  }
  
      void
! clip_lose_selection(VimClipboard *cbd)
  {
  #ifdef FEAT_X11
      int	    was_owned = cbd->owned;
***************
*** 543,550 ****
  }
  
      static void
! clip_copy_selection(clip)
!     VimClipboard	*clip;
  {
      if (VIsual_active && (State & NORMAL) && clip->available)
      {
--- 533,539 ----
  }
  
      static void
! clip_copy_selection(VimClipboard *clip)
  {
      if (VIsual_active && (State & NORMAL) && clip->available)
      {
***************
*** 569,575 ****
   * Save clip_unnamed and reset it.
   */
      void
! start_global_changes()
  {
      if (++global_change_count > 1)
  	return;
--- 558,564 ----
   * Save clip_unnamed and reset it.
   */
      void
! start_global_changes(void)
  {
      if (++global_change_count > 1)
  	return;
***************
*** 587,593 ****
   * Restore clip_unnamed and set the selection when needed.
   */
      void
! end_global_changes()
  {
      if (--global_change_count > 0)
  	/* recursive */
--- 576,582 ----
   * Restore clip_unnamed and set the selection when needed.
   */
      void
! end_global_changes(void)
  {
      if (--global_change_count > 0)
  	/* recursive */
***************
*** 619,625 ****
   * Called when Visual mode is ended: update the selection.
   */
      void
! clip_auto_select()
  {
      if (clip_isautosel_star())
  	clip_copy_selection(&clip_star);
--- 608,614 ----
   * Called when Visual mode is ended: update the selection.
   */
      void
! clip_auto_select(void)
  {
      if (clip_isautosel_star())
  	clip_copy_selection(&clip_star);
***************
*** 632,638 ****
   * register.
   */
      int
! clip_isautosel_star()
  {
      return (
  #ifdef FEAT_GUI
--- 621,627 ----
   * register.
   */
      int
! clip_isautosel_star(void)
  {
      return (
  #ifdef FEAT_GUI
***************
*** 646,652 ****
   * register.
   */
      int
! clip_isautosel_plus()
  {
      return (
  #ifdef FEAT_GUI
--- 635,641 ----
   * register.
   */
      int
! clip_isautosel_plus(void)
  {
      return (
  #ifdef FEAT_GUI
***************
*** 678,687 ****
   * command-line and in the cmdline window.
   */
      void
! clip_modeless(button, is_click, is_drag)
!     int		button;
!     int		is_click;
!     int		is_drag;
  {
      int		repeat;
  
--- 667,673 ----
   * command-line and in the cmdline window.
   */
      void
! clip_modeless(int button, int is_click, int is_drag)
  {
      int		repeat;
  
***************
*** 715,725 ****
   * Compare two screen positions ala strcmp()
   */
      static int
! clip_compare_pos(row1, col1, row2, col2)
!     int		row1;
!     int		col1;
!     int		row2;
!     int		col2;
  {
      if (row1 > row2) return(1);
      if (row1 < row2) return(-1);
--- 701,711 ----
   * Compare two screen positions ala strcmp()
   */
      static int
! clip_compare_pos(
!     int		row1,
!     int		col1,
!     int		row2,
!     int		col2)
  {
      if (row1 > row2) return(1);
      if (row1 < row2) return(-1);
***************
*** 732,741 ****
   * Start the selection
   */
      void
! clip_start_selection(col, row, repeated_click)
!     int		col;
!     int		row;
!     int		repeated_click;
  {
      VimClipboard	*cb = &clip_star;
  
--- 718,724 ----
   * Start the selection
   */
      void
! clip_start_selection(int col, int row, int repeated_click)
  {
      VimClipboard	*cb = &clip_star;
  
***************
*** 805,815 ****
   * Continue processing the selection
   */
      void
! clip_process_selection(button, col, row, repeated_click)
!     int		button;
!     int		col;
!     int		row;
!     int_u	repeated_click;
  {
      VimClipboard	*cb = &clip_star;
      int			diff;
--- 788,798 ----
   * Continue processing the selection
   */
      void
! clip_process_selection(
!     int		button,
!     int		col,
!     int		row,
!     int_u	repeated_click)
  {
      VimClipboard	*cb = &clip_star;
      int			diff;
***************
*** 990,998 ****
   * Only used for the GUI.
   */
      void
! clip_may_redraw_selection(row, col, len)
!     int		row, col;
!     int		len;
  {
      int		start = col;
      int		end = col + len;
--- 973,979 ----
   * Only used for the GUI.
   */
      void
! clip_may_redraw_selection(int row, int col, int len)
  {
      int		start = col;
      int		end = col + len;
***************
*** 1015,1022 ****
   * Called from outside to clear selected region from the display
   */
      void
! clip_clear_selection(cbd)
!     VimClipboard    *cbd;
  {
  
      if (cbd->state == SELECT_CLEARED)
--- 996,1002 ----
   * Called from outside to clear selected region from the display
   */
      void
! clip_clear_selection(VimClipboard *cbd)
  {
  
      if (cbd->state == SELECT_CLEARED)
***************
*** 1031,1038 ****
   * Clear the selection if any lines from "row1" to "row2" are inside of it.
   */
      void
! clip_may_clear_selection(row1, row2)
!     int	row1, row2;
  {
      if (clip_star.state == SELECT_DONE
  	    && row2 >= clip_star.start.lnum
--- 1011,1017 ----
   * Clear the selection if any lines from "row1" to "row2" are inside of it.
   */
      void
! clip_may_clear_selection(int row1, int row2)
  {
      if (clip_star.state == SELECT_DONE
  	    && row2 >= clip_star.start.lnum
***************
*** 1045,1052 ****
   * of the selection.  Call with big number when clearing the screen.
   */
      void
! clip_scroll_selection(rows)
!     int	    rows;		/* negative for scroll down */
  {
      int	    lnum;
  
--- 1024,1031 ----
   * of the selection.  Call with big number when clearing the screen.
   */
      void
! clip_scroll_selection(
!     int	    rows)		/* negative for scroll down */
  {
      int	    lnum;
  
***************
*** 1079,1090 ****
   * 0: invert (GUI only).
   */
      static void
! clip_invert_area(row1, col1, row2, col2, how)
!     int		row1;
!     int		col1;
!     int		row2;
!     int		col2;
!     int		how;
  {
      int		invert = FALSE;
  
--- 1058,1069 ----
   * 0: invert (GUI only).
   */
      static void
! clip_invert_area(
!     int		row1,
!     int		col1,
!     int		row2,
!     int		col2,
!     int		how)
  {
      int		invert = FALSE;
  
***************
*** 1139,1150 ****
   * "invert" is true if the result is inverted.
   */
      static void
! clip_invert_rectangle(row, col, height, width, invert)
!     int		row;
!     int		col;
!     int		height;
!     int		width;
!     int		invert;
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
--- 1118,1129 ----
   * "invert" is true if the result is inverted.
   */
      static void
! clip_invert_rectangle(
!     int		row,
!     int		col,
!     int		height,
!     int		width,
!     int		invert)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 1160,1167 ****
   * When "both" is TRUE also copy to the '+' register.
   */
      void
! clip_copy_modeless_selection(both)
!     int		both UNUSED;
  {
      char_u	*buffer;
      char_u	*bufp;
--- 1139,1145 ----
   * When "both" is TRUE also copy to the '+' register.
   */
      void
! clip_copy_modeless_selection(int both UNUSED)
  {
      char_u	*buffer;
      char_u	*bufp;
***************
*** 1344,1353 ****
  #define CHAR_CLASS(c)	(c <= ' ' ? ' ' : vim_iswordc(c))
  
      static void
! clip_get_word_boundaries(cb, row, col)
!     VimClipboard	*cb;
!     int			row;
!     int			col;
  {
      int		start_class;
      int		temp_col;
--- 1322,1328 ----
  #define CHAR_CLASS(c)	(c <= ' ' ? ' ' : vim_iswordc(c))
  
      static void
! clip_get_word_boundaries(VimClipboard *cb, int row, int col)
  {
      int		start_class;
      int		temp_col;
***************
*** 1406,1413 ****
   * line.
   */
      static int
! clip_get_line_end(row)
!     int		row;
  {
      int	    i;
  
--- 1381,1387 ----
   * line.
   */
      static int
! clip_get_line_end(int row)
  {
      int	    i;
  
***************
*** 1424,1435 ****
   * beginning or end and inverting the changed area(s).
   */
      static void
! clip_update_modeless_selection(cb, row1, col1, row2, col2)
!     VimClipboard    *cb;
!     int		    row1;
!     int		    col1;
!     int		    row2;
!     int		    col2;
  {
      /* See if we changed at the beginning of the selection */
      if (row1 != cb->start.lnum || col1 != (int)cb->start.col)
--- 1398,1409 ----
   * beginning or end and inverting the changed area(s).
   */
      static void
! clip_update_modeless_selection(
!     VimClipboard    *cb,
!     int		    row1,
!     int		    col1,
!     int		    row2,
!     int		    col2)
  {
      /* See if we changed at the beginning of the selection */
      if (row1 != cb->start.lnum || col1 != (int)cb->start.col)
***************
*** 1451,1458 ****
  }
  
      int
! clip_gen_own_selection(cbd)
!     VimClipboard	*cbd;
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI
--- 1425,1431 ----
  }
  
      int
! clip_gen_own_selection(VimClipboard *cbd)
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI
***************
*** 1467,1474 ****
  }
  
      void
! clip_gen_lose_selection(cbd)
!     VimClipboard	*cbd;
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI
--- 1440,1446 ----
  }
  
      void
! clip_gen_lose_selection(VimClipboard *cbd)
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI
***************
*** 1483,1490 ****
  }
  
      void
! clip_gen_set_selection(cbd)
!     VimClipboard	*cbd;
  {
      if (!clip_did_set_selection)
      {
--- 1455,1461 ----
  }
  
      void
! clip_gen_set_selection(VimClipboard *cbd)
  {
      if (!clip_did_set_selection)
      {
***************
*** 1510,1517 ****
  }
  
      void
! clip_gen_request_selection(cbd)
!     VimClipboard	*cbd;
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI
--- 1481,1487 ----
  }
  
      void
! clip_gen_request_selection(VimClipboard *cbd)
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI
***************
*** 1526,1533 ****
  }
  
      int
! clip_gen_owner_exists(cbd)
!     VimClipboard	*cbd UNUSED;
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI_GTK
--- 1496,1502 ----
  }
  
      int
! clip_gen_owner_exists(VimClipboard *cbd UNUSED)
  {
  #ifdef FEAT_XCLIPBOARD
  # ifdef FEAT_GUI_GTK
***************
*** 1584,1603 ****
   */
  
      int
! vim_is_input_buf_full()
  {
      return (inbufcount >= INBUFLEN);
  }
  
      int
! vim_is_input_buf_empty()
  {
      return (inbufcount == 0);
  }
  
  #if defined(FEAT_OLE) || defined(PROTO)
      int
! vim_free_in_input_buf()
  {
      return (INBUFLEN - inbufcount);
  }
--- 1553,1572 ----
   */
  
      int
! vim_is_input_buf_full(void)
  {
      return (inbufcount >= INBUFLEN);
  }
  
      int
! vim_is_input_buf_empty(void)
  {
      return (inbufcount == 0);
  }
  
  #if defined(FEAT_OLE) || defined(PROTO)
      int
! vim_free_in_input_buf(void)
  {
      return (INBUFLEN - inbufcount);
  }
***************
*** 1605,1611 ****
  
  #if defined(FEAT_GUI_GTK) || defined(PROTO)
      int
! vim_used_in_input_buf()
  {
      return inbufcount;
  }
--- 1574,1580 ----
  
  #if defined(FEAT_GUI_GTK) || defined(PROTO)
      int
! vim_used_in_input_buf(void)
  {
      return inbufcount;
  }
***************
*** 1617,1623 ****
   * The returned pointer must be passed to set_input_buf() later.
   */
      char_u *
! get_input_buf()
  {
      garray_T	*gap;
  
--- 1586,1592 ----
   * The returned pointer must be passed to set_input_buf() later.
   */
      char_u *
! get_input_buf(void)
  {
      garray_T	*gap;
  
***************
*** 1640,1647 ****
   * The allocated memory is freed, this only works once!
   */
      void
! set_input_buf(p)
!     char_u	*p;
  {
      garray_T	*gap = (garray_T *)p;
  
--- 1609,1615 ----
   * The allocated memory is freed, this only works once!
   */
      void
! set_input_buf(char_u *p)
  {
      garray_T	*gap = (garray_T *)p;
  
***************
*** 1669,1677 ****
   * CSI KS_EXTRA KE_CSI.  K_SPECIAL doesn't require translation.
   */
      void
! add_to_input_buf(s, len)
!     char_u  *s;
!     int	    len;
  {
      if (inbufcount + len > INBUFLEN + MAX_KEY_CODE_LEN)
  	return;	    /* Shouldn't ever happen! */
--- 1637,1643 ----
   * CSI KS_EXTRA KE_CSI.  K_SPECIAL doesn't require translation.
   */
      void
! add_to_input_buf(char_u *s, int len)
  {
      if (inbufcount + len > INBUFLEN + MAX_KEY_CODE_LEN)
  	return;	    /* Shouldn't ever happen! */
***************
*** 1719,1727 ****
  
  #if defined(FEAT_HANGULIN) || defined(PROTO)
      void
! push_raw_key(s, len)
!     char_u  *s;
!     int	    len;
  {
      char_u *tmpbuf;
  
--- 1685,1691 ----
  
  #if defined(FEAT_HANGULIN) || defined(PROTO)
      void
! push_raw_key(char_u *s, int len)
  {
      char_u *tmpbuf;
  
***************
*** 1741,1747 ****
  	|| defined(PROTO)
  /* Remove everything from the input buffer.  Called when ^C is found */
      void
! trash_input_buf()
  {
      inbufcount = 0;
  }
--- 1705,1711 ----
  	|| defined(PROTO)
  /* Remove everything from the input buffer.  Called when ^C is found */
      void
! trash_input_buf(void)
  {
      inbufcount = 0;
  }
***************
*** 1753,1761 ****
   * Note: this function used to be Read() in unix.c
   */
      int
! read_from_input_buf(buf, maxlen)
!     char_u  *buf;
!     long    maxlen;
  {
      if (inbufcount == 0)	/* if the buffer is empty, fill it */
  	fill_input_buf(TRUE);
--- 1717,1723 ----
   * Note: this function used to be Read() in unix.c
   */
      int
! read_from_input_buf(char_u *buf, long maxlen)
  {
      if (inbufcount == 0)	/* if the buffer is empty, fill it */
  	fill_input_buf(TRUE);
***************
*** 1769,1776 ****
  }
  
      void
! fill_input_buf(exit_on_error)
!     int	exit_on_error UNUSED;
  {
  #if defined(UNIX) || defined(VMS) || defined(MACOS_X_UNIX)
      int		len;
--- 1731,1737 ----
  }
  
      void
! fill_input_buf(int exit_on_error UNUSED)
  {
  #if defined(UNIX) || defined(VMS) || defined(MACOS_X_UNIX)
      int		len;
***************
*** 1948,1954 ****
   * Exit because of an input read error.
   */
      void
! read_error_exit()
  {
      if (silent_mode)	/* Normal way to exit for "ex -s" */
  	getout(0);
--- 1909,1915 ----
   * Exit because of an input read error.
   */
      void
! read_error_exit(void)
  {
      if (silent_mode)	/* Normal way to exit for "ex -s" */
  	getout(0);
***************
*** 1961,1967 ****
   * May update the shape of the cursor.
   */
      void
! ui_cursor_shape()
  {
  # ifdef FEAT_GUI
      if (gui.in_use)
--- 1922,1928 ----
   * May update the shape of the cursor.
   */
      void
! ui_cursor_shape(void)
  {
  # ifdef FEAT_GUI
      if (gui.in_use)
***************
*** 1986,1993 ****
   * Check bounds for column number
   */
      int
! check_col(col)
!     int	    col;
  {
      if (col < 0)
  	return 0;
--- 1947,1953 ----
   * Check bounds for column number
   */
      int
! check_col(int col)
  {
      if (col < 0)
  	return 0;
***************
*** 2000,2007 ****
   * Check bounds for row number
   */
      int
! check_row(row)
!     int	    row;
  {
      if (row < 0)
  	return 0;
--- 1960,1966 ----
   * Check bounds for row number
   */
      int
! check_row(int row)
  {
      if (row < 0)
  	return 0;
***************
*** 2024,2030 ****
   * Used for Motif and Athena GUI and the xterm clipboard.
   */
      void
! open_app_context()
  {
      if (app_context == NULL)
      {
--- 1983,1989 ----
   * Used for Motif and Athena GUI and the xterm clipboard.
   */
      void
! open_app_context(void)
  {
      if (app_context == NULL)
      {
***************
*** 2044,2051 ****
  static Atom	timestamp_atom;	/* Used to get a timestamp */
  
      void
! x11_setup_atoms(dpy)
!     Display	*dpy;
  {
      vim_atom	       = XInternAtom(dpy, VIM_ATOM_NAME,   False);
  #ifdef FEAT_MBYTE
--- 2003,2009 ----
  static Atom	timestamp_atom;	/* Used to get a timestamp */
  
      void
! x11_setup_atoms(Display *dpy)
  {
      vim_atom	       = XInternAtom(dpy, VIM_ATOM_NAME,   False);
  #ifdef FEAT_MBYTE
***************
*** 2073,2083 ****
   * Property callback to get a timestamp for XtOwnSelection.
   */
      static void
! clip_x11_timestamp_cb(w, n, event, cont)
!     Widget	w;
!     XtPointer	n UNUSED;
!     XEvent	*event;
!     Boolean	*cont UNUSED;
  {
      Atom	    actual_type;
      int		    format;
--- 2031,2041 ----
   * Property callback to get a timestamp for XtOwnSelection.
   */
      static void
! clip_x11_timestamp_cb(
!     Widget	w,
!     XtPointer	n UNUSED,
!     XEvent	*event,
!     Boolean	*cont UNUSED)
  {
      Atom	    actual_type;
      int		    format;
***************
*** 2119,2141 ****
  }
  
      void
! x11_setup_selection(w)
!     Widget	w;
  {
      XtAddEventHandler(w, PropertyChangeMask, False,
  	    /*(XtEventHandler)*/clip_x11_timestamp_cb, (XtPointer)NULL);
  }
  
      static void
! clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
! 			      format)
!     Widget	w UNUSED;
!     XtPointer	success;
!     Atom	*sel_atom;
!     Atom	*type;
!     XtPointer	value;
!     long_u	*length;
!     int		*format;
  {
      int		motion_type = MAUTO;
      long_u	len;
--- 2077,2097 ----
  }
  
      void
! x11_setup_selection(Widget w)
  {
      XtAddEventHandler(w, PropertyChangeMask, False,
  	    /*(XtEventHandler)*/clip_x11_timestamp_cb, (XtPointer)NULL);
  }
  
      static void
! clip_x11_request_selection_cb(
!     Widget	w UNUSED,
!     XtPointer	success,
!     Atom	*sel_atom,
!     Atom	*type,
!     XtPointer	value,
!     long_u	*length,
!     int		*format)
  {
      int		motion_type = MAUTO;
      long_u	len;
***************
*** 2241,2250 ****
  }
  
      void
! clip_x11_request_selection(myShell, dpy, cbd)
!     Widget	myShell;
!     Display	*dpy;
!     VimClipboard	*cbd;
  {
      XEvent	event;
      Atom	type;
--- 2197,2206 ----
  }
  
      void
! clip_x11_request_selection(
!     Widget	myShell,
!     Display	*dpy,
!     VimClipboard	*cbd)
  {
      XEvent	event;
      Atom	type;
***************
*** 2346,2359 ****
  }
  
      static Boolean
! clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)
!     Widget	w UNUSED;
!     Atom	*sel_atom;
!     Atom	*target;
!     Atom	*type;
!     XtPointer	*value;
!     long_u	*length;
!     int		*format;
  {
      char_u	*string;
      char_u	*result;
--- 2302,2315 ----
  }
  
      static Boolean
! clip_x11_convert_selection_cb(
!     Widget	w UNUSED,
!     Atom	*sel_atom,
!     Atom	*target,
!     Atom	*type,
!     XtPointer	*value,
!     long_u	*length,
!     int		*format)
  {
      char_u	*string;
      char_u	*result;
***************
*** 2488,2496 ****
  }
  
      static void
! clip_x11_lose_ownership_cb(w, sel_atom)
!     Widget  w UNUSED;
!     Atom    *sel_atom;
  {
      if (*sel_atom == clip_plus.sel_atom)
  	clip_lose_selection(&clip_plus);
--- 2444,2450 ----
  }
  
      static void
! clip_x11_lose_ownership_cb(Widget w UNUSED, Atom *sel_atom)
  {
      if (*sel_atom == clip_plus.sel_atom)
  	clip_lose_selection(&clip_plus);
***************
*** 2499,2516 ****
  }
  
      void
! clip_x11_lose_selection(myShell, cbd)
!     Widget		myShell;
!     VimClipboard	*cbd;
  {
      XtDisownSelection(myShell, cbd->sel_atom,
  				XtLastTimestampProcessed(XtDisplay(myShell)));
  }
  
      int
! clip_x11_own_selection(myShell, cbd)
!     Widget		myShell;
!     VimClipboard	*cbd;
  {
      /* When using the GUI we have proper timestamps, use the one of the last
       * event.  When in the console we don't get events (the terminal gets
--- 2453,2466 ----
  }
  
      void
! clip_x11_lose_selection(Widget myShell, VimClipboard *cbd)
  {
      XtDisownSelection(myShell, cbd->sel_atom,
  				XtLastTimestampProcessed(XtDisplay(myShell)));
  }
  
      int
! clip_x11_own_selection(Widget myShell, VimClipboard *cbd)
  {
      /* When using the GUI we have proper timestamps, use the one of the last
       * event.  When in the console we don't get events (the terminal gets
***************
*** 2542,2555 ****
   * will fill in the selection only when requested by another app.
   */
      void
! clip_x11_set_selection(cbd)
!     VimClipboard *cbd UNUSED;
  {
  }
  
      int
! clip_x11_owner_exists(cbd)
!     VimClipboard	*cbd;
  {
      return XGetSelectionOwner(X_DISPLAY, cbd->sel_atom) != None;
  }
--- 2492,2503 ----
   * will fill in the selection only when requested by another app.
   */
      void
! clip_x11_set_selection(VimClipboard *cbd UNUSED)
  {
  }
  
      int
! clip_x11_owner_exists(VimClipboard *cbd)
  {
      return XGetSelectionOwner(X_DISPLAY, cbd->sel_atom) != None;
  }
***************
*** 2561,2569 ****
   * Get the contents of the X CUT_BUFFER0 and put it in "cbd".
   */
      void
! yank_cut_buffer0(dpy, cbd)
!     Display		*dpy;
!     VimClipboard	*cbd;
  {
      int		nbytes = 0;
      char_u	*buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
--- 2509,2515 ----
   * Get the contents of the X CUT_BUFFER0 and put it in "cbd".
   */
      void
! yank_cut_buffer0(Display *dpy, VimClipboard *cbd)
  {
      int		nbytes = 0;
      char_u	*buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
***************
*** 2638,2647 ****
   * remembered.
   */
      int
! jump_to_mouse(flags, inclusive, which_button)
!     int		flags;
!     int		*inclusive;	/* used for inclusive operator, can be NULL */
!     int		which_button;	/* MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE */
  {
      static int	on_status_line = 0;	/* #lines below bottom of window */
  #ifdef FEAT_VERTSPLIT
--- 2584,2593 ----
   * remembered.
   */
      int
! jump_to_mouse(
!     int		flags,
!     int		*inclusive,	/* used for inclusive operator, can be NULL */
!     int		which_button)	/* MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE */
  {
      static int	on_status_line = 0;	/* #lines below bottom of window */
  #ifdef FEAT_VERTSPLIT
***************
*** 3051,3061 ****
   * Returns TRUE if the position is below the last line.
   */
      int
! mouse_comp_pos(win, rowp, colp, lnump)
!     win_T	*win;
!     int		*rowp;
!     int		*colp;
!     linenr_T	*lnump;
  {
      int		col = *colp;
      int		row = *rowp;
--- 2997,3007 ----
   * Returns TRUE if the position is below the last line.
   */
      int
! mouse_comp_pos(
!     win_T	*win,
!     int		*rowp,
!     int		*colp,
!     linenr_T	*lnump)
  {
      int		col = *colp;
      int		row = *rowp;
***************
*** 3140,3148 ****
   * updated to become relative to the top-left of the window.
   */
      win_T *
! mouse_find_win(rowp, colp)
!     int		*rowp;
!     int		*colp UNUSED;
  {
      frame_T	*fp;
  
--- 3086,3092 ----
   * updated to become relative to the top-left of the window.
   */
      win_T *
! mouse_find_win(int *rowp, int *colp UNUSED)
  {
      frame_T	*fp;
  
***************
*** 3184,3191 ****
   * Translate window coordinates to buffer position without any side effects
   */
      int
! get_fpos_of_mouse(mpos)
!     pos_T	*mpos;
  {
      win_T	*wp;
      int		row = mouse_row;
--- 3128,3134 ----
   * Translate window coordinates to buffer position without any side effects
   */
      int
! get_fpos_of_mouse(pos_T *mpos)
  {
      win_T	*wp;
      int		row = mouse_row;
***************
*** 3232,3241 ****
   * The first column is one.
   */
      int
! vcol2col(wp, lnum, vcol)
!     win_T	*wp;
!     linenr_T	lnum;
!     int		vcol;
  {
      /* try to advance to the specified column */
      int		count = 0;
--- 3175,3181 ----
   * The first column is one.
   */
      int
! vcol2col(win_T *wp, linenr_T lnum, int vcol)
  {
      /* try to advance to the specified column */
      int		count = 0;
***************
*** 3260,3267 ****
   * be done in the console (Win32).
   */
      void
! ui_focus_change(in_focus)
!     int		in_focus;	/* TRUE if focus gained. */
  {
      static time_t	last_time = (time_t)0;
      int			need_redraw = FALSE;
--- 3200,3207 ----
   * be done in the console (Win32).
   */
      void
! ui_focus_change(
!     int		in_focus)	/* TRUE if focus gained. */
  {
      static time_t	last_time = (time_t)0;
      int			need_redraw = FALSE;
***************
*** 3329,3336 ****
   * Save current Input Method status to specified place.
   */
      void
! im_save_status(psave)
!     long *psave;
  {
      /* Don't save when 'imdisable' is set or "xic" is NULL, IM is always
       * disabled then (but might start later).
--- 3269,3275 ----
   * Save current Input Method status to specified place.
   */
      void
! im_save_status(long *psave)
  {
      /* Don't save when 'imdisable' is set or "xic" is NULL, IM is always
       * disabled then (but might start later).
*** ../vim-7.4.1213/src/undo.c	2016-01-29 22:46:58.974534733 +0100
--- src/undo.c	2016-01-30 21:06:52.567356024 +0100
***************
*** 246,252 ****
   * Returns OK or FAIL.
   */
      int
! u_save_cursor()
  {
      return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),
  				      (linenr_T)(curwin->w_cursor.lnum + 1)));
--- 246,252 ----
   * Returns OK or FAIL.
   */
      int
! u_save_cursor(void)
  {
      return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),
  				      (linenr_T)(curwin->w_cursor.lnum + 1)));
***************
*** 259,266 ****
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_save(top, bot)
!     linenr_T top, bot;
  {
      if (undo_off)
  	return OK;
--- 259,265 ----
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_save(linenr_T top, linenr_T bot)
  {
      if (undo_off)
  	return OK;
***************
*** 283,290 ****
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_savesub(lnum)
!     linenr_T	lnum;
  {
      if (undo_off)
  	return OK;
--- 282,288 ----
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_savesub(linenr_T lnum)
  {
      if (undo_off)
  	return OK;
***************
*** 299,306 ****
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_inssub(lnum)
!     linenr_T	lnum;
  {
      if (undo_off)
  	return OK;
--- 297,303 ----
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_inssub(linenr_T lnum)
  {
      if (undo_off)
  	return OK;
***************
*** 316,324 ****
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_savedel(lnum, nlines)
!     linenr_T	lnum;
!     long	nlines;
  {
      if (undo_off)
  	return OK;
--- 313,319 ----
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_savedel(linenr_T lnum, long nlines)
  {
      if (undo_off)
  	return OK;
***************
*** 332,338 ****
   * return FALSE.
   */
      int
! undo_allowed()
  {
      /* Don't allow changes when 'modifiable' is off.  */
      if (!curbuf->b_p_ma)
--- 327,333 ----
   * return FALSE.
   */
      int
! undo_allowed(void)
  {
      /* Don't allow changes when 'modifiable' is off.  */
      if (!curbuf->b_p_ma)
***************
*** 365,371 ****
   * Get the undolevle value for the current buffer.
   */
      static long
! get_undolevel()
  {
      if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)
  	return p_ul;
--- 360,366 ----
   * Get the undolevle value for the current buffer.
   */
      static long
! get_undolevel(void)
  {
      if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)
  	return p_ul;
***************
*** 382,391 ****
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_savecommon(top, bot, newbot, reload)
!     linenr_T	top, bot;
!     linenr_T	newbot;
!     int		reload;
  {
      linenr_T	lnum;
      long	i;
--- 377,387 ----
   * Returns FAIL when lines could not be saved, OK otherwise.
   */
      int
! u_savecommon(
!     linenr_T	top,
!     linenr_T	bot,
!     linenr_T	newbot,
!     int		reload)
  {
      linenr_T	lnum;
      long	i;
***************
*** 749,756 ****
   * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE].
   */
      void
! u_compute_hash(hash)
!     char_u *hash;
  {
      context_sha256_T	ctx;
      linenr_T		lnum;
--- 745,751 ----
   * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE].
   */
      void
! u_compute_hash(char_u *hash)
  {
      context_sha256_T	ctx;
      linenr_T		lnum;
***************
*** 773,781 ****
   * Returns NULL when there is no place to write or no file to read.
   */
      char_u *
! u_get_undo_file_name(buf_ffname, reading)
!     char_u	*buf_ffname;
!     int		reading;
  {
      char_u	*dirp;
      char_u	dir_name[IOSIZE + 1];
--- 768,774 ----
   * Returns NULL when there is no place to write or no file to read.
   */
      char_u *
! u_get_undo_file_name(char_u *buf_ffname, int reading)
  {
      char_u	*dirp;
      char_u	dir_name[IOSIZE + 1];
***************
*** 859,874 ****
  }
  
      static void
! corruption_error(mesg, file_name)
!     char *mesg;
!     char_u *file_name;
  {
      EMSG3(_("E825: Corrupted undo file (%s): %s"), mesg, file_name);
  }
  
      static void
! u_free_uhp(uhp)
!     u_header_T	*uhp;
  {
      u_entry_T	*nuep;
      u_entry_T	*uep;
--- 852,864 ----
  }
  
      static void
! corruption_error(char *mesg, char_u *file_name)
  {
      EMSG3(_("E825: Corrupted undo file (%s): %s"), mesg, file_name);
  }
  
      static void
! u_free_uhp(u_header_T *uhp)
  {
      u_entry_T	*nuep;
      u_entry_T	*uep;
***************
*** 889,898 ****
   * Returns OK or FAIL.
   */
      static int
! undo_write(bi, ptr, len)
!     bufinfo_T	*bi;
!     char_u	*ptr;
!     size_t	len;
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
--- 879,885 ----
   * Returns OK or FAIL.
   */
      static int
! undo_write(bufinfo_T *bi, char_u *ptr, size_t len)
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
***************
*** 926,933 ****
  
  #ifdef FEAT_CRYPT
      static int
! undo_flush(bi)
!     bufinfo_T	*bi;
  {
      if (bi->bi_buffer != NULL && bi->bi_used > 0)
      {
--- 913,919 ----
  
  #ifdef FEAT_CRYPT
      static int
! undo_flush(bufinfo_T *bi)
  {
      if (bi->bi_buffer != NULL && bi->bi_used > 0)
      {
***************
*** 945,954 ****
   * Returns OK or FAIL.
   */
      static int
! fwrite_crypt(bi, ptr, len)
!     bufinfo_T	*bi;
!     char_u	*ptr;
!     size_t	len;
  {
  #ifdef FEAT_CRYPT
      char_u  *copy;
--- 931,937 ----
   * Returns OK or FAIL.
   */
      static int
! fwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len)
  {
  #ifdef FEAT_CRYPT
      char_u  *copy;
***************
*** 982,991 ****
   * Returns OK or FAIL.
   */
      static int
! undo_write_bytes(bi, nr, len)
!     bufinfo_T *bi;
!     long_u  nr;
!     int	    len;
  {
      char_u  buf[8];
      int	    i;
--- 965,971 ----
   * Returns OK or FAIL.
   */
      static int
! undo_write_bytes(bufinfo_T *bi, long_u nr, int len)
  {
      char_u  buf[8];
      int	    i;
***************
*** 1001,1016 ****
   * we use the sequence number of the header.  This is converted back to
   * pointers when reading. */
      static void
! put_header_ptr(bi, uhp)
!     bufinfo_T	*bi;
!     u_header_T	*uhp;
  {
      undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);
  }
  
      static int
! undo_read_4c(bi)
!     bufinfo_T	*bi;
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
--- 981,993 ----
   * we use the sequence number of the header.  This is converted back to
   * pointers when reading. */
      static void
! put_header_ptr(bufinfo_T *bi, u_header_T *uhp)
  {
      undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);
  }
  
      static int
! undo_read_4c(bufinfo_T *bi)
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
***************
*** 1027,1034 ****
  }
  
      static int
! undo_read_2c(bi)
!     bufinfo_T	*bi;
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
--- 1004,1010 ----
  }
  
      static int
! undo_read_2c(bufinfo_T *bi)
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
***************
*** 1045,1052 ****
  }
  
      static int
! undo_read_byte(bi)
!     bufinfo_T	*bi;
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
--- 1021,1027 ----
  }
  
      static int
! undo_read_byte(bufinfo_T *bi)
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
***************
*** 1061,1068 ****
  }
  
      static time_t
! undo_read_time(bi)
!     bufinfo_T	*bi;
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
--- 1036,1042 ----
  }
  
      static time_t
! undo_read_time(bufinfo_T *bi)
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
***************
*** 1085,1094 ****
   * Return OK or FAIL.
   */
      static int
! undo_read(bi, buffer, size)
!     bufinfo_T   *bi;
!     char_u	*buffer;
!     size_t	size;
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
--- 1059,1065 ----
   * Return OK or FAIL.
   */
      static int
! undo_read(bufinfo_T *bi, char_u *buffer, size_t size)
  {
  #ifdef FEAT_CRYPT
      if (bi->bi_buffer != NULL)
***************
*** 1138,1146 ****
   * Returns a pointer to allocated memory or NULL for failure.
   */
      static char_u *
! read_string_decrypt(bi, len)
!     bufinfo_T	*bi;
!     int		len;
  {
      char_u  *ptr = alloc((unsigned)len + 1);
  
--- 1109,1115 ----
   * Returns a pointer to allocated memory or NULL for failure.
   */
      static char_u *
! read_string_decrypt(bufinfo_T *bi, int len)
  {
      char_u  *ptr = alloc((unsigned)len + 1);
  
***************
*** 1164,1172 ****
   * Writes the (not encrypted) header and initializes encryption if needed.
   */
      static int
! serialize_header(bi, hash)
!     bufinfo_T	*bi;
!     char_u	*hash;
  {
      int		len;
      buf_T	*buf = bi->bi_buf;
--- 1133,1139 ----
   * Writes the (not encrypted) header and initializes encryption if needed.
   */
      static int
! serialize_header(bufinfo_T *bi, char_u *hash)
  {
      int		len;
      buf_T	*buf = bi->bi_buf;
***************
*** 1252,1260 ****
  }
  
      static int
! serialize_uhp(bi, uhp)
!     bufinfo_T	*bi;
!     u_header_T	*uhp;
  {
      int		i;
      u_entry_T	*uep;
--- 1219,1225 ----
  }
  
      static int
! serialize_uhp(bufinfo_T *bi, u_header_T *uhp)
  {
      int		i;
      u_entry_T	*uep;
***************
*** 1301,1309 ****
  }
  
      static u_header_T *
! unserialize_uhp(bi, file_name)
!     bufinfo_T	*bi;
!     char_u	*file_name;
  {
      u_header_T	*uhp;
      int		i;
--- 1266,1272 ----
  }
  
      static u_header_T *
! unserialize_uhp(bufinfo_T *bi, char_u *file_name)
  {
      u_header_T	*uhp;
      int		i;
***************
*** 1393,1401 ****
   * Serialize "uep".
   */
      static int
! serialize_uep(bi, uep)
!     bufinfo_T	*bi;
!     u_entry_T	*uep;
  {
      int		i;
      size_t	len;
--- 1356,1364 ----
   * Serialize "uep".
   */
      static int
! serialize_uep(
!     bufinfo_T	*bi,
!     u_entry_T	*uep)
  {
      int		i;
      size_t	len;
***************
*** 1416,1425 ****
  }
  
      static u_entry_T *
! unserialize_uep(bi, error, file_name)
!     bufinfo_T	*bi;
!     int		*error;
!     char_u	*file_name;
  {
      int		i;
      u_entry_T	*uep;
--- 1379,1385 ----
  }
  
      static u_entry_T *
! unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)
  {
      int		i;
      u_entry_T	*uep;
***************
*** 1476,1484 ****
   * Serialize "pos".
   */
      static void
! serialize_pos(bi, pos)
!     bufinfo_T *bi;
!     pos_T pos;
  {
      undo_write_bytes(bi, (long_u)pos.lnum, 4);
      undo_write_bytes(bi, (long_u)pos.col, 4);
--- 1436,1442 ----
   * Serialize "pos".
   */
      static void
! serialize_pos(bufinfo_T *bi, pos_T pos)
  {
      undo_write_bytes(bi, (long_u)pos.lnum, 4);
      undo_write_bytes(bi, (long_u)pos.col, 4);
***************
*** 1493,1501 ****
   * Unserialize the pos_T at the current position.
   */
      static void
! unserialize_pos(bi, pos)
!     bufinfo_T *bi;
!     pos_T *pos;
  {
      pos->lnum = undo_read_4c(bi);
      if (pos->lnum < 0)
--- 1451,1457 ----
   * Unserialize the pos_T at the current position.
   */
      static void
! unserialize_pos(bufinfo_T *bi, pos_T *pos)
  {
      pos->lnum = undo_read_4c(bi);
      if (pos->lnum < 0)
***************
*** 1516,1524 ****
   * Serialize "info".
   */
      static void
! serialize_visualinfo(bi, info)
!     bufinfo_T	    *bi;
!     visualinfo_T    *info;
  {
      serialize_pos(bi, info->vi_start);
      serialize_pos(bi, info->vi_end);
--- 1472,1478 ----
   * Serialize "info".
   */
      static void
! serialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)
  {
      serialize_pos(bi, info->vi_start);
      serialize_pos(bi, info->vi_end);
***************
*** 1530,1538 ****
   * Unserialize the visualinfo_T at the current position.
   */
      static void
! unserialize_visualinfo(bi, info)
!     bufinfo_T	    *bi;
!     visualinfo_T    *info;
  {
      unserialize_pos(bi, &info->vi_start);
      unserialize_pos(bi, &info->vi_end);
--- 1484,1490 ----
   * Unserialize the visualinfo_T at the current position.
   */
      static void
! unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)
  {
      unserialize_pos(bi, &info->vi_start);
      unserialize_pos(bi, &info->vi_end);
***************
*** 1550,1560 ****
   * "hash[UNDO_HASH_SIZE]" must be the hash value of the buffer text.
   */
      void
! u_write_undo(name, forceit, buf, hash)
!     char_u	*name;
!     int		forceit;
!     buf_T	*buf;
!     char_u	*hash;
  {
      u_header_T	*uhp;
      char_u	*file_name;
--- 1502,1512 ----
   * "hash[UNDO_HASH_SIZE]" must be the hash value of the buffer text.
   */
      void
! u_write_undo(
!     char_u	*name,
!     int		forceit,
!     buf_T	*buf,
!     char_u	*hash)
  {
      u_header_T	*uhp;
      char_u	*file_name;
***************
*** 1824,1833 ****
   * "hash[UNDO_HASH_SIZE]" must be the hash value of the buffer text.
   */
      void
! u_read_undo(name, hash, orig_name)
!     char_u *name;
!     char_u *hash;
!     char_u *orig_name;
  {
      char_u	*file_name;
      FILE	*fp;
--- 1776,1782 ----
   * "hash[UNDO_HASH_SIZE]" must be the hash value of the buffer text.
   */
      void
! u_read_undo(char_u *name, char_u *hash, char_u *orig_name)
  {
      char_u	*file_name;
      FILE	*fp;
***************
*** 2188,2195 ****
   * If 'cpoptions' does not contain 'u': Always undo.
   */
      void
! u_undo(count)
!     int count;
  {
      /*
       * If we get an undo command while executing a macro, we behave like the
--- 2137,2143 ----
   * If 'cpoptions' does not contain 'u': Always undo.
   */
      void
! u_undo(int count)
  {
      /*
       * If we get an undo command while executing a macro, we behave like the
***************
*** 2214,2221 ****
   * If 'cpoptions' does not contain 'u': Always redo.
   */
      void
! u_redo(count)
!     int count;
  {
      if (vim_strchr(p_cpo, CPO_UNDO) == NULL)
  	undo_undoes = FALSE;
--- 2162,2168 ----
   * If 'cpoptions' does not contain 'u': Always redo.
   */
      void
! u_redo(int count)
  {
      if (vim_strchr(p_cpo, CPO_UNDO) == NULL)
  	undo_undoes = FALSE;
***************
*** 2226,2233 ****
   * Undo or redo, depending on 'undo_undoes', 'count' times.
   */
      static void
! u_doit(startcount)
!     int startcount;
  {
      int count = startcount;
  
--- 2173,2179 ----
   * Undo or redo, depending on 'undo_undoes', 'count' times.
   */
      static void
! u_doit(int startcount)
  {
      int count = startcount;
  
***************
*** 2304,2314 ****
   * "sec" must be FALSE then.
   */
      void
! undo_time(step, sec, file, absolute)
!     long	step;
!     int		sec;
!     int		file;
!     int		absolute;
  {
      long	    target;
      long	    closest;
--- 2250,2260 ----
   * "sec" must be FALSE then.
   */
      void
! undo_time(
!     long	step,
!     int		sec,
!     int		file,
!     int		absolute)
  {
      long	    target;
      long	    closest;
***************
*** 2645,2652 ****
   * When "undo" is TRUE we go up in the tree, when FALSE we go down.
   */
      static void
! u_undoredo(undo)
!     int		undo;
  {
      char_u	**newarray = NULL;
      linenr_T	oldsize;
--- 2591,2597 ----
   * When "undo" is TRUE we go up in the tree, when FALSE we go down.
   */
      static void
! u_undoredo(int undo)
  {
      char_u	**newarray = NULL;
      linenr_T	oldsize;
***************
*** 2933,2941 ****
   * in some cases, but it's better than nothing).
   */
      static void
! u_undo_end(did_undo, absolute)
!     int		did_undo;	/* just did an undo */
!     int		absolute;	/* used ":undo N" */
  {
      char	*msgstr;
      u_header_T	*uhp;
--- 2878,2886 ----
   * in some cases, but it's better than nothing).
   */
      static void
! u_undo_end(
!     int		did_undo,	/* just did an undo */
!     int		absolute)	/* used ":undo N" */
  {
      char	*msgstr;
      u_header_T	*uhp;
***************
*** 3016,3023 ****
   * u_sync: stop adding to the current entry list
   */
      void
! u_sync(force)
!     int	    force;	/* Also sync when no_u_sync is set. */
  {
      /* Skip it when already synced or syncing is disabled. */
      if (curbuf->b_u_synced || (!force && no_u_sync > 0))
--- 2961,2968 ----
   * u_sync: stop adding to the current entry list
   */
      void
! u_sync(
!     int	    force)	/* Also sync when no_u_sync is set. */
  {
      /* Skip it when already synced or syncing is disabled. */
      if (curbuf->b_u_synced || (!force && no_u_sync > 0))
***************
*** 3039,3046 ****
   * ":undolist": List the leafs of the undo tree
   */
      void
! ex_undolist(eap)
!     exarg_T *eap UNUSED;
  {
      garray_T	ga;
      u_header_T	*uhp;
--- 2984,2990 ----
   * ":undolist": List the leafs of the undo tree
   */
      void
! ex_undolist(exarg_T *eap UNUSED)
  {
      garray_T	ga;
      u_header_T	*uhp;
***************
*** 3146,3155 ****
   * Put the timestamp of an undo header in "buf[buflen]" in a nice format.
   */
      static void
! u_add_time(buf, buflen, tt)
!     char_u	*buf;
!     size_t	buflen;
!     time_t	tt;
  {
  #ifdef HAVE_STRFTIME
      struct tm	*curtime;
--- 3090,3096 ----
   * Put the timestamp of an undo header in "buf[buflen]" in a nice format.
   */
      static void
! u_add_time(char_u *buf, size_t buflen, time_t tt)
  {
  #ifdef HAVE_STRFTIME
      struct tm	*curtime;
***************
*** 3174,3181 ****
   * ":undojoin": continue adding to the last entry list
   */
      void
! ex_undojoin(eap)
!     exarg_T *eap UNUSED;
  {
      if (curbuf->b_u_newhead == NULL)
  	return;		    /* nothing changed before */
--- 3115,3121 ----
   * ":undojoin": continue adding to the last entry list
   */
      void
! ex_undojoin(exarg_T *eap UNUSED)
  {
      if (curbuf->b_u_newhead == NULL)
  	return;		    /* nothing changed before */
***************
*** 3201,3208 ****
   * Now an undo means that the buffer is modified.
   */
      void
! u_unchanged(buf)
!     buf_T	*buf;
  {
      u_unch_branch(buf->b_u_oldhead);
      buf->b_did_warn = FALSE;
--- 3141,3147 ----
   * Now an undo means that the buffer is modified.
   */
      void
! u_unchanged(buf_T *buf)
  {
      u_unch_branch(buf->b_u_oldhead);
      buf->b_did_warn = FALSE;
***************
*** 3213,3219 ****
   * line that was changed and set the cursor there.
   */
      void
! u_find_first_changed()
  {
      u_header_T	*uhp = curbuf->b_u_newhead;
      u_entry_T   *uep;
--- 3152,3158 ----
   * line that was changed and set the cursor there.
   */
      void
! u_find_first_changed(void)
  {
      u_header_T	*uhp = curbuf->b_u_newhead;
      u_entry_T   *uep;
***************
*** 3249,3256 ****
   * used for "u".
   */
      void
! u_update_save_nr(buf)
!     buf_T *buf;
  {
      u_header_T	*uhp;
  
--- 3188,3194 ----
   * used for "u".
   */
      void
! u_update_save_nr(buf_T *buf)
  {
      u_header_T	*uhp;
  
***************
*** 3266,3273 ****
  }
  
      static void
! u_unch_branch(uhp)
!     u_header_T	*uhp;
  {
      u_header_T	*uh;
  
--- 3204,3210 ----
  }
  
      static void
! u_unch_branch(u_header_T *uhp)
  {
      u_header_T	*uh;
  
***************
*** 3284,3290 ****
   * If it's not valid, give an error message and return NULL.
   */
      static u_entry_T *
! u_get_headentry()
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
--- 3221,3227 ----
   * If it's not valid, give an error message and return NULL.
   */
      static u_entry_T *
! u_get_headentry(void)
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
***************
*** 3299,3305 ****
   *		It is called only when b_u_synced is FALSE.
   */
      static void
! u_getbot()
  {
      u_entry_T	*uep;
      linenr_T	extra;
--- 3236,3242 ----
   *		It is called only when b_u_synced is FALSE.
   */
      static void
! u_getbot(void)
  {
      u_entry_T	*uep;
      linenr_T	extra;
***************
*** 3337,3346 ****
   * Free one header "uhp" and its entry list and adjust the pointers.
   */
      static void
! u_freeheader(buf, uhp, uhpp)
!     buf_T	    *buf;
!     u_header_T	    *uhp;
!     u_header_T	    **uhpp;	/* if not NULL reset when freeing this header */
  {
      u_header_T	    *uhap;
  
--- 3274,3283 ----
   * Free one header "uhp" and its entry list and adjust the pointers.
   */
      static void
! u_freeheader(
!     buf_T	    *buf,
!     u_header_T	    *uhp,
!     u_header_T	    **uhpp)	/* if not NULL reset when freeing this header */
  {
      u_header_T	    *uhap;
  
***************
*** 3372,3381 ****
   * Free an alternate branch and any following alternate branches.
   */
      static void
! u_freebranch(buf, uhp, uhpp)
!     buf_T	    *buf;
!     u_header_T	    *uhp;
!     u_header_T	    **uhpp;	/* if not NULL reset when freeing this header */
  {
      u_header_T	    *tofree, *next;
  
--- 3309,3318 ----
   * Free an alternate branch and any following alternate branches.
   */
      static void
! u_freebranch(
!     buf_T	    *buf,
!     u_header_T	    *uhp,
!     u_header_T	    **uhpp)	/* if not NULL reset when freeing this header */
  {
      u_header_T	    *tofree, *next;
  
***************
*** 3407,3416 ****
   * This means that "uhp" is invalid when returning.
   */
      static void
! u_freeentries(buf, uhp, uhpp)
!     buf_T	    *buf;
!     u_header_T	    *uhp;
!     u_header_T	    **uhpp;	/* if not NULL reset when freeing this header */
  {
      u_entry_T	    *uep, *nuep;
  
--- 3344,3353 ----
   * This means that "uhp" is invalid when returning.
   */
      static void
! u_freeentries(
!     buf_T	    *buf,
!     u_header_T	    *uhp,
!     u_header_T	    **uhpp)	/* if not NULL reset when freeing this header */
  {
      u_entry_T	    *uep, *nuep;
  
***************
*** 3439,3447 ****
   * free entry 'uep' and 'n' lines in uep->ue_array[]
   */
      static void
! u_freeentry(uep, n)
!     u_entry_T	*uep;
!     long	    n;
  {
      while (n > 0)
  	vim_free(uep->ue_array[--n]);
--- 3376,3382 ----
   * free entry 'uep' and 'n' lines in uep->ue_array[]
   */
      static void
! u_freeentry(u_entry_T *uep, long n)
  {
      while (n > 0)
  	vim_free(uep->ue_array[--n]);
***************
*** 3456,3463 ****
   * invalidate the undo buffer; called when storage has already been released
   */
      void
! u_clearall(buf)
!     buf_T	*buf;
  {
      buf->b_u_newhead = buf->b_u_oldhead = buf->b_u_curhead = NULL;
      buf->b_u_synced = TRUE;
--- 3391,3397 ----
   * invalidate the undo buffer; called when storage has already been released
   */
      void
! u_clearall(buf_T *buf)
  {
      buf->b_u_newhead = buf->b_u_oldhead = buf->b_u_curhead = NULL;
      buf->b_u_synced = TRUE;
***************
*** 3470,3477 ****
   * save the line "lnum" for the "U" command
   */
      void
! u_saveline(lnum)
!     linenr_T lnum;
  {
      if (lnum == curbuf->b_u_line_lnum)	    /* line is already saved */
  	return;
--- 3404,3410 ----
   * save the line "lnum" for the "U" command
   */
      void
! u_saveline(linenr_T lnum)
  {
      if (lnum == curbuf->b_u_line_lnum)	    /* line is already saved */
  	return;
***************
*** 3492,3498 ****
   * (this is used externally for crossing a line while in insert mode)
   */
      void
! u_clearline()
  {
      if (curbuf->b_u_line_ptr != NULL)
      {
--- 3425,3431 ----
   * (this is used externally for crossing a line while in insert mode)
   */
      void
! u_clearline(void)
  {
      if (curbuf->b_u_line_ptr != NULL)
      {
***************
*** 3509,3515 ****
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! u_undoline()
  {
      colnr_T t;
      char_u  *oldp;
--- 3442,3448 ----
   * Careful: may trigger autocommands that reload the buffer.
   */
      void
! u_undoline(void)
  {
      colnr_T t;
      char_u  *oldp;
***************
*** 3551,3558 ****
   * Free all allocated memory blocks for the buffer 'buf'.
   */
      void
! u_blockfree(buf)
!     buf_T	*buf;
  {
      while (buf->b_u_oldhead != NULL)
  	u_freeheader(buf, buf->b_u_oldhead, NULL);
--- 3484,3490 ----
   * Free all allocated memory blocks for the buffer 'buf'.
   */
      void
! u_blockfree(buf_T *buf)
  {
      while (buf->b_u_oldhead != NULL)
  	u_freeheader(buf, buf->b_u_oldhead, NULL);
***************
*** 3564,3571 ****
   * Returns NULL when out of memory.
   */
      static char_u *
! u_save_line(lnum)
!     linenr_T	lnum;
  {
      return vim_strsave(ml_get(lnum));
  }
--- 3496,3502 ----
   * Returns NULL when out of memory.
   */
      static char_u *
! u_save_line(linenr_T lnum)
  {
      return vim_strsave(ml_get(lnum));
  }
***************
*** 3576,3583 ****
   * "nofile" and "scratch" type buffers are considered to always be unchanged.
   */
      int
! bufIsChanged(buf)
!     buf_T	*buf;
  {
      return
  #ifdef FEAT_QUICKFIX
--- 3507,3513 ----
   * "nofile" and "scratch" type buffers are considered to always be unchanged.
   */
      int
! bufIsChanged(buf_T *buf)
  {
      return
  #ifdef FEAT_QUICKFIX
***************
*** 3587,3593 ****
  }
  
      int
! curbufIsChanged()
  {
      return
  #ifdef FEAT_QUICKFIX
--- 3517,3523 ----
  }
  
      int
! curbufIsChanged(void)
  {
      return
  #ifdef FEAT_QUICKFIX
***************
*** 3602,3610 ****
   * Recursive.
   */
      void
! u_eval_tree(first_uhp, list)
!     u_header_T  *first_uhp;
!     list_T	*list;
  {
      u_header_T  *uhp = first_uhp;
      dict_T	*dict;
--- 3532,3538 ----
   * Recursive.
   */
      void
! u_eval_tree(u_header_T *first_uhp, list_T *list)
  {
      u_header_T  *uhp = first_uhp;
      dict_T	*dict;
*** ../vim-7.4.1213/src/version.c	2016-01-30 20:31:21.257607830 +0100
--- src/version.c	2016-01-30 20:32:25.476940101 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1214,
  /**/

-- 
You are only young once, but you can stay immature indefinitely.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
