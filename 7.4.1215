To: vim_dev@googlegroups.com
Subject: Patch 7.4.1215
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1215
Problem:    Using old style function declarations.
Solution:   Change to new style function declarations. (script by Hirohito
            Higashi)
Files:      src/version.c, src/winclip.c, src/window.c, src/workshop.c,
            src/xpm_w32.c, runtime/doc/doctags.c,
            runtime/tools/xcmdsrv_client.c, src/po/sjiscorr.c, src/xxd/xxd.c


*** ../vim-7.4.1214/src/version.c	2016-01-30 21:10:05.009342495 +0100
--- src/version.c	2016-01-30 21:12:52.727587971 +0100
***************
*** 36,42 ****
  						      + sizeof(__TIME__) + 3];
  
      void
! make_version()
  {
      /*
       * Construct the long version string.  Necessary because
--- 36,42 ----
  						      + sizeof(__TIME__) + 3];
  
      void
! make_version(void)
  {
      /*
       * Construct the long version string.  Necessary because
***************
*** 3192,3198 ****
  };
  
      int
! highest_patch()
  {
      int		i;
      int		h = 0;
--- 3194,3200 ----
  };
  
      int
! highest_patch(void)
  {
      int		i;
      int		h = 0;
***************
*** 3208,3215 ****
   * Return TRUE if patch "n" has been included.
   */
      int
! has_patch(n)
!     int		n;
  {
      int		i;
  
--- 3210,3216 ----
   * Return TRUE if patch "n" has been included.
   */
      int
! has_patch(int n)
  {
      int		i;
  
***************
*** 3221,3228 ****
  #endif
  
      void
! ex_version(eap)
!     exarg_T	*eap;
  {
      /*
       * Ignore a ":version 9.99" command.
--- 3222,3228 ----
  #endif
  
      void
! ex_version(exarg_T *eap)
  {
      /*
       * Ignore a ":version 9.99" command.
***************
*** 3238,3244 ****
   * List all features aligned in columns, dictionary style.
   */
      static void
! list_features()
  {
      int		i;
      int		ncol;
--- 3238,3244 ----
   * List all features aligned in columns, dictionary style.
   */
      static void
! list_features(void)
  {
      int		i;
      int		ncol;
***************
*** 3305,3311 ****
  }
  
      void
! list_version()
  {
      int		i;
      int		first;
--- 3305,3311 ----
  }
  
      void
! list_version(void)
  {
      int		i;
      int		first;
***************
*** 3598,3605 ****
   * newline, unless the message is too long to fit on the screen anyway.
   */
      static void
! version_msg(s)
!     char	*s;
  {
      int		len = (int)STRLEN(s);
  
--- 3598,3604 ----
   * newline, unless the message is too long to fit on the screen anyway.
   */
      static void
! version_msg(char *s)
  {
      int		len = (int)STRLEN(s);
  
***************
*** 3616,3622 ****
   * Show the intro message when not editing a file.
   */
      void
! maybe_intro_message()
  {
      if (bufempty()
  	    && curbuf->b_fname == NULL
--- 3615,3621 ----
   * Show the intro message when not editing a file.
   */
      void
! maybe_intro_message(void)
  {
      if (bufempty()
  	    && curbuf->b_fname == NULL
***************
*** 3633,3640 ****
   * Or with the ":intro" command (for Sven :-).
   */
      void
! intro_message(colon)
!     int		colon;		/* TRUE for ":intro" */
  {
      int		i;
      int		row;
--- 3632,3639 ----
   * Or with the ":intro" command (for Sven :-).
   */
      void
! intro_message(
!     int		colon)		/* TRUE for ":intro" */
  {
      int		i;
      int		row;
***************
*** 3765,3775 ****
  }
  
      static void
! do_intro_line(row, mesg, add_version, attr)
!     int		row;
!     char_u	*mesg;
!     int		add_version;
!     int		attr;
  {
      char_u	vers[20];
      int		col;
--- 3764,3774 ----
  }
  
      static void
! do_intro_line(
!     int		row,
!     char_u	*mesg,
!     int		add_version,
!     int		attr)
  {
      char_u	vers[20];
      int		col;
***************
*** 3842,3849 ****
   * ":intro": clear screen, display intro screen and wait for return.
   */
      void
! ex_intro(eap)
!     exarg_T	*eap UNUSED;
  {
      screenclear();
      intro_message(TRUE);
--- 3841,3847 ----
   * ":intro": clear screen, display intro screen and wait for return.
   */
      void
! ex_intro(exarg_T *eap UNUSED)
  {
      screenclear();
      intro_message(TRUE);
*** ../vim-7.4.1214/src/winclip.c	2014-03-12 19:24:32.508933166 +0100
--- src/winclip.c	2016-01-30 21:13:24.815252328 +0100
***************
*** 779,789 ****
   * The result is in allocated memory: "out[outlen]".  With terminating NUL.
   */
      void
! acp_to_enc(str, str_size, out, outlen)
!     char_u	*str;
!     int		str_size;
!     char_u	**out;
!     int		*outlen;
  
  {
      LPWSTR	widestr;
--- 779,789 ----
   * The result is in allocated memory: "out[outlen]".  With terminating NUL.
   */
      void
! acp_to_enc(
!     char_u	*str,
!     int		str_size,
!     char_u	**out,
!     int		*outlen)
  
  {
      LPWSTR	widestr;
***************
*** 804,814 ****
   * The result is in allocated memory: "out[outlen]".  With terminating NUL.
   */
      void
! enc_to_acp(str, str_size, out, outlen)
!     char_u	*str;
!     int		str_size;
!     char_u	**out;
!     int		*outlen;
  
  {
      LPWSTR	widestr;
--- 804,814 ----
   * The result is in allocated memory: "out[outlen]".  With terminating NUL.
   */
      void
! enc_to_acp(
!     char_u	*str,
!     int		str_size,
!     char_u	**out,
!     int		*outlen)
  
  {
      LPWSTR	widestr;
*** ../vim-7.4.1214/src/window.c	2016-01-29 22:46:58.978534691 +0100
--- src/window.c	2016-01-30 21:18:50.011851296 +0100
***************
*** 95,104 ****
   * all CTRL-W window commands are handled here, called from normal_cmd().
   */
      void
! do_window(nchar, Prenum, xchar)
!     int		nchar;
!     long	Prenum;
!     int		xchar;	    /* extra char from ":wincmd gx" or NUL */
  {
      long	Prenum1;
      win_T	*wp;
--- 95,104 ----
   * all CTRL-W window commands are handled here, called from normal_cmd().
   */
      void
! do_window(
!     int		nchar,
!     long	Prenum,
!     int		xchar)	    /* extra char from ":wincmd gx" or NUL */
  {
      long	Prenum1;
      win_T	*wp;
***************
*** 627,635 ****
   * Figure out the address type for ":wnncmd".
   */
      void
! get_wincmd_addr_type(arg, eap)
!     char_u	*arg;
!     exarg_T	*eap;
  {
      switch (*arg)
      {
--- 627,633 ----
   * Figure out the address type for ":wnncmd".
   */
      void
! get_wincmd_addr_type(char_u *arg, exarg_T *eap)
  {
      switch (*arg)
      {
***************
*** 728,738 ****
  }
  
      static void
! cmd_with_count(cmd, bufp, bufsize, Prenum)
!     char	*cmd;
!     char_u	*bufp;
!     size_t	bufsize;
!     long	Prenum;
  {
      size_t	len = STRLEN(cmd);
  
--- 726,736 ----
  }
  
      static void
! cmd_with_count(
!     char	*cmd,
!     char_u	*bufp,
!     size_t	bufsize,
!     long	Prenum)
  {
      size_t	len = STRLEN(cmd);
  
***************
*** 757,765 ****
   * return FAIL for failure, OK otherwise
   */
      int
! win_split(size, flags)
!     int		size;
!     int		flags;
  {
      /* When the ":tab" modifier was used open a new tab page instead. */
      if (may_open_tabpage() == OK)
--- 755,761 ----
   * return FAIL for failure, OK otherwise
   */
      int
! win_split(int size, int flags)
  {
      /* When the ":tab" modifier was used open a new tab page instead. */
      if (may_open_tabpage() == OK)
***************
*** 790,800 ****
   * return FAIL for failure, OK otherwise
   */
      int
! win_split_ins(size, flags, new_wp, dir)
!     int		size;
!     int		flags;
!     win_T	*new_wp;
!     int		dir;
  {
      win_T	*wp = new_wp;
      win_T	*oldwin;
--- 786,796 ----
   * return FAIL for failure, OK otherwise
   */
      int
! win_split_ins(
!     int		size,
!     int		flags,
!     win_T	*new_wp,
!     int		dir)
  {
      win_T	*wp = new_wp;
      win_T	*oldwin;
***************
*** 1334,1343 ****
   * being copied.
   */
      static void
! win_init(newp, oldp, flags)
!     win_T	*newp;
!     win_T	*oldp;
!     int		 flags UNUSED;
  {
      int		i;
  
--- 1330,1336 ----
   * being copied.
   */
      static void
! win_init(win_T *newp, win_T *oldp, int flags UNUSED)
  {
      int		i;
  
***************
*** 1403,1411 ****
   * Only the essential things are copied.
   */
      static void
! win_init_some(newp, oldp)
!     win_T	*newp;
!     win_T	*oldp;
  {
      /* Use the same argument list. */
      newp->w_alist = oldp->w_alist;
--- 1396,1402 ----
   * Only the essential things are copied.
   */
      static void
! win_init_some(win_T *newp, win_T *oldp)
  {
      /* Use the same argument list. */
      newp->w_alist = oldp->w_alist;
***************
*** 1423,1430 ****
   * Check if "win" is a pointer to an existing window.
   */
      int
! win_valid(win)
!     win_T	*win;
  {
      win_T	*wp;
  
--- 1414,1420 ----
   * Check if "win" is a pointer to an existing window.
   */
      int
! win_valid(win_T *win)
  {
      win_T	*wp;
  
***************
*** 1440,1446 ****
   * Return the number of windows.
   */
      int
! win_count()
  {
      win_T	*wp;
      int		count = 0;
--- 1430,1436 ----
   * Return the number of windows.
   */
      int
! win_count(void)
  {
      win_T	*wp;
      int		count = 0;
***************
*** 1457,1465 ****
   * (excluding the command line).
   */
      int
! make_windows(count, vertical)
!     int		count;
!     int		vertical UNUSED;  /* split windows vertically if TRUE */
  {
      int		maxcount;
      int		todo;
--- 1447,1455 ----
   * (excluding the command line).
   */
      int
! make_windows(
!     int		count,
!     int		vertical UNUSED)  /* split windows vertically if TRUE */
  {
      int		maxcount;
      int		todo;
***************
*** 1529,1536 ****
   * Exchange current and next window
   */
      static void
! win_exchange(Prenum)
!     long	Prenum;
  {
      frame_T	*frp;
      frame_T	*frp2;
--- 1519,1525 ----
   * Exchange current and next window
   */
      static void
! win_exchange(long Prenum)
  {
      frame_T	*frp;
      frame_T	*frp2;
***************
*** 1634,1642 ****
   *		   if upwards FALSE the first window becomes the second one
   */
      static void
! win_rotate(upwards, count)
!     int		upwards;
!     int		count;
  {
      win_T	*wp1;
      win_T	*wp2;
--- 1623,1629 ----
   *		   if upwards FALSE the first window becomes the second one
   */
      static void
! win_rotate(int upwards, int count)
  {
      win_T	*wp1;
      win_T	*wp2;
***************
*** 1723,1731 ****
   * Move the current window to the very top/bottom/left/right of the screen.
   */
      static void
! win_totop(size, flags)
!     int		size;
!     int		flags;
  {
      int		dir;
      int		height = curwin->w_height;
--- 1710,1716 ----
   * Move the current window to the very top/bottom/left/right of the screen.
   */
      static void
! win_totop(int size, int flags)
  {
      int		dir;
      int		height = curwin->w_height;
***************
*** 1763,1770 ****
   * window.  Only works within the same frame!
   */
      void
! win_move_after(win1, win2)
!     win_T	*win1, *win2;
  {
      int		height;
  
--- 1748,1754 ----
   * window.  Only works within the same frame!
   */
      void
! win_move_after(win_T *win1, win_T *win2)
  {
      int		height;
  
***************
*** 1828,1837 ****
   * rows.
   */
      void
! win_equal(next_curwin, current, dir)
!     win_T	*next_curwin;	/* pointer to current window to be or NULL */
!     int		current;	/* do only frame with current window */
!     int		dir;		/* 'v' for vertically, 'h' for horizontally,
  				   'b' for both, 0 for using p_ead */
  {
      if (dir == 0)
--- 1812,1821 ----
   * rows.
   */
      void
! win_equal(
!     win_T	*next_curwin,	/* pointer to current window to be or NULL */
!     int		current,	/* do only frame with current window */
!     int		dir)		/* 'v' for vertically, 'h' for horizontally,
  				   'b' for both, 0 for using p_ead */
  {
      if (dir == 0)
***************
*** 1852,1866 ****
   * 'winheight' and 'winwidth' if possible.
   */
      static void
! win_equal_rec(next_curwin, current, topfr, dir, col, row, width, height)
!     win_T	*next_curwin;	/* pointer to current window to be or NULL */
!     int		current;	/* do only frame with current window */
!     frame_T	*topfr;		/* frame to set size off */
!     int		dir;		/* 'v', 'h' or 'b', see win_equal() */
!     int		col;		/* horizontal position for frame */
!     int		row;		/* vertical position for frame */
!     int		width;		/* new width of frame */
!     int		height;		/* new height of frame */
  {
      int		n, m;
      int		extra_sep = 0;
--- 1836,1850 ----
   * 'winheight' and 'winwidth' if possible.
   */
      static void
! win_equal_rec(
!     win_T	*next_curwin,	/* pointer to current window to be or NULL */
!     int		current,	/* do only frame with current window */
!     frame_T	*topfr,		/* frame to set size off */
!     int		dir,		/* 'v', 'h' or 'b', see win_equal() */
!     int		col,		/* horizontal position for frame */
!     int		row,		/* vertical position for frame */
!     int		width,		/* new width of frame */
!     int		height)		/* new height of frame */
  {
      int		n, m;
      int		extra_sep = 0;
***************
*** 2183,2191 ****
   * close all windows for buffer 'buf'
   */
      void
! close_windows(buf, keep_curwin)
!     buf_T	*buf;
!     int		keep_curwin;	    /* don't close "curwin" */
  {
      win_T	*wp;
      tabpage_T   *tp, *nexttp;
--- 2167,2175 ----
   * close all windows for buffer 'buf'
   */
      void
! close_windows(
!     buf_T	*buf,
!     int		keep_curwin)	    /* don't close "curwin" */
  {
      win_T	*wp;
      tabpage_T   *tp, *nexttp;
***************
*** 2244,2250 ****
   * Returns FALSE if there is a window, possibly in another tab page.
   */
      static int
! last_window()
  {
      return (one_window() && first_tabpage->tp_next == NULL);
  }
--- 2228,2234 ----
   * Returns FALSE if there is a window, possibly in another tab page.
   */
      static int
! last_window(void)
  {
      return (one_window() && first_tabpage->tp_next == NULL);
  }
***************
*** 2254,2260 ****
   * current tab page.
   */
      int
! one_window()
  {
  #ifdef FEAT_AUTOCMD
      win_T	*wp;
--- 2238,2244 ----
   * current tab page.
   */
      int
! one_window(void)
  {
  #ifdef FEAT_AUTOCMD
      win_T	*wp;
***************
*** 2280,2289 ****
   * Returns TRUE when the window was closed already.
   */
      static int
! close_last_window_tabpage(win, free_buf, prev_curtab)
!     win_T	*win;
!     int		free_buf;
!     tabpage_T   *prev_curtab;
  {
      if (firstwin == lastwin)
      {
--- 2264,2273 ----
   * Returns TRUE when the window was closed already.
   */
      static int
! close_last_window_tabpage(
!     win_T	*win,
!     int		free_buf,
!     tabpage_T   *prev_curtab)
  {
      if (firstwin == lastwin)
      {
***************
*** 2333,2341 ****
   * Returns FAIL when the window was not closed.
   */
      int
! win_close(win, free_buf)
!     win_T	*win;
!     int		free_buf;
  {
      win_T	*wp;
  #ifdef FEAT_AUTOCMD
--- 2317,2323 ----
   * Returns FAIL when the window was not closed.
   */
      int
! win_close(win_T *win, int free_buf)
  {
      win_T	*wp;
  #ifdef FEAT_AUTOCMD
***************
*** 2557,2566 ****
   * updated.
   */
      void
! win_close_othertab(win, free_buf, tp)
!     win_T	*win;
!     int		free_buf;
!     tabpage_T	*tp;
  {
      win_T	*wp;
      int		dir;
--- 2539,2545 ----
   * updated.
   */
      void
! win_close_othertab(win_T *win, int free_buf, tabpage_T *tp)
  {
      win_T	*wp;
      int		dir;
***************
*** 2620,2629 ****
   * Returns a pointer to the window that got the freed up space.
   */
      static win_T *
! win_free_mem(win, dirp, tp)
!     win_T	*win;
!     int		*dirp;		/* set to 'v' or 'h' for direction if 'ea' */
!     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp;
      win_T	*wp;
--- 2599,2608 ----
   * Returns a pointer to the window that got the freed up space.
   */
      static win_T *
! win_free_mem(
!     win_T	*win,
!     int		*dirp,		/* set to 'v' or 'h' for direction if 'ea' */
!     tabpage_T	*tp)		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp;
      win_T	*wp;
***************
*** 2644,2650 ****
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! win_free_all()
  {
      int		dummy;
  
--- 2623,2629 ----
  
  #if defined(EXITFREE) || defined(PROTO)
      void
! win_free_all(void)
  {
      int		dummy;
  
***************
*** 2675,2684 ****
   * Returns a pointer to the window that got the freed up space.
   */
      win_T *
! winframe_remove(win, dirp, tp)
!     win_T	*win;
!     int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
!     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp, *frp2, *frp3;
      frame_T	*frp_close = win->w_frame;
--- 2654,2663 ----
   * Returns a pointer to the window that got the freed up space.
   */
      win_T *
! winframe_remove(
!     win_T	*win,
!     int		*dirp UNUSED,	/* set to 'v' or 'h' for direction if 'ea' */
!     tabpage_T	*tp)		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp, *frp2, *frp3;
      frame_T	*frp_close = win->w_frame;
***************
*** 2839,2847 ****
   * layout.
   */
      static frame_T *
! win_altframe(win, tp)
!     win_T	*win;
!     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp;
      int		b;
--- 2818,2826 ----
   * layout.
   */
      static frame_T *
! win_altframe(
!     win_T	*win,
!     tabpage_T	*tp)		/* tab page "win" is in, NULL for current */
  {
      frame_T	*frp;
      int		b;
***************
*** 2866,2872 ****
   * Return the tabpage that will be used if the current one is closed.
   */
      static tabpage_T *
! alt_tabpage()
  {
      tabpage_T	*tp;
  
--- 2845,2851 ----
   * Return the tabpage that will be used if the current one is closed.
   */
      static tabpage_T *
! alt_tabpage(void)
  {
      tabpage_T	*tp;
  
***************
*** 2884,2891 ****
   * Find the left-upper window in frame "frp".
   */
      static win_T *
! frame2win(frp)
!     frame_T	*frp;
  {
      while (frp->fr_win == NULL)
  	frp = frp->fr_child;
--- 2863,2869 ----
   * Find the left-upper window in frame "frp".
   */
      static win_T *
! frame2win(frame_T *frp)
  {
      while (frp->fr_win == NULL)
  	frp = frp->fr_child;
***************
*** 2896,2904 ****
   * Return TRUE if frame "frp" contains window "wp".
   */
      static int
! frame_has_win(frp, wp)
!     frame_T	*frp;
!     win_T	*wp;
  {
      frame_T	*p;
  
--- 2874,2880 ----
   * Return TRUE if frame "frp" contains window "wp".
   */
      static int
! frame_has_win(frame_T *frp, win_T *wp)
  {
      frame_T	*p;
  
***************
*** 2916,2926 ****
   * frames and windows.  Caller must take care of positions.
   */
      static void
! frame_new_height(topfrp, height, topfirst, wfh)
!     frame_T	*topfrp;
!     int		height;
!     int		topfirst;	/* resize topmost contained frame first */
!     int		wfh;		/* obey 'winfixheight' when there is a choice;
  				   may cause the height not to be set */
  {
      frame_T	*frp;
--- 2892,2902 ----
   * frames and windows.  Caller must take care of positions.
   */
      static void
! frame_new_height(
!     frame_T	*topfrp,
!     int		height,
!     int		topfirst,	/* resize topmost contained frame first */
!     int		wfh)		/* obey 'winfixheight' when there is a choice;
  				   may cause the height not to be set */
  {
      frame_T	*frp;
***************
*** 3027,3034 ****
   * the 'winfixheight' option.
   */
      static int
! frame_fixed_height(frp)
!     frame_T	*frp;
  {
      /* frame with one window: fixed height if 'winfixheight' set. */
      if (frp->fr_win != NULL)
--- 3003,3009 ----
   * the 'winfixheight' option.
   */
      static int
! frame_fixed_height(frame_T *frp)
  {
      /* frame with one window: fixed height if 'winfixheight' set. */
      if (frp->fr_win != NULL)
***************
*** 3058,3065 ****
   * the 'winfixwidth' option.
   */
      static int
! frame_fixed_width(frp)
!     frame_T	*frp;
  {
      /* frame with one window: fixed width if 'winfixwidth' set. */
      if (frp->fr_win != NULL)
--- 3033,3039 ----
   * the 'winfixwidth' option.
   */
      static int
! frame_fixed_width(frame_T *frp)
  {
      /* frame with one window: fixed width if 'winfixwidth' set. */
      if (frp->fr_win != NULL)
***************
*** 3088,3095 ****
   * Note: Does not check if there is room!
   */
      static void
! frame_add_statusline(frp)
!     frame_T	*frp;
  {
      win_T	*wp;
  
--- 3062,3068 ----
   * Note: Does not check if there is room!
   */
      static void
! frame_add_statusline(frame_T *frp)
  {
      win_T	*wp;
  
***************
*** 3123,3133 ****
   * May remove separator line for windows at the right side (for win_close()).
   */
      static void
! frame_new_width(topfrp, width, leftfirst, wfw)
!     frame_T	*topfrp;
!     int		width;
!     int		leftfirst;	/* resize leftmost contained frame first */
!     int		wfw;		/* obey 'winfixwidth' when there is a choice;
  				   may cause the width not to be set */
  {
      frame_T	*frp;
--- 3096,3106 ----
   * May remove separator line for windows at the right side (for win_close()).
   */
      static void
! frame_new_width(
!     frame_T	*topfrp,
!     int		width,
!     int		leftfirst,	/* resize leftmost contained frame first */
!     int		wfw)		/* obey 'winfixwidth' when there is a choice;
  				   may cause the width not to be set */
  {
      frame_T	*frp;
***************
*** 3238,3245 ****
   * Note: Does not check if there is room!
   */
      static void
! frame_add_vsep(frp)
!     frame_T	*frp;
  {
      win_T	*wp;
  
--- 3211,3217 ----
   * Note: Does not check if there is room!
   */
      static void
! frame_add_vsep(frame_T *frp)
  {
      win_T	*wp;
  
***************
*** 3273,3280 ****
   * Set frame width from the window it contains.
   */
      static void
! frame_fix_width(wp)
!     win_T	*wp;
  {
      wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;
  }
--- 3245,3251 ----
   * Set frame width from the window it contains.
   */
      static void
! frame_fix_width(win_T *wp)
  {
      wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;
  }
***************
*** 3284,3291 ****
   * Set frame height from the window it contains.
   */
      static void
! frame_fix_height(wp)
!     win_T	*wp;
  {
      wp->w_frame->fr_height = wp->w_height + wp->w_status_height;
  }
--- 3255,3261 ----
   * Set frame height from the window it contains.
   */
      static void
! frame_fix_height(win_T *wp)
  {
      wp->w_frame->fr_height = wp->w_height + wp->w_status_height;
  }
***************
*** 3298,3306 ****
   * window.
   */
      static int
! frame_minheight(topfrp, next_curwin)
!     frame_T	*topfrp;
!     win_T	*next_curwin;
  {
      frame_T	*frp;
      int		m;
--- 3268,3274 ----
   * window.
   */
      static int
! frame_minheight(frame_T *topfrp, win_T *next_curwin)
  {
      frame_T	*frp;
      int		m;
***************
*** 3353,3361 ****
   * window.
   */
      static int
! frame_minwidth(topfrp, next_curwin)
!     frame_T	*topfrp;
!     win_T	*next_curwin;	/* use p_wh and p_wiw for next_curwin */
  {
      frame_T	*frp;
      int		m, n;
--- 3321,3329 ----
   * window.
   */
      static int
! frame_minwidth(
!     frame_T	*topfrp,
!     win_T	*next_curwin)	/* use p_wh and p_wiw for next_curwin */
  {
      frame_T	*frp;
      int		m, n;
***************
*** 3405,3413 ****
   * Used by ":bdel" and ":only".
   */
      void
! close_others(message, forceit)
!     int		message;
!     int		forceit;	    /* always hide all other windows */
  {
      win_T	*wp;
      win_T	*nextwp;
--- 3373,3381 ----
   * Used by ":bdel" and ":only".
   */
      void
! close_others(
!     int		message,
!     int		forceit)	    /* always hide all other windows */
  {
      win_T	*wp;
      win_T	*nextwp;
***************
*** 3473,3486 ****
   * Called when a new file is being edited.
   */
      void
! curwin_init()
  {
      win_init_empty(curwin);
  }
  
      void
! win_init_empty(wp)
!     win_T *wp;
  {
      redraw_win_later(wp, NOT_VALID);
      wp->w_lines_valid = 0;
--- 3441,3453 ----
   * Called when a new file is being edited.
   */
      void
! curwin_init(void)
  {
      win_init_empty(curwin);
  }
  
      void
! win_init_empty(win_T *wp)
  {
      redraw_win_later(wp, NOT_VALID);
      wp->w_lines_valid = 0;
***************
*** 3515,3521 ****
   * Return FAIL when something goes wrong (out of memory).
   */
      int
! win_alloc_first()
  {
      if (win_alloc_firstwin(NULL) == FAIL)
  	return FAIL;
--- 3482,3488 ----
   * Return FAIL when something goes wrong (out of memory).
   */
      int
! win_alloc_first(void)
  {
      if (win_alloc_firstwin(NULL) == FAIL)
  	return FAIL;
***************
*** 3537,3543 ****
   * window is fully initialized, thus it can't be in win_alloc_first().
   */
      void
! win_alloc_aucmd_win()
  {
      aucmd_win = win_alloc(NULL, TRUE);
      if (aucmd_win != NULL)
--- 3504,3510 ----
   * window is fully initialized, thus it can't be in win_alloc_first().
   */
      void
! win_alloc_aucmd_win(void)
  {
      aucmd_win = win_alloc(NULL, TRUE);
      if (aucmd_win != NULL)
***************
*** 3557,3564 ****
   * Return FAIL when something goes wrong (out of memory).
   */
      static int
! win_alloc_firstwin(oldwin)
!     win_T	*oldwin;
  {
      curwin = win_alloc(NULL, FALSE);
      if (oldwin == NULL)
--- 3524,3530 ----
   * Return FAIL when something goes wrong (out of memory).
   */
      static int
! win_alloc_firstwin(win_T *oldwin)
  {
      curwin = win_alloc(NULL, FALSE);
      if (oldwin == NULL)
***************
*** 3622,3628 ****
   * Initialize the window and frame size to the maximum.
   */
      void
! win_init_size()
  {
      firstwin->w_height = ROWS_AVAIL;
      topframe->fr_height = ROWS_AVAIL;
--- 3588,3594 ----
   * Initialize the window and frame size to the maximum.
   */
      void
! win_init_size(void)
  {
      firstwin->w_height = ROWS_AVAIL;
      topframe->fr_height = ROWS_AVAIL;
***************
*** 3639,3645 ****
   * Returns NULL when out of memory.
   */
      static tabpage_T *
! alloc_tabpage()
  {
      tabpage_T	*tp;
  # ifdef FEAT_GUI
--- 3605,3611 ----
   * Returns NULL when out of memory.
   */
      static tabpage_T *
! alloc_tabpage(void)
  {
      tabpage_T	*tp;
  # ifdef FEAT_GUI
***************
*** 3675,3682 ****
  }
  
      void
! free_tabpage(tp)
!     tabpage_T	*tp;
  {
      int idx;
  
--- 3641,3647 ----
  }
  
      void
! free_tabpage(tabpage_T *tp)
  {
      int idx;
  
***************
*** 3710,3717 ****
   * Return FAIL or OK.
   */
      int
! win_new_tabpage(after)
!     int		after;
  {
      tabpage_T	*tp = curtab;
      tabpage_T	*newtp;
--- 3675,3681 ----
   * Return FAIL or OK.
   */
      int
! win_new_tabpage(int after)
  {
      tabpage_T	*tp = curtab;
      tabpage_T	*newtp;
***************
*** 3784,3790 ****
   * Returns OK if a new tab page was created, FAIL otherwise.
   */
      int
! may_open_tabpage()
  {
      int		n = (cmdmod.tab == 0) ? postponed_split_tab : cmdmod.tab;
  
--- 3748,3754 ----
   * Returns OK if a new tab page was created, FAIL otherwise.
   */
      int
! may_open_tabpage(void)
  {
      int		n = (cmdmod.tab == 0) ? postponed_split_tab : cmdmod.tab;
  
***************
*** 3802,3809 ****
   * Returns the number of resulting tab pages.
   */
      int
! make_tabpages(maxcount)
!     int		maxcount;
  {
      int		count = maxcount;
      int		todo;
--- 3766,3772 ----
   * Returns the number of resulting tab pages.
   */
      int
! make_tabpages(int maxcount)
  {
      int		count = maxcount;
      int		todo;
***************
*** 3836,3843 ****
   * Return TRUE when "tpc" points to a valid tab page.
   */
      int
! valid_tabpage(tpc)
!     tabpage_T	*tpc;
  {
      tabpage_T	*tp;
  
--- 3799,3805 ----
   * Return TRUE when "tpc" points to a valid tab page.
   */
      int
! valid_tabpage(tabpage_T *tpc)
  {
      tabpage_T	*tp;
  
***************
*** 3851,3858 ****
   * Find tab page "n" (first one is 1).  Returns NULL when not found.
   */
      tabpage_T *
! find_tabpage(n)
!     int		n;
  {
      tabpage_T	*tp;
      int		i = 1;
--- 3813,3819 ----
   * Find tab page "n" (first one is 1).  Returns NULL when not found.
   */
      tabpage_T *
! find_tabpage(int n)
  {
      tabpage_T	*tp;
      int		i = 1;
***************
*** 3867,3874 ****
   * When not found returns number of tab pages plus one.
   */
      int
! tabpage_index(ftp)
!     tabpage_T	*ftp;
  {
      int		i = 1;
      tabpage_T	*tp;
--- 3828,3834 ----
   * When not found returns number of tab pages plus one.
   */
      int
! tabpage_index(tabpage_T *ftp)
  {
      int		i = 1;
      tabpage_T	*tp;
***************
*** 3885,3894 ****
   * Careful: When OK is returned need to get a new tab page very very soon!
   */
      static int
! leave_tabpage(new_curbuf, trigger_leave_autocmds)
!     buf_T	*new_curbuf UNUSED;    /* what is going to be the new curbuf,
  				       NULL if unknown */
!     int		trigger_leave_autocmds UNUSED;
  {
      tabpage_T	*tp = curtab;
  
--- 3845,3854 ----
   * Careful: When OK is returned need to get a new tab page very very soon!
   */
      static int
! leave_tabpage(
!     buf_T	*new_curbuf UNUSED,    /* what is going to be the new curbuf,
  				       NULL if unknown */
!     int		trigger_leave_autocmds UNUSED)
  {
      tabpage_T	*tp = curtab;
  
***************
*** 3933,3943 ****
   * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.
   */
      static void
! enter_tabpage(tp, old_curbuf, trigger_enter_autocmds, trigger_leave_autocmds)
!     tabpage_T	*tp;
!     buf_T	*old_curbuf UNUSED;
!     int		trigger_enter_autocmds UNUSED;
!     int		trigger_leave_autocmds UNUSED;
  {
      int		old_off = tp->tp_firstwin->w_winrow;
      win_T	*next_prevwin = tp->tp_prevwin;
--- 3893,3903 ----
   * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.
   */
      static void
! enter_tabpage(
!     tabpage_T	*tp,
!     buf_T	*old_curbuf UNUSED,
!     int		trigger_enter_autocmds UNUSED,
!     int		trigger_leave_autocmds UNUSED)
  {
      int		old_off = tp->tp_firstwin->w_winrow;
      win_T	*next_prevwin = tp->tp_prevwin;
***************
*** 4002,4009 ****
   * When "n" is 9999 go to the last tab page.
   */
      void
! goto_tabpage(n)
!     int	    n;
  {
      tabpage_T	*tp;
      tabpage_T	*ttp;
--- 3962,3968 ----
   * When "n" is 9999 go to the last tab page.
   */
      void
! goto_tabpage(int n)
  {
      tabpage_T	*tp;
      tabpage_T	*ttp;
***************
*** 4082,4091 ****
   * Note: doesn't update the GUI tab.
   */
      void
! goto_tabpage_tp(tp, trigger_enter_autocmds, trigger_leave_autocmds)
!     tabpage_T	*tp;
!     int		trigger_enter_autocmds;
!     int		trigger_leave_autocmds;
  {
      /* Don't repeat a message in another tab page. */
      set_keep_msg(NULL, 0);
--- 4041,4050 ----
   * Note: doesn't update the GUI tab.
   */
      void
! goto_tabpage_tp(
!     tabpage_T	*tp,
!     int		trigger_enter_autocmds,
!     int		trigger_leave_autocmds)
  {
      /* Don't repeat a message in another tab page. */
      set_keep_msg(NULL, 0);
***************
*** 4107,4115 ****
   * Also updates the GUI tab.
   */
      void
! goto_tabpage_win(tp, wp)
!     tabpage_T	*tp;
!     win_T	*wp;
  {
      goto_tabpage_tp(tp, TRUE, TRUE);
      if (curtab == tp && win_valid(wp))
--- 4066,4072 ----
   * Also updates the GUI tab.
   */
      void
! goto_tabpage_win(tabpage_T *tp, win_T *wp)
  {
      goto_tabpage_tp(tp, TRUE, TRUE);
      if (curtab == tp && win_valid(wp))
***************
*** 4126,4133 ****
   * Move the current tab page to after tab page "nr".
   */
      void
! tabpage_move(nr)
!     int		nr;
  {
      int		n = 1;
      tabpage_T	*tp, *tp_dst;
--- 4083,4089 ----
   * Move the current tab page to after tab page "nr".
   */
      void
! tabpage_move(int nr)
  {
      int		n = 1;
      tabpage_T	*tp, *tp_dst;
***************
*** 4182,4189 ****
   * position to keep the same Visual area.
   */
      void
! win_goto(wp)
!     win_T	*wp;
  {
  #ifdef FEAT_CONCEAL
      win_T	*owp = curwin;
--- 4138,4144 ----
   * position to keep the same Visual area.
   */
      void
! win_goto(win_T *wp)
  {
  #ifdef FEAT_CONCEAL
      win_T	*owp = curwin;
***************
*** 4224,4231 ****
   * Find window number "winnr" (counting top to bottom).
   */
      win_T *
! win_find_nr(winnr)
!     int		winnr;
  {
      win_T	*wp;
  
--- 4179,4185 ----
   * Find window number "winnr" (counting top to bottom).
   */
      win_T *
! win_find_nr(int winnr)
  {
      win_T	*wp;
  
***************
*** 4246,4253 ****
   * Find the tabpage for window "win".
   */
      tabpage_T *
! win_find_tabpage(win)
!     win_T	*win;
  {
      win_T	*wp;
      tabpage_T	*tp;
--- 4200,4206 ----
   * Find the tabpage for window "win".
   */
      tabpage_T *
! win_find_tabpage(win_T *win)
  {
      win_T	*wp;
      tabpage_T	*tp;
***************
*** 4266,4274 ****
   * Move to window above or below "count" times.
   */
      static void
! win_goto_ver(up, count)
!     int		up;		/* TRUE to go to win above */
!     long	count;
  {
      frame_T	*fr;
      frame_T	*nfr;
--- 4219,4227 ----
   * Move to window above or below "count" times.
   */
      static void
! win_goto_ver(
!     int		up,		/* TRUE to go to win above */
!     long	count)
  {
      frame_T	*fr;
      frame_T	*nfr;
***************
*** 4329,4337 ****
   * Move to left or right window.
   */
      static void
! win_goto_hor(left, count)
!     int		left;		/* TRUE to go to left win */
!     long	count;
  {
      frame_T	*fr;
      frame_T	*nfr;
--- 4282,4290 ----
   * Move to left or right window.
   */
      static void
! win_goto_hor(
!     int		left,		/* TRUE to go to left win */
!     long	count)
  {
      frame_T	*fr;
      frame_T	*nfr;
***************
*** 4393,4401 ****
   * Make window "wp" the current window.
   */
      void
! win_enter(wp, undo_sync)
!     win_T	*wp;
!     int		undo_sync;
  {
      win_enter_ext(wp, undo_sync, FALSE, TRUE, TRUE);
  }
--- 4346,4352 ----
   * Make window "wp" the current window.
   */
      void
! win_enter(win_T *wp, int undo_sync)
  {
      win_enter_ext(wp, undo_sync, FALSE, TRUE, TRUE);
  }
***************
*** 4406,4417 ****
   * been closed and isn't valid.
   */
      static void
! win_enter_ext(wp, undo_sync, curwin_invalid, trigger_enter_autocmds, trigger_leave_autocmds)
!     win_T	*wp;
!     int		undo_sync;
!     int		curwin_invalid;
!     int		trigger_enter_autocmds UNUSED;
!     int		trigger_leave_autocmds UNUSED;
  {
  #ifdef FEAT_AUTOCMD
      int		other_buffer = FALSE;
--- 4357,4368 ----
   * been closed and isn't valid.
   */
      static void
! win_enter_ext(
!     win_T	*wp,
!     int		undo_sync,
!     int		curwin_invalid,
!     int		trigger_enter_autocmds UNUSED,
!     int		trigger_leave_autocmds UNUSED)
  {
  #ifdef FEAT_AUTOCMD
      int		other_buffer = FALSE;
***************
*** 4539,4546 ****
   * Returns a pointer to the window found, otherwise NULL.
   */
      win_T *
! buf_jump_open_win(buf)
!     buf_T	*buf;
  {
      win_T	*wp = NULL;
  
--- 4490,4496 ----
   * Returns a pointer to the window found, otherwise NULL.
   */
      win_T *
! buf_jump_open_win(buf_T *buf)
  {
      win_T	*wp = NULL;
  
***************
*** 4563,4570 ****
   * Returns a pointer to the window found, otherwise NULL.
   */
      win_T *
! buf_jump_open_tab(buf)
!     buf_T	*buf;
  {
      win_T	*wp = buf_jump_open_win(buf);
  # ifdef FEAT_WINDOWS
--- 4513,4519 ----
   * Returns a pointer to the window found, otherwise NULL.
   */
      win_T *
! buf_jump_open_tab(buf_T *buf)
  {
      win_T	*wp = buf_jump_open_win(buf);
  # ifdef FEAT_WINDOWS
***************
*** 4597,4605 ****
   * FALSE.
   */
      static win_T *
! win_alloc(after, hidden)
!     win_T	*after UNUSED;
!     int		hidden UNUSED;
  {
      win_T	*new_wp;
  
--- 4546,4552 ----
   * FALSE.
   */
      static win_T *
! win_alloc(win_T *after UNUSED, int hidden UNUSED)
  {
      win_T	*new_wp;
  
***************
*** 4689,4697 ****
   * Remove window 'wp' from the window list and free the structure.
   */
      static void
! win_free(wp, tp)
!     win_T	*wp;
!     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      int		i;
      buf_T	*buf;
--- 4636,4644 ----
   * Remove window 'wp' from the window list and free the structure.
   */
      static void
! win_free(
!     win_T	*wp,
!     tabpage_T	*tp)		/* tab page "win" is in, NULL for current */
  {
      int		i;
      buf_T	*buf;
***************
*** 4810,4817 ****
   * Append window "wp" in the window list after window "after".
   */
      void
! win_append(after, wp)
!     win_T	*after, *wp;
  {
      win_T	*before;
  
--- 4757,4763 ----
   * Append window "wp" in the window list after window "after".
   */
      void
! win_append(win_T *after, win_T *wp)
  {
      win_T	*before;
  
***************
*** 4836,4844 ****
   * Remove a window from the window list.
   */
      void
! win_remove(wp, tp)
!     win_T	*wp;
!     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
  {
      if (wp->w_prev != NULL)
  	wp->w_prev->w_next = wp->w_next;
--- 4782,4790 ----
   * Remove a window from the window list.
   */
      void
! win_remove(
!     win_T	*wp,
!     tabpage_T	*tp)		/* tab page "win" is in, NULL for current */
  {
      if (wp->w_prev != NULL)
  	wp->w_prev->w_next = wp->w_next;
***************
*** 4858,4865 ****
   * Append frame "frp" in a frame list after frame "after".
   */
      static void
! frame_append(after, frp)
!     frame_T	*after, *frp;
  {
      frp->fr_next = after->fr_next;
      after->fr_next = frp;
--- 4804,4810 ----
   * Append frame "frp" in a frame list after frame "after".
   */
      static void
! frame_append(frame_T *after, frame_T *frp)
  {
      frp->fr_next = after->fr_next;
      after->fr_next = frp;
***************
*** 4872,4879 ****
   * Insert frame "frp" in a frame list before frame "before".
   */
      static void
! frame_insert(before, frp)
!     frame_T	*before, *frp;
  {
      frp->fr_next = before;
      frp->fr_prev = before->fr_prev;
--- 4817,4823 ----
   * Insert frame "frp" in a frame list before frame "before".
   */
      static void
! frame_insert(frame_T *before, frame_T *frp)
  {
      frp->fr_next = before;
      frp->fr_prev = before->fr_prev;
***************
*** 4888,4895 ****
   * Remove a frame from a frame list.
   */
      static void
! frame_remove(frp)
!     frame_T	*frp;
  {
      if (frp->fr_prev != NULL)
  	frp->fr_prev->fr_next = frp->fr_next;
--- 4832,4838 ----
   * Remove a frame from a frame list.
   */
      static void
! frame_remove(frame_T *frp)
  {
      if (frp->fr_prev != NULL)
  	frp->fr_prev->fr_next = frp->fr_next;
***************
*** 4906,4913 ****
   * Return FAIL for failure, OK for success.
   */
      int
! win_alloc_lines(wp)
!     win_T	*wp;
  {
      wp->w_lines_valid = 0;
      wp->w_lines = (wline_T *)alloc_clear((unsigned)(Rows * sizeof(wline_T)));
--- 4849,4855 ----
   * Return FAIL for failure, OK for success.
   */
      int
! win_alloc_lines(win_T *wp)
  {
      wp->w_lines_valid = 0;
      wp->w_lines = (wline_T *)alloc_clear((unsigned)(Rows * sizeof(wline_T)));
***************
*** 4920,4927 ****
   * free lsize arrays for a window
   */
      void
! win_free_lsize(wp)
!     win_T	*wp;
  {
      /* TODO: why would wp be NULL here? */
      if (wp != NULL)
--- 4862,4868 ----
   * free lsize arrays for a window
   */
      void
! win_free_lsize(win_T *wp)
  {
      /* TODO: why would wp be NULL here? */
      if (wp != NULL)
***************
*** 4936,4942 ****
   * This only does the current tab page, others must be done when made active.
   */
      void
! shell_new_rows()
  {
      int		h = (int)ROWS_AVAIL;
  
--- 4877,4883 ----
   * This only does the current tab page, others must be done when made active.
   */
      void
! shell_new_rows(void)
  {
      int		h = (int)ROWS_AVAIL;
  
***************
*** 4975,4981 ****
   * Called from win_new_shellsize() after Columns changed.
   */
      void
! shell_new_columns()
  {
      if (firstwin == NULL)	/* not initialized yet */
  	return;
--- 4916,4922 ----
   * Called from win_new_shellsize() after Columns changed.
   */
      void
! shell_new_columns(void)
  {
      if (firstwin == NULL)	/* not initialized yet */
  	return;
***************
*** 5000,5007 ****
   * Save the size of all windows in "gap".
   */
      void
! win_size_save(gap)
!     garray_T	*gap;
  
  {
      win_T	*wp;
--- 4941,4947 ----
   * Save the size of all windows in "gap".
   */
      void
! win_size_save(garray_T *gap)
  
  {
      win_T	*wp;
***************
*** 5021,5028 ****
   * Does not free the growarray.
   */
      void
! win_size_restore(gap)
!     garray_T	*gap;
  {
      win_T	*wp;
      int		i, j;
--- 4961,4967 ----
   * Does not free the growarray.
   */
      void
! win_size_restore(garray_T *gap)
  {
      win_T	*wp;
      int		i, j;
***************
*** 5053,5059 ****
   * Returns the row just after the last window.
   */
      int
! win_comp_pos()
  {
      int		row = tabline_height();
      int		col = 0;
--- 4992,4998 ----
   * Returns the row just after the last window.
   */
      int
! win_comp_pos(void)
  {
      int		row = tabline_height();
      int		col = 0;
***************
*** 5069,5078 ****
   * to the bottom-right position plus one.
   */
      static void
! frame_comp_pos(topfrp, row, col)
!     frame_T	*topfrp;
!     int		*row;
!     int		*col;
  {
      win_T	*wp;
      frame_T	*frp;
--- 5008,5014 ----
   * to the bottom-right position plus one.
   */
      static void
! frame_comp_pos(frame_T *topfrp, int *row, int *col)
  {
      win_T	*wp;
      frame_T	*frp;
***************
*** 5129,5136 ****
   * fit around it.
   */
      void
! win_setheight(height)
!     int		height;
  {
      win_setheight_win(height, curwin);
  }
--- 5065,5071 ----
   * fit around it.
   */
      void
! win_setheight(int height)
  {
      win_setheight_win(height, curwin);
  }
***************
*** 5140,5148 ****
   * windows to fit around it.
   */
      void
! win_setheight_win(height, win)
!     int		height;
!     win_T	*win;
  {
      int		row;
  
--- 5075,5081 ----
   * windows to fit around it.
   */
      void
! win_setheight_win(int height, win_T *win)
  {
      int		row;
  
***************
*** 5199,5207 ****
   * At the top level we can also use change the command line height.
   */
      static void
! frame_setheight(curfrp, height)
!     frame_T	*curfrp;
!     int		height;
  {
      int		room;		/* total number of lines available */
      int		take;		/* number of lines taken from other windows */
--- 5132,5138 ----
   * At the top level we can also use change the command line height.
   */
      static void
! frame_setheight(frame_T *curfrp, int height)
  {
      int		room;		/* total number of lines available */
      int		take;		/* number of lines taken from other windows */
***************
*** 5379,5394 ****
   * fit around it.
   */
      void
! win_setwidth(width)
!     int		width;
  {
      win_setwidth_win(width, curwin);
  }
  
      void
! win_setwidth_win(width, wp)
!     int		width;
!     win_T	*wp;
  {
      /* Always keep current window at least one column wide, even when
       * 'winminwidth' is zero. */
--- 5310,5322 ----
   * fit around it.
   */
      void
! win_setwidth(int width)
  {
      win_setwidth_win(width, curwin);
  }
  
      void
! win_setwidth_win(int width, win_T *wp)
  {
      /* Always keep current window at least one column wide, even when
       * 'winminwidth' is zero. */
***************
*** 5416,5424 ****
   * Strategy is similar to frame_setheight().
   */
      static void
! frame_setwidth(curfrp, width)
!     frame_T	*curfrp;
!     int		width;
  {
      int		room;		/* total number of lines available */
      int		take;		/* number of lines taken from other windows */
--- 5344,5350 ----
   * Strategy is similar to frame_setheight().
   */
      static void
! frame_setwidth(frame_T *curfrp, int width)
  {
      int		room;		/* total number of lines available */
      int		take;		/* number of lines taken from other windows */
***************
*** 5559,5565 ****
   * Check 'winminheight' for a valid value.
   */
      void
! win_setminheight()
  {
      int		room;
      int		first = TRUE;
--- 5485,5491 ----
   * Check 'winminheight' for a valid value.
   */
      void
! win_setminheight(void)
  {
      int		room;
      int		first = TRUE;
***************
*** 5589,5597 ****
   * Status line of dragwin is dragged "offset" lines down (negative is up).
   */
      void
! win_drag_status_line(dragwin, offset)
!     win_T	*dragwin;
!     int		offset;
  {
      frame_T	*curfr;
      frame_T	*fr;
--- 5515,5521 ----
   * Status line of dragwin is dragged "offset" lines down (negative is up).
   */
      void
! win_drag_status_line(win_T *dragwin, int offset)
  {
      frame_T	*curfr;
      frame_T	*fr;
***************
*** 5721,5729 ****
   * Separator line of dragwin is dragged "offset" lines right (negative is left).
   */
      void
! win_drag_vsep_line(dragwin, offset)
!     win_T	*dragwin;
!     int		offset;
  {
      frame_T	*curfr;
      frame_T	*fr;
--- 5645,5651 ----
   * Separator line of dragwin is dragged "offset" lines right (negative is left).
   */
      void
! win_drag_vsep_line(win_T *dragwin, int offset)
  {
      frame_T	*curfr;
      frame_T	*fr;
***************
*** 5832,5839 ****
   * Set wp->w_fraction for the current w_wrow and w_height.
   */
      void
! set_fraction(wp)
!     win_T	*wp;
  {
      wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
  				    + wp->w_height / 2) / (long)wp->w_height;
--- 5754,5760 ----
   * Set wp->w_fraction for the current w_wrow and w_height.
   */
      void
! set_fraction(win_T *wp)
  {
      wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
  				    + wp->w_height / 2) / (long)wp->w_height;
***************
*** 5845,5853 ****
   * window position, the frame or to other windows.
   */
      void
! win_new_height(wp, height)
!     win_T	*wp;
!     int		height;
  {
      linenr_T	lnum;
      int		sline, line_size;
--- 5766,5772 ----
   * window position, the frame or to other windows.
   */
      void
! win_new_height(win_T *wp, int height)
  {
      linenr_T	lnum;
      int		sline, line_size;
***************
*** 6000,6008 ****
   * Set the width of a window.
   */
      void
! win_new_width(wp, width)
!     win_T	*wp;
!     int		width;
  {
      wp->w_width = width;
      wp->w_lines_valid = 0;
--- 5919,5925 ----
   * Set the width of a window.
   */
      void
! win_new_width(win_T *wp, int width)
  {
      wp->w_width = width;
      wp->w_lines_valid = 0;
***************
*** 6019,6026 ****
  #endif
  
      void
! win_comp_scroll(wp)
!     win_T	*wp;
  {
      wp->w_p_scr = ((unsigned)wp->w_height >> 1);
      if (wp->w_p_scr == 0)
--- 5936,5942 ----
  #endif
  
      void
! win_comp_scroll(win_T *wp)
  {
      wp->w_p_scr = ((unsigned)wp->w_height >> 1);
      if (wp->w_p_scr == 0)
***************
*** 6031,6037 ****
   * command_height: called whenever p_ch has been changed
   */
      void
! command_height()
  {
  #ifdef FEAT_WINDOWS
      int		h;
--- 5947,5953 ----
   * command_height: called whenever p_ch has been changed
   */
      void
! command_height(void)
  {
  #ifdef FEAT_WINDOWS
      int		h;
***************
*** 6112,6120 ****
   * Also resize the frames it is contained in.
   */
      static void
! frame_add_height(frp, n)
!     frame_T	*frp;
!     int		n;
  {
      frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);
      for (;;)
--- 6028,6034 ----
   * Also resize the frames it is contained in.
   */
      static void
! frame_add_height(frame_T *frp, int n)
  {
      frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);
      for (;;)
***************
*** 6131,6138 ****
   * value of 'laststatus'.
   */
      void
! last_status(morewin)
!     int		morewin;	/* pretend there are two or more windows */
  {
      /* Don't make a difference between horizontal or vertical split. */
      last_status_rec(topframe, (p_ls == 2
--- 6045,6052 ----
   * value of 'laststatus'.
   */
      void
! last_status(
!     int		morewin)	/* pretend there are two or more windows */
  {
      /* Don't make a difference between horizontal or vertical split. */
      last_status_rec(topframe, (p_ls == 2
***************
*** 6140,6148 ****
  }
  
      static void
! last_status_rec(fr, statusline)
!     frame_T	*fr;
!     int		statusline;
  {
      frame_T	*fp;
      win_T	*wp;
--- 6054,6060 ----
  }
  
      static void
! last_status_rec(frame_T *fr, int statusline)
  {
      frame_T	*fp;
      win_T	*wp;
***************
*** 6209,6215 ****
   * Return the number of lines used by the tab page line.
   */
      int
! tabline_height()
  {
  #ifdef FEAT_GUI_TABLINE
      /* When the GUI has the tabline then this always returns zero. */
--- 6121,6127 ----
   * Return the number of lines used by the tab page line.
   */
      int
! tabline_height(void)
  {
  #ifdef FEAT_GUI_TABLINE
      /* When the GUI has the tabline then this always returns zero. */
***************
*** 6233,6241 ****
   * Returns the name in allocated memory, NULL for failure.
   */
      char_u *
! grab_file_name(count, file_lnum)
!     long	count;
!     linenr_T	*file_lnum;
  {
      int options = FNAME_MESS|FNAME_EXP|FNAME_REL|FNAME_UNESC;
  
--- 6145,6151 ----
   * Returns the name in allocated memory, NULL for failure.
   */
      char_u *
! grab_file_name(long count, linenr_T *file_lnum)
  {
      int options = FNAME_MESS|FNAME_EXP|FNAME_REL|FNAME_UNESC;
  
***************
*** 6267,6276 ****
   * FNAME_INCL	    apply "includeexpr"
   */
      char_u *
! file_name_at_cursor(options, count, file_lnum)
!     int		options;
!     long	count;
!     linenr_T	*file_lnum;
  {
      return file_name_in_line(ml_get_curline(),
  		      curwin->w_cursor.col, options, count, curbuf->b_ffname,
--- 6177,6183 ----
   * FNAME_INCL	    apply "includeexpr"
   */
      char_u *
! file_name_at_cursor(int options, long count, linenr_T *file_lnum)
  {
      return file_name_in_line(ml_get_curline(),
  		      curwin->w_cursor.col, options, count, curbuf->b_ffname,
***************
*** 6282,6294 ****
   * Otherwise like file_name_at_cursor().
   */
      char_u *
! file_name_in_line(line, col, options, count, rel_fname, file_lnum)
!     char_u	*line;
!     int		col;
!     int		options;
!     long	count;
!     char_u	*rel_fname;	/* file we are searching relative to */
!     linenr_T	*file_lnum;	/* line number after the file name */
  {
      char_u	*ptr;
      int		len;
--- 6189,6201 ----
   * Otherwise like file_name_at_cursor().
   */
      char_u *
! file_name_in_line(
!     char_u	*line,
!     int		col,
!     int		options,
!     long	count,
!     char_u	*rel_fname,	/* file we are searching relative to */
!     linenr_T	*file_lnum)	/* line number after the file name */
  {
      char_u	*ptr;
      int		len;
***************
*** 6375,6383 ****
  static char_u *eval_includeexpr(char_u *ptr, int len);
  
      static char_u *
! eval_includeexpr(ptr, len)
!     char_u	*ptr;
!     int		len;
  {
      char_u	*res;
  
--- 6282,6288 ----
  static char_u *eval_includeexpr(char_u *ptr, int len);
  
      static char_u *
! eval_includeexpr(char_u *ptr, int len)
  {
      char_u	*res;
  
***************
*** 6394,6405 ****
   * Otherwise like file_name_at_cursor().
   */
      char_u *
! find_file_name_in_path(ptr, len, options, count, rel_fname)
!     char_u	*ptr;
!     int		len;
!     int		options;
!     long	count;
!     char_u	*rel_fname;	/* file we are searching relative to */
  {
      char_u	*file_name;
      int		c;
--- 6299,6310 ----
   * Otherwise like file_name_at_cursor().
   */
      char_u *
! find_file_name_in_path(
!     char_u	*ptr,
!     int		len,
!     int		options,
!     long	count,
!     char_u	*rel_fname)	/* file we are searching relative to */
  {
      char_u	*file_name;
      int		c;
***************
*** 6473,6480 ****
   * URL_BACKSLASH.
   */
      static int
! path_is_url(p)
!     char_u  *p;
  {
      if (STRNCMP(p, "://", (size_t)3) == 0)
  	return URL_SLASH;
--- 6378,6384 ----
   * URL_BACKSLASH.
   */
      static int
! path_is_url(char_u *p)
  {
      if (STRNCMP(p, "://", (size_t)3) == 0)
  	return URL_SLASH;
***************
*** 6489,6496 ****
   * Return zero otherwise.
   */
      int
! path_with_url(fname)
!     char_u *fname;
  {
      char_u *p;
  
--- 6393,6399 ----
   * Return zero otherwise.
   */
      int
! path_with_url(char_u *fname)
  {
      char_u *p;
  
***************
*** 6503,6510 ****
   * Return TRUE if "name" is a full (absolute) path name or URL.
   */
      int
! vim_isAbsName(name)
!     char_u	*name;
  {
      return (path_with_url(name) != 0 || mch_isFullName(name));
  }
--- 6406,6412 ----
   * Return TRUE if "name" is a full (absolute) path name or URL.
   */
      int
! vim_isAbsName(char_u *name)
  {
      return (path_with_url(name) != 0 || mch_isFullName(name));
  }
***************
*** 6515,6524 ****
   * return FAIL for failure, OK otherwise
   */
      int
! vim_FullName(fname, buf, len, force)
!     char_u	*fname, *buf;
!     int		len;
!     int		force;	    /* force expansion even when already absolute */
  {
      int		retval = OK;
      int		url;
--- 6417,6427 ----
   * return FAIL for failure, OK otherwise
   */
      int
! vim_FullName(
!     char_u	*fname,
!     char_u	*buf,
!     int		len,
!     int		force)	    /* force expansion even when already absolute */
  {
      int		retval = OK;
      int		url;
***************
*** 6546,6552 ****
   * the current number of windows.
   */
      int
! min_rows()
  {
      int		total;
  #ifdef FEAT_WINDOWS
--- 6449,6455 ----
   * the current number of windows.
   */
      int
! min_rows(void)
  {
      int		total;
  #ifdef FEAT_WINDOWS
***************
*** 6579,6585 ****
   * Does not count "aucmd_win".
   */
      int
! only_one_window()
  {
  #ifdef FEAT_WINDOWS
      int		count = 0;
--- 6482,6488 ----
   * Does not count "aucmd_win".
   */
      int
! only_one_window(void)
  {
  #ifdef FEAT_WINDOWS
      int		count = 0;
***************
*** 6614,6621 ****
   * When "do_curwin" is TRUE, also check current window.
   */
      void
! check_lnums(do_curwin)
!     int		do_curwin;
  {
      win_T	*wp;
  
--- 6517,6523 ----
   * When "do_curwin" is TRUE, also check current window.
   */
      void
! check_lnums(int do_curwin)
  {
      win_T	*wp;
  
***************
*** 6655,6671 ****
   * Create a snapshot of the current frame sizes.
   */
      void
! make_snapshot(idx)
!     int idx;
  {
      clear_snapshot(curtab, idx);
      make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);
  }
  
      static void
! make_snapshot_rec(fr, frp)
!     frame_T	*fr;
!     frame_T	**frp;
  {
      *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
      if (*frp == NULL)
--- 6557,6570 ----
   * Create a snapshot of the current frame sizes.
   */
      void
! make_snapshot(int idx)
  {
      clear_snapshot(curtab, idx);
      make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);
  }
  
      static void
! make_snapshot_rec(frame_T *fr, frame_T **frp)
  {
      *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
      if (*frp == NULL)
***************
*** 6687,6703 ****
   * Remove any existing snapshot.
   */
      static void
! clear_snapshot(tp, idx)
!     tabpage_T	*tp;
!     int		idx;
  {
      clear_snapshot_rec(tp->tp_snapshot[idx]);
      tp->tp_snapshot[idx] = NULL;
  }
  
      static void
! clear_snapshot_rec(fr)
!     frame_T	*fr;
  {
      if (fr != NULL)
      {
--- 6586,6599 ----
   * Remove any existing snapshot.
   */
      static void
! clear_snapshot(tabpage_T *tp, int idx)
  {
      clear_snapshot_rec(tp->tp_snapshot[idx]);
      tp->tp_snapshot[idx] = NULL;
  }
  
      static void
! clear_snapshot_rec(frame_T *fr)
  {
      if (fr != NULL)
      {
***************
*** 6713,6721 ****
   * still the same.
   */
      void
! restore_snapshot(idx, close_curwin)
!     int		idx;
!     int		close_curwin;	    /* closing current window */
  {
      win_T	*wp;
  
--- 6609,6617 ----
   * still the same.
   */
      void
! restore_snapshot(
!     int		idx,
!     int		close_curwin)	    /* closing current window */
  {
      win_T	*wp;
  
***************
*** 6740,6748 ****
   * and same children.
   */
      static int
! check_snapshot_rec(sn, fr)
!     frame_T	*sn;
!     frame_T	*fr;
  {
      if (sn->fr_layout != fr->fr_layout
  	    || (sn->fr_next == NULL) != (fr->fr_next == NULL)
--- 6636,6642 ----
   * and same children.
   */
      static int
! check_snapshot_rec(frame_T *sn, frame_T *fr)
  {
      if (sn->fr_layout != fr->fr_layout
  	    || (sn->fr_next == NULL) != (fr->fr_next == NULL)
***************
*** 6761,6769 ****
   * Returns a pointer to the old current window, or NULL.
   */
      static win_T *
! restore_snapshot_rec(sn, fr)
!     frame_T	*sn;
!     frame_T	*fr;
  {
      win_T	*wp = NULL;
      win_T	*wp2;
--- 6655,6661 ----
   * Returns a pointer to the old current window, or NULL.
   */
      static win_T *
! restore_snapshot_rec(frame_T *sn, frame_T *fr)
  {
      win_T	*wp = NULL;
      win_T	*wp2;
***************
*** 6808,6819 ****
   * Returns FAIL if switching to "win" failed.
   */
      int
! switch_win(save_curwin, save_curtab, win, tp, no_display)
!     win_T	**save_curwin UNUSED;
!     tabpage_T	**save_curtab UNUSED;
!     win_T	*win UNUSED;
!     tabpage_T	*tp UNUSED;
!     int		no_display UNUSED;
  {
  # ifdef FEAT_AUTOCMD
      block_autocmds();
--- 6700,6711 ----
   * Returns FAIL if switching to "win" failed.
   */
      int
! switch_win(
!     win_T	**save_curwin UNUSED,
!     tabpage_T	**save_curtab UNUSED,
!     win_T	*win UNUSED,
!     tabpage_T	*tp UNUSED,
!     int		no_display UNUSED)
  {
  # ifdef FEAT_AUTOCMD
      block_autocmds();
***************
*** 6848,6857 ****
   * triggered.
   */
      void
! restore_win(save_curwin, save_curtab, no_display)
!     win_T	*save_curwin UNUSED;
!     tabpage_T	*save_curtab UNUSED;
!     int		no_display UNUSED;
  {
  # ifdef FEAT_WINDOWS
      if (save_curtab != NULL && valid_tabpage(save_curtab))
--- 6740,6749 ----
   * triggered.
   */
      void
! restore_win(
!     win_T	*save_curwin UNUSED,
!     tabpage_T	*save_curtab UNUSED,
!     int		no_display UNUSED)
  {
  # ifdef FEAT_WINDOWS
      if (save_curtab != NULL && valid_tabpage(save_curtab))
***************
*** 6883,6891 ****
   * No autocommands will be executed.  Use aucmd_prepbuf() if there are any.
   */
      void
! switch_buffer(save_curbuf, buf)
!     buf_T *buf;
!     buf_T **save_curbuf;
  {
  # ifdef FEAT_AUTOCMD
      block_autocmds();
--- 6775,6781 ----
   * No autocommands will be executed.  Use aucmd_prepbuf() if there are any.
   */
      void
! switch_buffer(buf_T **save_curbuf, buf_T *buf)
  {
  # ifdef FEAT_AUTOCMD
      block_autocmds();
***************
*** 6901,6908 ****
   * Restore the current buffer after using switch_buffer().
   */
      void
! restore_buffer(save_curbuf)
!     buf_T *save_curbuf;
  {
  # ifdef FEAT_AUTOCMD
      unblock_autocmds();
--- 6791,6797 ----
   * Restore the current buffer after using switch_buffer().
   */
      void
! restore_buffer(buf_T *save_curbuf)
  {
  # ifdef FEAT_AUTOCMD
      unblock_autocmds();
***************
*** 6923,6929 ****
   * Return TRUE if there is any vertically split window.
   */
      int
! win_hasvertsplit()
  {
      frame_T	*fr;
  
--- 6812,6818 ----
   * Return TRUE if there is any vertically split window.
   */
      int
! win_hasvertsplit(void)
  {
      frame_T	*fr;
  
***************
*** 6948,6961 ****
   * Return ID of added match, -1 on failure.
   */
      int
! match_add(wp, grp, pat, prio, id, pos_list, conceal_char)
!     win_T	*wp;
!     char_u	*grp;
!     char_u	*pat;
!     int		prio;
!     int		id;
!     list_T	*pos_list;
!     char_u      *conceal_char UNUSED; /* pointer to conceal replacement char */
  {
      matchitem_T	*cur;
      matchitem_T	*prev;
--- 6837,6850 ----
   * Return ID of added match, -1 on failure.
   */
      int
! match_add(
!     win_T	*wp,
!     char_u	*grp,
!     char_u	*pat,
!     int		prio,
!     int		id,
!     list_T	*pos_list,
!     char_u      *conceal_char UNUSED) /* pointer to conceal replacement char */
  {
      matchitem_T	*cur;
      matchitem_T	*prev;
***************
*** 7146,7155 ****
   * Print error messages if 'perr' is TRUE.
   */
      int
! match_delete(wp, id, perr)
!     win_T	*wp;
!     int		id;
!     int		perr;
  {
      matchitem_T	*cur = wp->w_match_head;
      matchitem_T	*prev = cur;
--- 7035,7041 ----
   * Print error messages if 'perr' is TRUE.
   */
      int
! match_delete(win_T *wp, int id, int perr)
  {
      matchitem_T	*cur = wp->w_match_head;
      matchitem_T	*prev = cur;
***************
*** 7206,7213 ****
   * Delete all matches in the match list of window 'wp'.
   */
      void
! clear_matches(wp)
!     win_T	*wp;
  {
      matchitem_T *m;
  
--- 7092,7098 ----
   * Delete all matches in the match list of window 'wp'.
   */
      void
! clear_matches(win_T *wp)
  {
      matchitem_T *m;
  
***************
*** 7227,7235 ****
   * Return NULL if match not found.
   */
      matchitem_T *
! get_match(wp, id)
!     win_T	*wp;
!     int		id;
  {
      matchitem_T *cur = wp->w_match_head;
  
--- 7112,7118 ----
   * Return NULL if match not found.
   */
      matchitem_T *
! get_match(win_T *wp, int id)
  {
      matchitem_T *cur = wp->w_match_head;
  
***************
*** 7278,7286 ****
   * Return TRUE if "topfrp" and its children are at the right height.
   */
      static int
! frame_check_height(topfrp, height)
!     frame_T *topfrp;
!     int	    height;
  {
      frame_T *frp;
  
--- 7161,7167 ----
   * Return TRUE if "topfrp" and its children are at the right height.
   */
      static int
! frame_check_height(frame_T *topfrp, int height)
  {
      frame_T *frp;
  
***************
*** 7301,7309 ****
   * Return TRUE if "topfrp" and its children are at the right width.
   */
      static int
! frame_check_width(topfrp, width)
!     frame_T *topfrp;
!     int	    width;
  {
      frame_T *frp;
  
--- 7182,7188 ----
   * Return TRUE if "topfrp" and its children are at the right width.
   */
      static int
! frame_check_width(frame_T *topfrp, int width)
  {
      frame_T *frp;
  
*** ../vim-7.4.1214/src/workshop.c	2010-12-17 20:09:31.000000000 +0100
--- src/workshop.c	2016-01-30 21:19:33.799393425 +0100
***************
*** 98,104 ****
  
  
      void
! workshop_init()
  {
      char_u	 buf[64];
      int		 is_dirty = FALSE;
--- 98,104 ----
  
  
      void
! workshop_init(void)
  {
      char_u	 buf[64];
      int		 is_dirty = FALSE;
***************
*** 148,154 ****
  }
  
      void
! workshop_postinit()
  {
      do_cmdline_cmd((char_u *)initialFileCmd);
      ALT_INPUT_LOCK_OFF;
--- 148,154 ----
  }
  
      void
! workshop_postinit(void)
  {
      do_cmdline_cmd((char_u *)initialFileCmd);
      ALT_INPUT_LOCK_OFF;
***************
*** 170,176 ****
   * of NEdit, for example, when the connection is initiated from the editor.
   */
      char *
! workshop_get_editor_name()
  {
      return "gvim";
  }
--- 170,176 ----
   * of NEdit, for example, when the connection is initiated from the editor.
   */
      char *
! workshop_get_editor_name(void)
  {
      return "gvim";
  }
***************
*** 181,187 ****
   * version to the application.
   */
      char *
! workshop_get_editor_version()
  {
      return Version;
  }
--- 181,187 ----
   * version to the application.
   */
      char *
! workshop_get_editor_version(void)
  {
      return Version;
  }
***************
*** 288,294 ****
  }
  
      void
! workshop_save_files()
  {
      /* Save the given file */
  #ifdef WSDEBUG_TRACE
--- 288,294 ----
  }
  
      void
! workshop_save_files(void)
  {
      /* Save the given file */
  #ifdef WSDEBUG_TRACE
***************
*** 300,306 ****
  }
  
      void
! workshop_quit()
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 300,306 ----
  }
  
      void
! workshop_quit(void)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 311,317 ****
  }
  
      void
! workshop_minimize()
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 311,317 ----
  }
  
      void
! workshop_minimize(void)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 320,326 ****
      workshop_minimize_shell(vimShell);
  }
      void
! workshop_maximize()
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 320,326 ----
      workshop_minimize_shell(vimShell);
  }
      void
! workshop_maximize(void)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 510,516 ****
  }
  
      int
! workshop_get_font_height()
  {
      XmFontList	 fontList;	/* fontList made from gui.norm_font */
      XmString	 str;
--- 510,516 ----
  }
  
      int
! workshop_get_font_height(void)
  {
      XmFontList	 fontList;	/* fontList made from gui.norm_font */
      XmString	 str;
***************
*** 623,629 ****
   */
  
      void
! workshop_submenu_end()
  {
      char		*p;
  
--- 623,629 ----
   */
  
      void
! workshop_submenu_end(void)
  {
      char		*p;
  
***************
*** 720,726 ****
   */
  
      void
! workshop_menu_end()
  {
      Boolean		 using_tearoff;	/* set per current option setting */
  
--- 720,726 ----
   */
  
      void
! workshop_menu_end(void)
  {
      Boolean		 using_tearoff;	/* set per current option setting */
  
***************
*** 734,740 ****
  }
  
      void
! workshop_toolbar_begin()
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
--- 734,740 ----
  }
  
      void
! workshop_toolbar_begin(void)
  {
  #ifdef WSDEBUG_TRACE
      if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
***************
*** 746,752 ****
  }
  
      void
! workshop_toolbar_end()
  {
      char_u	buf[64];
  
--- 746,752 ----
  }
  
      void
! workshop_toolbar_end(void)
  {
      char_u	buf[64];
  
***************
*** 1405,1411 ****
  /* For the NoHands test suite */
  
      char *
! workshop_test_getcurrentfile()
  {
      char	*filename, *selection;
      int		curLine, curCol, selStartLine, selStartCol, selEndLine;
--- 1405,1411 ----
  /* For the NoHands test suite */
  
      char *
! workshop_test_getcurrentfile(void)
  {
      char	*filename, *selection;
      int		curLine, curCol, selStartLine, selStartCol, selEndLine;
***************
*** 1421,1433 ****
  }
  
      int
! workshop_test_getcursorrow()
  {
      return 0;
  }
  
      int
! workshop_test_getcursorcol()
  {
      char	*filename, *selection;
      int		curLine, curCol, selStartLine, selStartCol, selEndLine;
--- 1421,1433 ----
  }
  
      int
! workshop_test_getcursorrow(void)
  {
      return 0;
  }
  
      int
! workshop_test_getcursorcol(void)
  {
      char	*filename, *selection;
      int		curLine, curCol, selStartLine, selStartCol, selEndLine;
***************
*** 1443,1455 ****
  }
  
      char *
! workshop_test_getcursorrowtext()
  {
      return NULL;
  }
  
      char *
! workshop_test_getselectedtext()
  {
      char	*filename, *selection;
      int		curLine, curCol, selStartLine, selStartCol, selEndLine;
--- 1443,1455 ----
  }
  
      char *
! workshop_test_getcursorrowtext(void)
  {
      return NULL;
  }
  
      char *
! workshop_test_getselectedtext(void)
  {
      char	*filename, *selection;
      int		curLine, curCol, selStartLine, selStartCol, selEndLine;
*** ../vim-7.4.1214/src/xpm_w32.c	2016-01-29 23:20:35.313308119 +0100
--- src/xpm_w32.c	2016-01-30 21:19:57.343147242 +0100
***************
*** 28,37 ****
   * "hShape".
   */
      int
! LoadXpmImage(filename, hImage, hShape)
!     char    *filename;
!     HBITMAP *hImage;
!     HBITMAP *hShape;
  {
      XImage	    *img;  /* loaded image */
      XImage	    *shp;  /* shapeimage */
--- 28,37 ----
   * "hShape".
   */
      int
! LoadXpmImage(
!     char    *filename,
!     HBITMAP *hImage,
!     HBITMAP *hShape)
  {
      XImage	    *img;  /* loaded image */
      XImage	    *shp;  /* shapeimage */
*** ../vim-7.4.1214/runtime/doc/doctags.c	2010-05-15 13:04:00.000000000 +0200
--- runtime/doc/doctags.c	2016-01-30 21:20:54.298551718 +0100
***************
*** 14,22 ****
  #define LINELEN 200
  
  	int
! main(argc, argv)
! 	int		argc;
! 	char	**argv;
  {
  	char	line[LINELEN];
  	char	*p1, *p2;
--- 14,20 ----
  #define LINELEN 200
  
  	int
! main(int argc, char **argv)
  {
  	char	line[LINELEN];
  	char	*p1, *p2;
*** ../vim-7.4.1214/runtime/tools/xcmdsrv_client.c	2016-01-29 23:20:35.313308119 +0100
--- runtime/tools/xcmdsrv_client.c	2016-01-30 21:23:42.896789027 +0100
***************
*** 94,105 ****
   */
  
      char *
! sendToVim(dpy, name, cmd, asKeys, code)
!     Display	*dpy;			/* Where to send. */
!     char	*name;			/* Where to send. */
!     char	*cmd;			/* What to send. */
!     int		asKeys;			/* Interpret as keystrokes or expr ? */
!     int		*code;			/* Return code. 0 => OK */
  {
      Window	    w;
      Atom	    *plist;
--- 94,105 ----
   */
  
      char *
! sendToVim(
!     Display	*dpy,			/* Where to send. */
!     char	*name,			/* Where to send. */
!     char	*cmd,			/* What to send. */
!     int		asKeys,			/* Interpret as keystrokes or expr ? */
!     int		*code)			/* Return code. 0 => OK */
  {
      Window	    w;
      Atom	    *plist;
***************
*** 245,252 ****
   */
  
      static int
! SendInit(dpy)
!     Display *dpy;
  {
      XErrorHandler old_handler;
  
--- 245,251 ----
   */
  
      static int
! SendInit(Display *dpy)
  {
      XErrorHandler old_handler;
  
***************
*** 289,299 ****
   */
  
      static Window
! LookupName(dpy, name, delete, loose)
!     Display *dpy;	/* Display whose registry to check. */
!     char *name;		/* Name of an interpreter. */
!     int delete;		/* If non-zero, delete info about name. */
!     char **loose;	/* Do another search matching -999 if not found
  			   Return result here if a match is found */
  {
      unsigned char   *regProp, *entry;
--- 288,298 ----
   */
  
      static Window
! LookupName(
!     Display *dpy,	/* Display whose registry to check. */
!     char *name,		/* Name of an interpreter. */
!     int delete,		/* If non-zero, delete info about name. */
!     char **loose)	/* Do another search matching -999 if not found
  			   Return result here if a match is found */
  {
      unsigned char   *regProp, *entry;
***************
*** 396,406 ****
  }
  
      static char *
! SendEventProc(dpy, eventPtr, expected, code)
!     Display	   *dpy;
!     XEvent	    *eventPtr;		/* Information about event. */
!     int		    expected;		/* The one were waiting for */
!     int		    *code;		/* Return code. 0 => OK */
  {
      unsigned char   *propInfo;
      unsigned char   *p;
--- 395,405 ----
  }
  
      static char *
! SendEventProc(
!     Display	   *dpy,
!     XEvent	    *eventPtr,		/* Information about event. */
!     int		    expected,		/* The one were waiting for */
!     int		    *code)		/* Return code. 0 => OK */
  {
      unsigned char   *propInfo;
      unsigned char   *p;
***************
*** 535,547 ****
   */
  
      static int
! AppendPropCarefully(dpy, window, property, value, length)
!     Display *dpy;		/* Display on which to operate. */
!     Window window;		/* Window whose property is to
  				 * be modified. */
!     Atom property;		/* Name of property. */
!     char *value;		/* Characters  to append to property. */
!     int  length;		/* How much to append */
  {
      XErrorHandler old_handler;
  
--- 534,546 ----
   */
  
      static int
! AppendPropCarefully(
!     Display *dpy,		/* Display on which to operate. */
!     Window window,		/* Window whose property is to
  				 * be modified. */
!     Atom property,		/* Name of property. */
!     char *value,		/* Characters  to append to property. */
!     int  length)		/* How much to append */
  {
      XErrorHandler old_handler;
  
***************
*** 560,568 ****
   */
  /* ARGSUSED */
      static int
! x_error_check(dpy, error_event)
!     Display *dpy;
!     XErrorEvent	*error_event;
  {
      got_x_error = TRUE;
      return 0;
--- 559,565 ----
   */
  /* ARGSUSED */
      static int
! x_error_check(Display *dpy, XErrorEvent *error_event)
  {
      got_x_error = TRUE;
      return 0;
***************
*** 573,580 ****
   * Actually just checks if the name ends in a digit.
   */
      static int
! IsSerialName(str)
!     char   *str;
  {
      int len = strlen(str);
  
--- 570,576 ----
   * Actually just checks if the name ends in a digit.
   */
      static int
! IsSerialName(char *str)
  {
      int len = strlen(str);
  
*** ../vim-7.4.1214/src/po/sjiscorr.c	2014-11-12 13:07:48.774069557 +0100
--- src/po/sjiscorr.c	2016-01-30 21:25:43.427529029 +0100
***************
*** 7,15 ****
  #include <string.h>
  
  	int
! main(argc, argv)
! 	int	argc;
! 	char	**argv;
  {
  	char buffer[BUFSIZ];
  	char *p;
--- 7,13 ----
  #include <string.h>
  
  	int
! main(int argc, char **argv);
  {
  	char buffer[BUFSIZ];
  	char *p;
*** ../vim-7.4.1214/src/xxd/xxd.c	2015-08-04 17:29:02.859390663 +0200
--- src/xxd/xxd.c	2016-01-30 21:27:56.914133737 +0100
***************
*** 234,240 ****
  static char *pname;
  
    static void
! exit_with_usage()
  {
    fprintf(stderr, "Usage:\n       %s [options] [infile [outfile]]\n", pname);
    fprintf(stderr, "    or\n       %s -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]\n", pname);
--- 234,240 ----
  static char *pname;
  
    static void
! exit_with_usage(void)
  {
    fprintf(stderr, "Usage:\n       %s [options] [infile [outfile]]\n", pname);
    fprintf(stderr, "    or\n       %s -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]\n", pname);
***************
*** 264,271 ****
  }
  
    static void
! die(ret)
!   int ret;
  {
    fprintf(stderr, "%s: ", pname);
    perror(NULL);
--- 264,270 ----
  }
  
    static void
! die(int ret)
  {
    fprintf(stderr, "%s: ", pname);
    perror(NULL);
***************
*** 280,289 ****
   * The name is historic and came from 'undo type opt h'.
   */
    static int
! huntype(fpi, fpo, fperr, cols, hextype, base_off)
!   FILE *fpi, *fpo, *fperr;
!   int cols, hextype;
!   long base_off;
  {
    int c, ign_garb = 1, n1 = -1, n2 = 0, n3, p = cols;
    long have_off = 0, want_off = 0;
--- 279,291 ----
   * The name is historic and came from 'undo type opt h'.
   */
    static int
! huntype(
!   FILE *fpi,
!   FILE *fpo,
!   FILE *fperr,
!   int cols,
!   int hextype,
!   long base_off)
  {
    int c, ign_garb = 1, n1 = -1, n2 = 0, n3, p = cols;
    long have_off = 0, want_off = 0;
***************
*** 409,418 ****
   * If nz is always positive, lines are never suppressed.
   */
    static void
! xxdline(fp, l, nz)
!   FILE *fp;
!   char *l;
!   int nz;
  {
    static char z[LLEN+1];
    static int zero_seen = 0;
--- 411,417 ----
   * If nz is always positive, lines are never suppressed.
   */
    static void
! xxdline(FILE *fp, char *l, int nz)
  {
    static char z[LLEN+1];
    static int zero_seen = 0;
***************
*** 472,480 ****
  };
  
    int
! main(argc, argv)
!   int argc;
!   char *argv[];
  {
    FILE *fp, *fpo;
    int c, e, p = 0, relseek = 1, negseek = 0, revert = 0;
--- 471,477 ----
  };
  
    int
! main(int argc, char *argv[])
  {
    FILE *fp, *fpo;
    int c, e, p = 0, relseek = 1, negseek = 0, revert = 0;
*** ../vim-7.4.1214/src/version.c	2016-01-30 21:10:05.009342495 +0100
--- src/version.c	2016-01-30 21:12:52.727587971 +0100
***************
*** 748,749 ****
--- 748,751 ----
  {   /* Add new patch number below this line */
+ /**/
+     1215,
  /**/

-- 
From "know your smileys":
 |-P	Reaction to unusually ugly C code

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
