To: vim_dev@googlegroups.com
Subject: Patch 7.4.1303
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1303
Problem:    A Funcref is not accepted as a callback.
Solution:   Make a Funcref work. (Damien)
Files:      src/eval.c, src/testdir/test_channel.vim


*** ../vim-7.4.1302/src/eval.c	2016-02-11 12:48:32.692069619 +0100
--- src/eval.c	2016-02-11 20:40:21.910290189 +0100
***************
*** 9871,9882 ****
  
      if (argvars[1].v_type == VAR_DICT)
      {
! 	/* parse argdict */
! 	dict_T	*dict = argvars[1].vval.v_dict;
  
! 	if (dict_find(dict, (char_u *)"mode", -1) != NULL)
  	{
! 	    mode = get_dict_string(dict, (char_u *)"mode", FALSE);
  	    if (STRCMP(mode, "raw") == 0)
  		ch_mode = MODE_RAW;
  	    else if (STRCMP(mode, "js") == 0)
--- 9871,9883 ----
  
      if (argvars[1].v_type == VAR_DICT)
      {
! 	dict_T	    *dict = argvars[1].vval.v_dict;
! 	dictitem_T  *item;
  
! 	/* parse argdict */
! 	if ((item = dict_find(dict, (char_u *)"mode", -1)) != NULL)
  	{
! 	    mode = get_tv_string(&item->di_tv);
  	    if (STRCMP(mode, "raw") == 0)
  		ch_mode = MODE_RAW;
  	    else if (STRCMP(mode, "js") == 0)
***************
*** 9889,9900 ****
  		return;
  	    }
  	}
! 	if (dict_find(dict, (char_u *)"waittime", -1) != NULL)
! 	    waittime = get_dict_number(dict, (char_u *)"waittime");
! 	if (dict_find(dict, (char_u *)"timeout", -1) != NULL)
! 	    timeout = get_dict_number(dict, (char_u *)"timeout");
! 	if (dict_find(dict, (char_u *)"callback", -1) != NULL)
! 	    callback = get_dict_string(dict, (char_u *)"callback", FALSE);
      }
      if (waittime < 0 || timeout < 0)
      {
--- 9890,9901 ----
  		return;
  	    }
  	}
! 	if ((item = dict_find(dict, (char_u *)"waittime", -1)) != NULL)
! 	    waittime = get_tv_number(&item->di_tv);
! 	if ((item = dict_find(dict, (char_u *)"timeout", -1)) != NULL)
! 	    timeout = get_tv_number(&item->di_tv);
! 	if ((item = dict_find(dict, (char_u *)"callback", -1)) != NULL)
! 	    callback = get_callback(&item->di_tv);
      }
      if (waittime < 0 || timeout < 0)
      {
*** ../vim-7.4.1302/src/testdir/test_channel.vim	2016-02-10 23:28:15.283268981 +0100
--- src/testdir/test_channel.vim	2016-02-11 20:38:30.583464452 +0100
***************
*** 118,123 ****
--- 118,130 ----
    call assert_equal(handle, s:responseHandle)
    call assert_equal('got it', s:responseMsg)
  
+   let s:responseHandle = -1
+   let s:responseMsg = ''
+   call ch_sendexpr(handle, 'hello!', function('s:RequestHandler'))
+   sleep 10m
+   call assert_equal(handle, s:responseHandle)
+   call assert_equal('got it', s:responseMsg)
+ 
    " Send an eval request that works.
    call assert_equal('ok', ch_sendexpr(handle, 'eval-works'))
    sleep 10m
***************
*** 206,218 ****
  
  let s:reply = ""
  func s:Handler(chan, msg)
    let s:reply = a:msg
  endfunc
  
  func s:channel_handler(port)
!   let chopt = copy(s:chopt)
!   let chopt['callback'] = 's:Handler'
!   let handle = ch_open('localhost:' . a:port, chopt)
    if handle < 0
      call assert_false(1, "Can't open channel")
      return
--- 213,224 ----
  
  let s:reply = ""
  func s:Handler(chan, msg)
+   unlet s:reply
    let s:reply = a:msg
  endfunc
  
  func s:channel_handler(port)
!   let handle = ch_open('localhost:' . a:port, s:chopt)
    if handle < 0
      call assert_false(1, "Can't open channel")
      return
***************
*** 230,236 ****
--- 236,246 ----
  endfunc
  
  func Test_channel_handler()
+   let s:chopt.callback = 's:Handler'
+   call s:run_server('s:channel_handler')
+   let s:chopt.callback = function('s:Handler')
    call s:run_server('s:channel_handler')
+   unlet s:chopt.callback
  endfunc
  
  " Test that trying to connect to a non-existing port fails quickly.
*** ../vim-7.4.1302/src/version.c	2016-02-11 12:48:32.696069578 +0100
--- src/version.c	2016-02-11 20:37:43.247963878 +0100
***************
*** 749,750 ****
--- 749,752 ----
  {   /* Add new patch number below this line */
+ /**/
+     1303,
  /**/

-- 
The term "free software" is defined by Richard M. Stallman as
being software that isn't necessarily for free.  Confusing?
Let's call it "Stallman software" then!
				-- Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
