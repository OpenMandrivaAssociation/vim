To: vim_dev@googlegroups.com
Subject: Patch 7.4.1339
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1339
Problem:    Warnings when building the GUI with MingW. (Cesar Romani)
Solution:   Add type cats. (Yasuhiro Matsumoto)
Files:      src/edit.c, src/gui_w32.c, src/gui_w48.c, src/os_mswin.c,
            src/os_win32.c


*** ../vim-7.4.1338/src/edit.c	2016-02-09 21:24:40.988610334 +0100
--- src/edit.c	2016-02-16 20:03:08.305104484 +0100
***************
*** 328,334 ****
  {
      int		c = 0;
      char_u	*ptr;
!     int		lastc;
      int		mincol;
      static linenr_T o_lnum = 0;
      int		i;
--- 328,334 ----
  {
      int		c = 0;
      char_u	*ptr;
!     int		lastc = 0;
      int		mincol;
      static linenr_T o_lnum = 0;
      int		i;
*** ../vim-7.4.1338/src/gui_w32.c	2016-01-31 17:30:47.422544414 +0100
--- src/gui_w32.c	2016-02-16 20:03:08.305104484 +0100
***************
*** 1131,1137 ****
  
  			    if (STRLEN(str) < sizeof(lpdi->szText)
  				    || ((tt_text = vim_strsave(str)) == NULL))
! 				vim_strncpy(lpdi->szText, str,
  						sizeof(lpdi->szText) - 1);
  			    else
  				lpdi->lpszText = tt_text;
--- 1131,1137 ----
  
  			    if (STRLEN(str) < sizeof(lpdi->szText)
  				    || ((tt_text = vim_strsave(str)) == NULL))
! 				vim_strncpy((char_u *)lpdi->szText, str,
  						sizeof(lpdi->szText) - 1);
  			    else
  				lpdi->lpszText = tt_text;
***************
*** 1747,1755 ****
  
      /* Initialise the struct */
      s_findrep_struct.lStructSize = sizeof(s_findrep_struct);
!     s_findrep_struct.lpstrFindWhat = alloc(MSWIN_FR_BUFSIZE);
      s_findrep_struct.lpstrFindWhat[0] = NUL;
!     s_findrep_struct.lpstrReplaceWith = alloc(MSWIN_FR_BUFSIZE);
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
--- 1747,1755 ----
  
      /* Initialise the struct */
      s_findrep_struct.lStructSize = sizeof(s_findrep_struct);
!     s_findrep_struct.lpstrFindWhat = (LPSTR)alloc(MSWIN_FR_BUFSIZE);
      s_findrep_struct.lpstrFindWhat[0] = NUL;
!     s_findrep_struct.lpstrReplaceWith = (LPSTR)alloc(MSWIN_FR_BUFSIZE);
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
***************
*** 2099,2105 ****
      pImmGetCompositionStringA(hIMC, GCS, buf, ret);
  
      /* convert from codepage to UCS-2 */
!     MultiByteToWideChar_alloc(GetACP(), 0, buf, ret, &wbuf, lenp);
      vim_free(buf);
  
      return (short_u *)wbuf;
--- 2099,2105 ----
      pImmGetCompositionStringA(hIMC, GCS, buf, ret);
  
      /* convert from codepage to UCS-2 */
!     MultiByteToWideChar_alloc(GetACP(), 0, (LPCSTR)buf, ret, &wbuf, lenp);
      vim_free(buf);
  
      return (short_u *)wbuf;
***************
*** 3028,3034 ****
  
      HWND thwnd = menu->tearoff_handle;
  
!     GetWindowText(thwnd, tbuf, 127);
      if (GetWindowRect(thwnd, &trect)
  	    && GetWindowRect(s_hwnd, &rct)
  	    && GetClientRect(s_hwnd, &roct))
--- 3028,3034 ----
  
      HWND thwnd = menu->tearoff_handle;
  
!     GetWindowText(thwnd, (LPSTR)tbuf, 127);
      if (GetWindowRect(thwnd, &trect)
  	    && GetWindowRect(s_hwnd, &rct)
  	    && GetClientRect(s_hwnd, &roct))
***************
*** 3174,3180 ****
  	    else
  # endif
  		GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
! 							 s_textfield, IOSIZE);
  	}
  
  	/*
--- 3174,3180 ----
  	    else
  # endif
  		GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
! 						(LPSTR)s_textfield, IOSIZE);
  	}
  
  	/*
***************
*** 3216,3222 ****
   * If stubbing out this fn, return 1.
   */
  
! static const char_u *dlg_icons[] = /* must match names in resource file */
  {
      "IDR_VIM",
      "IDR_VIM_ERROR",
--- 3216,3222 ----
   * If stubbing out this fn, return 1.
   */
  
! static const char *dlg_icons[] = /* must match names in resource file */
  {
      "IDR_VIM",
      "IDR_VIM_ERROR",
***************
*** 3353,3359 ****
      fontHeight = fontInfo.tmHeight;
  
      /* Minimum width for horizontal button */
!     minButtonWidth = GetTextWidth(hdc, "Cancel", 6);
  
      /* Maximum width of a dialog, if possible */
      if (s_hwnd == NULL)
--- 3353,3359 ----
      fontHeight = fontInfo.tmHeight;
  
      /* Minimum width for horizontal button */
!     minButtonWidth = GetTextWidth(hdc, (char_u *)"Cancel", 6);
  
      /* Maximum width of a dialog, if possible */
      if (s_hwnd == NULL)
***************
*** 3617,3623 ****
  				   + 2 * fontHeight * i),
  		    PixelToDialogX(dlgwidth - 2 * DLG_VERT_PADDING_X),
  		    (WORD)(PixelToDialogY(2 * fontHeight) - 1),
! 		    (WORD)(IDCANCEL + 1 + i), (WORD)0x0080, pstart);
  	}
  	else
  	{
--- 3617,3623 ----
  				   + 2 * fontHeight * i),
  		    PixelToDialogX(dlgwidth - 2 * DLG_VERT_PADDING_X),
  		    (WORD)(PixelToDialogY(2 * fontHeight) - 1),
! 		    (WORD)(IDCANCEL + 1 + i), (WORD)0x0080, (char *)pstart);
  	}
  	else
  	{
***************
*** 3628,3634 ****
  		    PixelToDialogY(buttonYpos), /* TBK */
  		    PixelToDialogX(buttonWidths[i]),
  		    (WORD)(PixelToDialogY(2 * fontHeight) - 1),
! 		    (WORD)(IDCANCEL + 1 + i), (WORD)0x0080, pstart);
  	}
  	pstart = pend + 1;	/*next button*/
      }
--- 3628,3634 ----
  		    PixelToDialogY(buttonYpos), /* TBK */
  		    PixelToDialogX(buttonWidths[i]),
  		    (WORD)(PixelToDialogY(2 * fontHeight) - 1),
! 		    (WORD)(IDCANCEL + 1 + i), (WORD)0x0080, (char *)pstart);
  	}
  	pstart = pend + 1;	/*next button*/
      }
***************
*** 3649,3655 ****
  	    PixelToDialogY(dlgPaddingY),
  	    (WORD)(PixelToDialogX(messageWidth) + 1),
  	    PixelToDialogY(msgheight),
! 	    DLG_NONBUTTON_CONTROL + 1, (WORD)0x0081, message);
  
      /* Edit box */
      if (textfield != NULL)
--- 3649,3655 ----
  	    PixelToDialogY(dlgPaddingY),
  	    (WORD)(PixelToDialogX(messageWidth) + 1),
  	    PixelToDialogY(msgheight),
! 	    DLG_NONBUTTON_CONTROL + 1, (WORD)0x0081, (char *)message);
  
      /* Edit box */
      if (textfield != NULL)
***************
*** 3659,3665 ****
  		PixelToDialogY(2 * dlgPaddingY + msgheight),
  		PixelToDialogX(dlgwidth - 4 * dlgPaddingX),
  		PixelToDialogY(fontHeight + dlgPaddingY),
! 		DLG_NONBUTTON_CONTROL + 2, (WORD)0x0081, textfield);
  	*pnumitems += 1;
      }
  
--- 3659,3665 ----
  		PixelToDialogY(2 * dlgPaddingY + msgheight),
  		PixelToDialogX(dlgwidth - 4 * dlgPaddingX),
  		PixelToDialogY(fontHeight + dlgPaddingY),
! 		DLG_NONBUTTON_CONTROL + 2, (WORD)0x0081, (char *)textfield);
  	*pnumitems += 1;
      }
  
***************
*** 3798,3804 ****
      if (enc_codepage == 0 && (int)GetACP() != enc_codepage)
      {
  	/* Not a codepage, use our own conversion function. */
! 	wn = enc_to_utf16(lpAnsiIn, NULL);
  	if (wn != NULL)
  	{
  	    wcscpy(lpWCStr, wn);
--- 3798,3804 ----
      if (enc_codepage == 0 && (int)GetACP() != enc_codepage)
      {
  	/* Not a codepage, use our own conversion function. */
! 	wn = enc_to_utf16((char_u *)lpAnsiIn, NULL);
  	if (wn != NULL)
  	{
  	    wcscpy(lpWCStr, wn);
***************
*** 4043,4049 ****
  
      /* Calculate width of a single space.  Used for padding columns to the
       * right width. */
!     spaceWidth = GetTextWidth(hdc, " ", 1);
  
      /* Figure out max width of the text column, the accelerator column and the
       * optional submenu column. */
--- 4043,4049 ----
  
      /* Calculate width of a single space.  Used for padding columns to the
       * right width. */
!     spaceWidth = GetTextWidth(hdc, (char_u *)" ", 1);
  
      /* Figure out max width of the text column, the accelerator column and the
       * optional submenu column. */
***************
*** 4086,4092 ****
      textWidth = columnWidths[0] + columnWidths[1];
      if (submenuWidth != 0)
      {
! 	submenuWidth = GetTextWidth(hdc, TEAROFF_SUBMENU_LABEL,
  					  (int)STRLEN(TEAROFF_SUBMENU_LABEL));
  	textWidth += submenuWidth;
      }
--- 4086,4092 ----
      textWidth = columnWidths[0] + columnWidths[1];
      if (submenuWidth != 0)
      {
! 	submenuWidth = GetTextWidth(hdc, (char_u *)TEAROFF_SUBMENU_LABEL,
  					  (int)STRLEN(TEAROFF_SUBMENU_LABEL));
  	textWidth += submenuWidth;
      }
***************
*** 4262,4268 ****
  		(WORD)(sepPadding + 1 + 13 * (*pnumitems)),
  		(WORD)PixelToDialogX(dlgwidth - 2 * TEAROFF_PADDING_X),
  		(WORD)12,
! 		menuID, (WORD)0x0080, label);
  	vim_free(label);
  	(*pnumitems)++;
      }
--- 4262,4268 ----
  		(WORD)(sepPadding + 1 + 13 * (*pnumitems)),
  		(WORD)PixelToDialogX(dlgwidth - 2 * TEAROFF_PADDING_X),
  		(WORD)12,
! 		menuID, (WORD)0x0080, (char *)label);
  	vim_free(label);
  	(*pnumitems)++;
      }
***************
*** 4360,4366 ****
  	    gui_find_iconfile(menu->iconfile, fname, "bmp");
  	    hbitmap = LoadImage(
  			NULL,
! 			fname,
  			IMAGE_BITMAP,
  			TOOLBAR_BUTTON_WIDTH,
  			TOOLBAR_BUTTON_HEIGHT,
--- 4360,4366 ----
  	    gui_find_iconfile(menu->iconfile, fname, "bmp");
  	    hbitmap = LoadImage(
  			NULL,
! 			(LPCSTR)fname,
  			IMAGE_BITMAP,
  			TOOLBAR_BUTTON_WIDTH,
  			TOOLBAR_BUTTON_HEIGHT,
***************
*** 4381,4387 ****
  					menu->dname, fname, "bmp") == OK))
  	    hbitmap = LoadImage(
  		    NULL,
! 		    fname,
  		    IMAGE_BITMAP,
  		    TOOLBAR_BUTTON_WIDTH,
  		    TOOLBAR_BUTTON_HEIGHT,
--- 4381,4387 ----
  					menu->dname, fname, "bmp") == OK))
  	    hbitmap = LoadImage(
  		    NULL,
! 		    (LPCSTR)fname,
  		    IMAGE_BITMAP,
  		    TOOLBAR_BUTTON_WIDTH,
  		    TOOLBAR_BUTTON_HEIGHT,
***************
*** 4629,4642 ****
  	    do_load = 0;
  
  	if (do_load)
! 	    sign.hImage = (HANDLE)LoadImage(NULL, signfile, sign.uType,
  		    gui.char_width * 2, gui.char_height,
  		    LR_LOADFROMFILE | LR_CREATEDIBSECTION);
  #ifdef FEAT_XPM_W32
  	if (!STRICMP(ext, ".xpm"))
  	{
  	    sign.uType = IMAGE_XPM;
! 	    LoadXpmImage(signfile, (HBITMAP *)&sign.hImage, (HBITMAP *)&sign.hShape);
  	}
  #endif
      }
--- 4629,4643 ----
  	    do_load = 0;
  
  	if (do_load)
! 	    sign.hImage = (HANDLE)LoadImage(NULL, (LPCSTR)signfile, sign.uType,
  		    gui.char_width * 2, gui.char_height,
  		    LR_LOADFROMFILE | LR_CREATEDIBSECTION);
  #ifdef FEAT_XPM_W32
  	if (!STRICMP(ext, ".xpm"))
  	{
  	    sign.uType = IMAGE_XPM;
! 	    LoadXpmImage((char *)signfile, (HBITMAP *)&sign.hImage,
! 		    (HBITMAP *)&sign.hShape);
  	}
  #endif
      }
***************
*** 4740,4752 ****
  		UINT vlen = 0;
  		void *data = alloc(len);
  
! 		if (data != NULL
  			&& GetFileVersionInfo(comctl_dll, 0, len, data)
  			&& VerQueryValue(data, "\\", (void **)&ver, &vlen)
  			&& vlen
! 			&& HIWORD(ver->dwFileVersionMS) > 4
! 			|| (HIWORD(ver->dwFileVersionMS) == 4
! 			    && LOWORD(ver->dwFileVersionMS) >= 70))
  		{
  		    vim_free(data);
  		    multiline_tip = TRUE;
--- 4741,4753 ----
  		UINT vlen = 0;
  		void *data = alloc(len);
  
! 		if ((data != NULL
  			&& GetFileVersionInfo(comctl_dll, 0, len, data)
  			&& VerQueryValue(data, "\\", (void **)&ver, &vlen)
  			&& vlen
! 			&& HIWORD(ver->dwFileVersionMS) > 4)
! 			|| ((HIWORD(ver->dwFileVersionMS) == 4
! 			    && LOWORD(ver->dwFileVersionMS) >= 70)))
  		{
  		    vim_free(data);
  		    multiline_tip = TRUE;
***************
*** 4908,4914 ****
      {
  	gui_mch_disable_beval_area(cur_beval);
  	beval->showState = ShS_SHOWING;
! 	make_tooltip(beval, mesg, pt);
      }
      // TRACE0("gui_mch_post_balloon }}}");
  }
--- 4909,4915 ----
      {
  	gui_mch_disable_beval_area(cur_beval);
  	beval->showState = ShS_SHOWING;
! 	make_tooltip(beval, (char *)mesg, pt);
      }
      // TRACE0("gui_mch_post_balloon }}}");
  }
*** ../vim-7.4.1338/src/gui_w48.c	2016-02-14 19:13:37.326808543 +0100
--- src/gui_w48.c	2016-02-16 20:03:08.305104484 +0100
***************
*** 534,540 ****
  	else
  	{
  	    string[0] = ch;
! 	    len = MultiByteToWideChar(GetACP(), 0, string, 1, wstring, 2);
  	}
      }
      else
--- 534,541 ----
  	else
  	{
  	    string[0] = ch;
! 	    len = MultiByteToWideChar(GetACP(), 0, (LPCSTR)string,
! 		    1, wstring, 2);
  	}
      }
      else
***************
*** 551,557 ****
  	if (enc_codepage > 0)
  	{
  	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 						       string, slen, 0, NULL);
  	    /* If we had included the ALT key into the character but now the
  	     * upper bit is no longer set, that probably means the conversion
  	     * failed.  Convert the original character and set the upper bit
--- 552,558 ----
  	if (enc_codepage > 0)
  	{
  	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
  	    /* If we had included the ALT key into the character but now the
  	     * upper bit is no longer set, that probably means the conversion
  	     * failed.  Convert the original character and set the upper bit
***************
*** 560,566 ****
  	    {
  		wstring[0] = ch & 0x7f;
  		len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 						       string, slen, 0, NULL);
  		if (len == 1) /* safety check */
  		    string[0] |= 0x80;
  	    }
--- 561,567 ----
  	    {
  		wstring[0] = ch & 0x7f;
  		len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
  		if (len == 1) /* safety check */
  		    string[0] |= 0x80;
  	    }
***************
*** 921,927 ****
      lpfrw->hwndOwner = lpfr->hwndOwner;
      lpfrw->Flags = lpfr->Flags;
  
!     wp = enc_to_utf16(lpfr->lpstrFindWhat, NULL);
      wcsncpy(lpfrw->lpstrFindWhat, wp, lpfrw->wFindWhatLen - 1);
      vim_free(wp);
  
--- 922,928 ----
      lpfrw->hwndOwner = lpfr->hwndOwner;
      lpfrw->Flags = lpfr->Flags;
  
!     wp = enc_to_utf16((char_u *)lpfr->lpstrFindWhat, NULL);
      wcsncpy(lpfrw->lpstrFindWhat, wp, lpfrw->wFindWhatLen - 1);
      vim_free(wp);
  
***************
*** 938,949 ****
  
      lpfr->Flags = lpfrw->Flags;
  
!     p = utf16_to_enc(lpfrw->lpstrFindWhat, NULL);
!     vim_strncpy(lpfr->lpstrFindWhat, p, lpfr->wFindWhatLen - 1);
      vim_free(p);
  
!     p = utf16_to_enc(lpfrw->lpstrReplaceWith, NULL);
!     vim_strncpy(lpfr->lpstrReplaceWith, p, lpfr->wReplaceWithLen - 1);
      vim_free(p);
  }
  # endif
--- 939,950 ----
  
      lpfr->Flags = lpfrw->Flags;
  
!     p = utf16_to_enc((short_u*)lpfrw->lpstrFindWhat, NULL);
!     vim_strncpy((char_u *)lpfr->lpstrFindWhat, p, lpfr->wFindWhatLen - 1);
      vim_free(p);
  
!     p = utf16_to_enc((short_u*)lpfrw->lpstrReplaceWith, NULL);
!     vim_strncpy((char_u *)lpfr->lpstrReplaceWith, p, lpfr->wReplaceWithLen - 1);
      vim_free(p);
  }
  # endif
***************
*** 1000,1007 ****
  	if (s_findrep_struct.Flags & FR_MATCHCASE)
  	    flags |= FRD_MATCH_CASE;
  	down = (s_findrep_struct.Flags & FR_DOWN) != 0;
! 	gui_do_findrepl(flags, s_findrep_struct.lpstrFindWhat,
! 				     s_findrep_struct.lpstrReplaceWith, down);
      }
  }
  #endif
--- 1001,1008 ----
  	if (s_findrep_struct.Flags & FR_MATCHCASE)
  	    flags |= FRD_MATCH_CASE;
  	down = (s_findrep_struct.Flags & FR_DOWN) != 0;
! 	gui_do_findrepl(flags, (char_u *)s_findrep_struct.lpstrFindWhat,
! 			     (char_u *)s_findrep_struct.lpstrReplaceWith, down);
      }
  }
  #endif
***************
*** 1530,1536 ****
      int		    r, g, b;
      int		    i;
  
!     if (name[0] == '#' && strlen(name) == 7)
      {
  	/* Name is in "#rrggbb" format */
  	r = hex_digit(name[1]) * 16 + hex_digit(name[2]);
--- 1531,1537 ----
      int		    r, g, b;
      int		    i;
  
!     if (name[0] == '#' && STRLEN(name) == 7)
      {
  	/* Name is in "#rrggbb" format */
  	r = hex_digit(name[1]) * 16 + hex_digit(name[2]);
***************
*** 2268,2274 ****
  {
      SIZE    size;
  
!     GetTextExtentPoint(hdc, str, len, &size);
      return size.cx;
  }
  
--- 2269,2275 ----
  {
      SIZE    size;
  
!     GetTextExtentPoint(hdc, (LPCSTR)str, len, &size);
      return size.cx;
  }
  
***************
*** 2468,2477 ****
  
      if (first_tabpage->tp_next != NULL)
  	add_tabline_popup_menu_entry(tab_pmenu,
! 					  TABLINE_MENU_CLOSE, _("Close tab"));
!     add_tabline_popup_menu_entry(tab_pmenu, TABLINE_MENU_NEW, _("New tab"));
!     add_tabline_popup_menu_entry(tab_pmenu, TABLINE_MENU_OPEN,
! 				 _("Open tab..."));
  
      GetCursorPos(&pt);
      rval = TrackPopupMenuEx(tab_pmenu, TPM_RETURNCMD, pt.x, pt.y, s_tabhwnd,
--- 2469,2479 ----
  
      if (first_tabpage->tp_next != NULL)
  	add_tabline_popup_menu_entry(tab_pmenu,
! 				TABLINE_MENU_CLOSE, (char_u *)_("Close tab"));
!     add_tabline_popup_menu_entry(tab_pmenu,
! 				TABLINE_MENU_NEW, (char_u *)_("New tab"));
!     add_tabline_popup_menu_entry(tab_pmenu,
! 				TABLINE_MENU_OPEN, (char_u *)_("Open tab..."));
  
      GetCursorPos(&pt);
      rval = TrackPopupMenuEx(tab_pmenu, TPM_RETURNCMD, pt.x, pt.y, s_tabhwnd,
***************
*** 2583,2589 ****
  	}
  
  	get_tabline_label(tp, FALSE);
! 	tie.pszText = NameBuff;
  #ifdef FEAT_MBYTE
  	wstr = NULL;
  	if (use_unicode)
--- 2585,2591 ----
  	}
  
  	get_tabline_label(tp, FALSE);
! 	tie.pszText = (LPSTR)NameBuff;
  #ifdef FEAT_MBYTE
  	wstr = NULL;
  	if (use_unicode)
***************
*** 2680,2686 ****
      if (wword)
  	s_findrep_struct.Flags |= FR_WHOLEWORD;
      if (entry_text != NULL && *entry_text != NUL)
! 	vim_strncpy(s_findrep_struct.lpstrFindWhat, entry_text,
  					   s_findrep_struct.wFindWhatLen - 1);
      vim_free(entry_text);
  }
--- 2682,2688 ----
      if (wword)
  	s_findrep_struct.Flags |= FR_WHOLEWORD;
      if (entry_text != NULL && *entry_text != NUL)
! 	vim_strncpy((char_u *)s_findrep_struct.lpstrFindWhat, entry_text,
  					   s_findrep_struct.wFindWhatLen - 1);
      vim_free(entry_text);
  }
***************
*** 3194,3204 ****
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	int	len;
! 	acp_to_enc(lf.lfFaceName, (int)strlen(lf.lfFaceName),
  						(char_u **)&font_name, &len);
      }
  #endif
!     res = alloc((unsigned)(strlen(font_name) + 20
  		    + (charset_name == NULL ? 0 : strlen(charset_name) + 2)));
      if (res != NULL)
      {
--- 3196,3206 ----
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	int	len;
! 	acp_to_enc((char_u *)lf.lfFaceName, (int)strlen(lf.lfFaceName),
  						(char_u **)&font_name, &len);
      }
  #endif
!     res = (char *)alloc((unsigned)(strlen(font_name) + 20
  		    + (charset_name == NULL ? 0 : strlen(charset_name) + 2)));
      if (res != NULL)
      {
***************
*** 3233,3239 ****
      if (font_name != lf.lfFaceName)
  	vim_free(font_name);
  #endif
!     return res;
  }
  
  
--- 3235,3241 ----
      if (font_name != lf.lfFaceName)
  	vim_free(font_name);
  #endif
!     return (char_u *)res;
  }
  
  
***************
*** 3323,3329 ****
  	return FAIL;
  
      if (font_name == NULL)
! 	font_name = lf.lfFaceName;
  #if defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME)
      norm_logfont = lf;
      sub_logfont = lf;
--- 3325,3331 ----
  	return FAIL;
  
      if (font_name == NULL)
! 	font_name = (char_u *)lf.lfFaceName;
  #if defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME)
      norm_logfont = lf;
      sub_logfont = lf;
***************
*** 3753,3764 ****
      fileStruct.lStructSize = sizeof(fileStruct);
  #endif
  
!     fileStruct.lpstrTitle = title;
!     fileStruct.lpstrDefExt = ext;
  
!     fileStruct.lpstrFile = fileBuf;
      fileStruct.nMaxFile = MAXPATHL;
!     fileStruct.lpstrFilter = filterp;
      fileStruct.hwndOwner = s_hwnd;		/* main Vim window is owner*/
      /* has an initial dir been specified? */
      if (initdir != NULL && *initdir != NUL)
--- 3755,3766 ----
      fileStruct.lStructSize = sizeof(fileStruct);
  #endif
  
!     fileStruct.lpstrTitle = (LPSTR)title;
!     fileStruct.lpstrDefExt = (LPSTR)ext;
  
!     fileStruct.lpstrFile = (LPSTR)fileBuf;
      fileStruct.nMaxFile = MAXPATHL;
!     fileStruct.lpstrFilter = (LPSTR)filterp;
      fileStruct.hwndOwner = s_hwnd;		/* main Vim window is owner*/
      /* has an initial dir been specified? */
      if (initdir != NULL && *initdir != NUL)
***************
*** 3769,3775 ****
  	    for (p = initdirp; *p != NUL; ++p)
  		if (*p == '/')
  		    *p = '\\';
! 	fileStruct.lpstrInitialDir = initdirp;
      }
  
      /*
--- 3771,3777 ----
  	    for (p = initdirp; *p != NUL; ++p)
  		if (*p == '/')
  		    *p = '\\';
! 	fileStruct.lpstrInitialDir = (LPSTR)initdirp;
      }
  
      /*
***************
*** 3851,3857 ****
  #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
! 		fnames[i] = vim_strsave(szFile);
  	    }
  	}
  
--- 3853,3859 ----
  #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
! 		fnames[i] = vim_strsave((char_u *)szFile);
  	    }
  	}
  
*** ../vim-7.4.1338/src/os_mswin.c	2016-02-16 15:06:54.669635233 +0100
--- src/os_mswin.c	2016-02-16 20:03:08.305104484 +0100
***************
*** 741,747 ****
  				     gui.starting ? (char_u *)_("Message") :
  #endif
  					     (char_u *)_("Error"),
! 				     p, (char_u *)_("&Ok"), 1, NULL, FALSE);
  		break;
  	    }
  	ga_clear(&error_ga);
--- 741,748 ----
  				     gui.starting ? (char_u *)_("Message") :
  #endif
  					     (char_u *)_("Error"),
! 				     (char_u *)p, (char_u *)_("&Ok"),
! 					1, NULL, FALSE);
  		break;
  	    }
  	ga_clear(&error_ga);
***************
*** 2951,2957 ****
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	int	len;
! 	enc_to_acp(name, (int)strlen((char *)name), &acpname, &len);
  	name = acpname;
      }
  #endif
--- 2952,2958 ----
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	int	len;
! 	enc_to_acp(name, (int)STRLEN(name), &acpname, &len);
  	name = acpname;
      }
  #endif
*** ../vim-7.4.1338/src/os_win32.c	2016-02-16 19:25:07.580925715 +0100
--- src/os_win32.c	2016-02-16 20:05:54.527365127 +0100
***************
*** 236,241 ****
--- 236,242 ----
  
  static BOOL win8_or_later = FALSE;
  
+ #ifndef FEAT_GUI_W32
  /*
   * Version of ReadConsoleInput() that works with IME.
   * Works around problems on Windows 8.
***************
*** 325,330 ****
--- 326,332 ----
      return read_console_input(hInput, lpBuffer, -1, lpEvents);
  }
  
+ # ifdef FEAT_CLIENTSERVER
      static DWORD
  msg_wait_for_multiple_objects(
      DWORD    nCount,
***************
*** 338,345 ****
      return MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll,
  				     dwMilliseconds, dwWakeMask);
  }
  
! #ifndef FEAT_CLIENTSERVER
      static DWORD
  wait_for_single_object(
      HANDLE hHandle,
--- 340,348 ----
      return MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll,
  				     dwMilliseconds, dwWakeMask);
  }
+ # endif
  
! # ifndef FEAT_CLIENTSERVER
      static DWORD
  wait_for_single_object(
      HANDLE hHandle,
***************
*** 349,354 ****
--- 352,359 ----
  	return WAIT_OBJECT_0;
      return WaitForSingleObject(hHandle, dwMilliseconds);
  }
+ # endif
+ #endif
  #endif
  
      static void
*** ../vim-7.4.1338/src/version.c	2016-02-16 19:44:14.736951039 +0100
--- src/version.c	2016-02-16 20:08:41.045623121 +0100
***************
*** 749,750 ****
--- 749,752 ----
  {   /* Add new patch number below this line */
+ /**/
+     1339,
  /**/

-- 
Facepalm reply #3: "I had a great time in Manhattan" "I thought you were
going to New York?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
