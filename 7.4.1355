To: vim_dev@googlegroups.com
Subject: Patch 7.4.1355
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1355
Problem:    Win32 console and GUI handle channels differently.
Solution:   Consolidate code between Win32 console and GUI.
Files:      src/channel.c, src/eval.c, src/gui_w48.c, src/os_win32.c,
            src/proto/channel.pro


*** ../vim-7.4.1354/src/channel.c	2016-02-18 22:23:21.169660447 +0100
--- src/channel.c	2016-02-19 20:59:19.203893645 +0100
***************
*** 1508,1524 ****
      static int
  channel_wait(channel_T *channel, sock_T fd, int timeout)
  {
- #if defined(HAVE_SELECT) && !defined(FEAT_GUI_W32)
-     struct timeval	tval;
-     fd_set		rfds;
-     int			ret;
- 
      if (timeout > 0)
  	ch_logn(channel, "Waiting for up to %d msec", timeout);
  
- 
  # ifdef WIN32
!     if (channel->CH_SOCK == CHAN_FD_INVALID)
      {
  	DWORD	nread;
  	int	diff;
--- 1508,1518 ----
      static int
  channel_wait(channel_T *channel, sock_T fd, int timeout)
  {
      if (timeout > 0)
  	ch_logn(channel, "Waiting for up to %d msec", timeout);
  
  # ifdef WIN32
!     if (fd != channel->CH_SOCK)
      {
  	DWORD	nread;
  	int	diff;
***************
*** 1537,1580 ****
  	     * TODO: increase the sleep time when looping more often */
  	    Sleep(5);
  	}
- 	return FAIL;
      }
  #endif
- 
-     FD_ZERO(&rfds);
-     FD_SET((int)fd, &rfds);
-     tval.tv_sec = timeout / 1000;
-     tval.tv_usec = (timeout % 1000) * 1000;
-     for (;;)
      {
! 	ret = select((int)fd + 1, &rfds, NULL, NULL, &tval);
! # ifdef EINTR
! 	if (ret == -1 && errno == EINTR)
! 	    continue;
! # endif
! 	if (ret <= 0)
! 	{
! 	    ch_log(channel, "Nothing to read");
! 	    return FAIL;
! 	}
! 	break;
!     }
  #else
! # ifdef HAVE_POLL
!     struct pollfd	fds;
  
!     if (timeout > 0)
! 	ch_logn(channel, "Waiting for %d msec", timeout);
!     fds.fd = fd;
!     fds.events = POLLIN;
!     if (poll(&fds, 1, timeout) <= 0)
!     {
! 	ch_log(channel, "Nothing to read");
! 	return FAIL;
!     }
  # endif
  #endif
!     return OK;
  }
  
  /*
--- 1531,1578 ----
  	     * TODO: increase the sleep time when looping more often */
  	    Sleep(5);
  	}
      }
+     else
  #endif
      {
! #if defined(FEAT_GUI_W32)
! 	/* Can't check socket for Win32 GUI, always return OK. */
! 	ch_log(channel, "Can't check, assuming there is something to read");
! 	return OK;
  #else
! # if defined(HAVE_SELECT)
! 	struct timeval	tval;
! 	fd_set		rfds;
! 	int			ret;
! 
! 	FD_ZERO(&rfds);
! 	FD_SET((int)fd, &rfds);
! 	tval.tv_sec = timeout / 1000;
! 	tval.tv_usec = (timeout % 1000) * 1000;
! 	for (;;)
! 	{
! 	    ret = select((int)fd + 1, &rfds, NULL, NULL, &tval);
! #  ifdef EINTR
! 	    SOCK_ERRNO;
! 	    if (ret == -1 && errno == EINTR)
! 		continue;
! #  endif
! 	    if (ret > 0)
! 		return OK;
! 	    break;
! 	}
! # else
! 	struct pollfd	fds;
  
! 	fds.fd = fd;
! 	fds.events = POLLIN;
! 	if (poll(&fds, 1, timeout) > 0)
! 	    return OK;
  # endif
  #endif
!     }
!     ch_log(channel, "Nothing to read");
!     return FAIL;
  }
  
  /*
***************
*** 1667,1674 ****
      }
  #endif
  
!     /* Reading a socket disconnection (readlen == 0), or a socket error. */
!     if (readlen <= 0)
      {
  	/* Queue a "DETACH" netbeans message in the command queue in order to
  	 * terminate the netbeans session later. Do not end the session here
--- 1665,1673 ----
      }
  #endif
  
!     /* Reading a socket disconnection (readlen == 0), or a socket error.
!      * TODO: call error callback. */
!     if (readlen <= 0 && channel->ch_job == NULL)
      {
  	/* Queue a "DETACH" netbeans message in the command queue in order to
  	 * terminate the netbeans session later. Do not end the session here
***************
*** 1836,1841 ****
--- 1835,1869 ----
  	}
      return NULL;
  }
+ 
+     void
+ channel_handle_events(void)
+ {
+     channel_T	*channel;
+     int		which;
+     static int	loop = 0;
+ 
+     /* Skip heavily polling */
+     if (loop++ % 2)
+ 	return;
+ 
+     for (channel = first_channel; channel != NULL; channel = channel->ch_next)
+     {
+ #  ifdef FEAT_GUI_W32
+ 	/* only check the pipes */
+ 	for (which = CHAN_OUT; which < CHAN_ERR; ++which)
+ #  else
+ #   ifdef CHANNEL_PIPES
+ 	/* check the socket and pipes */
+ 	for (which = CHAN_SOCK; which < CHAN_ERR; ++which)
+ #   else
+ 	/* only check the socket */
+ 	which = CHAN_SOCK;
+ #   endif
+ #  endif
+ 	channel_read(channel, which, "channel_handle_events");
+     }
+ }
  # endif
  
  /*
***************
*** 1969,1975 ****
  }
  # endif /* UNIX && !HAVE_SELECT */
  
! # if (!defined(FEAT_GUI_W32) && defined(HAVE_SELECT)) || defined(PROTO)
  /*
   * The type of "rfds" is hidden to avoid problems with the function proto.
   */
--- 1997,2003 ----
  }
  # endif /* UNIX && !HAVE_SELECT */
  
! # if (!defined(WIN32) && defined(HAVE_SELECT)) || defined(PROTO)
  /*
   * The type of "rfds" is hidden to avoid problems with the function proto.
   */
***************
*** 2034,2040 ****
  
      return ret;
  }
! # endif /* !FEAT_GUI_W32 && HAVE_SELECT */
  
  /*
   * Execute queued up commands.
--- 2062,2068 ----
  
      return ret;
  }
! # endif /* !WIN32 && HAVE_SELECT */
  
  /*
   * Execute queued up commands.
*** ../vim-7.4.1354/src/eval.c	2016-02-18 22:23:21.173660406 +0100
--- src/eval.c	2016-02-19 20:08:38.667979860 +0100
***************
*** 14635,14648 ****
  		ga_concat(&ga, (char_u *)"  ");
  	    ga_concat(&ga, (char_u *)argv[i]);
  	}
! 	ch_logs(NULL, "Starting job: %s", ga.ga_data);
  	ga_clear(&ga);
      }
  # endif
      mch_start_job(argv, job, &options);
  #else
  # ifdef FEAT_CHANNEL
!     ch_logs(NULL, "Starting job: %s", cmd);
  # endif
      mch_start_job((char *)cmd, job, &options);
  #endif
--- 14635,14648 ----
  		ga_concat(&ga, (char_u *)"  ");
  	    ga_concat(&ga, (char_u *)argv[i]);
  	}
! 	ch_logs(NULL, "Starting job: %s", (char *)ga.ga_data);
  	ga_clear(&ga);
      }
  # endif
      mch_start_job(argv, job, &options);
  #else
  # ifdef FEAT_CHANNEL
!     ch_logs(NULL, "Starting job: %s", (char *)cmd);
  # endif
      mch_start_job((char *)cmd, job, &options);
  #endif
*** ../vim-7.4.1354/src/gui_w48.c	2016-02-17 20:48:14.887567873 +0100
--- src/gui_w48.c	2016-02-19 20:52:42.580082266 +0100
***************
*** 2099,2104 ****
--- 2099,2108 ----
  	parse_queued_messages();
  #endif
  
+ #ifdef FEAT_CHANNEL
+ 	channel_handle_events();
+ #endif
+ 
  	/*
  	 * Don't use gui_mch_update() because then we will spin-lock until a
  	 * char arrives, instead we use GetMessage() to hang until an
*** ../vim-7.4.1354/src/os_win32.c	2016-02-16 21:02:17.603873545 +0100
--- src/os_win32.c	2016-02-19 20:52:58.331915879 +0100
***************
*** 1128,1157 ****
      SetConsoleMode(g_hConIn, cmodein);
  }
  
- #ifdef FEAT_CHANNEL
-     static int
- handle_channel_event(void)
- {
-     int		    ret;
-     fd_set	    rfds;
-     int		    maxfd;
- 
-     FD_ZERO(&rfds);
-     maxfd = channel_select_setup(-1, &rfds);
-     if (maxfd >= 0)
-     {
- 	struct timeval  tv;
- 
- 	tv.tv_sec = 0;
- 	tv.tv_usec = 0;
- 	ret = select(maxfd + 1, &rfds, NULL, NULL, &tv);
- 	if (ret > 0 && channel_select_check(ret, &rfds) > 0)
- 	    return TRUE;
-     }
-     return FALSE;
- }
- #endif
- 
  /*
   * Decode a MOUSE_EVENT.  If it's a valid event, return MOUSE_LEFT,
   * MOUSE_MIDDLE, or MOUSE_RIGHT for a click; MOUSE_DRAG for a mouse
--- 1128,1133 ----
***************
*** 1495,1502 ****
  #endif
  
  #ifdef FEAT_CHANNEL
! 	if (handle_channel_event())
! 	    return TRUE;
  #endif
  
  	if (0
--- 1471,1477 ----
  #endif
  
  #ifdef FEAT_CHANNEL
! 	channel_handle_events();
  #endif
  
  	if (0
*** ../vim-7.4.1354/src/proto/channel.pro	2016-02-18 22:23:21.173660406 +0100
--- src/proto/channel.pro	2016-02-19 20:53:33.843540778 +0100
***************
*** 30,35 ****
--- 30,36 ----
  char_u *channel_read_block(channel_T *channel);
  int channel_read_json_block(channel_T *channel, int id, typval_T **rettv);
  channel_T *channel_fd2channel(sock_T fd, int *whichp);
+ void channel_handle_events(void);
  int channel_send(channel_T *channel, char_u *buf, char *fun);
  int channel_poll_setup(int nfd_in, void *fds_in);
  int channel_poll_check(int ret_in, void *fds_in);
*** ../vim-7.4.1354/src/version.c	2016-02-19 19:43:45.779649915 +0100
--- src/version.c	2016-02-19 20:59:54.815517655 +0100
***************
*** 749,750 ****
--- 749,752 ----
  {   /* Add new patch number below this line */
+ /**/
+     1355,
  /**/


-- 
Luxury. We used to have to get out of the lake at three o'clock in the 
morning, clean the lake, eat a handful of hot gravel, go to work at the 
mill every day for tuppence a month, come home, and Dad would beat us 
around the head and neck with a broken bottle, if we were LUCKY!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
