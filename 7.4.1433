To: vim_dev@googlegroups.com
Subject: Patch 7.4.1433
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1433
Problem:    The Sniff interface is no longer useful, the tool has not been
            available for may years.
Solution:   Delete the Sniff interface and related code.
Files:      src/if_sniff.c, src/if_sniff.h, src/charset.c, src/edit.c,
            src/eval.c, src/ex_cmds2.c, src/ex_docmd.c, src/ex_getln.c,
            src/gui_gtk_x11.c, src/gui_w32.c, src/gui_x11.c, src/normal.c,
            src/os_unix.c, src/os_win32.c, src/term.c, src/ui.c,
            src/version.c, src/ex_cmds.h, src/feature.h, src/keymap.h,
            src/structs.h, src/vim.h, src/Make_mvc.mak, src/Make_vms.mms,
            src/Makefile, src/configure.in, src/auto/configure,
            src/config.h.in, src/config.mk.in, runtime/doc/if_sniff.txt,
            src/config.aap.in, src/main.aap


*** ../vim-7.4.1432/src/if_sniff.c	2016-01-30 17:24:01.798502450 +0100
--- src/if_sniff.c	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,1201 ****
- /* vi:set ts=8 sts=4 sw=4:
-  *
-  * if_sniff.c Interface between Vim and SNiFF+
-  *
-  * See README.txt for an overview of the Vim source code.
-  */
- 
- #include "vim.h"
- 
- #ifdef WIN32
- # include <stdio.h>
- # include <process.h>
- # include <string.h>
- # include <assert.h>
- #else
- # ifdef FEAT_GUI_X11
- #  include "gui_x11.pro"
- # endif
- # include "os_unixx.h"
- #endif
- 
- static int sniffemacs_pid;
- 
- int fd_from_sniff;
- int sniff_connected = 0;
- int sniff_request_waiting = 0;
- int want_sniff_request = 0;
- 
- #define MAX_REQUEST_LEN 512
- 
- #define NEED_SYMBOL	2
- #define EMPTY_SYMBOL	4
- #define NEED_FILE	8
- #define SILENT		16
- #define DISCONNECT	32
- #define CONNECT		64
- 
- #define RQ_NONE		0
- #define RQ_SIMPLE	1
- #define RQ_CONTEXT	NEED_FILE + NEED_SYMBOL
- #define RQ_SCONTEXT	NEED_FILE + NEED_SYMBOL + EMPTY_SYMBOL
- #define RQ_NOSYMBOL	NEED_FILE
- #define RQ_SILENT	RQ_NOSYMBOL + SILENT
- #define RQ_CONNECT	RQ_NONE + CONNECT
- #define RQ_DISCONNECT	RQ_SIMPLE + DISCONNECT
- 
- struct sn_cmd
- {
-     char *cmd_name;
-     char cmd_code;
-     char *cmd_msg;
-     int  cmd_type;
- };
- 
- struct sn_cmd_list
- {
-     struct sn_cmd* sniff_cmd;
-     struct sn_cmd_list* next_cmd;
- };
- 
- static struct sn_cmd sniff_cmds[] =
- {
-     { "toggle",		'e', N_("Toggle implementation/definition"),RQ_SCONTEXT },
-     { "superclass",	's', N_("Show base class of"),		RQ_CONTEXT },
-     { "overridden",	'm', N_("Show overridden member function"),RQ_SCONTEXT },
-     { "retrieve-file",	'r', N_("Retrieve from file"),		RQ_CONTEXT },
-     { "retrieve-project",'p', N_("Retrieve from project"),	RQ_CONTEXT },
-     { "retrieve-all-projects",
- 			'P', N_("Retrieve from all projects"),	RQ_CONTEXT },
-     { "retrieve-next",	'R', N_("Retrieve"),	RQ_CONTEXT },
-     { "goto-symbol",	'g', N_("Show source of"),		RQ_CONTEXT },
-     { "find-symbol",	'f', N_("Find symbol"),			RQ_CONTEXT },
-     { "browse-class",	'w', N_("Browse class"),		RQ_CONTEXT },
-     { "hierarchy",	't', N_("Show class in hierarchy"),	RQ_CONTEXT },
-     { "restr-hier",	'T', N_("Show class in restricted hierarchy"),RQ_CONTEXT },
-     { "xref-to",	'x', N_("Xref refers to"),		RQ_CONTEXT },
-     { "xref-by",	'X', N_("Xref referred by"),		RQ_CONTEXT },
-     { "xref-has",	'c', N_("Xref has a"),			RQ_CONTEXT },
-     { "xref-used-by",	'C', N_("Xref used by"),		RQ_CONTEXT },
-     { "show-docu",	'd', N_("Show docu of"),		RQ_CONTEXT },
-     { "gen-docu",	'D', N_("Generate docu for"),		RQ_CONTEXT },
-     { "connect",	'y', NULL,				RQ_CONNECT },
-     { "disconnect",	'q', NULL,				RQ_DISCONNECT },
-     { "font-info",	'z', NULL,				RQ_SILENT },
-     { "update",		'u', NULL,				RQ_SILENT },
-     { NULL,		'\0', NULL, 0}
- };
- 
- 
- static char *SniffEmacs[2] = {"sniffemacs", (char *)NULL};  /* Yes, Emacs! */
- static int fd_to_sniff;
- static int sniff_will_disconnect = 0;
- static char msg_sniff_disconnect[] = N_("Cannot connect to SNiFF+. Check environment (sniffemacs must be found in $PATH).\n");
- static char sniff_rq_sep[] = " ";
- static struct sn_cmd_list *sniff_cmd_ext = NULL;
- 
- /* Initializing vim commands
-  * executed each time vim connects to Sniff
-  */
- static char *init_cmds[]= {
-     "augroup sniff",
-     "autocmd BufWritePost * sniff update",
-     "autocmd BufReadPost * sniff font-info",
-     "autocmd VimLeave * sniff disconnect",
-     "augroup END",
- 
-     "let g:sniff_connected = 1",
- 
-     "if ! exists('g:sniff_mappings_sourced')|"
- 	"if ! exists('g:sniff_mappings')|"
- 	    "if exists('$SNIFF_DIR4')|"
- 		"let g:sniff_mappings='$SNIFF_DIR4/config/integrations/vim/sniff.vim'|"
- 	    "else|"
- 		"let g:sniff_mappings='$SNIFF_DIR/config/sniff.vim'|"
- 	    "endif|"
- 	"endif|"
- 	"let g:sniff_mappings=expand(g:sniff_mappings)|"
- 	"if filereadable(g:sniff_mappings)|"
- 	    "execute 'source' g:sniff_mappings|"
- 	    "let g:sniff_mappings_sourced=1|"
- 	"endif|"
-     "endif",
- 
-     NULL
- };
- 
- /*-------- Function Prototypes ----------------------------------*/
- 
- static int ConnectToSniffEmacs(void);
- static void sniff_connect(void);
- static void HandleSniffRequest(char* buffer);
- static int get_request(int fd, char *buf, int maxlen);
- static void WriteToSniff(char *str);
- static void SendRequest(struct sn_cmd *command, char* symbol);
- static void vi_msg(char *);
- static void vi_error_msg(char *);
- static char *vi_symbol_under_cursor(void);
- static void vi_open_file(char *);
- static char *vi_buffer_name(void);
- static buf_T *vi_find_buffer(char *);
- static void vi_exec_cmd(char *);
- static void vi_set_cursor_pos(long char_nr);
- static long vi_cursor_pos(void);
- 
- /* debug trace */
- #if 0
- static FILE* _tracefile = NULL;
- #define SNIFF_TRACE_OPEN(file) if (!_tracefile) _tracefile = fopen(file, "w")
- #define SNIFF_TRACE(msg) fprintf(_tracefile, msg); fflush(_tracefile);
- #define SNIFF_TRACE1(msg, arg) fprintf(_tracefile, msg,arg); fflush(_tracefile);
- #define SNIFF_TRACE_CLOSE fclose(_tracefile); _tracefile=NULL;
- #else
- #define SNIFF_TRACE_OPEN(file)
- #define SNIFF_TRACE(msg)
- #define SNIFF_TRACE1(msg, arg)
- #define SNIFF_TRACE_CLOSE
- #endif
- 
- /*-------- Windows Only Declarations -----------------------------*/
- #ifdef WIN32
- 
- static int  sniff_request_processed=1;
- static HANDLE sniffemacs_handle=NULL;
- static HANDLE readthread_handle=NULL;
- static HANDLE handle_to_sniff=NULL;
- static HANDLE handle_from_sniff=NULL;
- 
- struct sniffBufNode
- {
-     struct sniffBufNode *next;
-     int    bufLen;
-     char   buf[MAX_REQUEST_LEN];
- };
- static struct sniffBufNode *sniffBufStart=NULL;
- static struct sniffBufNode *sniffBufEnd=NULL;
- static HANDLE hBufferMutex=NULL;
- 
- # ifdef FEAT_GUI_W32
-     extern HWND s_hwnd;       /* gvim's Window handle */
- # endif
- /*
-  * some helper functions for Windows port only
-  */
- 
-     static HANDLE
- ExecuteDetachedProgram(char *szBinary, char *szCmdLine,
-     HANDLE hStdInput, HANDLE hStdOutput)
- {
-     BOOL bResult;
-     DWORD nError;
-     PROCESS_INFORMATION aProcessInformation;
-     PROCESS_INFORMATION *pProcessInformation= &aProcessInformation;
-     STARTUPINFO aStartupInfo;
-     STARTUPINFO *pStartupInfo= &aStartupInfo;
-     DWORD dwCreationFlags= 0;
-     char szPath[512];
-     HINSTANCE hResult;
- 
-     hResult = FindExecutable(szBinary, ".", szPath);
-     if ((int)hResult <= 32)
-     {
- 	/* can't find the exe file */
- 	return NULL;
-     }
- 
-     ZeroMemory(pStartupInfo, sizeof(*pStartupInfo));
-     pStartupInfo->dwFlags= STARTF_USESHOWWINDOW|STARTF_USESTDHANDLES;
-     pStartupInfo->hStdInput = hStdInput;
-     pStartupInfo->hStdOutput = hStdOutput;
-     pStartupInfo->wShowWindow= SW_HIDE;
-     pStartupInfo->cb = sizeof(STARTUPINFO);
- 
-     bResult= CreateProcess(
- 	szPath,
- 	szCmdLine,
- 	NULL,    /* security attr for process */
- 	NULL,    /* security attr for primary thread */
- 	TRUE,    /* DO inherit stdin and stdout */
- 	dwCreationFlags, /* creation flags */
- 	NULL,    /* environment */
- 	".",    /* current directory */
- 	pStartupInfo,   /* startup info: NULL crashes  */
- 	pProcessInformation /* process information: NULL crashes */
-     );
-     nError= GetLastError();
-     if (bResult)
-     {
- 	CloseHandle(pProcessInformation->hThread);
- 	CloseHandle(hStdInput);
- 	CloseHandle(hStdOutput);
- 	return(pProcessInformation->hProcess);
-     }
-     else
- 	return(NULL);
- }
- 
- /*
-  * write to the internal Thread / Thread communications buffer.
-  * Return TRUE if successful, FALSE else.
-  */
-     static BOOL
- writeToBuffer(char *msg, int len)
- {
-     DWORD dwWaitResult;     /* Request ownership of mutex. */
-     struct sniffBufNode *bn;
-     int bnSize;
- 
-     SNIFF_TRACE1("writeToBuffer %d\n", len);
-     bnSize = sizeof(struct sniffBufNode) - MAX_REQUEST_LEN + len + 1;
-     if (bnSize < 128) bnSize = 128; /* minimum length to avoid fragmentation */
-     bn = (struct sniffBufNode *)malloc(bnSize);
-     if (!bn)
- 	return FALSE;
- 
-     memcpy(bn->buf, msg, len);
-     bn->buf[len]='\0';    /* terminate CString for added safety */
-     bn->next = NULL;
-     bn->bufLen = len;
-     /* now, acquire a Mutex for adding the string to our linked list */
-     dwWaitResult = WaitForSingleObject(
- 	hBufferMutex,   /* handle of mutex */
- 	1000L);   /* one-second time-out interval */
-     if (dwWaitResult == WAIT_OBJECT_0)
-     {
- 	/* The thread got mutex ownership. */
- 	if (sniffBufEnd)
- 	{
- 	    sniffBufEnd->next = bn;
- 	    sniffBufEnd = bn;
- 	}
- 	else
- 	    sniffBufStart = sniffBufEnd = bn;
- 	/* Release ownership of the mutex object. */
- 	if (! ReleaseMutex(hBufferMutex))
- 	{
- 	    /* Deal with error. */
- 	}
- 	return TRUE;
-     }
- 
-     /* Cannot get mutex ownership due to time-out or mutex object abandoned. */
-     free(bn);
-     return FALSE;
- }
- 
- /*
-  * read from the internal Thread / Thread communications buffer.
-  * Return TRUE if successful, FALSE else.
-  */
-     static int
- ReadFromBuffer(char *buf, int maxlen)
- {
-     DWORD dwWaitResult;     /* Request ownership of mutex. */
-     int   theLen;
-     struct sniffBufNode *bn;
- 
-     dwWaitResult = WaitForSingleObject(
- 	hBufferMutex,   /* handle of mutex */
- 	1000L);		/* one-second time-out interval */
-     if (dwWaitResult == WAIT_OBJECT_0)
-     {
- 	if (!sniffBufStart)
- 	{
- 	    /* all pending Requests Processed */
- 	    theLen = 0;
- 	}
- 	else
- 	{
- 	    bn = sniffBufStart;
- 	    theLen = bn->bufLen;
- 	    SNIFF_TRACE1("ReadFromBuffer %d\n", theLen);
- 	    if (theLen >= maxlen)
- 	    {
- 		/* notify the user of buffer overflow? */
- 		theLen = maxlen-1;
- 	    }
- 	    memcpy(buf, bn->buf, theLen);
- 	    buf[theLen] = '\0';
- 	    if (! (sniffBufStart = bn->next))
- 	    {
- 		sniffBufEnd = NULL;
- 		sniff_request_processed = 1;
- 	    }
- 	    free(bn);
- 	}
- 	if (! ReleaseMutex(hBufferMutex))
- 	{
- 	    /* Deal with error. */
- 	}
- 	return theLen;
-     }
- 
-     /* Cannot get mutex ownership due to time-out or mutex object abandoned. */
-     return -1;
- }
- 
- /* on Win32, a separate Thread reads the input pipe. get_request is not needed here. */
-     static void __cdecl
- SniffEmacsReadThread(void *dummy)
- {
-     static char	ReadThreadBuffer[MAX_REQUEST_LEN];
-     int		ReadThreadLen=0;
-     int		result=0;
-     int		msgLen=0;
-     char	*msgStart, *msgCur;
- 
-     SNIFF_TRACE("begin thread\n");
-     /* Read from the pipe to SniffEmacs */
-     while (sniff_connected)
-     {
- 	if (!ReadFile(handle_from_sniff,
- 		ReadThreadBuffer + ReadThreadLen,    /* acknowledge rest in buffer */
- 		MAX_REQUEST_LEN - ReadThreadLen,
- 		&result,
- 		NULL))
- 	{
- 	    DWORD err = GetLastError();
- 	    result = -1;
- 	}
- 
- 	if (result < 0)
- 	{
- 	    /* probably sniffemacs died... log the Error? */
- 	    sniff_disconnect(1);
- 	}
- 	else if (result > 0)
- 	{
- 	    ReadThreadLen += result-1;   /* total length of valid chars */
- 	    for(msgCur=msgStart=ReadThreadBuffer; ReadThreadLen > 0; msgCur++, ReadThreadLen--)
- 	    {
- 		if (*msgCur == '\0' || *msgCur == '\r' || *msgCur == '\n')
- 		{
- 		    msgLen = msgCur-msgStart; /* don't add the CR/LF chars */
- 		    if (msgLen > 0)
- 			writeToBuffer(msgStart, msgLen);
- 		    msgStart = msgCur + 1; /* over-read single CR/LF chars */
- 		}
- 	    }
- 
- 	/* move incomplete message to beginning of buffer */
- 	ReadThreadLen = msgCur - msgStart;
- 	if (ReadThreadLen > 0)
- 	    mch_memmove(ReadThreadBuffer, msgStart, ReadThreadLen);
- 
- 	if (sniff_request_processed)
- 	{
- 	    /* notify others that new data has arrived */
- 	    sniff_request_processed = 0;
- 	    sniff_request_waiting = 1;
- #ifdef FEAT_GUI_W32
- 	    PostMessage(s_hwnd, WM_USER, (WPARAM)0, (LPARAM)0);
- #endif
- 	    }
- 	}
-     }
-     SNIFF_TRACE("end thread\n");
- }
- #endif /* WIN32 */
- /*-------- End of Windows Only Declarations ------------------------*/
- 
- 
- /* ProcessSniffRequests
-  * Function that should be called from outside
-  * to process the waiting sniff requests
-  */
-     void
- ProcessSniffRequests(void)
- {
-     static char buf[MAX_REQUEST_LEN];
-     int len;
- 
-     while (sniff_connected)
-     {
- #ifdef WIN32
- 	len = ReadFromBuffer(buf, sizeof(buf));
- #else
- 	len = get_request(fd_from_sniff, buf, sizeof(buf));
- #endif
- 	if (len < 0)
- 	{
- 	    vi_error_msg(_("E274: Sniff: Error during read. Disconnected"));
- 	    sniff_disconnect(1);
- 	    break;
- 	}
- 	else if (len > 0)
- 	    HandleSniffRequest( buf );
- 	else
- 	    break;
-     }
- 
-     if (sniff_will_disconnect)	/* Now the last msg has been processed */
- 	sniff_disconnect(1);
- }
- 
-     static struct sn_cmd *
- find_sniff_cmd(char *cmd)
- {
-     struct sn_cmd *sniff_cmd = NULL;
-     int i;
-     for(i=0; sniff_cmds[i].cmd_name; i++)
-     {
- 	if (!strcmp(cmd, sniff_cmds[i].cmd_name))
- 	{
- 	    sniff_cmd = &sniff_cmds[i];
- 	    break;
- 	}
-     }
-     if (!sniff_cmd)
-     {
- 	struct sn_cmd_list *list = sniff_cmd_ext;
- 	while (list)
- 	{
- 	    if (!strcmp(cmd, list->sniff_cmd->cmd_name))
- 	    {
- 		sniff_cmd = list->sniff_cmd;
- 		break;
- 	    }
- 	    list = list->next_cmd;
- 	}
-     }
-     return sniff_cmd;
- }
- 
-     static int
- add_sniff_cmd(char *cmd, char *def, char *msg)
- {
-     int rc = 0;
-     if (def != NULL && def[0] != NUL && find_sniff_cmd(cmd) == NULL)
-     {
- 	struct sn_cmd_list *list = sniff_cmd_ext;
- 	struct sn_cmd *sniff_cmd = (struct sn_cmd*)malloc(sizeof(struct sn_cmd));
- 	struct sn_cmd_list *cmd_node = (struct sn_cmd_list*)malloc(sizeof(struct sn_cmd_list));
- 	int rq_type = 0;
- 
- 	/* unescape message text */
- 	char *p = msg;
- 	char *end = p+strlen(msg);
- 	while (*p)
- 	{
- 	    if (*p == '\\')
- 		mch_memmove(p,p+1,end-p);
- 	    p++;
- 	}
- 	SNIFF_TRACE1("request name = %s\n",cmd);
- 	SNIFF_TRACE1("request def = %s\n",def);
- 	SNIFF_TRACE1("request msg = %s\n",msg);
- 
- 	while (list && list->next_cmd)
- 	    list = list->next_cmd;
- 	if (!list)
- 	    sniff_cmd_ext = cmd_node;
- 	else
- 	    list->next_cmd = cmd_node;
- 
- 	sniff_cmd->cmd_name = cmd;
- 	sniff_cmd->cmd_code = def[0];
- 	sniff_cmd->cmd_msg = msg;
- 	switch(def[1])
- 	{
- 	    case 'f':
- 		rq_type = RQ_NOSYMBOL;
- 		break;
- 	    case 's':
- 		rq_type = RQ_CONTEXT;
- 		break;
- 	    case 'S':
- 		rq_type = RQ_SCONTEXT;
- 		break;
- 	    default:
- 		rq_type = RQ_SIMPLE;
- 		break;
- 	}
- 	sniff_cmd->cmd_type = rq_type;
- 	cmd_node->sniff_cmd = sniff_cmd;
- 	cmd_node->next_cmd = NULL;
- 	rc = 1;
-     }
-     return rc;
- }
- 
- /* ex_sniff
-  * Handle ":sniff" command
-  */
-     void
- ex_sniff(exarg_T *eap)
- {
-     char_u	*arg = eap->arg;
-     char_u *symbol = NULL;
-     char_u *cmd = NULL;
- 
-     SNIFF_TRACE_OPEN("if_sniff.log");
-     if (ends_excmd(*arg))	/* no request: print available commands */
-     {
- 	int i;
- 	msg_start();
- 	msg_outtrans_attr((char_u *)"-- SNiFF+ commands --", hl_attr(HLF_T));
- 	for(i=0; sniff_cmds[i].cmd_name; i++)
- 	{
- 	    msg_putchar('\n');
- 	    msg_outtrans((char_u *)":sniff ");
- 	    msg_outtrans((char_u *)sniff_cmds[i].cmd_name);
- 	}
- 	msg_putchar('\n');
- 	msg_outtrans((char_u *)_("SNiFF+ is currently "));
- 	if (!sniff_connected)
- 	    msg_outtrans((char_u *)_("not "));
- 	msg_outtrans((char_u *)_("connected"));
- 	msg_end();
-     }
-     else	/* extract command name and symbol if present */
-     {
- 	symbol = skiptowhite(arg);
- 	cmd  = vim_strnsave(arg, (int)(symbol-arg));
- 	symbol = skipwhite(symbol);
- 	if (ends_excmd(*symbol))
- 	    symbol = NULL;
- 	if (!strcmp((char *)cmd, "addcmd"))
- 	{
- 	    char_u *def = skiptowhite(symbol);
- 	    char_u *name = vim_strnsave(symbol, (int)(def-symbol));
- 	    char_u *msg;
- 	    def = skipwhite(def);
- 	    msg = skiptowhite(def);
- 	    def = vim_strnsave(def, (int)(msg-def));
- 	    msg = skipwhite(msg);
- 	    if (ends_excmd(*msg))
- 		msg = vim_strsave(name);
- 	    else
- 		msg = vim_strnsave(msg, (int)(skiptowhite_esc(msg)-msg));
- 	    if (!add_sniff_cmd((char*)name, (char*)def, (char*)msg))
- 	    {
- 		vim_free(msg);
- 		vim_free(def);
- 		vim_free(name);
- 	    }
- 	}
- 	else
- 	{
- 	    struct sn_cmd* sniff_cmd = find_sniff_cmd((char*)cmd);
- 	    if (sniff_cmd)
- 		SendRequest(sniff_cmd, (char *)symbol);
- 	    else
- 		EMSG2(_("E275: Unknown SNiFF+ request: %s"), cmd);
- 	}
- 	vim_free(cmd);
-     }
- }
- 
- 
-     static void
- sniff_connect(void)
- {
-     if (sniff_connected)
- 	return;
-     if (ConnectToSniffEmacs())
- 	vi_error_msg(_("E276: Error connecting to SNiFF+"));
-     else
-     {
- 	int i;
- 
- 	for (i = 0; init_cmds[i]; i++)
- 	    vi_exec_cmd(init_cmds[i]);
-     }
- }
- 
-     void
- sniff_disconnect(int immediately)
- {
-     if (!sniff_connected)
- 	return;
-     if (immediately)
-     {
- 	vi_exec_cmd("augroup sniff");
- 	vi_exec_cmd("au!");
- 	vi_exec_cmd("augroup END");
- 	vi_exec_cmd("unlet g:sniff_connected");
- 	sniff_connected = 0;
- 	want_sniff_request = 0;
- 	sniff_will_disconnect = 0;
- #ifdef FEAT_GUI
- 	if (gui.in_use)
- 	    gui_mch_wait_for_chars(0L);
- #endif
- #ifdef WIN32
- 	while (sniffBufStart != NULL)
- 	{
- 	    struct sniffBufNode *node = sniffBufStart;
- 	    sniffBufStart = sniffBufStart->next;
- 	    free(node);
- 	}
- 	sniffBufStart = sniffBufEnd = NULL;
- 	sniff_request_processed = 1;
- 	CloseHandle(handle_to_sniff);
- 	CloseHandle(handle_from_sniff);
- 	WaitForSingleObject(sniffemacs_handle, 1000L);
- 	CloseHandle(sniffemacs_handle);
- 	sniffemacs_handle = NULL;
- 	WaitForSingleObject(readthread_handle, 1000L);
- 	readthread_handle = NULL;
- 	CloseHandle(hBufferMutex);
- 	hBufferMutex = NULL;
- 	SNIFF_TRACE_CLOSE;
- #else
- 	close(fd_to_sniff);
- 	close(fd_from_sniff);
- 	wait(NULL);
- #endif
-     }
-     else
-     {
- #ifdef WIN32
- # if (defined(_MSC_VER) && _MSC_VER >= 1400)
-         Sleep(2);
- # else
- 	_sleep(2);
- # endif
- 	if (!sniff_request_processed)
- 	    ProcessSniffRequests();
- #else
- 	sleep(2);		    /* Incoming msg could disturb edit */
- #endif
- 	sniff_will_disconnect = 1;  /* We expect disconnect msg in 2 secs */
-     }
- }
- 
- 
- /* ConnectToSniffEmacs
-  * Connect to Sniff: returns 1 on error
-  */
-     static int
- ConnectToSniffEmacs(void)
- {
- #ifdef WIN32		/* Windows Version of the Code */
-     HANDLE ToSniffEmacs[2], FromSniffEmacs[2];
-     SECURITY_ATTRIBUTES sa;
- 
-     sa.nLength = sizeof(sa);
-     sa.lpSecurityDescriptor = NULL;
-     sa.bInheritHandle = TRUE;
- 
-     if (! CreatePipe(&ToSniffEmacs[0], &ToSniffEmacs[1], &sa, 0))
- 	return 1;
-     if (! CreatePipe(&FromSniffEmacs[0], &FromSniffEmacs[1], &sa, 0))
- 	return 1;
- 
-     sniffemacs_handle = ExecuteDetachedProgram(SniffEmacs[0], SniffEmacs[0],
- 	ToSniffEmacs[0], FromSniffEmacs[1]);
- 
-     if (sniffemacs_handle)
-     {
- 	handle_to_sniff  = ToSniffEmacs[1];
- 	handle_from_sniff = FromSniffEmacs[0];
- 	sniff_connected = 1;
- 	hBufferMutex = CreateMutex(
- 	    NULL,			/* no security attributes */
- 	    FALSE,			/* initially not owned */
- 	    "SniffReadBufferMutex");    /* name of mutex */
- 	if (hBufferMutex == NULL)
- 	{
- 	    /* Check for error. */
- 	}
- 	readthread_handle = (HANDLE)_beginthread(SniffEmacsReadThread, 0, NULL);
- 	return 0;
-     }
-     else
-     {
- 	/* error in spawn() */
- 	return 1;
-     }
- 
- #else		/* UNIX Version of the Code */
-     int ToSniffEmacs[2], FromSniffEmacs[2];
- 
-     if (pipe(ToSniffEmacs) != 0)
- 	return 1;
-     if (pipe(FromSniffEmacs) != 0)
- 	return 1;
- 
-     /* fork */
-     if ((sniffemacs_pid=fork()) == 0)
-     {
- 	/* child */
- 
- 	/* prepare communication pipes */
- 	close(ToSniffEmacs[1]);
- 	close(FromSniffEmacs[0]);
- 
- 	dup2(ToSniffEmacs[0],fileno(stdin));   /* write to ToSniffEmacs[1] */
- 	dup2(FromSniffEmacs[1],fileno(stdout));/* read from FromSniffEmacs[0] */
- 
- 	close(ToSniffEmacs[0]);
- 	close(FromSniffEmacs[1]);
- 
- 	/* start sniffemacs */
- 	execvp (SniffEmacs[0], SniffEmacs);
- 	{
- /*	    FILE *out = fdopen(FromSniffEmacs[1], "w"); */
- 	    sleep(1);
- 	    fputs(_(msg_sniff_disconnect), stdout);
- 	    fflush(stdout);
- 	    sleep(3);
- #ifdef FEAT_GUI
- 	    if (gui.in_use)
- 		gui_exit(1);
- #endif
- 	    exit(1);
- 	}
- 	return 1;
-     }
-     else if (sniffemacs_pid > 0)
-     {
- 	/* parent process */
- 	close(ToSniffEmacs[0]);
- 	fd_to_sniff  = ToSniffEmacs[1];
- 	close(FromSniffEmacs[1]);
- 	fd_from_sniff = FromSniffEmacs[0];
- 	sniff_connected = 1;
- 	return 0;
-     }
-     else   /* error in fork() */
- 	return 1;
- #endif		/* UNIX Version of the Code */
- }
- 
- 
- /* HandleSniffRequest
-  * Handle one request from SNiFF+
-  */
-     static void
- HandleSniffRequest(char *buffer)
- {
-     char VICommand[MAX_REQUEST_LEN];
-     char command;
-     char *arguments;
-     char *token;
-     char *argv[3];
-     int argc = 0;
-     buf_T  *buf;
- 
-     const char *SetTab     = "set tabstop=%d";
-     const char *SelectBuf  = "buf %s";
-     const char *DeleteBuf  = "bd %s";
-     const char *UnloadBuf  = "bun %s";
-     const char *GotoLine   = "%d";
- 
-     command   = buffer[0];
-     arguments = &buffer[1];
-     token = strtok(arguments, sniff_rq_sep);
-     while (argc <3)
-     {
- 	if (token)
- 	{
- 	    argv[argc] = (char*)vim_strsave((char_u *)token);
- 	    token = strtok(0, sniff_rq_sep);
- 	}
- 	else
- 	    argv[argc] = strdup("");
- 	argc++;
-     }
- 
-     switch (command)
-     {
- 	case 'o' :  /* visit file at char pos */
- 	case 'O' :  /* visit file at line number */
- 	{
- 	    char *file = argv[0];
- 	    int position = atoi(argv[1]);
- 
- 	    buf = vi_find_buffer(file);
- 	    setpcmark();      /* insert current pos in jump list [mark.c]*/
- 	    if (!buf)
- 		vi_open_file(file);
- 	    else if (buf!=curbuf)
- 	    {
- 		vim_snprintf(VICommand, sizeof(VICommand),
- 						     (char *)SelectBuf, file);
- 		vi_exec_cmd(VICommand);
- 	    }
- 	    if (command == 'o')
- 		vi_set_cursor_pos((long)position);
- 	    else
- 	    {
- 		vim_snprintf(VICommand, sizeof(VICommand),
- 					     (char *)GotoLine, (int)position);
- 		vi_exec_cmd(VICommand);
- 	    }
- 	    checkpcmark();	/* [mark.c] */
- #if defined(FEAT_GUI_X11) || defined(FEAT_GUI_W32)
- 	    if (gui.in_use && !gui.in_focus)  /* Raise Vim Window */
- 	    {
- # ifdef FEAT_GUI_W32
- 		SetForegroundWindow(s_hwnd);
- # else
- 		extern Widget vimShell;
- 
- 		XSetInputFocus(gui.dpy, XtWindow(vimShell), RevertToNone,
- 			CurrentTime);
- 		XRaiseWindow(gui.dpy, XtWindow(vimShell));
- # endif
- 	    }
- #endif
- 	    break;
- 	}
- 	case 'p' :  /* path of file has changed */
- 	    /* when changing from shared to private WS (checkout) */
- 	{
- 	    char *file = argv[0];
- 	    char *new_path = argv[1];
- 
- 	    buf = vi_find_buffer(file);
- 	    if (buf && !buf->b_changed) /* delete buffer only if not modified */
- 	    {
- 		vim_snprintf(VICommand, sizeof(VICommand),
- 						     (char *)DeleteBuf, file);
- 		vi_exec_cmd(VICommand);
- 	    }
- 	    vi_open_file(new_path);
- 	    break;
- 	}
- 	case 'w' :  /* writability has changed */
- 	    /* Sniff sends request twice,
- 	     * but only the last one is the right one */
- 	{
- 	    char *file = argv[0];
- 	    int writable = atoi(argv[1]);
- 
- 	    buf = vi_find_buffer(file);
- 	    if (buf)
- 	    {
- 		buf->b_p_ro = !writable;
- 		if (buf != curbuf)
- 		{
- 		    buf->b_flags |= BF_CHECK_RO + BF_NEVERLOADED;
- 		    if (writable && !buf->b_changed)
- 		    {
- 			vim_snprintf(VICommand, sizeof(VICommand),
- 						     (char *)UnloadBuf, file);
- 			vi_exec_cmd(VICommand);
- 		    }
- 		}
- 		else if (writable && !buf->b_changed)
- 		{
- 		    vi_exec_cmd("e");
- 		}
- 	    }
- 	    break;
- 	}
- 	case 'h' :  /* highlight info */
- 	    break;  /* not implemented */
- 
- 	case 't' :  /* Set tab width */
- 	{
- 	    int tab_width = atoi(argv[1]);
- 
- 	    if (tab_width > 0 && tab_width <= 16)
- 	    {
- 		vim_snprintf(VICommand, sizeof(VICommand),
- 						   (char *)SetTab, tab_width);
- 		vi_exec_cmd(VICommand);
- 	    }
- 	    break;
- 	}
- 	case '|':
- 	{
- 	    /* change the request separator */
- 	    sniff_rq_sep[0] = arguments[0];
- 	    /* echo the request */
- 	    WriteToSniff(buffer);
- 	    break;
- 	}
- 	case 'A' :  /* Warning/Info msg */
- 	    vi_msg(arguments);
- 	    if (!strncmp(arguments, "Disconnected", 12))
- 		sniff_disconnect(1);	/* unexpected disconnection */
- 	    break;
- 	case 'a' :  /* Error msg */
- 	    vi_error_msg(arguments);
- 	    if (!strncmp(arguments, "Cannot connect", 14))
- 		sniff_disconnect(1);
- 	    break;
- 
- 	default :
- 	    break;
-     }
-     while (argc)
- 	vim_free(argv[--argc]);
- }
- 
- 
- #ifndef WIN32
- /* get_request
-  * read string from fd up to next newline (excluding the nl),
-  * returns  length of string
-  *	    0 if no data available or no complete line
-  *	   <0 on error
-  */
-     static int
- get_request(int fd, char *buf, int maxlen)
- {
-     static char	inbuf[1024];
-     static int	pos = 0, bytes = 0;
-     int		len;
- #ifdef HAVE_SELECT
-     struct timeval tval;
-     fd_set	rfds;
- 
-     FD_ZERO(&rfds);
-     FD_SET(fd, &rfds);
-     tval.tv_sec  = 0;
-     tval.tv_usec = 0;
- #else
-     struct pollfd fds;
- 
-     fds.fd = fd;
-     fds.events = POLLIN;
- #endif
- 
-     for (len = 0; len < maxlen; len++)
-     {
- 	if (pos >= bytes)	    /* end of buffer reached? */
- 	{
- #ifdef HAVE_SELECT
- 	    if (select(fd + 1, &rfds, NULL, NULL, &tval) > 0)
- #else
- 	    if (poll(&fds, 1, 0) > 0)
- #endif
- 	    {
- 		pos = 0;
- 		bytes = read(fd, inbuf, sizeof(inbuf));
- 		if (bytes <= 0)
- 		    return bytes;
- 	    }
- 	    else
- 	    {
- 		pos = pos-len;
- 		buf[0] = '\0';
- 		return 0;
- 	    }
- 	}
- 	if ((buf[len] = inbuf[pos++]) =='\n')
- 	    break;
-     }
-     buf[len] = '\0';
-     return len;
- }
- #endif     /* WIN32 */
- 
- 
-     static void
- SendRequest(struct sn_cmd *command, char *symbol)
- {
-     int		cmd_type = command->cmd_type;
-     static char cmdstr[MAX_REQUEST_LEN];
-     static char msgtxt[MAX_REQUEST_LEN];
-     char	*buffer_name = NULL;
- 
-     if (cmd_type == RQ_CONNECT)
-     {
- 	sniff_connect();
- 	return;
-     }
-     if (!sniff_connected && !(cmd_type & SILENT))
-     {
- 	vi_error_msg(_("E278: SNiFF+ not connected"));
- 	return;
-     }
- 
-     if (cmd_type & NEED_FILE)
-     {
- 	if (!curbuf->b_sniff)
- 	{
- 	    if (!(cmd_type & SILENT))
- 		vi_error_msg(_("E279: Not a SNiFF+ buffer"));
- 	    return;
- 	}
- 	buffer_name = vi_buffer_name();
- 	if (buffer_name == NULL)
- 	    return;
- 	if (cmd_type & NEED_SYMBOL)
- 	{
- 	    if (cmd_type & EMPTY_SYMBOL)
- 		symbol = " ";
- 	    else if (!symbol && !(symbol = vi_symbol_under_cursor()))
- 		return;	    /* error msg already displayed */
- 	}
- 
- 	if (symbol)
- 	    vim_snprintf(cmdstr, sizeof(cmdstr), "%c%s%s%ld%s%s\n",
- 		command->cmd_code,
- 		buffer_name,
- 		sniff_rq_sep,
- 		vi_cursor_pos(),
- 		sniff_rq_sep,
- 		symbol
- 	    );
- 	else
- 	    vim_snprintf(cmdstr, sizeof(cmdstr), "%c%s\n",
- 		    command->cmd_code, buffer_name);
-     }
-     else    /* simple request */
-     {
- 	cmdstr[0] = command->cmd_code;
- 	cmdstr[1] = '\n';
- 	cmdstr[2] = '\0';
-     }
-     if (command->cmd_msg && !(cmd_type & SILENT))
-     {
- 	if ((cmd_type & NEED_SYMBOL) && !(cmd_type & EMPTY_SYMBOL))
- 	{
- 	    vim_snprintf(msgtxt, sizeof(msgtxt), "%s: %s",
- 						 _(command->cmd_msg), symbol);
- 	    vi_msg(msgtxt);
- 	}
- 	else
- 	    vi_msg(_(command->cmd_msg));
-     }
-     WriteToSniff(cmdstr);
-     if (cmd_type & DISCONNECT)
- 	sniff_disconnect(0);
- }
- 
- 
- 
-     static void
- WriteToSniff(char *str)
- {
-     int bytes;
- #ifdef WIN32
-     if (! WriteFile(handle_to_sniff, str, strlen(str), &bytes, NULL))
-     {
- 	DWORD err=GetLastError();
- 	bytes = -1;
-     }
- #else
-     bytes = write(fd_to_sniff, str, strlen(str));
- #endif
-     if (bytes<0)
-     {
- 	vi_msg(_("Sniff: Error during write. Disconnected"));
- 	sniff_disconnect(1);
-     }
- }
- 
- /*-------- vim helping functions --------------------------------*/
- 
-     static void
- vi_msg(char *str)
- {
-     if (str != NULL && *str != NUL)
- 	MSG((char_u *)str);
- }
- 
-     static void
- vi_error_msg(char *str)
- {
-     if (str != NULL && *str != NUL)
- 	EMSG((char_u *)str);
- }
- 
-     static void
- vi_open_file(char *fname)
- {
-     ++no_wait_return;
-     do_ecmd(0, (char_u *)fname, NULL, NULL, ECMD_ONE, ECMD_HIDE+ECMD_OLDBUF,
- 	    curwin);
-     curbuf->b_sniff = TRUE;
-     --no_wait_return;					/* [ex_docmd.c] */
- }
- 
-     static buf_T *
- vi_find_buffer(char *fname)
- {			    /* derived from buflist_findname() [buffer.c] */
-     buf_T	*buf;
- 
-     for (buf = firstbuf; buf != NULL; buf = buf->b_next)
- 	if (buf->b_sfname != NULL && fnamecmp(fname, buf->b_sfname) == 0)
- 	    return (buf);
-     return NULL;
- }
- 
- 
-     static char *
- vi_symbol_under_cursor(void)
- {
-     int		len;
-     char	*symbolp;
-     char	*p;
-     static char sniff_symbol[256];
- 
-     len = find_ident_under_cursor((char_u **)&symbolp, FIND_IDENT);
-     /* [normal.c] */
-     if (len <= 0)
- 	return NULL;
-     for (p=sniff_symbol; len; len--)
- 	*p++ = *symbolp++;
-     *p = '\0';
-     return sniff_symbol;
- }
- 
- 
-     static char *
- vi_buffer_name(void)
- {
-     return (char *)curbuf->b_sfname;
- }
- 
-     static void
- vi_exec_cmd(char *vicmd)
- {
-     do_cmdline_cmd((char_u *)vicmd);  /* [ex_docmd.c] */
- }
- 
- /*
-  * Set cursor on character position
-  * derived from cursor_pos_info() [buffer.c]
-  */
-     static void
- vi_set_cursor_pos(long char_pos)
- {
-     linenr_T	lnum;
-     long	char_count = 1;  /* first position = 1 */
-     int		line_size;
-     int		eol_size;
- 
-     if (char_pos == 0)
-     {
- 	char_pos = 1;
-     }
-     if (get_fileformat(curbuf) == EOL_DOS)
- 	eol_size = 2;
-     else
- 	eol_size = 1;
-     for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
-     {
- 	line_size = STRLEN(ml_get(lnum)) + eol_size;
- 	if (char_count+line_size > char_pos) break;
- 	char_count += line_size;
-     }
-     curwin->w_cursor.lnum = lnum;
-     curwin->w_cursor.col  = char_pos - char_count;
- }
- 
-     static long
- vi_cursor_pos(void)
- {
-     linenr_T	lnum;
-     long	char_count=1;  /* sniff starts with pos 1 */
-     int		line_size;
-     int		eol_size;
- 
-     if (curbuf->b_p_tx)
- 	eol_size = 2;
-     else
- 	eol_size = 1;
-     for (lnum = 1; lnum < curwin->w_cursor.lnum; ++lnum)
-     {
- 	line_size = STRLEN(ml_get(lnum)) + eol_size;
- 	char_count += line_size;
-     }
-     return char_count + curwin->w_cursor.col;
- }
--- 0 ----
*** ../vim-7.4.1432/src/if_sniff.h	2016-01-29 23:20:35.313308119 +0100
--- src/if_sniff.h	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,16 ****
- /*
-  * if_sniff.h Interface between Vim and SNiFF+
-  */
- 
- #ifndef __if_sniff_h__
- #define __if_sniff_h__
- 
- extern int  want_sniff_request;
- extern int  sniff_request_waiting;
- extern int  sniff_connected;
- extern int  fd_from_sniff;
- extern void sniff_disconnect(int immediately);
- extern void ProcessSniffRequests(void);
- extern void ex_sniff(exarg_T *eap);
- 
- #endif
--- 0 ----
*** ../vim-7.4.1432/src/charset.c	2016-01-31 14:55:35.215538598 +0100
--- src/charset.c	2016-02-27 17:30:36.347326969 +0100
***************
*** 1761,1768 ****
      return p;
  }
  
! #if defined(FEAT_LISTCMDS) || defined(FEAT_SIGNS) || defined(FEAT_SNIFF) \
! 	|| defined(PROTO)
  /*
   * skiptowhite_esc: Like skiptowhite(), but also skip escaped chars
   */
--- 1761,1767 ----
      return p;
  }
  
! #if defined(FEAT_LISTCMDS) || defined(FEAT_SIGNS) || defined(PROTO)
  /*
   * skiptowhite_esc: Like skiptowhite(), but also skip escaped chars
   */
*** ../vim-7.4.1432/src/edit.c	2016-02-23 20:13:10.172805422 +0100
--- src/edit.c	2016-02-27 17:30:50.295180695 +0100
***************
*** 1052,1063 ****
  	case K_SELECT:	/* end of Select mode mapping - ignore */
  	    break;
  
- #ifdef FEAT_SNIFF
- 	case K_SNIFF:	/* Sniff command received */
- 	    stuffcharReadbuff(K_SNIFF);
- 	    goto doESCkey;
- #endif
- 
  	case K_HELP:	/* Help key works like <ESC> <Help> */
  	case K_F1:
  	case K_XF1:
--- 1052,1057 ----
*** ../vim-7.4.1432/src/eval.c	2016-02-27 14:44:21.331585379 +0100
--- src/eval.c	2016-02-27 17:43:28.083236326 +0100
***************
*** 13930,13938 ****
  #ifdef FEAT_SMARTINDENT
  	"smartindent",
  #endif
- #ifdef FEAT_SNIFF
- 	"sniff",
- #endif
  #ifdef STARTUPTIME
  	"startuptime",
  #endif
--- 13930,13935 ----
*** ../vim-7.4.1432/src/ex_cmds2.c	2016-02-23 18:55:38.033647023 +0100
--- src/ex_cmds2.c	2016-02-27 17:43:47.083037202 +0100
***************
*** 131,139 ****
      redir_off = TRUE;		/* don't redirect debug commands */
  
      State = NORMAL;
- #ifdef FEAT_SNIFF
-     want_sniff_request = 0;    /* No K_SNIFF wanted */
- #endif
  
      if (!debug_did_msg)
  	MSG(_("Entering Debug mode.  Type \"cont\" to continue."));
--- 131,136 ----
***************
*** 151,159 ****
      {
  	msg_scroll = TRUE;
  	need_wait_return = FALSE;
! #ifdef FEAT_SNIFF
! 	ProcessSniffRequests();
! #endif
  	/* Save the current typeahead buffer and replace it with an empty one.
  	 * This makes sure we get input from the user here and don't interfere
  	 * with the commands being executed.  Reset "ex_normal_busy" to avoid
--- 148,154 ----
      {
  	msg_scroll = TRUE;
  	need_wait_return = FALSE;
! 
  	/* Save the current typeahead buffer and replace it with an empty one.
  	 * This makes sure we get input from the user here and don't interfere
  	 * with the commands being executed.  Reset "ex_normal_busy" to avoid
*** ../vim-7.4.1432/src/ex_docmd.c	2016-02-23 14:52:31.877232254 +0100
--- src/ex_docmd.c	2016-02-27 17:44:10.914787442 +0100
***************
*** 296,304 ****
  # define ex_rubydo		ex_ni
  # define ex_rubyfile		ex_ni
  #endif
- #ifndef FEAT_SNIFF
- # define ex_sniff		ex_ni
- #endif
  #ifndef FEAT_KEYMAP
  # define ex_loadkeymap		ex_ni
  #endif
--- 296,301 ----
***************
*** 641,649 ****
      /* Ignore scrollbar and mouse events in Ex mode */
      ++hold_gui_events;
  #endif
- #ifdef FEAT_SNIFF
-     want_sniff_request = 0;    /* No K_SNIFF wanted */
- #endif
  
      MSG(_("Entering Ex mode.  Type \"visual\" to go to Normal mode."));
      while (exmode_active)
--- 638,643 ----
***************
*** 661,669 ****
  	changedtick = curbuf->b_changedtick;
  	prev_msg_row = msg_row;
  	prev_line = curwin->w_cursor.lnum;
- #ifdef FEAT_SNIFF
- 	ProcessSniffRequests();
- #endif
  	if (improved)
  	{
  	    cmdline_row = msg_row;
--- 655,660 ----
*** ../vim-7.4.1432/src/ex_getln.c	2016-02-23 14:52:31.877232254 +0100
--- src/ex_getln.c	2016-02-27 17:45:18.114083209 +0100
***************
*** 206,214 ****
      struct cmdline_info save_ccline;
  #endif
  
- #ifdef FEAT_SNIFF
-     want_sniff_request = 0;
- #endif
  #ifdef FEAT_EVAL
      if (firstc == -1)
      {
--- 206,211 ----
*** ../vim-7.4.1432/src/gui_gtk_x11.c	2016-02-23 17:13:56.885032246 +0100
--- src/gui_gtk_x11.c	2016-02-27 17:46:20.717427170 +0100
***************
*** 6460,6481 ****
      return FALSE;		/* don't happen again */
  }
  
- #ifdef FEAT_SNIFF
- /*
-  * Callback function, used when data is available on the SNiFF connection.
-  */
-     static void
- sniff_request_cb(
-     gpointer	data UNUSED,
-     gint	source_fd UNUSED,
-     GdkInputCondition condition UNUSED)
- {
-     static char_u bytes[3] = {CSI, (int)KS_EXTRA, (int)KE_SNIFF};
- 
-     add_to_input_buf(bytes, 3);
- }
- #endif
- 
  /*
   * GUI input routine called by gui_wait_for_chars().  Waits for a character
   * from the keyboard.
--- 6460,6465 ----
***************
*** 6491,6516 ****
      int focus;
      guint timer;
      static int timed_out;
- #ifdef FEAT_SNIFF
-     static int	sniff_on = 0;
-     static gint	sniff_input_id = 0;
- #endif
- 
- #ifdef FEAT_SNIFF
-     if (sniff_on && !want_sniff_request)
-     {
- 	if (sniff_input_id)
- 	    gdk_input_remove(sniff_input_id);
- 	sniff_on = 0;
-     }
-     else if (!sniff_on && want_sniff_request)
-     {
- 	/* Add fd_from_sniff to watch for available data in main loop. */
- 	sniff_input_id = gdk_input_add(fd_from_sniff,
- 			       GDK_INPUT_READ, sniff_request_cb, NULL);
- 	sniff_on = 1;
-     }
- #endif
  
      timed_out = FALSE;
  
--- 6475,6480 ----
*** ../vim-7.4.1432/src/gui_w32.c	2016-02-27 16:04:54.505159279 +0100
--- src/gui_w32.c	2016-02-27 17:47:46.128532174 +0100
***************
*** 326,332 ****
  #endif
  
  static HINSTANCE	s_hinst = NULL;
! #if !defined(FEAT_SNIFF) && !defined(FEAT_GUI)
  static
  #endif
  HWND			s_hwnd = NULL;
--- 326,332 ----
  #endif
  
  static HINSTANCE	s_hinst = NULL;
! #if !defined(FEAT_GUI)
  static
  #endif
  HWND			s_hwnd = NULL;
***************
*** 1926,1948 ****
  	return;
      }
  #endif
- 
- #ifdef FEAT_SNIFF
-     if (sniff_request_waiting && want_sniff_request)
-     {
- 	static char_u bytes[3] = {CSI, (char_u)KS_EXTRA, (char_u)KE_SNIFF};
- 	add_to_input_buf(bytes, 3); /* K_SNIFF */
- 	sniff_request_waiting = 0;
- 	want_sniff_request = 0;
- 	/* request is handled in normal.c */
-     }
-     if (msg.message == WM_USER)
-     {
- 	MyTranslateMessage(&msg);
- 	pDispatchMessage(&msg);
- 	return;
-     }
- #endif
  
  #ifdef MSWIN_FIND_REPLACE
      /* Don't process messages used by the dialog */
--- 1926,1931 ----
*** ../vim-7.4.1432/src/gui_x11.c	2016-01-31 17:30:47.422544414 +0100
--- src/gui_x11.c	2016-02-27 17:48:22.316152991 +0100
***************
*** 145,153 ****
  static void gui_x11_enter_cb(Widget w, XtPointer data, XEvent *event, Boolean *dum);
  static void gui_x11_leave_cb(Widget w, XtPointer data, XEvent *event, Boolean *dum);
  static void gui_x11_mouse_cb(Widget w, XtPointer data, XEvent *event, Boolean *dum);
- #ifdef FEAT_SNIFF
- static void gui_x11_sniff_request_cb(XtPointer closure, int *source, XtInputId *id);
- #endif
  static void gui_x11_check_copy_area(void);
  #ifdef FEAT_CLIENTSERVER
  static void gui_x11_send_event_handler(Widget, XtPointer, XEvent *, Boolean *);
--- 145,150 ----
***************
*** 1163,1182 ****
      gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
  }
  
- #ifdef FEAT_SNIFF
- /* ARGSUSED */
-     static void
- gui_x11_sniff_request_cb(
-     XtPointer	closure UNUSED,
-     int		*source UNUSED,
-     XtInputId	*id UNUSED)
- {
-     static char_u bytes[3] = {CSI, (int)KS_EXTRA, (int)KE_SNIFF};
- 
-     add_to_input_buf(bytes, 3);
- }
- #endif
- 
  /*
   * End of call-back routines
   */
--- 1160,1165 ----
***************
*** 2818,2845 ****
      static int	    timed_out;
      XtIntervalId    timer = (XtIntervalId)0;
      XtInputMask	    desired;
- #ifdef FEAT_SNIFF
-     static int	    sniff_on = 0;
-     static XtInputId sniff_input_id = 0;
- #endif
  
      timed_out = FALSE;
  
- #ifdef FEAT_SNIFF
-     if (sniff_on && !want_sniff_request)
-     {
- 	if (sniff_input_id)
- 	    XtRemoveInput(sniff_input_id);
- 	sniff_on = 0;
-     }
-     else if (!sniff_on && want_sniff_request)
-     {
- 	sniff_input_id = XtAppAddInput(app_context, fd_from_sniff,
- 		     (XtPointer)XtInputReadMask, gui_x11_sniff_request_cb, 0);
- 	sniff_on = 1;
-     }
- #endif
- 
      if (wtime > 0)
  	timer = XtAppAddTimeOut(app_context, (long_u)wtime, gui_x11_timer_cb,
  								  &timed_out);
--- 2801,2809 ----
*** ../vim-7.4.1432/src/normal.c	2016-01-31 14:55:35.231538430 +0100
--- src/normal.c	2016-02-27 17:49:11.643636142 +0100
***************
*** 163,171 ****
  static void	nv_join(cmdarg_T *cap);
  static void	nv_put(cmdarg_T *cap);
  static void	nv_open(cmdarg_T *cap);
- #ifdef FEAT_SNIFF
- static void	nv_sniff(cmdarg_T *cap);
- #endif
  #ifdef FEAT_NETBEANS_INTG
  static void	nv_nbcmd(cmdarg_T *cap);
  #endif
--- 163,168 ----
***************
*** 420,428 ****
      {K_F8,	farsi_fkey,	0,			0},
      {K_F9,	farsi_fkey,	0,			0},
  #endif
- #ifdef FEAT_SNIFF
-     {K_SNIFF,	nv_sniff,	0,			0},
- #endif
  #ifdef FEAT_NETBEANS_INTG
      {K_F21,	nv_nbcmd,	NV_NCH_ALW,		0},
  #endif
--- 417,422 ----
***************
*** 570,579 ****
       * remembered in "opcount". */
      ca.opcount = opcount;
  
- #ifdef FEAT_SNIFF
-     want_sniff_request = sniff_connected;
- #endif
- 
      /*
       * If there is an operator pending, then the command we take this time
       * will terminate it. Finish_op tells us to finish the operation before
--- 564,569 ----
***************
*** 9388,9401 ****
  	n_opencmd(cap);
  }
  
- #ifdef FEAT_SNIFF
-     static void
- nv_sniff(cmdarg_T *cap UNUSED)
- {
-     ProcessSniffRequests();
- }
- #endif
- 
  #ifdef FEAT_NETBEANS_INTG
      static void
  nv_nbcmd(cmdarg_T *cap)
--- 9378,9383 ----
*** ../vim-7.4.1432/src/os_unix.c	2016-02-25 20:55:55.698165525 +0100
--- src/os_unix.c	2016-02-27 17:49:58.699143115 +0100
***************
*** 5340,5346 ****
   * "msec" == 0 will check for characters once.
   * "msec" == -1 will block until a character is available.
   * When a GUI is being used, this will not be used for input -- webb
-  * Returns also, when a request from Sniff is waiting -- toni.
   * Or when a Linux GPM mouse event is waiting.
   * Or when a clientserver message is on the queue.
   */
--- 5340,5345 ----
***************
*** 5427,5441 ****
  	fds[0].events = POLLIN;
  	nfd = 1;
  
- # ifdef FEAT_SNIFF
- #  define SNIFF_IDX 1
- 	if (want_sniff_request)
- 	{
- 	    fds[SNIFF_IDX].fd = fd_from_sniff;
- 	    fds[SNIFF_IDX].events = POLLIN;
- 	    nfd++;
- 	}
- # endif
  # ifdef FEAT_XCLIPBOARD
  	may_restore_clipboard();
  	if (xterm_Shell != (Widget)0)
--- 5426,5431 ----
***************
*** 5478,5494 ****
  	    finished = FALSE;
  # endif
  
- # ifdef FEAT_SNIFF
- 	if (ret < 0)
- 	    sniff_disconnect(1);
- 	else if (want_sniff_request)
- 	{
- 	    if (fds[SNIFF_IDX].revents & POLLHUP)
- 		sniff_disconnect(1);
- 	    if (fds[SNIFF_IDX].revents & POLLIN)
- 		sniff_request_waiting = 1;
- 	}
- # endif
  # ifdef FEAT_XCLIPBOARD
  	if (xterm_Shell != (Widget)0 && (fds[xterm_idx].revents & POLLIN))
  	{
--- 5468,5473 ----
***************
*** 5574,5588 ****
  # endif
  	maxfd = fd;
  
- # ifdef FEAT_SNIFF
- 	if (want_sniff_request)
- 	{
- 	    FD_SET(fd_from_sniff, &rfds);
- 	    FD_SET(fd_from_sniff, &efds);
- 	    if (maxfd < fd_from_sniff)
- 		maxfd = fd_from_sniff;
- 	}
- # endif
  # ifdef FEAT_XCLIPBOARD
  	may_restore_clipboard();
  	if (xterm_Shell != (Widget)0)
--- 5553,5558 ----
***************
*** 5652,5668 ****
  	    finished = FALSE;
  # endif
  
- # ifdef FEAT_SNIFF
- 	if (ret < 0 )
- 	    sniff_disconnect(1);
- 	else if (ret > 0 && want_sniff_request)
- 	{
- 	    if (FD_ISSET(fd_from_sniff, &efds))
- 		sniff_disconnect(1);
- 	    if (FD_ISSET(fd_from_sniff, &rfds))
- 		sniff_request_waiting = 1;
- 	}
- # endif
  # ifdef FEAT_XCLIPBOARD
  	if (ret > 0 && xterm_Shell != (Widget)0
  		&& FD_ISSET(ConnectionNumber(xterm_dpy), &rfds))
--- 5622,5627 ----
*** ../vim-7.4.1432/src/os_win32.c	2016-02-25 20:55:55.694165566 +0100
--- src/os_win32.c	2016-02-27 17:50:16.070961105 +0100
***************
*** 1683,1709 ****
      if (typeaheadlen > 0)
  	goto theend;
  
- #ifdef FEAT_SNIFF
-     if (want_sniff_request)
-     {
- 	if (sniff_request_waiting)
- 	{
- 	    /* return K_SNIFF */
- 	    typeahead[typeaheadlen++] = CSI;
- 	    typeahead[typeaheadlen++] = (char_u)KS_EXTRA;
- 	    typeahead[typeaheadlen++] = (char_u)KE_SNIFF;
- 	    sniff_request_waiting = 0;
- 	    want_sniff_request = 0;
- 	    goto theend;
- 	}
- 	else if (time < 0 || time > 250)
- 	{
- 	    /* don't wait too long, a request might be pending */
- 	    time = 250;
- 	}
-     }
- #endif
- 
      if (time >= 0)
      {
  	if (!WaitForChar(time))     /* no character available */
--- 1683,1688 ----
*** ../vim-7.4.1432/src/term.c	2016-02-23 14:52:31.897232046 +0100
--- src/term.c	2016-02-27 17:50:37.350738153 +0100
***************
*** 1796,1811 ****
  # endif
  #endif	/* FEAT_MOUSE */
  
- #ifdef FEAT_SNIFF
-     {
- 	char_u	name[2];
- 
- 	name[0] = (int)KS_EXTRA;
- 	name[1] = (int)KE_SNIFF;
- 	add_termcode(name, (char_u *)"\233sniff", FALSE);
-     }
- #endif
- 
  #ifdef USE_TERM_CONSOLE
      /* DEFAULT_TERM indicates that it is the machine console. */
      if (STRCMP(term, DEFAULT_TERM) != 0)
--- 1796,1801 ----
*** ../vim-7.4.1432/src/ui.c	2016-02-23 23:04:32.252922964 +0100
--- src/ui.c	2016-02-27 17:51:16.770325155 +0100
***************
*** 1627,1633 ****
  #if defined(FEAT_GUI) \
  	|| defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE) \
  	|| defined(FEAT_XCLIPBOARD) || defined(VMS) \
! 	|| defined(FEAT_SNIFF) || defined(FEAT_CLIENTSERVER) \
  	|| defined(PROTO)
  /*
   * Add the given bytes to the input buffer
--- 1627,1633 ----
  #if defined(FEAT_GUI) \
  	|| defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE) \
  	|| defined(FEAT_XCLIPBOARD) || defined(VMS) \
! 	|| defined(FEAT_CLIENTSERVER) \
  	|| defined(PROTO)
  /*
   * Add the given bytes to the input buffer
***************
*** 1772,1788 ****
      inbufcount = 0;
  # else
  
! #  ifdef FEAT_SNIFF
!     if (sniff_request_waiting)
!     {
! 	add_to_input_buf((char_u *)"\233sniff",6); /* results in K_SNIFF */
! 	sniff_request_waiting = 0;
! 	want_sniff_request = 0;
! 	return;
!     }
! #  endif
! 
! # ifdef FEAT_MBYTE
      if (rest != NULL)
      {
  	/* Use remainder of previous call, starts with an invalid character
--- 1772,1778 ----
      inbufcount = 0;
  # else
  
! #  ifdef FEAT_MBYTE
      if (rest != NULL)
      {
  	/* Use remainder of previous call, starts with an invalid character
***************
*** 1806,1812 ****
      }
      else
  	unconverted = 0;
! #endif
  
      len = 0;	/* to avoid gcc warning */
      for (try = 0; try < 100; ++try)
--- 1796,1802 ----
      }
      else
  	unconverted = 0;
! #  endif
  
      len = 0;	/* to avoid gcc warning */
      for (try = 0; try < 100; ++try)
*** ../vim-7.4.1432/src/version.c	2016-02-27 18:07:39.656009438 +0100
--- src/version.c	2016-02-27 18:09:29.486856900 +0100
***************
*** 554,564 ****
  #else
  	"-smartindent",
  #endif
- #ifdef FEAT_SNIFF
- 	"+sniff",
- #else
- 	"-sniff",
- #endif
  #ifdef STARTUPTIME
  	"+startuptime",
  #else
--- 554,559 ----
*** ../vim-7.4.1432/src/ex_cmds.h	2016-02-21 23:01:47.445323348 +0100
--- src/ex_cmds.h	2016-02-27 17:54:14.172464838 +0100
***************
*** 1281,1289 ****
  EX(CMD_snext,		"snext",	ex_next,
  			RANGE|NOTADR|BANG|FILES|EDITCMD|ARGOPT|TRLBAR,
  			ADDR_LINES),
- EX(CMD_sniff,		"sniff",	ex_sniff,
- 			EXTRA|TRLBAR,
- 			ADDR_LINES),
  EX(CMD_snomagic,	"snomagic",	ex_submagic,
  			RANGE|WHOLEFOLD|EXTRA|CMDWIN,
  			ADDR_LINES),
--- 1281,1286 ----
*** ../vim-7.4.1432/src/feature.h	2016-02-23 14:52:31.877232254 +0100
--- src/feature.h	2016-02-27 17:54:19.812405613 +0100
***************
*** 1221,1227 ****
   * +perl		Perl interface: "--enable-perlinterp"
   * +python		Python interface: "--enable-pythoninterp"
   * +tcl			TCL interface: "--enable-tclinterp"
-  * +sniff		Sniff interface: "--enable-sniff"
   * +sun_workshop	Sun Workshop integration
   * +netbeans_intg	Netbeans integration
   * +channel		Inter process communication
--- 1221,1226 ----
*** ../vim-7.4.1432/src/keymap.h	2012-08-15 15:46:07.000000000 +0200
--- src/keymap.h	2016-02-27 17:54:45.584134990 +0100
***************
*** 211,218 ****
      , KE_TAB		/* unshifted TAB key */
      , KE_S_TAB_OLD	/* shifted TAB key (no longer used) */
  
-     , KE_SNIFF		/* SNiFF+ input waiting */
- 
      , KE_XF1		/* extra vt100 function keys for xterm */
      , KE_XF2
      , KE_XF3
--- 211,216 ----
***************
*** 449,456 ****
  #define K_IGNORE	TERMCAP2KEY(KS_EXTRA, KE_IGNORE)
  #define K_NOP		TERMCAP2KEY(KS_EXTRA, KE_NOP)
  
- #define K_SNIFF		TERMCAP2KEY(KS_EXTRA, KE_SNIFF)
- 
  #define K_MOUSEDOWN	TERMCAP2KEY(KS_EXTRA, KE_MOUSEDOWN)
  #define K_MOUSEUP	TERMCAP2KEY(KS_EXTRA, KE_MOUSEUP)
  #define K_MOUSELEFT	TERMCAP2KEY(KS_EXTRA, KE_MOUSELEFT)
--- 447,452 ----
*** ../vim-7.4.1432/src/structs.h	2016-02-27 14:44:21.331585379 +0100
--- src/structs.h	2016-02-27 17:54:55.632029481 +0100
***************
*** 1639,1648 ****
      char	 b_fab_rat;	/* Record attribute */
      unsigned int b_fab_mrs;	/* Max record size  */
  #endif
- #ifdef FEAT_SNIFF
-     int		b_sniff;	/* file was loaded through Sniff */
- #endif
- 
      int		b_fnum;		/* buffer number for this file. */
  
      int		b_changed;	/* 'modified': Set to TRUE if something in the
--- 1639,1644 ----
*** ../vim-7.4.1432/src/vim.h	2016-02-23 19:33:57.429544837 +0100
--- src/vim.h	2016-02-27 17:55:14.599830311 +0100
***************
*** 1972,1981 ****
  
  #include "globals.h"	    /* global variables and messages */
  
- #ifdef FEAT_SNIFF
- # include "if_sniff.h"
- #endif
- 
  #ifndef FEAT_VIRTUALEDIT
  # define getvvcol(w, p, s, c, e) getvcol(w, p, s, c, e)
  # define virtual_active() FALSE
--- 1972,1977 ----
*** ../vim-7.4.1432/src/Make_mvc.mak	2016-02-20 13:54:39.137147115 +0100
--- src/Make_mvc.mak	2016-02-27 17:56:12.187225633 +0100
***************
*** 82,89 ****
  #	  TCL_VER_LONG=[Tcl version, eg 8.3] (default is 8.3)
  #	    You must set TCL_VER_LONG when you set TCL_VER.
  #
- #	SNiFF+ interface: SNIFF=yes
- #
  #	Cscope support: CSCOPE=yes
  #
  #	Iconv library support (always dynamically loaded):
--- 82,87 ----
***************
*** 269,284 ****
  CTAGS = ctags
  !endif
  
- !if "$(SNIFF)" == "yes"
- # SNIFF - Include support for SNiFF+.
- SNIFF_INCL  = if_sniff.h
- SNIFF_OBJ   = $(OBJDIR)/if_sniff.obj
- SNIFF_LIB   = shell32.lib
- SNIFF_DEFS  = -DFEAT_SNIFF
- # The SNiFF integration needs multithreaded libraries!
- MULTITHREADED = yes
- !endif
- 
  !ifndef CSCOPE
  CSCOPE = yes
  !endif
--- 267,272 ----
***************
*** 380,386 ****
  #VIMRUNTIMEDIR = somewhere
  
  CFLAGS = -c /W3 /nologo $(CVARS) -I. -Iproto -DHAVE_PATHDEF -DWIN32 \
! 		$(SNIFF_DEFS) $(CSCOPE_DEFS) $(NETBEANS_DEFS) $(CHANNEL_DEFS) \
  		$(NBDEBUG_DEFS) $(XPM_DEFS) \
  		$(DEFINES) -DWINVER=$(WINVER) -D_WIN32_WINNT=$(WINVER) \
  		/Fo$(OUTDIR)/ 
--- 368,374 ----
  #VIMRUNTIMEDIR = somewhere
  
  CFLAGS = -c /W3 /nologo $(CVARS) -I. -Iproto -DHAVE_PATHDEF -DWIN32 \
! 		$(CSCOPE_DEFS) $(NETBEANS_DEFS) $(CHANNEL_DEFS) \
  		$(NBDEBUG_DEFS) $(XPM_DEFS) \
  		$(DEFINES) -DWINVER=$(WINVER) -D_WIN32_WINNT=$(WINVER) \
  		/Fo$(OUTDIR)/ 
***************
*** 528,534 ****
  !endif # DEBUG
  
  INCL =	vim.h os_win32.h ascii.h feature.h globals.h keymap.h macros.h \
! 	proto.h option.h structs.h term.h $(SNIFF_INCL) $(CSCOPE_INCL) \
  	$(NBDEBUG_INCL)
  
  OBJ = \
--- 516,522 ----
  !endif # DEBUG
  
  INCL =	vim.h os_win32.h ascii.h feature.h globals.h keymap.h macros.h \
! 	proto.h option.h structs.h term.h $(CSCOPE_INCL) \
  	$(NBDEBUG_INCL)
  
  OBJ = \
***************
*** 997,1003 ****
  !ENDIF
  
  LINKARGS1 = $(linkdebug) $(conflags)
! LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(NODEFAULTLIB) $(LIBC) $(OLE_LIB) user32.lib $(SNIFF_LIB) \
  		$(LUA_LIB) $(MZSCHEME_LIB) $(PERL_LIB) $(PYTHON_LIB) $(PYTHON3_LIB) $(RUBY_LIB) \
  		$(TCL_LIB) $(NETBEANS_LIB) $(XPM_LIB) $(LINK_PDB)
  
--- 985,991 ----
  !ENDIF
  
  LINKARGS1 = $(linkdebug) $(conflags)
! LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(NODEFAULTLIB) $(LIBC) $(OLE_LIB) user32.lib \
  		$(LUA_LIB) $(MZSCHEME_LIB) $(PERL_LIB) $(PYTHON_LIB) $(PYTHON3_LIB) $(RUBY_LIB) \
  		$(TCL_LIB) $(NETBEANS_LIB) $(XPM_LIB) $(LINK_PDB)
  
***************
*** 1020,1031 ****
  
  $(VIM).exe: $(OUTDIR) $(OBJ) $(GUI_OBJ) $(OLE_OBJ) $(OLE_IDL) $(MZSCHEME_OBJ) \
  		$(LUA_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(PYTHON3_OBJ) $(RUBY_OBJ) $(TCL_OBJ) \
! 		$(SNIFF_OBJ) $(CSCOPE_OBJ) $(NETBEANS_OBJ) $(CHANNEL_OBJ) $(XPM_OBJ) \
  		version.c version.h
  	$(CC) $(CFLAGS) version.c
  	$(link) $(LINKARGS1) -out:$(VIM).exe $(OBJ) $(GUI_OBJ) $(OLE_OBJ) \
  		$(LUA_OBJ) $(MZSCHEME_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(PYTHON3_OBJ) $(RUBY_OBJ) \
! 		$(TCL_OBJ) $(SNIFF_OBJ) $(CSCOPE_OBJ) $(NETBEANS_OBJ) $(CHANNEL_OBJ) \
  		$(XPM_OBJ) $(OUTDIR)\version.obj $(LINKARGS2)
  	if exist $(VIM).exe.manifest mt.exe -nologo -manifest $(VIM).exe.manifest -updateresource:$(VIM).exe;1
  
--- 1008,1019 ----
  
  $(VIM).exe: $(OUTDIR) $(OBJ) $(GUI_OBJ) $(OLE_OBJ) $(OLE_IDL) $(MZSCHEME_OBJ) \
  		$(LUA_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(PYTHON3_OBJ) $(RUBY_OBJ) $(TCL_OBJ) \
! 		$(CSCOPE_OBJ) $(NETBEANS_OBJ) $(CHANNEL_OBJ) $(XPM_OBJ) \
  		version.c version.h
  	$(CC) $(CFLAGS) version.c
  	$(link) $(LINKARGS1) -out:$(VIM).exe $(OBJ) $(GUI_OBJ) $(OLE_OBJ) \
  		$(LUA_OBJ) $(MZSCHEME_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(PYTHON3_OBJ) $(RUBY_OBJ) \
! 		$(TCL_OBJ) $(CSCOPE_OBJ) $(NETBEANS_OBJ) $(CHANNEL_OBJ) \
  		$(XPM_OBJ) $(OUTDIR)\version.obj $(LINKARGS2)
  	if exist $(VIM).exe.manifest mt.exe -nologo -manifest $(VIM).exe.manifest -updateresource:$(VIM).exe;1
  
***************
*** 1212,1220 ****
  $(OUTDIR)/if_ruby.obj: $(OUTDIR) if_ruby.c  $(INCL)
  	$(CC) $(CFLAGS) $(RUBY_INC) if_ruby.c
  
- $(OUTDIR)/if_sniff.obj:	$(OUTDIR) if_sniff.c  $(INCL)
- 	$(CC) $(CFLAGS) if_sniff.c
- 
  $(OUTDIR)/if_tcl.obj: $(OUTDIR) if_tcl.c  $(INCL)
  	$(CC) $(CFLAGS) $(TCL_INC) if_tcl.c
  
--- 1200,1205 ----
*** ../vim-7.4.1432/src/Make_vms.mms	2016-01-23 19:45:48.626931291 +0100
--- src/Make_vms.mms	2016-02-27 17:56:55.478771081 +0100
***************
*** 2,8 ****
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2016 Jan 22
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
--- 2,8 ----
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2016 Feb 27
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
***************
*** 66,72 ****
  # VIM_PERL   = YES
  # VIM_PYTHON = YES
  # VIM_RUBY   = YES
- # VIM_SNIFF  = YES
  
  # X Input Method.  For entering special languages like chinese and
  # Japanese. Please define just one: VIM_XIM or VIM_HANGULIN
--- 66,71 ----
***************
*** 228,242 ****
  TCL_INC = ,dka0:[tcl80.generic]
  .ENDIF
  
- .IFDEF VIM_SNIFF
- # SNIFF related setup.
- SNIFF_DEF = ,"FEAT_SNIFF"
- SNIFF_SRC = if_sniff.c
- SNIFF_OBJ = if_sniff.obj
- SNIFF_LIB =
- SNIFF_INC =
- .ENDIF
- 
  .IFDEF VIM_RUBY
  # RUBY related setup.
  RUBY_DEF = ,"FEAT_RUBY"
--- 227,232 ----
***************
*** 293,299 ****
  .SUFFIXES : .obj .c
  
  ALL_CFLAGS = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
!  $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)$(ICONV_DEF)) -
   $(CFLAGS)$(GUI_FLAG) -
   /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))
  
--- 283,289 ----
  .SUFFIXES : .obj .c
  
  ALL_CFLAGS = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
!  $(TCL_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)$(ICONV_DEF)) -
   $(CFLAGS)$(GUI_FLAG) -
   /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))
  
***************
*** 302,313 ****
  # as $(GUI_INC) - replaced with $(GUI_INC_VER)
  # Otherwise should not be any other difference.
  ALL_CFLAGS_VER = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
!  $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)$(ICONV_DEF)) -
   $(CFLAGS)$(GUI_FLAG) -
   /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC_VER)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))
  
  ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
! 	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(SNIFF_LIB) $(RUBY_LIB)
  
  SRC =	blowfish.c buffer.c charset.c crypt.c, crypt_zip.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
  	ex_docmd.c ex_eval.c ex_getln.c if_xcmdsrv.c fileio.c fold.c getchar.c \
--- 292,303 ----
  # as $(GUI_INC) - replaced with $(GUI_INC_VER)
  # Otherwise should not be any other difference.
  ALL_CFLAGS_VER = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
!  $(TCL_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)$(ICONV_DEF)) -
   $(CFLAGS)$(GUI_FLAG) -
   /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC_VER)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))
  
  ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
! 	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB)
  
  SRC =	blowfish.c buffer.c charset.c crypt.c, crypt_zip.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
  	ex_docmd.c ex_eval.c ex_getln.c if_xcmdsrv.c fileio.c fold.c getchar.c \
***************
*** 315,321 ****
  	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
  	spell.c syntax.c tag.c term.c termlib.c ui.c undo.c version.c screen.c \
  	window.c os_unix.c os_vms.c pathdef.c \
! 	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) $(SNIFF_SRC) \
  	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
  
  OBJ =	blowfish.obj buffer.obj charset.obj crypt.obj, crypt_zip.obj diff.obj digraph.obj edit.obj eval.obj \
--- 305,311 ----
  	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
  	spell.c syntax.c tag.c term.c termlib.c ui.c undo.c version.c screen.c \
  	window.c os_unix.c os_vms.c pathdef.c \
! 	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) \
  	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
  
  OBJ =	blowfish.obj buffer.obj charset.obj crypt.obj, crypt_zip.obj diff.obj digraph.obj edit.obj eval.obj \
***************
*** 326,332 ****
  	regexp.obj search.obj sha256.obj spell.obj syntax.obj tag.obj term.obj termlib.obj \
  	ui.obj undo.obj screen.obj version.obj window.obj os_unix.obj \
  	os_vms.obj pathdef.obj if_mzsch.obj\
! 	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) $(SNIFF_OBJ) \
  	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)
  
  # Default target is making the executable
--- 316,322 ----
  	regexp.obj search.obj sha256.obj spell.obj syntax.obj tag.obj term.obj termlib.obj \
  	ui.obj undo.obj screen.obj version.obj window.obj os_unix.obj \
  	os_vms.obj pathdef.obj if_mzsch.obj\
! 	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) \
  	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)
  
  # Default target is making the executable
***************
*** 778,787 ****
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h version.h
- if_sniff.obj : if_sniff.c vim.h [.auto]config.h feature.h os_unix.h \
-  ascii.h keymap.h term.h macros.h structs.h regexp.h \
-  gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
-  globals.h farsi.h arabic.h os_unixx.h
  gui_beval.obj : gui_beval.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
--- 768,773 ----
*** ../vim-7.4.1432/src/Makefile	2016-02-23 14:52:31.865232378 +0100
--- src/Makefile	2016-02-27 17:57:38.890315287 +0100
***************
*** 466,474 ****
  # Uncomment this when you do not want inter process communication.
  #CONF_OPT_CHANNEL = --disable-channel
  
- # SNIFF - Include support for SNiFF+.
- #CONF_OPT_SNIFF = --enable-sniff
- 
  # MULTIBYTE - To edit multi-byte characters.
  # Uncomment this when you want to edit a multibyte language.
  # It's automatically enabled with normal features, GTK or IME support.
--- 466,471 ----
***************
*** 1391,1397 ****
  
  LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(TCL_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
  
! LINT_EXTRA = -DUSE_SNIFF -DHANGUL_INPUT -D"__attribute__(x)="
  
  DEPEND_CFLAGS = -DPROTO -DDEPEND -DFEAT_GUI $(LINT_CFLAGS)
  
--- 1388,1394 ----
  
  LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(TCL_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
  
! LINT_EXTRA = -DHANGUL_INPUT -D"__attribute__(x)="
  
  DEPEND_CFLAGS = -DPROTO -DDEPEND -DFEAT_GUI $(LINT_CFLAGS)
  
***************
*** 1532,1545 ****
  	$(PYTHON_SRC) $(PYTHON3_SRC) \
  	$(TCL_SRC) \
  	$(RUBY_SRC) \
- 	$(SNIFF_SRC) \
  	$(WORKSHOP_SRC) \
  	$(WSDEBUG_SRC)
  
  TAGS_SRC = *.c *.cpp if_perl.xs
  
  EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
! 	    if_python.c if_python3.c if_tcl.c if_ruby.c if_sniff.c \
  	    gui_beval.c workshop.c wsdebug.c integration.c \
  	    netbeans.c channel.c \
  	    $(GRESOURCE_SRC)
--- 1529,1541 ----
  	$(PYTHON_SRC) $(PYTHON3_SRC) \
  	$(TCL_SRC) \
  	$(RUBY_SRC) \
  	$(WORKSHOP_SRC) \
  	$(WSDEBUG_SRC)
  
  TAGS_SRC = *.c *.cpp if_perl.xs
  
  EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
! 	    if_python.c if_python3.c if_tcl.c if_ruby.c \
  	    gui_beval.c workshop.c wsdebug.c integration.c \
  	    netbeans.c channel.c \
  	    $(GRESOURCE_SRC)
***************
*** 1561,1567 ****
  # The perl sources also don't work well with lint.
  LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) \
  	   $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \
! 	   $(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) \
  	   $(NETBEANS_SRC) $(CHANNEL_SRC)
  #LINT_SRC = $(SRC)
  #LINT_SRC = $(ALL_SRC)
--- 1557,1563 ----
  # The perl sources also don't work well with lint.
  LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) \
  	   $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \
! 	   $(WORKSHOP_SRC) $(WSDEBUG_SRC) \
  	   $(NETBEANS_SRC) $(CHANNEL_SRC)
  #LINT_SRC = $(SRC)
  #LINT_SRC = $(ALL_SRC)
***************
*** 1611,1617 ****
  	objects/sha256.o \
  	objects/spell.o \
  	objects/syntax.o \
- 	$(SNIFF_OBJ) \
  	objects/tag.o \
  	objects/term.o \
  	objects/ui.o \
--- 1607,1612 ----
***************
*** 1750,1756 ****
  		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
  		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
  		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \
! 		$(CONF_OPT_SNIFF) $(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
  		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \
  		$(CONF_OPT_CHANNEL) \
  		$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \
--- 1745,1751 ----
  		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
  		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
  		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \
! 		$(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
  		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \
  		$(CONF_OPT_CHANNEL) \
  		$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \
***************
*** 2815,2823 ****
  objects/if_ruby.o: if_ruby.c
  	$(CCC) $(RUBY_CFLAGS) -o $@ if_ruby.c
  
- objects/if_sniff.o: if_sniff.c
- 	$(CCC) -o $@ if_sniff.c
- 
  objects/if_tcl.o: if_tcl.c
  	$(CCC) $(TCL_CFLAGS) -o $@ if_tcl.c
  
--- 2810,2815 ----
***************
*** 3364,3373 ****
   ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
   gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h proto.h globals.h \
   farsi.h arabic.h version.h
- objects/if_sniff.o: if_sniff.c vim.h auto/config.h feature.h os_unix.h \
-  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
-  regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h proto.h \
-  globals.h farsi.h arabic.h os_unixx.h
  objects/gui_beval.o: gui_beval.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
   regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h proto.h \
--- 3356,3361 ----
*** ../vim-7.4.1432/src/configure.in	2016-02-23 22:30:25.270438299 +0100
--- src/configure.in	2016-02-27 17:59:15.769298200 +0100
***************
*** 2021,2039 ****
    AC_SUBST(CHANNEL_OBJ)
  fi
  
- AC_MSG_CHECKING(--enable-sniff argument)
- AC_ARG_ENABLE(sniff,
- 	[  --enable-sniff          Include Sniff interface.], ,
- 	[enable_sniff="no"])
- AC_MSG_RESULT($enable_sniff)
- if test "$enable_sniff" = "yes"; then
-   AC_DEFINE(FEAT_SNIFF)
-   SNIFF_SRC="if_sniff.c"
-   AC_SUBST(SNIFF_SRC)
-   SNIFF_OBJ="objects/if_sniff.o"
-   AC_SUBST(SNIFF_OBJ)
- fi
- 
  AC_MSG_CHECKING(--enable-multibyte argument)
  AC_ARG_ENABLE(multibyte,
  	[  --enable-multibyte      Include multibyte editing support.], ,
--- 2021,2026 ----
*** ../vim-7.4.1432/src/auto/configure	2016-02-23 22:30:25.274438259 +0100
--- src/auto/configure	2016-02-27 17:59:19.341260702 +0100
***************
*** 653,660 ****
  X_CFLAGS
  XMKMF
  xmkmfpath
- SNIFF_OBJ
- SNIFF_SRC
  CHANNEL_OBJ
  CHANNEL_SRC
  NETBEANS_OBJ
--- 653,658 ----
***************
*** 812,818 ****
  enable_workshop
  enable_netbeans
  enable_channel
- enable_sniff
  enable_multibyte
  enable_hangulinput
  enable_xim
--- 810,815 ----
***************
*** 1477,1483 ****
    --enable-workshop       Include Sun Visual Workshop support.
    --disable-netbeans      Disable NetBeans integration support.
    --disable-channel      Disable process communication support.
-   --enable-sniff          Include Sniff interface.
    --enable-multibyte      Include multibyte editing support.
    --enable-hangulinput    Include Hangul input support.
    --enable-xim            Include XIM input support.
--- 1474,1479 ----
***************
*** 7439,7464 ****
  
  fi
  
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-sniff argument" >&5
- $as_echo_n "checking --enable-sniff argument... " >&6; }
- # Check whether --enable-sniff was given.
- if test "${enable_sniff+set}" = set; then :
-   enableval=$enable_sniff;
- else
-   enable_sniff="no"
- fi
- 
- { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_sniff" >&5
- $as_echo "$enable_sniff" >&6; }
- if test "$enable_sniff" = "yes"; then
-   $as_echo "#define FEAT_SNIFF 1" >>confdefs.h
- 
-   SNIFF_SRC="if_sniff.c"
- 
-   SNIFF_OBJ="objects/if_sniff.o"
- 
- fi
- 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-multibyte argument" >&5
  $as_echo_n "checking --enable-multibyte argument... " >&6; }
  # Check whether --enable-multibyte was given.
--- 7435,7440 ----
*** ../vim-7.4.1432/src/config.h.in	2016-02-23 17:13:56.873032372 +0100
--- src/config.h.in	2016-02-27 17:59:29.933149512 +0100
***************
*** 362,370 ****
  /* Define for linking via dlopen() or LoadLibrary() */
  #undef DYNAMIC_TCL
  
- /* Define if you want to include the Sniff interface. */
- #undef FEAT_SNIFF
- 
  /* Define if you want to add support for ACL */
  #undef HAVE_POSIX_ACL
  #undef HAVE_SOLARIS_ZFS_ACL
--- 362,367 ----
*** ../vim-7.4.1432/src/config.mk.in	2016-01-31 17:56:02.966915370 +0100
--- src/config.mk.in	2016-02-27 17:59:58.928845127 +0100
***************
*** 99,107 ****
  RUBY_CFLAGS	= @RUBY_CFLAGS@
  RUBY_LIBS	= @RUBY_LIBS@
  
- SNIFF_SRC	= @SNIFF_SRC@
- SNIFF_OBJ	= @SNIFF_OBJ@
- 
  AWK		= @AWK@
  
  STRIP		= @STRIP@
--- 99,104 ----
*** ../vim-7.4.1432/runtime/doc/if_sniff.txt	2013-08-10 13:24:55.000000000 +0200
--- runtime/doc/if_sniff.txt	2016-02-27 18:01:09.544103863 +0100
***************
*** 1,95 ****
! *if_sniff.txt*	For Vim version 7.4.  Last change: 2005 Mar 29
  
  
  		  VIM REFERENCE MANUAL
  		by Anton Leherbauer (toni@takefive.co.at)
  
  
! SNiFF+ and Vim				    *sniff*
! 
! 1. Introduction				    |sniff-intro|
! 2. Commands				    |sniff-commands|
! 3. Compiling Vim with SNiFF+ interface	    |sniff-compiling|
! 
! {Vi does not have any of these commands}  *E275* *E274* *E276* *E278* *E279*
! 
! The SNiFF+ interface only works, when Vim was compiled with the |+sniff|
! feature.
! 
! ==============================================================================
! 1. Introduction					*sniff-intro*
! 
! The following features for the use with SNiFF+ are available:
! 
!    * Vim can be used for all editing requests
!    * SNiFF+ recognizes and updates all browsers when a file is saved in Vim
!    * SNiFF+ commands can be issued directly from Vim
! 
! How to use Vim with SNiFF+
!    1. Make sure SNiFF+ is running.
!    2. In the Editor view of the Preferences dialog set the Field named
!       'External Editor' to 'Emacs/Vim'.
!    4. Start Vim
!    5. Connect to SNiFF+ (:sniff connect)
! 
! Once a connection is established, SNiFF+ uses Vim for all requests to show or
! edit source code.  On the other hand, you can send queries to SNiFF+ with the
! :sniff command.
! 
! ==============================================================================
! 2. Commands				    *sniff-commands*
! 
! 			    *:sniff* *:sni*
! :sni[ff] request [symbol]   Send request to sniff with optional symbol.
! 			    {not in Vi}
! :sni[ff]		    Display all possible requests and the connection
! 			    status
! 
! Most requests require a symbol (identifier) as parameter.  If it is omitted,
! Vim will use the current word under the cursor.
! The available requests are listed below:
! 
! request		      mapping	description
! -------------------------------------------------------------------------------
! connect			sc	Establish connection with SNiFF+.
! 				Make sure SNiFF+ is prepared for this in the
! 				Preferences
! disconnect		sq	Disconnect from SNiFF+.  You can reconnect any
! 				time with :sniff connect (or 'sc')
! toggle			st	Toggle between implementation
! 				and definition file
! find-symbol		sf	Load the symbol into a Symbol Browser
! browse-class		sb	Loads the class into a Class Browser
! superclass		ss	Edit superclass of symbol
! overridden		so	Edit overridden method of symbol
! retrieve-file		srf	Retrieve symbol in current file
! retrieve-project	srp	Retrieve symbol in current project
! retrieve-all-projects	srP	Retrieve symbol in all projects
! retrieve-next		sR	Retrieve symbol using current Retriever
! 				settings
! goto-symbol		sg	Goto definition or implementation of symbol
! hierarchy		sh	Load symbol into the Hierarchy Browser
! restr-hier		sH	same as above but show only related classes
! xref-to			sxt	Start a refers-to query on symbol and
! 				load the results into the Cross Referencer
! xref-by			sxb	Start a referred-by query on symbol
! xref-has		sxh	Start a refers-to components query on symbol
! xref-used-by		sxu	Start a referred-by as component query on
! 				symbol
! show-docu		sd	Show documentation of symbol
! gen-docu		sD	Generate documentation of symbol
! 
! The mappings are defined in a file 'sniff.vim', which is part of every SNiFF+
! product ($SNIFF_DIR/config/sniff.vim).  This file is sourced whenever Vim
! connects to SNiFF+.
! 
! ==============================================================================
! 3. Compiling Vim with SNiFF+ interface		*sniff-compiling*
! 
! To compile Vim with SNiFF+ support, you need two source files of the extra
! archive: if_sniff.c and if_sniff.h.
! On Unix: Edit the Makefile and uncomment the line "--enable-sniff".  Or run
! configure manually with this argument.
! On NT: Specify SNIFF=yes with your make command.
  
   vim:tw=78:ts=8:ft=help:norl:
--- 1,11 ----
! *if_sniff.txt*	For Vim version 7.4.  Last change: 2016 Feb 27
  
  
  		  VIM REFERENCE MANUAL
  		by Anton Leherbauer (toni@takefive.co.at)
  
  
! The SNiFF+ support was removed at patch 7.4.1433.  If you want to check it out
! sync to before that.
  
   vim:tw=78:ts=8:ft=help:norl:
*** ../vim-7.4.1432/src/version.c	2016-02-27 18:07:39.656009438 +0100
--- src/version.c	2016-02-27 18:09:29.486856900 +0100
***************
*** 750,751 ****
--- 745,748 ----
  {   /* Add new patch number below this line */
+ /**/
+     1433,
  /**/

-- 
Females are strictly forbidden to appear unshaven in public.
		[real standing law in New Mexico, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
