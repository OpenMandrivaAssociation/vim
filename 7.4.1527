To: vim_dev@googlegroups.com
Subject: Patch 7.4.1527
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.1527
Problem:    Channel test is flaky on MS-Windows.
Solution:   Limit the select() timeout to 50 msec and try with a new socket if
            it fails.
Files:      src/channel.c


*** ../vim-7.4.1526/src/channel.c	2016-03-08 22:33:02.815116985 +0100
--- src/channel.c	2016-03-09 21:47:07.822727537 +0100
***************
*** 628,636 ****
       */
      while (TRUE)
      {
! #ifndef WIN32
! 	long elapsed_msec = 0;
! #endif
  
  	if (sd >= 0)
  	    sock_close(sd);
--- 628,635 ----
       */
      while (TRUE)
      {
! 	long	elapsed_msec = 0;
! 	int	waitnow;
  
  	if (sd >= 0)
  	    sock_close(sd);
***************
*** 688,694 ****
  	}
  
  	/* If connect() didn't finish then try using select() to wait for the
! 	 * connection to be made. */
  #ifndef WIN32
  	if (errno != ECONNREFUSED)
  #endif
--- 687,693 ----
  	}
  
  	/* If connect() didn't finish then try using select() to wait for the
! 	 * connection to be made. For Win32 always use select() to wait. */
  #ifndef WIN32
  	if (errno != ECONNREFUSED)
  #endif
***************
*** 702,720 ****
  	    struct timeval	start_tv;
  	    struct timeval	end_tv;
  #endif
  
  	    FD_ZERO(&rfds);
  	    FD_SET(sd, &rfds);
  	    FD_ZERO(&wfds);
  	    FD_SET(sd, &wfds);
  
! 	    tv.tv_sec = waittime / 1000;
! 	    tv.tv_usec = (waittime % 1000) * 1000;
  #ifndef WIN32
  	    gettimeofday(&start_tv, NULL);
  #endif
  	    ch_logn(channel,
! 		    "Waiting for connection (waittime %d msec)...", waittime);
  	    ret = select((int)sd + 1, &rfds, &wfds, NULL, &tv);
  
  	    if (ret < 0)
--- 701,722 ----
  	    struct timeval	start_tv;
  	    struct timeval	end_tv;
  #endif
+ 	    /* Limit the waittime to 50 msec.  If it doesn't work within this
+ 	     * time we close the socket and try creating it again. */
+ 	    waitnow = waittime > 50 ? 50 : waittime;
  
  	    FD_ZERO(&rfds);
  	    FD_SET(sd, &rfds);
  	    FD_ZERO(&wfds);
  	    FD_SET(sd, &wfds);
  
! 	    tv.tv_sec = waitnow / 1000;
! 	    tv.tv_usec = (waitnow % 1000) * 1000;
  #ifndef WIN32
  	    gettimeofday(&start_tv, NULL);
  #endif
  	    ch_logn(channel,
! 		    "Waiting for connection (waiting %d msec)...", waitnow);
  	    ret = select((int)sd + 1, &rfds, &wfds, NULL, &tv);
  
  	    if (ret < 0)
***************
*** 729,738 ****
  	    }
  
  #ifdef WIN32
! 	    /* On Win32: select() is expected to work and wait for up to the
! 	     * waittime for the socket to be open. */
  	    if (FD_ISSET(sd, &wfds))
  		break;
  #else
  	    /* On Linux-like systems: See socket(7) for the behavior
  	     * After putting the socket in non-blocking mode, connect() will
--- 731,746 ----
  	    }
  
  #ifdef WIN32
! 	    /* On Win32: select() is expected to work and wait for up to
! 	     * "waitnow" msec for the socket to be open. */
  	    if (FD_ISSET(sd, &wfds))
  		break;
+ 	    elapsed_msec = waitnow;
+ 	    if (waittime > 1 && elapsed_msec < waittime)
+ 	    {
+ 		waittime -= elapsed_msec;
+ 		continue;
+ 	    }
  #else
  	    /* On Linux-like systems: See socket(7) for the behavior
  	     * After putting the socket in non-blocking mode, connect() will
***************
*** 778,794 ****
  	{
  	    /* The port isn't ready but we also didn't get an error.
  	     * This happens when the server didn't open the socket
! 	     * yet.  Wait a bit and try again. */
! 	    mch_delay(waittime < 50 ? (long)waittime : 50L, TRUE);
! 	    ui_breakcheck();
  	    if (!got_int)
  	    {
! 		/* reduce the waittime by the elapsed time and the 50
! 		 * msec delay (or a bit more) */
! 		waittime -= elapsed_msec;
! 		if (waittime > 50)
! 		    waittime -= 50;
! 		else
  		    waittime = 1;
  		continue;
  	    }
--- 786,805 ----
  	{
  	    /* The port isn't ready but we also didn't get an error.
  	     * This happens when the server didn't open the socket
! 	     * yet.  Select() may return early, wait until the remaining
! 	     * "waitnow"  and try again. */
! 	    waitnow -= elapsed_msec;
! 	    waittime -= elapsed_msec;
! 	    if (waitnow > 0)
! 	    {
! 		mch_delay((long)waitnow, TRUE);
! 		ui_breakcheck();
! 		waittime -= waitnow;
! 	    }
  	    if (!got_int)
  	    {
! 		if (waittime <= 0)
! 		    /* give it one more try */
  		    waittime = 1;
  		continue;
  	    }
*** ../vim-7.4.1526/src/version.c	2016-03-09 20:54:48.200138811 +0100
--- src/version.c	2016-03-09 21:49:02.921497988 +0100
***************
*** 745,746 ****
--- 745,748 ----
  {   /* Add new patch number below this line */
+ /**/
+     1527,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
25. You believe nothing looks sexier than a man in boxer shorts illuminated
    only by a 17" inch svga monitor.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
