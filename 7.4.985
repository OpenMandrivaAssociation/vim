To: vim_dev@googlegroups.com
Subject: Patch 7.4.985
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.4.985
Problem:    Can't build with Ruby 2.3.0.
Solution:   Use the new TypedData_XXX macro family instead of Data_XXX. Use
            TypedData. (Ken Takata)
Files:      src/if_ruby.c


*** ../vim-7.4.984/src/if_ruby.c	2015-11-19 19:33:10.846992524 +0100
--- src/if_ruby.c	2015-12-28 20:23:45.948253180 +0100
***************
*** 103,109 ****
  #endif
  #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 22
  # define rb_gc_writebarrier_unprotect rb_gc_writebarrier_unprotect_stub
- # define rb_check_type rb_check_type_stub
  #endif
  
  #include <ruby.h>
--- 103,108 ----
***************
*** 123,128 ****
--- 122,136 ----
  #endif
  
  /*
+  * The TypedData_XXX macro family can be used since Ruby 1.9.2, and
+  * the old Data_XXX macro family was deprecated on Ruby 2.2.
+  * Use TypedData_XXX if available.
+  */
+ #ifdef TypedData_Wrap_Struct
+ # define USE_TYPEDDATA	1
+ #endif
+ 
+ /*
   * Backward compatibility for Ruby 1.8 and earlier.
   * Ruby 1.9 does not provide STR2CSTR, instead StringValuePtr is provided.
   * Ruby 1.9 does not provide RXXX(s)->len and RXXX(s)->ptr, instead
***************
*** 184,194 ****
   */
  # define rb_assoc_new			dll_rb_assoc_new
  # define rb_cObject			(*dll_rb_cObject)
! # if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 22
! #  define rb_check_type			dll_rb_check_type
  # endif
  # define rb_class_path			dll_rb_class_path
! # define rb_data_object_alloc		dll_rb_data_object_alloc
  # define rb_define_class_under		dll_rb_define_class_under
  # define rb_define_const			dll_rb_define_const
  # define rb_define_global_function	dll_rb_define_global_function
--- 192,211 ----
   */
  # define rb_assoc_new			dll_rb_assoc_new
  # define rb_cObject			(*dll_rb_cObject)
! # define rb_check_type			dll_rb_check_type
! # ifdef USE_TYPEDDATA
! #  define rb_check_typeddata		dll_rb_check_typeddata
  # endif
  # define rb_class_path			dll_rb_class_path
! # ifdef USE_TYPEDDATA
! #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 23
! #   define rb_data_typed_object_wrap	dll_rb_data_typed_object_wrap
! #  else
! #   define rb_data_typed_object_alloc	dll_rb_data_typed_object_alloc
! #  endif
! # else
! #  define rb_data_object_alloc		dll_rb_data_object_alloc
! # endif
  # define rb_define_class_under		dll_rb_define_class_under
  # define rb_define_const			dll_rb_define_const
  # define rb_define_global_function	dll_rb_define_global_function
***************
*** 297,304 ****
--- 314,332 ----
  VALUE *dll_rb_cSymbol;
  VALUE *dll_rb_cTrueClass;
  static void (*dll_rb_check_type) (VALUE,int);
+ # ifdef USE_TYPEDDATA
+ static void *(*dll_rb_check_typeddata) (VALUE,const rb_data_type_t *);
+ # endif
  static VALUE (*dll_rb_class_path) (VALUE);
+ # ifdef USE_TYPEDDATA
+ #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 23
+ static VALUE (*dll_rb_data_typed_object_wrap) (VALUE, void*, const rb_data_type_t *);
+ #  else
+ static VALUE (*dll_rb_data_typed_object_alloc) (VALUE, void*, const rb_data_type_t *);
+ #  endif
+ # else
  static VALUE (*dll_rb_data_object_alloc) (VALUE, void*, RUBY_DATA_FUNC, RUBY_DATA_FUNC);
+ # endif
  static VALUE (*dll_rb_define_class_under) (VALUE, const char*, VALUE);
  static void (*dll_rb_define_const) (VALUE,const char*,VALUE);
  static void (*dll_rb_define_global_function) (const char*,VALUE(*)(),int);
***************
*** 451,463 ****
  #  endif
  # endif
  
- # if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 22
- void rb_check_type_stub(VALUE v, int i)
- {
-     dll_rb_check_type(v, i);
- }
- # endif
- 
  static HINSTANCE hinstRuby = NULL; /* Instance of ruby.dll */
  
  /*
--- 479,484 ----
***************
*** 480,487 ****
--- 501,519 ----
      {"rb_cSymbol", (RUBY_PROC*)&dll_rb_cSymbol},
      {"rb_cTrueClass", (RUBY_PROC*)&dll_rb_cTrueClass},
      {"rb_check_type", (RUBY_PROC*)&dll_rb_check_type},
+ # ifdef USE_TYPEDDATA
+     {"rb_check_typeddata", (RUBY_PROC*)&dll_rb_check_typeddata},
+ # endif
      {"rb_class_path", (RUBY_PROC*)&dll_rb_class_path},
+ # ifdef USE_TYPEDDATA
+ #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 23
+     {"rb_data_typed_object_wrap", (RUBY_PROC*)&dll_rb_data_typed_object_wrap},
+ #  else
+     {"rb_data_typed_object_alloc", (RUBY_PROC*)&dll_rb_data_typed_object_alloc},
+ #  endif
+ # else
      {"rb_data_object_alloc", (RUBY_PROC*)&dll_rb_data_object_alloc},
+ # endif
      {"rb_define_class_under", (RUBY_PROC*)&dll_rb_define_class_under},
      {"rb_define_const", (RUBY_PROC*)&dll_rb_define_const},
      {"rb_define_global_function", (RUBY_PROC*)&dll_rb_define_global_function},
***************
*** 1026,1031 ****
--- 1058,1081 ----
  #endif
  }
  
+ #ifdef USE_TYPEDDATA
+ static size_t buffer_dsize(const void *buf);
+ 
+ static const rb_data_type_t buffer_type = {
+     "vim_buffer",
+     {0, 0, buffer_dsize, {0, 0}},
+     0, 0,
+ # ifdef RUBY_TYPED_FREE_IMMEDIATELY
+     0,
+ # endif
+ };
+ 
+ static size_t buffer_dsize(const void *buf UNUSED)
+ {
+     return sizeof(buf_T);
+ }
+ #endif
+ 
  static VALUE buffer_new(buf_T *buf)
  {
      if (buf->b_ruby_ref)
***************
*** 1034,1040 ****
--- 1084,1094 ----
      }
      else
      {
+ #ifdef USE_TYPEDDATA
+ 	VALUE obj = TypedData_Wrap_Struct(cBuffer, &buffer_type, buf);
+ #else
  	VALUE obj = Data_Wrap_Struct(cBuffer, 0, 0, buf);
+ #endif
  	buf->b_ruby_ref = (void *) obj;
  	rb_hash_aset(objtbl, rb_obj_id(obj), obj);
  	return obj;
***************
*** 1045,1051 ****
--- 1099,1109 ----
  {
      buf_T *buf;
  
+ #ifdef USE_TYPEDDATA
+     TypedData_Get_Struct(obj, buf_T, &buffer_type, buf);
+ #else
      Data_Get_Struct(obj, buf_T, buf);
+ #endif
      if (buf == NULL)
  	rb_raise(eDeletedBufferError, "attempt to refer to deleted buffer");
      return buf;
***************
*** 1242,1247 ****
--- 1300,1323 ----
      return str;
  }
  
+ #ifdef USE_TYPEDDATA
+ static size_t window_dsize(const void *buf);
+ 
+ static const rb_data_type_t window_type = {
+     "vim_window",
+     {0, 0, window_dsize, {0, 0}},
+     0, 0,
+ # ifdef RUBY_TYPED_FREE_IMMEDIATELY
+     0,
+ # endif
+ };
+ 
+ static size_t window_dsize(const void *win UNUSED)
+ {
+     return sizeof(win_T);
+ }
+ #endif
+ 
  static VALUE window_new(win_T *win)
  {
      if (win->w_ruby_ref)
***************
*** 1250,1256 ****
--- 1326,1336 ----
      }
      else
      {
+ #ifdef USE_TYPEDDATA
+ 	VALUE obj = TypedData_Wrap_Struct(cVimWindow, &window_type, win);
+ #else
  	VALUE obj = Data_Wrap_Struct(cVimWindow, 0, 0, win);
+ #endif
  	win->w_ruby_ref = (void *) obj;
  	rb_hash_aset(objtbl, rb_obj_id(obj), obj);
  	return obj;
***************
*** 1261,1267 ****
--- 1341,1351 ----
  {
      win_T *win;
  
+ #ifdef USE_TYPEDDATA
+     TypedData_Get_Struct(obj, win_T, &window_type, win);
+ #else
      Data_Get_Struct(obj, win_T, win);
+ #endif
      if (win == NULL)
  	rb_raise(eDeletedWindowError, "attempt to refer to deleted window");
      return win;
*** ../vim-7.4.984/src/version.c	2015-12-28 19:19:41.550241796 +0100
--- src/version.c	2015-12-28 20:18:04.376007561 +0100
***************
*** 743,744 ****
--- 743,746 ----
  {   /* Add new patch number below this line */
+ /**/
+     985,
  /**/

-- 
GUARD #2:  Wait a minute -- supposing two swallows carried it together?
GUARD #1:  No, they'd have to have it on a line.
GUARD #2:  Well, simple!  They'd just use a standard creeper!
GUARD #1:  What, held under the dorsal guiding feathers?
GUARD #2:  Well, why not?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
